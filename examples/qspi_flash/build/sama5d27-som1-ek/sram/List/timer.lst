###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         18/Feb/2021  16:03:21
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c
#    Command line      =
#        -f C:\Users\c40450\AppData\Local\Temp\EWBB76.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c -D
#        "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_QSPI -D CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_NFC -D
#        CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D
#        CONFIG_HAVE_GMAC_QUEUES -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_MPDDRC_DDR3 -D CONFIG_HAVE_MPDDRC_LPDDR3 -D
#        CONFIG_HAVE_ADC_SETTLING_TIME -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_FAST_STARTUP -D
#        CONFIG_HAVE_PMC_GENERATED_CLOCKS -D CONFIG_HAVE_PMC_AUDIO_CLOCK -D
#        CONFIG_HAVE_PMC_PLLADIV2 -D CONFIG_HAVE_PMC_H32MXDIV -D
#        CONFIG_HAVE_PMC_UPLL_BIAS -D CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA
#        -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
#        -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_SFRBU
#        -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_TRNG -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale            =  C
#    List file         =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List\timer.lst
#    Object file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj\timer.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *         Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include "board.h"
     35          #include "irqflags.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void arch_irq_enable(void)
   \                     arch_irq_enable:
   \        0x0   0xF108'00C0        cpsie if
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void arch_irq_disable(void)
   \                     arch_irq_disable:
   \        0x0   0xF10C'00C0        cpsid if
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
     36          #include "irq/irq.h"
     37          #include "peripherals/pmc.h"
     38          #include "peripherals/tc.h"
     39          #include "timer.h"
     40          
     41          /*----------------------------------------------------------------------------
     42           *         Local type definitions
     43           *----------------------------------------------------------------------------*/
     44          
     45          struct _timer {
     46          	Tc* tc;
     47          	uint8_t channel;
     48          	uint32_t channel_freq;
     49          	volatile uint32_t upper;
     50          };
     51          
     52          /*----------------------------------------------------------------------------
     53           *         Local variables
     54           *----------------------------------------------------------------------------*/
     55          
     56          /** System timer */

   \                                 In section .bss, align 4
     57          static struct _timer _timer;
   \                     _timer:
   \        0x0                      DS8 16
     58          
     59          /*----------------------------------------------------------------------------
     60           *         Local Functions
     61           *----------------------------------------------------------------------------*/
     62          

   \                                 In section SOFTPACK, align 4, keep-with-next
     63          static void timer_update_upper_tick_counter(void)
     64          {
   \                     timer_update_upper_tick_counter:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
     65          	uint32_t status = tc_get_status(_timer.tc, _timer.channel);
   \        0x4   0x....'....        LDR      R4,??DataTable6
   \        0x8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       tc_get_status
     66          	if ((status & TC_SR_COVFS) == TC_SR_COVFS)
   \       0x14   0xE310'0001        TST      R0,#0x1
   \       0x18   0x0A00'0002        BEQ      ??timer_update_upper_tick_counter_0
     67          		_timer.upper++;
   \       0x1C   0xE594'100C        LDR      R1,[R4, #+12]
   \       0x20   0xE291'1001        ADDS     R1,R1,#+1
   \       0x24   0xE584'100C        STR      R1,[R4, #+12]
     68          }
   \                     ??timer_update_upper_tick_counter_0:
   \       0x28   0xE8BD'8010        POP      {R4,PC}          ;; return
     69          

   \                                 In section SOFTPACK, align 4, keep-with-next
     70          static uint32_t timer_get_upper_tick_counter(void)
     71          {
   \                     timer_get_upper_tick_counter:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
     72          	timer_update_upper_tick_counter();
   \        0x4   0x....'....        BL       timer_update_upper_tick_counter
     73          	return _timer.upper;
   \        0x8   0x....'....        LDR      R0,??DataTable6
   \        0xC   0xE590'000C        LDR      R0,[R0, #+12]
   \       0x10   0xE8BD'8002        POP      {R1,PC}          ;; return
     74          }
     75          
     76          #ifndef CONFIG_TIMER_POLLING
     77          
     78          /**
     79           *  \brief Handler for timer interrupt.
     80           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     81          static void timer_irq_handler(uint32_t source, void* user_arg)
     82          {
   \                     timer_irq_handler:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     83          	timer_update_upper_tick_counter();
   \        0xC   0x....'....        BL       timer_update_upper_tick_counter
     84          }
   \       0x10   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
     85          
     86          #endif /* !CONFIG_TIMER_POLLING */
     87          

   \                                 In section SOFTPACK, align 4, keep-with-next
     88          static uint64_t _timer_get_tick(void)
     89          {
   \                     _timer_get_tick:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
     90          	uint32_t upper, lower;
     91          
     92          	do {
     93          		upper = timer_get_upper_tick_counter();
   \                     ??_timer_get_tick_0:
   \        0x4   0x....'....        BL       timer_get_upper_tick_counter
   \        0x8   0xE1B0'5000        MOVS     R5,R0
     94          		COMPILER_BARRIER();
     95          		lower = tc_get_cv(_timer.tc, _timer.channel);
   \        0xC   0x....'....        LDR      R0,??DataTable6
   \       0x10   0xE5D0'1004        LDRB     R1,[R0, #+4]
   \       0x14   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x18   0x....'....        BL       tc_get_cv
   \       0x1C   0xE1B0'4000        MOVS     R4,R0
     96          	} while (upper != timer_get_upper_tick_counter());
   \       0x20   0x....'....        BL       timer_get_upper_tick_counter
   \       0x24   0xE155'0000        CMP      R5,R0
   \       0x28   0x1AFF'FFF5        BNE      ??_timer_get_tick_0
     97          	return (((uint64_t)upper) << TC_CHANNEL_SIZE) | lower;
   \       0x2C   0xE1B0'1005        MOVS     R1,R5
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0xE8BD'8034        POP      {R2,R4,R5,PC}    ;; return
     98          }
     99          
    100          /*----------------------------------------------------------------------------
    101           *         Exported Functions
    102           *----------------------------------------------------------------------------*/
    103          

   \                                 In section SOFTPACK, align 4, keep-with-next
    104          void timer_configure(Tc* tc, uint8_t channel, uint32_t clock_source)
    105          {
   \                     timer_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    106          	uint32_t tc_id = get_tc_id_from_addr(tc, channel);
   \       0x10   0xE1B0'1005        MOVS     R1,R5
   \       0x14   0xE6EF'1071        UXTB     R1,R1
   \       0x18   0xE1B0'0004        MOVS     R0,R4
   \       0x1C   0x....'....        BL       get_tc_id_from_addr
   \       0x20   0xE1B0'7000        MOVS     R7,R0
    107          
    108          	_timer.tc = tc;
   \       0x24   0x....'....        LDR      R8,??DataTable6
   \       0x28   0xE588'4000        STR      R4,[R8, #+0]
    109          	_timer.channel = channel;
   \       0x2C   0xE5C8'5004        STRB     R5,[R8, #+4]
    110          
    111          	if (!pmc_is_peripheral_enabled(tc_id))
   \       0x30   0xE1B0'0007        MOVS     R0,R7
   \       0x34   0x....'....        BL       pmc_is_peripheral_enabled
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x1A00'0003        BNE      ??timer_configure_0
    112          		pmc_configure_peripheral(tc_id, NULL, true);
   \       0x40   0xE3A0'2001        MOV      R2,#+1
   \       0x44   0xE3A0'1000        MOV      R1,#+0
   \       0x48   0xE1B0'0007        MOVS     R0,R7
   \       0x4C   0x....'....        BL       pmc_configure_peripheral
    113          
    114          	tc_configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP |
    115          			(clock_source & TC_CMR_TCCLKS_Msk));
   \                     ??timer_configure_0:
   \       0x50   0xE216'0007        ANDS     R0,R6,#0x7
   \       0x54   0xE390'2C80        ORRS     R2,R0,#0x8000
   \       0x58   0xE1B0'1005        MOVS     R1,R5
   \       0x5C   0xE6EF'1071        UXTB     R1,R1
   \       0x60   0xE1B0'0004        MOVS     R0,R4
   \       0x64   0x....'....        BL       tc_configure
    116          	_timer.channel_freq = tc_get_channel_freq(tc, channel);
   \       0x68   0xE1B0'1005        MOVS     R1,R5
   \       0x6C   0xE6EF'1071        UXTB     R1,R1
   \       0x70   0xE1B0'0004        MOVS     R0,R4
   \       0x74   0x....'....        BL       tc_get_channel_freq
   \       0x78   0xE588'0008        STR      R0,[R8, #+8]
    117          #ifndef CONFIG_TIMER_POLLING
    118          	irq_add_handler(tc_id, timer_irq_handler, &_timer);
   \       0x7C   0xE1B0'2008        MOVS     R2,R8
   \       0x80   0x....'....        ADR      R1,timer_irq_handler
   \       0x84   0xE1B0'0007        MOVS     R0,R7
   \       0x88   0x....'....        BL       irq_add_handler
    119          	irq_enable(tc_id);
   \       0x8C   0xE1B0'0007        MOVS     R0,R7
   \       0x90   0x....'....        BL       irq_enable
    120          	tc_enable_it(tc, channel, TC_IER_COVFS);
   \       0x94   0xE3A0'2001        MOV      R2,#+1
   \       0x98   0xE1B0'1005        MOVS     R1,R5
   \       0x9C   0xE6EF'1071        UXTB     R1,R1
   \       0xA0   0xE1B0'0004        MOVS     R0,R4
   \       0xA4   0x....'....        BL       tc_enable_it
    121          #endif
    122          	tc_start(tc, channel);
   \       0xA8   0xE1B0'1005        MOVS     R1,R5
   \       0xAC   0xE6EF'1071        UXTB     R1,R1
   \       0xB0   0xE1B0'0004        MOVS     R0,R4
   \       0xB4   0x....'....        BL       tc_start
    123          }
   \       0xB8   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    124          

   \                                 In section SOFTPACK, align 4, keep-with-next
    125          uint64_t timer_get_interval(uint64_t start, uint64_t end)
    126          {
   \                     timer_get_interval:
   \        0x0   0xE92D'4000        PUSH     {LR}
    127          	if (end >= start)
   \        0x4   0xE153'0001        CMP      R3,R1
   \        0x8   0x3A00'0005        BCC      ??timer_get_interval_0
   \        0xC   0x8A00'0001        BHI      ??timer_get_interval_1
   \       0x10   0xE152'0000        CMP      R2,R0
   \       0x14   0x3A00'0002        BCC      ??timer_get_interval_0
    128          		return end - start;
   \                     ??timer_get_interval_1:
   \       0x18   0xE052'0000        SUBS     R0,R2,R0
   \       0x1C   0xE0C3'1001        SBC      R1,R3,R1
   \       0x20   0xEA00'0005        B        ??timer_get_interval_2
    129          	return end + (0xffffffffffffffffu - start) + 1;
   \                     ??timer_get_interval_0:
   \       0x24   0xE252'2001        SUBS     R2,R2,#+1
   \       0x28   0xE2C3'3000        SBC      R3,R3,#+0
   \       0x2C   0xE052'0000        SUBS     R0,R2,R0
   \       0x30   0xE0C3'1001        SBC      R1,R3,R1
   \       0x34   0xE290'0001        ADDS     R0,R0,#+1
   \       0x38   0xE2A1'1000        ADC      R1,R1,#+0
   \                     ??timer_get_interval_2:
   \       0x3C   0xE8BD'8000        POP      {PC}             ;; return
    130          }
    131          

   \                                 In section SOFTPACK, align 4, keep-with-next
    132          void timer_start_timeout(struct _timeout* timeout, uint64_t count)
    133          {
   \                     timer_start_timeout:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'6000        MOVS     R6,R0
   \        0x8   0xE1A0'4002        MOV      R4,R2
   \        0xC   0xE1A0'5003        MOV      R5,R3
    134          	timeout->start = timer_get_tick();
   \       0x10   0x....'....        BL       timer_get_tick
   \       0x14   0xE1C6'00F0        STRD     R0,R1,[R6, #+0]
    135          	timeout->count = count ;
   \       0x18   0xE1C6'40F8        STRD     R4,R5,[R6, #+8]
    136          }
   \       0x1C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    137          

   \                                 In section SOFTPACK, align 4, keep-with-next
    138          void timer_reset_timeout(struct _timeout* timeout)
    139          {
   \                     timer_reset_timeout:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    140          	timeout->start = timer_get_tick();
   \        0x8   0x....'....        BL       timer_get_tick
   \        0xC   0xE1C4'00F0        STRD     R0,R1,[R4, #+0]
    141          }
   \       0x10   0xE8BD'8010        POP      {R4,PC}          ;; return
    142          

   \                                 In section SOFTPACK, align 4, keep-with-next
    143          uint8_t timer_timeout_reached(struct _timeout* timeout)
    144          {
   \                     timer_timeout_reached:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    145          	return timer_get_interval(timeout->start, timer_get_tick()) >= timeout->count;
   \        0x8   0x....'....        BL       timer_get_tick
   \        0xC   0xE1A0'2000        MOV      R2,R0
   \       0x10   0xE1A0'3001        MOV      R3,R1
   \       0x14   0xE1C4'00D0        LDRD     R0,R1,[R4, #+0]
   \       0x18   0x....'....        BL       timer_get_interval
   \       0x1C   0xE1C4'20D8        LDRD     R2,R3,[R4, #+8]
   \       0x20   0xE151'0003        CMP      R1,R3
   \       0x24   0x3A00'0004        BCC      ??timer_timeout_reached_0
   \       0x28   0x8A00'0001        BHI      ??timer_timeout_reached_1
   \       0x2C   0xE150'0002        CMP      R0,R2
   \       0x30   0x3A00'0001        BCC      ??timer_timeout_reached_0
   \                     ??timer_timeout_reached_1:
   \       0x34   0xE3A0'0001        MOV      R0,#+1
   \       0x38   0xEA00'0000        B        ??timer_timeout_reached_2
   \                     ??timer_timeout_reached_0:
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \                     ??timer_timeout_reached_2:
   \       0x40   0xE6EF'0070        UXTB     R0,R0
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
    146          }
    147          

   \                                 In section SOFTPACK, align 4, keep-with-next
    148          void timer_sleep(uint64_t count)
    149          {
   \                     timer_sleep:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1A0'6000        MOV      R6,R0
   \        0x8   0xE1A0'7001        MOV      R7,R1
    150          	uint64_t end_tick = timer_get_tick() + count;
   \        0xC   0x....'....        BL       timer_get_tick
   \       0x10   0xE090'4006        ADDS     R4,R0,R6
   \       0x14   0xE0A1'5007        ADC      R5,R1,R7
    151          
    152          	while (timer_get_tick() <= end_tick);
   \                     ??timer_sleep_0:
   \       0x18   0x....'....        BL       timer_get_tick
   \       0x1C   0xE155'0001        CMP      R5,R1
   \       0x20   0x8AFF'FFFC        BHI      ??timer_sleep_0
   \       0x24   0x3A00'0001        BCC      ??timer_sleep_1
   \       0x28   0xE154'0000        CMP      R4,R0
   \       0x2C   0x2AFF'FFF9        BCS      ??timer_sleep_0
    153          }
   \                     ??timer_sleep_1:
   \       0x30   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    154          

   \                                 In section SOFTPACK, align 4, keep-with-next
    155          uint64_t timer_get_tick(void)
    156          {
   \                     timer_get_tick:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    157          	return (_timer_get_tick() * 1000) / _timer.channel_freq;
   \        0x4   0x....'....        BL       _timer_get_tick
   \        0x8   0xE1A0'2000        MOV      R2,R0
   \        0xC   0xE1A0'3001        MOV      R3,R1
   \       0x10   0xE3A0'4FFA        MOV      R4,#+1000
   \       0x14   0xE3A0'5000        MOV      R5,#+0
   \       0x18   0xE081'0492        UMULL    R0,R1,R2,R4
   \       0x1C   0xE021'1592        MLA      R1,R2,R5,R1
   \       0x20   0xE021'1493        MLA      R1,R3,R4,R1
   \       0x24   0x....'....        LDR      R2,??DataTable6
   \       0x28   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x2C   0xE3B0'3000        MOVS     R3,#+0
   \       0x30   0x....'....        BL       __aeabi_uldivmod
   \       0x34   0xE8BD'8034        POP      {R2,R4,R5,PC}    ;; return
    158          }
    159          

   \                                 In section SOFTPACK, align 4, keep-with-next
    160          void sleep(uint32_t count)
    161          {
   \                     sleep:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    162          	timer_sleep(count * 1000);
   \        0x8   0xE3A0'1FFA        MOV      R1,#+1000
   \        0xC   0xE010'0491        MULS     R0,R1,R4
   \       0x10   0xE3B0'1000        MOVS     R1,#+0
   \       0x14   0x....'....        BL       timer_sleep
    163          }
   \       0x18   0xE8BD'8010        POP      {R4,PC}          ;; return
    164          

   \                                 In section SOFTPACK, align 4, keep-with-next
    165          void msleep(uint32_t count)
    166          {
   \                     msleep:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    167          	timer_sleep(count);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE3B0'1000        MOVS     R1,#+0
   \       0x10   0x....'....        BL       timer_sleep
    168          }
   \       0x14   0xE8BD'8010        POP      {R4,PC}          ;; return
    169          

   \                                 In section SOFTPACK, align 4, keep-with-next
    170          void usleep(uint32_t count)
    171          {
   \                     usleep:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'6000        MOVS     R6,R0
    172          	uint64_t deadline;
    173          
    174          	/* Disable interrupts */
    175          	arch_irq_disable();
   \        0x8   0x....'....        BL       arch_irq_disable
    176          
    177          	/* Compute deadline */
    178          	deadline = _timer_get_tick();
   \        0xC   0x....'....        BL       _timer_get_tick
   \       0x10   0xE1A0'4000        MOV      R4,R0
   \       0x14   0xE1A0'5001        MOV      R5,R1
    179          	deadline += ROUND_INT_DIV((_timer.channel_freq / 1000) * count, 1000);
   \       0x18   0xE3A0'7FFA        MOV      R7,#+1000
   \       0x1C   0x....'....        LDR      R8,??DataTable6
   \       0x20   0xE598'0008        LDR      R0,[R8, #+8]
   \       0x24   0xE1B0'1007        MOVS     R1,R7
   \       0x28   0x....'....        BL       __aeabi_uidiv
   \       0x2C   0xE010'0096        MULS     R0,R6,R0
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x1A00'0001        BNE      ??usleep_0
   \       0x38   0xE3A0'0000        MOV      R0,#+0
   \       0x3C   0xEA00'001B        B        ??usleep_1
   \                     ??usleep_0:
   \       0x40   0xE598'0008        LDR      R0,[R8, #+8]
   \       0x44   0xE1B0'1007        MOVS     R1,R7
   \       0x48   0x....'....        BL       __aeabi_uidiv
   \       0x4C   0xE010'0096        MULS     R0,R6,R0
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x1A00'0001        BNE      ??usleep_2
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xEA00'0000        B        ??usleep_3
   \                     ??usleep_2:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \                     ??usleep_3:
   \       0x64   0xE6EF'0070        UXTB     R0,R0
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x0A00'0008        BEQ      ??usleep_4
   \       0x70   0xE598'0008        LDR      R0,[R8, #+8]
   \       0x74   0xE1B0'1007        MOVS     R1,R7
   \       0x78   0x....'....        BL       __aeabi_uidiv
   \       0x7C   0xE3E0'10F3        MVN      R1,#+243
   \       0x80   0xE3C1'1F40        BIC      R1,R1,#0x100
   \       0x84   0xE020'1096        MLA      R0,R6,R0,R1
   \       0x88   0xE1B0'1007        MOVS     R1,R7
   \       0x8C   0x....'....        BL       __aeabi_uidiv
   \       0x90   0xEA00'0006        B        ??usleep_1
   \                     ??usleep_4:
   \       0x94   0xE598'0008        LDR      R0,[R8, #+8]
   \       0x98   0xE1B0'1007        MOVS     R1,R7
   \       0x9C   0x....'....        BL       __aeabi_uidiv
   \       0xA0   0xE010'0096        MULS     R0,R6,R0
   \       0xA4   0xE290'0F7D        ADDS     R0,R0,#+500
   \       0xA8   0xE1B0'1007        MOVS     R1,R7
   \       0xAC   0x....'....        BL       __aeabi_uidiv
   \                     ??usleep_1:
   \       0xB0   0xE3B0'1000        MOVS     R1,#+0
   \       0xB4   0xE094'4000        ADDS     R4,R4,R0
   \       0xB8   0xE0A5'5001        ADC      R5,R5,R1
    180          
    181          	/* Wait for deadline to be reached */
    182          	while ((int64_t)(_timer_get_tick() - deadline) < 0);
   \                     ??usleep_5:
   \       0xBC   0x....'....        BL       _timer_get_tick
   \       0xC0   0xE050'0004        SUBS     R0,R0,R4
   \       0xC4   0xE0C1'1005        SBC      R1,R1,R5
   \       0xC8   0xE351'0000        CMP      R1,#+0
   \       0xCC   0xBAFF'FFFA        BLT      ??usleep_5
   \       0xD0   0xCA00'0001        BGT      ??usleep_6
   \       0xD4   0xE350'0000        CMP      R0,#+0
   \       0xD8   0x3AFF'FFF7        BCC      ??usleep_5
    183          
    184          	/* Re-enable interrupts */
    185          	arch_irq_enable();
   \                     ??usleep_6:
   \       0xDC   0x....'....        BL       arch_irq_enable
    186          }
   \       0xE0   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     _timer

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _timer_get_tick
        16   -> tc_get_cv
        16   -> timer_get_upper_tick_counter
       0   arch_irq_disable
       0   arch_irq_enable
       8   msleep
         8   -> timer_sleep
       8   sleep
         8   -> timer_sleep
      24   timer_configure
        24   -> get_tc_id_from_addr
        24   -> irq_add_handler
        24   -> irq_enable
        24   -> pmc_configure_peripheral
        24   -> pmc_is_peripheral_enabled
        24   -> tc_configure
        24   -> tc_enable_it
        24   -> tc_get_channel_freq
        24   -> tc_start
       4   timer_get_interval
      16   timer_get_tick
        16   -> _timer_get_tick
        16 __aeabi_uldivmod
       8   timer_get_upper_tick_counter
         8   -> timer_update_upper_tick_counter
      16   timer_irq_handler
        16   -> timer_update_upper_tick_counter
       8   timer_reset_timeout
         8   -> timer_get_tick
      24   timer_sleep
        24   -> timer_get_tick
      16   timer_start_timeout
        16   -> timer_get_tick
       8   timer_timeout_reached
         8   -> timer_get_interval
         8   -> timer_get_tick
       8   timer_update_upper_tick_counter
         8   -> tc_get_status
      24   usleep
        24   -> _timer_get_tick
        24   -> arch_irq_disable
        24   -> arch_irq_enable
        24 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
      16  _timer
      56  _timer_get_tick
       8  arch_irq_disable
       8  arch_irq_enable
      24  msleep
      28  sleep
     188  timer_configure
      64  timer_get_interval
      56  timer_get_tick
      20  timer_get_upper_tick_counter
      20  timer_irq_handler
      20  timer_reset_timeout
      52  timer_sleep
      32  timer_start_timeout
      72  timer_timeout_reached
      44  timer_update_upper_tick_counter
     228  usleep

 
  16 bytes in section .bss
 924 bytes in section SOFTPACK
 
 924 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
