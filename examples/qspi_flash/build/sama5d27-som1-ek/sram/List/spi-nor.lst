###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         18/Feb/2021  16:03:20
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\spi-nor.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EWB6BD.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\spi-nor.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_QSPI -D CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_NFC -D
#        CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D
#        CONFIG_HAVE_GMAC_QUEUES -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_MPDDRC_DDR3 -D CONFIG_HAVE_MPDDRC_LPDDR3 -D
#        CONFIG_HAVE_ADC_SETTLING_TIME -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_FAST_STARTUP -D
#        CONFIG_HAVE_PMC_GENERATED_CLOCKS -D CONFIG_HAVE_PMC_AUDIO_CLOCK -D
#        CONFIG_HAVE_PMC_PLLADIV2 -D CONFIG_HAVE_PMC_H32MXDIV -D
#        CONFIG_HAVE_PMC_UPLL_BIAS -D CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA
#        -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
#        -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_SFRBU
#        -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_TRNG -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List\spi-nor.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj\spi-nor.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf         
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\spi-nor.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2017, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           */
     28          
     29          /*----------------------------------------------------------------------------
     30           *        Headers
     31           *----------------------------------------------------------------------------*/
     32          
     33          #include "board.h"
     34          #include "errno.h"
     35          #include "intmath.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp uint32_t min_u32(uint32_t, uint32_t)
   \                     min_u32:
   \        0x0   0xE1B0'2000        MOVS     R2,R0
   \        0x4   0xE152'0001        CMP      R2,R1
   \        0x8   0x2A00'0001        BCS      ??min_u32_0
   \        0xC   0xE1B0'0002        MOVS     R0,R2
   \       0x10   0xEA00'0000        B        ??min_u32_1
   \                     ??min_u32_0:
   \       0x14   0xE1B0'0001        MOVS     R0,R1
   \                     ??min_u32_1:
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
     36          #include "mm/cache.h"
     37          #include "nvm/spi-nor/spi-nor.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void spi_flash_set_read_settings(struct spi_flash_read_command *, uint8_t, uint8_t, uint8_t, enum spi_flash_protocol)
   \                     spi_flash_set_read_settings:
   \        0x0   0xE59D'C000        LDR      R12,[SP, #+0]
   \        0x4   0xE5C0'1000        STRB     R1,[R0, #+0]
   \        0x8   0xE5C0'2001        STRB     R2,[R0, #+1]
   \        0xC   0xE5C0'3002        STRB     R3,[R0, #+2]
   \       0x10   0xE580'C004        STR      R12,[R0, #+4]
   \       0x14   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void spi_flash_set_pp_settings(struct spi_flash_pp_command *, uint8_t, enum spi_flash_protocol)
   \                     spi_flash_set_pp_settings:
   \        0x0   0xE5C0'1000        STRB     R1,[R0, #+0]
   \        0x4   0xE580'2004        STR      R2,[R0, #+4]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     38          #include "peripherals/bus.h"
     39          #include "timer.h"
     40          #include "trace.h"
     41          
     42          /*----------------------------------------------------------------------------
     43           *        Debug Constants
     44           *----------------------------------------------------------------------------*/
     45          
     46          //#define SPI_NOR_VERBOSE_DEBUG
     47          
     48          /*----------------------------------------------------------------------------
     49           *        Local Variables
     50           *----------------------------------------------------------------------------*/
     51          

   \                                 In section .bss, align 4
     52          static struct spi_flash_parameters params;
   \                     params:
   \        0x0                      DS8 112
     53          

   \                                 In section .bss, align 4
     54          static CACHE_ALIGNED uint8_t _spi_flash_hdr[16];
                        ^
Warning[Pe606]: this pragma must immediately precede a declaration

  static CACHE_ALIGNED uint8_t _spi_flash_hdr[16];
         ^
"C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\spi-nor.c",54  Warning[Pe606]: 
          this pragma must immediately precede a declaration
   \                     _spi_flash_hdr:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
     55          static struct _buffer _bus_exec_buffer[2];
   \                     _bus_exec_buffer:
   \        0x0                      DS8 24
     56          

   \                                 In section .rodata, align 4
     57          static const char flash_name[] = "unknown";
   \                     flash_name:
   \        0x0   0x75 0x6E          DC8 "unknown"

   \              0x6B 0x6E    

   \              0x6F 0x77    

   \              0x6E 0x00
     58          
     59          /*----------------------------------------------------------------------------
     60           *        Local Functions
     61           *----------------------------------------------------------------------------*/
     62          

   \                                 In section SOFTPACK, align 4, keep-with-next
     63          static const struct spi_nor_info *spi_nor_read_id(struct spi_flash *flash)
     64          {
   \                     spi_nor_read_id:
   \        0x0   0xE92D'41FC        PUSH     {R2-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
     65          	const struct spi_nor_info *info;
     66          	char id_str[8], *p;
     67          	int i, rc;
     68          
     69          #ifdef SPI_NOR_VERBOSE_DEBUG
     70          	trace_debug("spi-nor: cmd: 0x%02x\r\n", SFLASH_INST_READ_ID);
     71          #endif
     72          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_ID, flash->id, sizeof(flash->id));
   \        0x8   0xE3A0'3006        MOV      R3,#+6
   \        0xC   0xE294'2033        ADDS     R2,R4,#+51
   \       0x10   0xE3A0'109F        MOV      R1,#+159
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0x....'....        BL       spi_flash_read_reg
   \       0x1C   0xE1B0'5000        MOVS     R5,R0
     73          	if (rc < 0)
   \       0x20   0xE355'0000        CMP      R5,#+0
   \       0x24   0x5A00'0001        BPL      ??spi_nor_read_id_0
     74          		return NULL;
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0xEA00'0038        B        ??spi_nor_read_id_1
     75          
     76          	p = id_str;
   \                     ??spi_nor_read_id_0:
   \       0x30   0xE1B0'700D        MOVS     R7,SP
     77          	for (i = 0; i < 3; i++) {
   \       0x34   0xE3A0'6000        MOV      R6,#+0
   \                     ??spi_nor_read_id_2:
   \       0x38   0xE356'0003        CMP      R6,#+3
   \       0x3C   0xAA00'001C        BGE      ??spi_nor_read_id_3
     78          		uint8_t lo = (flash->id[i] & 0x0f) >> 0;
   \       0x40   0xE094'0006        ADDS     R0,R4,R6
   \       0x44   0xE5D0'0033        LDRB     R0,[R0, #+51]
   \       0x48   0xE210'100F        ANDS     R1,R0,#0xF
     79          		uint8_t hi = (flash->id[i] & 0xf0) >> 4;
   \       0x4C   0xE094'0006        ADDS     R0,R4,R6
   \       0x50   0xE5D0'0033        LDRB     R0,[R0, #+51]
   \       0x54   0xE6EF'0070        UXTB     R0,R0
   \       0x58   0xE1B0'2220        LSRS     R2,R0,#+4
     80          
     81          		*p++ = (hi < 10) ? ('0' + hi) : ('a' + hi - 10);
   \       0x5C   0xE1B0'3007        MOVS     R3,R7
   \       0x60   0xE293'0001        ADDS     R0,R3,#+1
   \       0x64   0xE1B0'C002        MOVS     R12,R2
   \       0x68   0xE6EF'C07C        UXTB     R12,R12
   \       0x6C   0xE35C'000A        CMP      R12,#+10
   \       0x70   0xAA00'0001        BGE      ??spi_nor_read_id_4
   \       0x74   0xE292'C030        ADDS     R12,R2,#+48
   \       0x78   0xEA00'0000        B        ??spi_nor_read_id_5
   \                     ??spi_nor_read_id_4:
   \       0x7C   0xE292'C057        ADDS     R12,R2,#+87
   \                     ??spi_nor_read_id_5:
   \       0x80   0xE5C3'C000        STRB     R12,[R3, #+0]
     82          		*p++ = (lo < 10) ? ('0' + lo) : ('a' + lo - 10);
   \       0x84   0xE1B0'3000        MOVS     R3,R0
   \       0x88   0xE293'7001        ADDS     R7,R3,#+1
   \       0x8C   0xE1B0'0001        MOVS     R0,R1
   \       0x90   0xE6EF'0070        UXTB     R0,R0
   \       0x94   0xE350'000A        CMP      R0,#+10
   \       0x98   0xAA00'0001        BGE      ??spi_nor_read_id_6
   \       0x9C   0xE291'0030        ADDS     R0,R1,#+48
   \       0xA0   0xEA00'0000        B        ??spi_nor_read_id_7
   \                     ??spi_nor_read_id_6:
   \       0xA4   0xE291'0057        ADDS     R0,R1,#+87
   \                     ??spi_nor_read_id_7:
   \       0xA8   0xE5C3'0000        STRB     R0,[R3, #+0]
     83          	}
   \       0xAC   0xE296'6001        ADDS     R6,R6,#+1
   \       0xB0   0xEAFF'FFE0        B        ??spi_nor_read_id_2
     84          	*p = '\0';
   \                     ??spi_nor_read_id_3:
   \       0xB4   0xE3A0'0000        MOV      R0,#+0
   \       0xB8   0xE5C7'0000        STRB     R0,[R7, #+0]
     85          	trace_info("SF: Got Manufacturer and Device ID: %s\r\n", id_str);
   \       0xBC   0x....'....        LDR      R0,??DataTable7
   \       0xC0   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xC4   0xE350'0004        CMP      R0,#+4
   \       0xC8   0x3A00'0002        BCC      ??spi_nor_read_id_8
   \       0xCC   0xE1B0'100D        MOVS     R1,SP
   \       0xD0   0x....'....        LDR      R0,??DataTable7_1
   \       0xD4   0x....'....        BL       printf
     86          
     87          	for (info = spi_nor_ids; info->name; info++) {
   \                     ??spi_nor_read_id_8:
   \       0xD8   0x....'....        LDR      R8,??DataTable7_2
   \                     ??spi_nor_read_id_9:
   \       0xDC   0xE598'0000        LDR      R0,[R8, #+0]
   \       0xE0   0xE350'0000        CMP      R0,#+0
   \       0xE4   0x0A00'0009        BEQ      ??spi_nor_read_id_10
     88          		if (!memcmp(info->id, flash->id, info->id_len))
   \       0xE8   0xE5D8'200A        LDRB     R2,[R8, #+10]
   \       0xEC   0xE294'1033        ADDS     R1,R4,#+51
   \       0xF0   0xE298'0004        ADDS     R0,R8,#+4
   \       0xF4   0x....'....        BL       memcmp
   \       0xF8   0xE350'0000        CMP      R0,#+0
   \       0xFC   0x1A00'0001        BNE      ??spi_nor_read_id_11
     89          			return info;
   \      0x100   0xE1B0'0008        MOVS     R0,R8
   \      0x104   0xEA00'0002        B        ??spi_nor_read_id_1
     90          	}
   \                     ??spi_nor_read_id_11:
   \      0x108   0xE298'801C        ADDS     R8,R8,#+28
   \      0x10C   0xEAFF'FFF2        B        ??spi_nor_read_id_9
     91          
     92          	return NULL;
   \                     ??spi_nor_read_id_10:
   \      0x110   0xE3A0'0000        MOV      R0,#+0
   \                     ??spi_nor_read_id_1:
   \      0x114   0xE8BD'81F6        POP      {R1,R2,R4-R8,PC}  ;; return
     93          }
     94          

   \                                 In section SOFTPACK, align 4, keep-with-next
     95          static int spi_nor_init_params(struct spi_flash *flash, const struct spi_nor_info *info, struct spi_flash_parameters *fparams)
     96          {
   \                     spi_nor_init_params:
   \        0x0   0xE92D'4FFE        PUSH     {R1-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
     97          	struct spi_flash_erase_map *map = &flash->erase_map;
   \       0x10   0xE294'A048        ADDS     R10,R4,#+72
     98          	uint32_t erase_mask = 0;
   \       0x14   0xE3A0'7000        MOV      R7,#+0
   \       0x18   0xE58D'7004        STR      R7,[SP, #+4]
     99          	uint32_t erase_offset = 0;
   \       0x1C   0xE1B0'9007        MOVS     R9,R7
    100          
    101          	if (info && info->params)
   \       0x20   0xE355'0000        CMP      R5,#+0
   \       0x24   0x0A00'000C        BEQ      ??spi_nor_init_params_0
   \       0x28   0xE595'0018        LDR      R0,[R5, #+24]
   \       0x2C   0xE350'0000        CMP      R0,#+0
   \       0x30   0x0A00'0009        BEQ      ??spi_nor_init_params_0
    102          		memcpy(fparams, info->params, sizeof(*fparams));
   \       0x34   0xE3A0'8070        MOV      R8,#+112
   \       0x38   0xE595'0018        LDR      R0,[R5, #+24]
   \       0x3C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x40   0xE1B0'B006        MOVS     R11,R6
   \       0x44   0xE1B0'2008        MOVS     R2,R8
   \       0x48   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x4C   0xE1B0'000B        MOVS     R0,R11
   \       0x50   0x....'....        BL       __aeabi_memcpy
   \       0x54   0xE1B0'000B        MOVS     R0,R11
   \       0x58   0xEA00'0007        B        ??spi_nor_init_params_1
    103          	else
    104          		memset(fparams, 0, sizeof(*fparams));
   \                     ??spi_nor_init_params_0:
   \       0x5C   0xE3A0'8070        MOV      R8,#+112
   \       0x60   0xE3A0'B000        MOV      R11,#+0
   \       0x64   0xE58D'6000        STR      R6,[SP, #+0]
   \       0x68   0xE1B0'200B        MOVS     R2,R11
   \       0x6C   0xE1B0'1008        MOVS     R1,R8
   \       0x70   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x74   0x....'....        BL       __aeabi_memset
   \       0x78   0xE59D'0000        LDR      R0,[SP, #+0]
    105          
    106          	/* Set SPI NOR sizes. */
    107          	if (info) {
   \                     ??spi_nor_init_params_1:
   \       0x7C   0xE355'0000        CMP      R5,#+0
   \       0x80   0x0A00'0006        BEQ      ??spi_nor_init_params_2
    108          		fparams->size = info->sector_size * info->n_sectors;
   \       0x84   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x88   0xE1D5'11B0        LDRH     R1,[R5, #+16]
   \       0x8C   0xE010'0091        MULS     R0,R1,R0
   \       0x90   0xE586'0000        STR      R0,[R6, #+0]
    109          		fparams->page_size = info->page_size;
   \       0x94   0xE1D5'01B2        LDRH     R0,[R5, #+18]
   \       0x98   0xE586'0004        STR      R0,[R6, #+4]
   \       0x9C   0xEA00'0001        B        ??spi_nor_init_params_3
    110          	} else {
    111          		flash->page_size = 256;
   \                     ??spi_nor_init_params_2:
   \       0xA0   0xE3A0'0F40        MOV      R0,#+256
   \       0xA4   0xE584'0044        STR      R0,[R4, #+68]
    112          	}
    113          
    114          	/* Set legacy flash parameters as default. */
    115          	if (info && info->params)
   \                     ??spi_nor_init_params_3:
   \       0xA8   0xE355'0000        CMP      R5,#+0
   \       0xAC   0x0A00'0002        BEQ      ??spi_nor_init_params_4
   \       0xB0   0xE595'0018        LDR      R0,[R5, #+24]
   \       0xB4   0xE350'0000        CMP      R0,#+0
   \       0xB8   0x1A00'001E        BNE      ??spi_nor_init_params_5
    116          		goto set_erase_map;
    117          
    118          	/* (Fast) Read settings. */
    119          	fparams->hwcaps.mask |= SFLASH_HWCAPS_READ;
   \                     ??spi_nor_init_params_4:
   \       0xBC   0xE596'0008        LDR      R0,[R6, #+8]
   \       0xC0   0xE390'0001        ORRS     R0,R0,#0x1
   \       0xC4   0xE586'0008        STR      R0,[R6, #+8]
    120          	spi_flash_set_read_settings(&fparams->reads[SFLASH_CMD_READ], 0, 0, SFLASH_INST_READ, SFLASH_PROTO_1_1_1);
   \       0xC8   0x....'....        LDR      R8,??DataTable7_3  ;; 0x10101
   \       0xCC   0xE58D'8000        STR      R8,[SP, #+0]
   \       0xD0   0xE3A0'3003        MOV      R3,#+3
   \       0xD4   0xE3A0'2000        MOV      R2,#+0
   \       0xD8   0xE3A0'1000        MOV      R1,#+0
   \       0xDC   0xE296'000C        ADDS     R0,R6,#+12
   \       0xE0   0x....'....        BL       spi_flash_set_read_settings
    121          	if (!info || !(info->flags & SNOR_NO_FR)) {
   \       0xE4   0xE355'0000        CMP      R5,#+0
   \       0xE8   0x0A00'0002        BEQ      ??spi_nor_init_params_6
   \       0xEC   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \       0xF0   0xE310'0002        TST      R0,#0x2
   \       0xF4   0x1A00'0008        BNE      ??spi_nor_init_params_7
    122          		fparams->hwcaps.mask |= SFLASH_HWCAPS_READ_FAST;
   \                     ??spi_nor_init_params_6:
   \       0xF8   0xE596'0008        LDR      R0,[R6, #+8]
   \       0xFC   0xE390'0002        ORRS     R0,R0,#0x2
   \      0x100   0xE586'0008        STR      R0,[R6, #+8]
    123          		spi_flash_set_read_settings(&fparams->reads[SFLASH_CMD_READ_FAST], 0, 8, SFLASH_INST_FAST_READ, SFLASH_PROTO_1_1_1);
   \      0x104   0xE58D'8000        STR      R8,[SP, #+0]
   \      0x108   0xE3A0'300B        MOV      R3,#+11
   \      0x10C   0xE3A0'2008        MOV      R2,#+8
   \      0x110   0xE3A0'1000        MOV      R1,#+0
   \      0x114   0xE296'0014        ADDS     R0,R6,#+20
   \      0x118   0x....'....        BL       spi_flash_set_read_settings
    124          	}
    125          
    126          	/* Page Program settings. */
    127          	fparams->hwcaps.mask |= SFLASH_HWCAPS_PP;
   \                     ??spi_nor_init_params_7:
   \      0x11C   0xE596'0008        LDR      R0,[R6, #+8]
   \      0x120   0xE390'0B40        ORRS     R0,R0,#0x10000
   \      0x124   0xE586'0008        STR      R0,[R6, #+8]
    128          	spi_flash_set_pp_settings(&fparams->page_programs[SFLASH_CMD_PP], SFLASH_INST_PAGE_PROGRAM, SFLASH_PROTO_1_1_1);
   \      0x128   0xE1B0'2008        MOVS     R2,R8
   \      0x12C   0xE3A0'1002        MOV      R1,#+2
   \      0x130   0xE296'004C        ADDS     R0,R6,#+76
   \      0x134   0x....'....        BL       spi_flash_set_pp_settings
    129          
    130          	/* Sector Erase settings. */
    131          set_erase_map:
    132          	if (info && info->flags & SNOR_SECT_4K_ONLY) {
   \                     ??spi_nor_init_params_5:
   \      0x138   0xE355'0000        CMP      R5,#+0
   \      0x13C   0x0A00'000C        BEQ      ??spi_nor_init_params_8
   \      0x140   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \      0x144   0xE310'0020        TST      R0,#0x20
   \      0x148   0x0A00'0009        BEQ      ??spi_nor_init_params_8
    133          		erase_mask |= (0x1UL << erase_offset);
   \      0x14C   0xE59D'0004        LDR      R0,[SP, #+4]
   \      0x150   0xE3A0'1001        MOV      R1,#+1
   \      0x154   0xE190'8911        ORRS     R8,R0,R1, LSL R9
    134          		spi_flash_set_erase_command(&map->commands[erase_offset], 4096u, SFLASH_INST_ERASE_4K);
   \      0x158   0xE3A0'2020        MOV      R2,#+32
   \      0x15C   0xE3A0'1D40        MOV      R1,#+4096
   \      0x160   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x164   0xE09A'0000        ADDS     R0,R10,R0
   \      0x168   0x....'....        BL       spi_flash_set_erase_command
    135          		erase_offset++;
   \      0x16C   0xE299'9001        ADDS     R9,R9,#+1
   \      0x170   0xEA00'0024        B        ??spi_nor_init_params_9
    136          	} else {
    137          		/* 64KB erase is always supported */
    138          		erase_mask |= (0x1UL << erase_offset);
   \                     ??spi_nor_init_params_8:
   \      0x174   0xE3A0'B001        MOV      R11,#+1
   \      0x178   0xE59D'0004        LDR      R0,[SP, #+4]
   \      0x17C   0xE190'891B        ORRS     R8,R0,R11, LSL R9
    139          		spi_flash_set_erase_command(&map->commands[erase_offset], info ? info->sector_size : 65536u, SFLASH_INST_ERASE_64K);
   \      0x180   0xE355'0000        CMP      R5,#+0
   \      0x184   0x0A00'0001        BEQ      ??spi_nor_init_params_10
   \      0x188   0xE595'100C        LDR      R1,[R5, #+12]
   \      0x18C   0xEA00'0000        B        ??spi_nor_init_params_11
   \                     ??spi_nor_init_params_10:
   \      0x190   0xE3A0'1B40        MOV      R1,#+65536
   \                     ??spi_nor_init_params_11:
   \      0x194   0xE3A0'20D8        MOV      R2,#+216
   \      0x198   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x19C   0xE09A'0000        ADDS     R0,R10,R0
   \      0x1A0   0x....'....        BL       spi_flash_set_erase_command
    140          		erase_offset++;
   \      0x1A4   0xE299'9001        ADDS     R9,R9,#+1
    141          
    142          		if (info && info->flags & SNOR_SECT_4K) {
   \      0x1A8   0xE355'0000        CMP      R5,#+0
   \      0x1AC   0x0A00'0009        BEQ      ??spi_nor_init_params_12
   \      0x1B0   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \      0x1B4   0xE310'0001        TST      R0,#0x1
   \      0x1B8   0x0A00'0006        BEQ      ??spi_nor_init_params_12
    143          			erase_mask |= (0x1UL << erase_offset);
   \      0x1BC   0xE198'891B        ORRS     R8,R8,R11, LSL R9
    144          			spi_flash_set_erase_command(&map->commands[erase_offset], 4096u, SFLASH_INST_ERASE_4K);
   \      0x1C0   0xE3A0'2020        MOV      R2,#+32
   \      0x1C4   0xE3A0'1D40        MOV      R1,#+4096
   \      0x1C8   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x1CC   0xE09A'0000        ADDS     R0,R10,R0
   \      0x1D0   0x....'....        BL       spi_flash_set_erase_command
    145          			erase_offset++;
   \      0x1D4   0xE299'9001        ADDS     R9,R9,#+1
    146          		}
    147          
    148          		if (info && info->flags & SNOR_SECT_32K) {
   \                     ??spi_nor_init_params_12:
   \      0x1D8   0xE355'0000        CMP      R5,#+0
   \      0x1DC   0x0A00'0009        BEQ      ??spi_nor_init_params_9
   \      0x1E0   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \      0x1E4   0xE310'0080        TST      R0,#0x80
   \      0x1E8   0x0A00'0006        BEQ      ??spi_nor_init_params_9
    149          			erase_mask |= (0x1UL << erase_offset);
   \      0x1EC   0xE198'891B        ORRS     R8,R8,R11, LSL R9
    150          			spi_flash_set_erase_command(&map->commands[erase_offset], 32768u, SFLASH_INST_ERASE_32K);
   \      0x1F0   0xE3A0'2052        MOV      R2,#+82
   \      0x1F4   0xE3A0'1C80        MOV      R1,#+32768
   \      0x1F8   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x1FC   0xE09A'0000        ADDS     R0,R10,R0
   \      0x200   0x....'....        BL       spi_flash_set_erase_command
    151          			erase_offset++;
   \      0x204   0xE299'9001        ADDS     R9,R9,#+1
    152          		}
    153          	}
    154          	spi_flash_init_uniform_erase_map(map, erase_mask, fparams->size);
   \                     ??spi_nor_init_params_9:
   \      0x208   0xE596'2000        LDR      R2,[R6, #+0]
   \      0x20C   0xE3B0'3000        MOVS     R3,#+0
   \      0x210   0xE1B0'1008        MOVS     R1,R8
   \      0x214   0xE1B0'000A        MOVS     R0,R10
   \      0x218   0x....'....        BL       spi_flash_init_uniform_erase_map
    155          
    156          	/* Quad Enable Requirements & 0-4-4 Mode Entry Method. */
    157          	flash->enable_0_4_4 = NULL;
   \      0x21C   0xE584'70B0        STR      R7,[R4, #+176]
    158          	switch (spi_flash_get_mfr(flash)) {
   \      0x220   0xE1B0'0004        MOVS     R0,R4
   \      0x224   0x....'....        BL       spi_flash_get_mfr
   \      0x228   0xE350'001F        CMP      R0,#+31
   \      0x22C   0x0A00'000E        BEQ      ??spi_nor_init_params_13
   \      0x230   0xE350'0020        CMP      R0,#+32
   \      0x234   0x0A00'0004        BEQ      ??spi_nor_init_params_14
   \      0x238   0xE350'00BF        CMP      R0,#+191
   \      0x23C   0x0A00'000D        BEQ      ??spi_nor_init_params_15
   \      0x240   0xE350'00C2        CMP      R0,#+194
   \      0x244   0x0A00'0005        BEQ      ??spi_nor_init_params_16
   \      0x248   0xEA00'001B        B        ??spi_nor_init_params_17
    159          	case SFLASH_MFR_MICRON:
    160          		fparams->quad_enable = NULL;
   \                     ??spi_nor_init_params_14:
   \      0x24C   0xE586'706C        STR      R7,[R6, #+108]
    161          		flash->enable_0_4_4 = micron_enable_0_4_4;
   \      0x250   0x....'....        LDR      R0,??DataTable8
   \      0x254   0xE584'00B0        STR      R0,[R4, #+176]
    162          		flash->xip_mode = 0x00u;
   \      0x258   0xE5C4'7030        STRB     R7,[R4, #+48]
    163          		break;
   \      0x25C   0xEA00'0018        B        ??spi_nor_init_params_18
    164          
    165          	case SFLASH_MFR_MACRONIX:
    166          		fparams->quad_enable = macronix_quad_enable;
   \                     ??spi_nor_init_params_16:
   \      0x260   0x....'....        LDR      R0,??DataTable8_1
   \      0x264   0xE586'006C        STR      R0,[R6, #+108]
    167          		break;
   \      0x268   0xEA00'0015        B        ??spi_nor_init_params_18
    168          
    169          	case SFLASH_MFR_ATMEL:
    170          		flash->set_protection = at25_set_protection;
   \                     ??spi_nor_init_params_13:
   \      0x26C   0x....'....        LDR      R0,??DataTable8_2
   \      0x270   0xE584'00B4        STR      R0,[R4, #+180]
    171          		break;
   \      0x274   0xEA00'0012        B        ??spi_nor_init_params_18
    172          
    173          	case SFLASH_MFR_SST:
    174          		flash->xip_mode = 0xa0u;
   \                     ??spi_nor_init_params_15:
   \      0x278   0xE3A0'00A0        MOV      R0,#+160
   \      0x27C   0xE5C4'0030        STRB     R0,[R4, #+48]
    175          		fparams->hwcaps.mask |= SFLASH_HWCAPS_READ_1_4_4;
   \      0x280   0xE596'0008        LDR      R0,[R6, #+8]
   \      0x284   0xE390'0040        ORRS     R0,R0,#0x40
   \      0x288   0xE586'0008        STR      R0,[R6, #+8]
    176          		fparams->reads[SFLASH_CMD_READ_1_4_4].num_mode_cycles = 2;
   \      0x28C   0xE3A0'0002        MOV      R0,#+2
   \      0x290   0xE5C6'003C        STRB     R0,[R6, #+60]
    177          		fparams->reads[SFLASH_CMD_READ_1_4_4].num_wait_states = 4;
   \      0x294   0xE3A0'0004        MOV      R0,#+4
   \      0x298   0xE5C6'003D        STRB     R0,[R6, #+61]
    178          		fparams->reads[SFLASH_CMD_READ_1_4_4].inst = SFLASH_INST_FAST_READ_1_4_4;
   \      0x29C   0xE3A0'00EB        MOV      R0,#+235
   \      0x2A0   0xE5C6'003E        STRB     R0,[R6, #+62]
    179          		fparams->reads[SFLASH_CMD_READ_1_4_4].proto = SFLASH_PROTO_1_4_4;
   \      0x2A4   0xE3A0'0004        MOV      R0,#+4
   \      0x2A8   0xE380'0B41        ORR      R0,R0,#0x10400
   \      0x2AC   0xE586'0040        STR      R0,[R6, #+64]
    180          		fparams->quad_enable = spansion_new_quad_enable;
   \      0x2B0   0x....'....        LDR      R0,??DataTable8_3
   \      0x2B4   0xE586'006C        STR      R0,[R6, #+108]
    181          		break;
   \      0x2B8   0xEA00'0001        B        ??spi_nor_init_params_18
    182          
    183          	default:
    184          		fparams->quad_enable = spansion_quad_enable;
   \                     ??spi_nor_init_params_17:
   \      0x2BC   0x....'....        LDR      R0,??DataTable8_4
   \      0x2C0   0xE586'006C        STR      R0,[R6, #+108]
    185          		break;
    186          	}
    187          
    188          	/* Override the parameters with data read from SFDP tables. */
    189          	if (!info || !(info->flags & SNOR_SKIP_SFDP))
   \                     ??spi_nor_init_params_18:
   \      0x2C4   0xE355'0000        CMP      R5,#+0
   \      0x2C8   0x0A00'0002        BEQ      ??spi_nor_init_params_19
   \      0x2CC   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \      0x2D0   0xE310'0010        TST      R0,#0x10
   \      0x2D4   0x1A00'0002        BNE      ??spi_nor_init_params_20
    190          		spi_flash_parse_sfdp(flash, fparams);
   \                     ??spi_nor_init_params_19:
   \      0x2D8   0xE1B0'1006        MOVS     R1,R6
   \      0x2DC   0xE1B0'0004        MOVS     R0,R4
   \      0x2E0   0x....'....        BL       spi_flash_parse_sfdp
    191          
    192          	return 0;
   \                     ??spi_nor_init_params_20:
   \      0x2E4   0xE3A0'0000        MOV      R0,#+0
   \      0x2E8   0xE8BD'8FFE        POP      {R1-R11,PC}      ;; return
    193          }
    194          

   \                                 In section SOFTPACK, align 4, keep-with-next
    195          static uint8_t spi_nor_convert_inst(uint8_t inst, const uint8_t table[][2], size_t size)
    196          {
   \                     spi_nor_convert_inst:
   \        0x0   0xE92D'4000        PUSH     {LR}
   \        0x4   0xE1B0'3000        MOVS     R3,R0
    197          	size_t i;
    198          
    199          	for (i = 0; i < size; i++)
   \        0x8   0xE3A0'C000        MOV      R12,#+0
   \                     ??spi_nor_convert_inst_0:
   \        0xC   0xE15C'0002        CMP      R12,R2
   \       0x10   0x2A00'000B        BCS      ??spi_nor_convert_inst_1
    200          		if (table[i][0] == inst)
   \       0x14   0xE1B0'008C        LSLS     R0,R12,#+1
   \       0x18   0xE7D1'0000        LDRB     R0,[R1, +R0]
   \       0x1C   0xE1B0'E003        MOVS     LR,R3
   \       0x20   0xE6EF'E07E        UXTB     LR,LR
   \       0x24   0xE150'000E        CMP      R0,LR
   \       0x28   0x1A00'0003        BNE      ??spi_nor_convert_inst_2
    201          			return table[i][1];
   \       0x2C   0xE1B0'008C        LSLS     R0,R12,#+1
   \       0x30   0xE091'0000        ADDS     R0,R1,R0
   \       0x34   0xE5D0'0001        LDRB     R0,[R0, #+1]
   \       0x38   0xEA00'0003        B        ??spi_nor_convert_inst_3
   \                     ??spi_nor_convert_inst_2:
   \       0x3C   0xE29C'C001        ADDS     R12,R12,#+1
   \       0x40   0xEAFF'FFF1        B        ??spi_nor_convert_inst_0
    202          
    203          	/* No conversion found, keep input op code. */
    204          	return inst;
   \                     ??spi_nor_convert_inst_1:
   \       0x44   0xE1B0'0003        MOVS     R0,R3
   \       0x48   0xE6EF'0070        UXTB     R0,R0
   \                     ??spi_nor_convert_inst_3:
   \       0x4C   0xE8BD'8000        POP      {PC}             ;; return
    205          }
    206          

   \                                 In section SOFTPACK, align 4, keep-with-next
    207          static inline uint8_t spi_nor_convert_3to4_read(uint8_t inst)
    208          {
   \                     spi_nor_convert_3to4_read:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    209          	static const uint8_t spi_nor_3to4_read[][2] = {
    210          		{ SFLASH_INST_READ,		SFLASH_INST_READ_4B },
    211          		{ SFLASH_INST_FAST_READ,	SFLASH_INST_FAST_READ_4B },
    212          		{ SFLASH_INST_FAST_READ_1_1_2,	SFLASH_INST_FAST_READ_1_1_2_4B },
    213          		{ SFLASH_INST_FAST_READ_1_2_2,	SFLASH_INST_FAST_READ_1_2_2_4B },
    214          		{ SFLASH_INST_FAST_READ_1_1_4,	SFLASH_INST_FAST_READ_1_1_4_4B },
    215          		{ SFLASH_INST_FAST_READ_1_4_4,	SFLASH_INST_FAST_READ_1_4_4_4B },
    216          	};
    217          
    218          	return spi_nor_convert_inst(inst, spi_nor_3to4_read,
    219          				    ARRAY_SIZE(spi_nor_3to4_read));
   \        0x8   0xE3A0'2006        MOV      R2,#+6
   \        0xC   0x....'....        LDR      R1,??DataTable8_5
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0x....'....        BL       spi_nor_convert_inst
   \       0x1C   0xE8BD'8010        POP      {R4,PC}          ;; return
    220          }

   \                                 In section .rodata, align 4
   \                     `spi_nor_convert_3to4_read::spi_nor_3to4_read`:
   \        0x0   0x03 0x13          DC8 3, 19, 11, 12, 59, 60, 187, 188, 107, 108, 235, 236

   \              0x0B 0x0C    

   \              0x3B 0x3C    

   \              0xBB 0xBC    

   \              0x6B 0x6C    

   \              0xEB 0xEC
    221          

   \                                 In section SOFTPACK, align 4, keep-with-next
    222          static inline uint8_t spi_nor_convert_3to4_write(uint8_t inst)
    223          {
   \                     spi_nor_convert_3to4_write:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    224          	static const uint8_t spi_nor_3to4_program[][2] = {
    225          		{ SFLASH_INST_PAGE_PROGRAM,		SFLASH_INST_PAGE_PROGRAM_4B },
    226          		{ SFLASH_INST_PAGE_PROGRAM_1_1_4,	SFLASH_INST_PAGE_PROGRAM_1_1_4_4B },
    227          		{ SFLASH_INST_PAGE_PROGRAM_1_4_4,	SFLASH_INST_PAGE_PROGRAM_1_4_4_4B },
    228          	};
    229          
    230          	return spi_nor_convert_inst(inst, spi_nor_3to4_program,
    231          				    ARRAY_SIZE(spi_nor_3to4_program));
   \        0x8   0xE3A0'2003        MOV      R2,#+3
   \        0xC   0x....'....        LDR      R1,??DataTable8_6
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0x....'....        BL       spi_nor_convert_inst
   \       0x1C   0xE8BD'8010        POP      {R4,PC}          ;; return
    232          }

   \                                 In section .rodata, align 4
   \                     `spi_nor_convert_3to4_write::spi_nor_3to4_program`:
   \        0x0   0x02 0x12          DC8 2, 18, 50, 52, 56, 62, 0, 0

   \              0x32 0x34    

   \              0x38 0x3E    

   \              0x00 0x00
    233          

   \                                 In section SOFTPACK, align 4, keep-with-next
    234          static inline uint8_t spi_nor_convert_3to4_erase(uint8_t inst)
    235          {
   \                     spi_nor_convert_3to4_erase:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    236          	static const uint8_t spi_nor_3to4_erase[][2] = {
    237          		{ SFLASH_INST_ERASE_4K,		SFLASH_INST_ERASE_4K_4B },
    238          		{ SFLASH_INST_ERASE_32K,	SFLASH_INST_ERASE_32K_4B },
    239          		{ SFLASH_INST_ERASE_64K,	SFLASH_INST_ERASE_64K_4B },
    240          	};
    241          
    242          	return spi_nor_convert_inst(inst, spi_nor_3to4_erase,
    243          				    ARRAY_SIZE(spi_nor_3to4_erase));
   \        0x8   0xE3A0'2003        MOV      R2,#+3
   \        0xC   0x....'....        LDR      R1,??DataTable8_7
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0x....'....        BL       spi_nor_convert_inst
   \       0x1C   0xE8BD'8010        POP      {R4,PC}          ;; return
    244          }

   \                                 In section .rodata, align 4
   \                     `spi_nor_convert_3to4_erase::spi_nor_3to4_erase`:
   \        0x0   0x20 0x21          DC8 32, 33, 82, 92, 216, 220, 0, 0

   \              0x52 0x5C    

   \              0xD8 0xDC    

   \              0x00 0x00
    245          

   \                                 In section SOFTPACK, align 4, keep-with-next
    246          static void spi_nor_set_4bais(struct spi_flash *flash)
    247          {
   \                     spi_nor_set_4bais:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    248          	struct spi_flash_erase_map *map = &flash->erase_map;
   \        0x8   0xE294'5048        ADDS     R5,R4,#+72
    249          	int i;
    250          
    251          	flash->read_inst = spi_nor_convert_3to4_read(flash->read_inst);
   \        0xC   0xE5D4'002D        LDRB     R0,[R4, #+45]
   \       0x10   0x....'....        BL       spi_nor_convert_3to4_read
   \       0x14   0xE5C4'002D        STRB     R0,[R4, #+45]
    252          	flash->write_inst = spi_nor_convert_3to4_write(flash->write_inst);
   \       0x18   0xE5D4'002E        LDRB     R0,[R4, #+46]
   \       0x1C   0x....'....        BL       spi_nor_convert_3to4_write
   \       0x20   0xE5C4'002E        STRB     R0,[R4, #+46]
    253          
    254          	for (i = 0; i < SFLASH_CMD_ERASE_MAX; i++) {
   \       0x24   0xE3A0'6000        MOV      R6,#+0
   \                     ??spi_nor_set_4bais_0:
   \       0x28   0xE356'0004        CMP      R6,#+4
   \       0x2C   0xAA00'0006        BGE      ??spi_nor_set_4bais_1
    255          		struct spi_flash_erase_command *cmd = &map->commands[i];
   \       0x30   0xE1B0'0206        LSLS     R0,R6,#+4
   \       0x34   0xE095'7000        ADDS     R7,R5,R0
    256          
    257          		cmd->inst = spi_nor_convert_3to4_erase(cmd->inst);
   \       0x38   0xE5D7'000C        LDRB     R0,[R7, #+12]
   \       0x3C   0x....'....        BL       spi_nor_convert_3to4_erase
   \       0x40   0xE5C7'000C        STRB     R0,[R7, #+12]
    258          	}
   \       0x44   0xE296'6001        ADDS     R6,R6,#+1
   \       0x48   0xEAFF'FFF6        B        ??spi_nor_set_4bais_0
    259          
    260          	flash->addr_len = 4;
   \                     ??spi_nor_set_4bais_1:
   \       0x4C   0xE3A0'0004        MOV      R0,#+4
   \       0x50   0xE5C4'002C        STRB     R0,[R4, #+44]
    261          }
   \       0x54   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    262          

   \                                 In section SOFTPACK, align 4, keep-with-next
    263          static int sst26_unlock_block_protection(struct spi_flash *flash)
    264          {
   \                     sst26_unlock_block_protection:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    265          	int rc;
    266          
    267          	rc = spi_flash_write_enable(flash);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0x....'....        BL       spi_flash_write_enable
   \       0x10   0xE1B0'5000        MOVS     R5,R0
    268          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_ULBPR, NULL, 0);
   \       0x14   0xE355'0000        CMP      R5,#+0
   \       0x18   0x5A00'0001        BPL      ??sst26_unlock_block_protection_0
   \       0x1C   0xE1B0'6005        MOVS     R6,R5
   \       0x20   0xEA00'0005        B        ??sst26_unlock_block_protection_1
   \                     ??sst26_unlock_block_protection_0:
   \       0x24   0xE3A0'3000        MOV      R3,#+0
   \       0x28   0xE3A0'2000        MOV      R2,#+0
   \       0x2C   0xE3A0'1098        MOV      R1,#+152
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0x....'....        BL       spi_flash_write_reg
   \       0x38   0xE1B0'6000        MOVS     R6,R0
    269          	return rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??sst26_unlock_block_protection_1:
   \       0x3C   0xE356'0000        CMP      R6,#+0
   \       0x40   0x5A00'0001        BPL      ??sst26_unlock_block_protection_2
   \       0x44   0xE1B0'0006        MOVS     R0,R6
   \       0x48   0xEA00'0001        B        ??sst26_unlock_block_protection_3
   \                     ??sst26_unlock_block_protection_2:
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0x....'....        BL       spi_flash_wait_till_ready
   \                     ??sst26_unlock_block_protection_3:
   \       0x54   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    270          }
    271          

   \                                 In section SOFTPACK, align 4, keep-with-next
    272          static int spi_nor_clear_sr_bp(struct spi_flash *flash)
    273          {
   \                     spi_nor_clear_sr_bp:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    274          	uint8_t sr = 0;
   \        0x8   0xE3A0'0000        MOV      R0,#+0
   \        0xC   0xE5CD'0000        STRB     R0,[SP, #+0]
    275          	int rc;
    276          
    277          	rc = spi_flash_write_enable(flash);
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       spi_flash_write_enable
   \       0x18   0xE1B0'5000        MOVS     R5,R0
    278          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, &sr, 1);
   \       0x1C   0xE355'0000        CMP      R5,#+0
   \       0x20   0x5A00'0001        BPL      ??spi_nor_clear_sr_bp_0
   \       0x24   0xE1B0'6005        MOVS     R6,R5
   \       0x28   0xEA00'0005        B        ??spi_nor_clear_sr_bp_1
   \                     ??spi_nor_clear_sr_bp_0:
   \       0x2C   0xE3A0'3001        MOV      R3,#+1
   \       0x30   0xE1B0'200D        MOVS     R2,SP
   \       0x34   0xE3A0'1001        MOV      R1,#+1
   \       0x38   0xE1B0'0004        MOVS     R0,R4
   \       0x3C   0x....'....        BL       spi_flash_write_reg
   \       0x40   0xE1B0'6000        MOVS     R6,R0
    279          	return rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??spi_nor_clear_sr_bp_1:
   \       0x44   0xE356'0000        CMP      R6,#+0
   \       0x48   0x5A00'0001        BPL      ??spi_nor_clear_sr_bp_2
   \       0x4C   0xE1B0'0006        MOVS     R0,R6
   \       0x50   0xEA00'0001        B        ??spi_nor_clear_sr_bp_3
   \                     ??spi_nor_clear_sr_bp_2:
   \       0x54   0xE1B0'0004        MOVS     R0,R4
   \       0x58   0x....'....        BL       spi_flash_wait_till_ready
   \                     ??spi_nor_clear_sr_bp_3:
   \       0x5C   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    280          }
    281          

   \                                 In section SOFTPACK, align 4, keep-with-next
    282          static int spi_nor_probe(struct spi_flash *flash)
    283          {
   \                     spi_nor_probe:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    284          	const struct spi_nor_info *info;
    285          	int rc;
    286          
    287          	/* Check minimum requirement. */
    288          	if (!flash->ops)
   \        0x8   0xE594'00A0        LDR      R0,[R4, #+160]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'0001        BNE      ??spi_nor_probe_0
    289          		return -EINVAL;
   \       0x14   0xE3E0'001B        MVN      R0,#+27
   \       0x18   0xEA00'0082        B        ??spi_nor_probe_1
    290          
    291          	/*
    292          	 * Reset the SPI flash memory:
    293          	 * exit the 4-byte address and/or the 4-4-4 modes.
    294          	 */
    295          	if (flash->hwcaps.mask & (SFLASH_HWCAPS_READ_4_4_4 | SFLASH_HWCAPS_PP_4_4_4)) {
   \                     ??spi_nor_probe_0:
   \       0x1C   0xE594'0018        LDR      R0,[R4, #+24]
   \       0x20   0xE3A0'1080        MOV      R1,#+128
   \       0x24   0xE381'1A80        ORR      R1,R1,#0x80000
   \       0x28   0xE111'0000        TST      R1,R0
   \       0x2C   0x0A00'0003        BEQ      ??spi_nor_probe_2
    296          		flash->reg_proto = SFLASH_PROTO_4_4_4;
   \       0x30   0x....'....        LDR      R0,??DataTable8_8  ;; 0x40404
   \       0x34   0xE584'0028        STR      R0,[R4, #+40]
    297          		spi_flash_reset(flash);
   \       0x38   0xE1B0'0004        MOVS     R0,R4
   \       0x3C   0x....'....        BL       spi_flash_reset
    298          	}
    299          	flash->reg_proto = SFLASH_PROTO_1_1_1;
   \                     ??spi_nor_probe_2:
   \       0x40   0x....'....        LDR      R5,??DataTable7_3  ;; 0x10101
   \       0x44   0xE584'5028        STR      R5,[R4, #+40]
    300          	spi_flash_reset(flash);
   \       0x48   0xE1B0'0004        MOVS     R0,R4
   \       0x4C   0x....'....        BL       spi_flash_reset
    301          	usleep(50);
   \       0x50   0xE3A0'0032        MOV      R0,#+50
   \       0x54   0x....'....        BL       usleep
    302          
    303          	/* Set default settings. */
    304          	flash->read_proto = SFLASH_PROTO_1_1_1;
   \       0x58   0xE584'5020        STR      R5,[R4, #+32]
    305          	flash->write_proto = SFLASH_PROTO_1_1_1;
   \       0x5C   0xE584'5024        STR      R5,[R4, #+36]
    306          	flash->read = spi_nor_read;
   \       0x60   0x....'....        LDR      R0,??DataTable8_9
   \       0x64   0xE584'00A4        STR      R0,[R4, #+164]
    307          	flash->write = spi_nor_write;
   \       0x68   0x....'....        LDR      R0,??DataTable8_10
   \       0x6C   0xE584'00A8        STR      R0,[R4, #+168]
    308          	flash->erase = spi_nor_erase;
   \       0x70   0x....'....        LDR      R0,??DataTable8_11
   \       0x74   0xE584'00AC        STR      R0,[R4, #+172]
    309          	flash->flags = 0;
   \       0x78   0xE3A0'0000        MOV      R0,#+0
   \       0x7C   0xE584'001C        STR      R0,[R4, #+28]
    310          	flash->normal_mode = 0xFFu;
   \       0x80   0xE3A0'00FF        MOV      R0,#+255
   \       0x84   0xE5C4'002F        STRB     R0,[R4, #+47]
    311          	flash->xip_mode = 0xA5u;
   \       0x88   0xE3A0'00A5        MOV      R0,#+165
   \       0x8C   0xE5C4'0030        STRB     R0,[R4, #+48]
    312          
    313          	/* Get the static SPI flash info (might by NULL). */
    314          	info = spi_nor_read_id(flash);
   \       0x90   0xE1B0'0004        MOVS     R0,R4
   \       0x94   0x....'....        BL       spi_nor_read_id
   \       0x98   0xE1B0'5000        MOVS     R5,R0
    315          	if (!info) {
   \       0x9C   0xE355'0000        CMP      R5,#+0
   \       0xA0   0x1A00'0002        BNE      ??spi_nor_probe_3
    316          		flash->name = flash_name;
   \       0xA4   0x....'....        LDR      R0,??DataTable8_12
   \       0xA8   0xE584'003C        STR      R0,[R4, #+60]
    317          		goto init_params;
   \       0xAC   0xEA00'0021        B        ??spi_nor_probe_4
    318          	}
    319          
    320          	if (info->flags & SNOR_HAS_FSR)
   \                     ??spi_nor_probe_3:
   \       0xB0   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \       0xB4   0xE310'0004        TST      R0,#0x4
   \       0xB8   0x0A00'0002        BEQ      ??spi_nor_probe_5
    321          		flash->flags |= SFLASH_FLG_HAS_FSR;
   \       0xBC   0xE594'001C        LDR      R0,[R4, #+28]
   \       0xC0   0xE390'0001        ORRS     R0,R0,#0x1
   \       0xC4   0xE584'001C        STR      R0,[R4, #+28]
    322          
    323          	if (info->flags & SNOR_SST_ULBPR)
   \                     ??spi_nor_probe_5:
   \       0xC8   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \       0xCC   0xE310'0040        TST      R0,#0x40
   \       0xD0   0x0A00'0009        BEQ      ??spi_nor_probe_6
    324          		if (sst26_unlock_block_protection(flash))
   \       0xD4   0xE1B0'0004        MOVS     R0,R4
   \       0xD8   0x....'....        BL       sst26_unlock_block_protection
   \       0xDC   0xE350'0000        CMP      R0,#+0
   \       0xE0   0x0A00'0005        BEQ      ??spi_nor_probe_6
    325          			trace_info("SF: WARNING: SST26 - can't unlock block protection\r\n");
   \       0xE4   0x....'....        LDR      R0,??DataTable7
   \       0xE8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xEC   0xE350'0004        CMP      R0,#+4
   \       0xF0   0x3A00'0001        BCC      ??spi_nor_probe_7
   \       0xF4   0x....'....        LDR      R0,??DataTable8_13
   \       0xF8   0x....'....        BL       printf
    326          
    327          	if (info->flags & SNOR_CLEAR_SR_BP)
   \                     ??spi_nor_probe_7:
   \                     ??spi_nor_probe_6:
   \       0xFC   0xE1D5'01B6        LDRH     R0,[R5, #+22]
   \      0x100   0xE310'0F40        TST      R0,#0x100
   \      0x104   0x0A00'0009        BEQ      ??spi_nor_probe_8
    328          		if (spi_nor_clear_sr_bp(flash))
   \      0x108   0xE1B0'0004        MOVS     R0,R4
   \      0x10C   0x....'....        BL       spi_nor_clear_sr_bp
   \      0x110   0xE350'0000        CMP      R0,#+0
   \      0x114   0x0A00'0005        BEQ      ??spi_nor_probe_8
    329          			trace_warning("SF: WARNING: can't clear Block Protection bits in Status Register\r\n");
   \      0x118   0x....'....        LDR      R0,??DataTable7
   \      0x11C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x120   0xE350'0003        CMP      R0,#+3
   \      0x124   0x3A00'0001        BCC      ??spi_nor_probe_9
   \      0x128   0x....'....        LDR      R0,??DataTable8_14
   \      0x12C   0x....'....        BL       printf
    330          
    331          	flash->name = info->name;
   \                     ??spi_nor_probe_9:
   \                     ??spi_nor_probe_8:
   \      0x130   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x134   0xE584'003C        STR      R0,[R4, #+60]
    332          
    333          	/* Parse the Serial Flash Discoverable Parameter tables. */
    334          init_params:
    335          	rc = spi_nor_init_params(flash, info, &params);
   \                     ??spi_nor_probe_4:
   \      0x138   0x....'....        LDR      R7,??DataTable8_15
   \      0x13C   0xE1B0'2007        MOVS     R2,R7
   \      0x140   0xE1B0'1005        MOVS     R1,R5
   \      0x144   0xE1B0'0004        MOVS     R0,R4
   \      0x148   0x....'....        BL       spi_nor_init_params
   \      0x14C   0xE1B0'6000        MOVS     R6,R0
    336          	if (rc < 0)
   \      0x150   0xE356'0000        CMP      R6,#+0
   \      0x154   0x5A00'0001        BPL      ??spi_nor_probe_10
    337          		return rc;
   \      0x158   0xE1B0'0006        MOVS     R0,R6
   \      0x15C   0xEA00'0031        B        ??spi_nor_probe_1
    338          
    339          	if (params.size == 0)
   \                     ??spi_nor_probe_10:
   \      0x160   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x164   0xE350'0000        CMP      R0,#+0
   \      0x168   0x1A00'0001        BNE      ??spi_nor_probe_11
    340          		return -ENODEV;
   \      0x16C   0xE3E0'002B        MVN      R0,#+43
   \      0x170   0xEA00'002C        B        ??spi_nor_probe_1
    341          
    342          	flash->size = params.size;
   \                     ??spi_nor_probe_11:
   \      0x174   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x178   0xE584'0040        STR      R0,[R4, #+64]
    343          	if (params.page_size > 0)
   \      0x17C   0xE597'0004        LDR      R0,[R7, #+4]
   \      0x180   0xE350'0000        CMP      R0,#+0
   \      0x184   0x0A00'0001        BEQ      ??spi_nor_probe_12
    344          		flash->page_size = params.page_size;
   \      0x188   0xE597'0004        LDR      R0,[R7, #+4]
   \      0x18C   0xE584'0044        STR      R0,[R4, #+68]
    345          
    346          	/*
    347          	 * Configure the SPI memory:
    348          	 * - select instructions for (Fast) Read, Page Program and Sector Erase.
    349          	 * - set the number of mode & wait state cycles.
    350          	 * - set the SPI protocols for register and memory accesses.
    351          	 * - set the Quad Enable bit if needed (required by SPI x-y-4 protos).
    352          	 */
    353          	rc = spi_flash_setup(flash, &params);
   \                     ??spi_nor_probe_12:
   \      0x190   0xE1B0'1007        MOVS     R1,R7
   \      0x194   0xE1B0'0004        MOVS     R0,R4
   \      0x198   0x....'....        BL       spi_flash_setup
   \      0x19C   0xE1B0'7000        MOVS     R7,R0
    354          	if (rc < 0)
   \      0x1A0   0xE357'0000        CMP      R7,#+0
   \      0x1A4   0x5A00'0001        BPL      ??spi_nor_probe_13
    355          		return rc;
   \      0x1A8   0xE1B0'0007        MOVS     R0,R7
   \      0x1AC   0xEA00'001D        B        ??spi_nor_probe_1
    356          
    357          	if (info && info->addr_len) {
   \                     ??spi_nor_probe_13:
   \      0x1B0   0xE355'0000        CMP      R5,#+0
   \      0x1B4   0x0A00'0005        BEQ      ??spi_nor_probe_14
   \      0x1B8   0xE1D5'01B4        LDRH     R0,[R5, #+20]
   \      0x1BC   0xE350'0000        CMP      R0,#+0
   \      0x1C0   0x0A00'0002        BEQ      ??spi_nor_probe_14
    358          		flash->addr_len = info->addr_len;
   \      0x1C4   0xE1D5'01B4        LDRH     R0,[R5, #+20]
   \      0x1C8   0xE5C4'002C        STRB     R0,[R4, #+44]
   \      0x1CC   0xEA00'0014        B        ??spi_nor_probe_15
    359          	} else {
    360          		flash->addr_len = 3;
   \                     ??spi_nor_probe_14:
   \      0x1D0   0xE3A0'0003        MOV      R0,#+3
   \      0x1D4   0xE5C4'002C        STRB     R0,[R4, #+44]
    361          		if (flash->size > 0x01000000u) {
   \      0x1D8   0xE594'0040        LDR      R0,[R4, #+64]
   \      0x1DC   0xE3A0'1001        MOV      R1,#+1
   \      0x1E0   0xE381'1740        ORR      R1,R1,#0x1000000
   \      0x1E4   0xE150'0001        CMP      R0,R1
   \      0x1E8   0x3A00'000D        BCC      ??spi_nor_probe_15
    362          			if (!info || !(info->flags & SNOR_NO_4BAIS))
   \      0x1EC   0xE355'0000        CMP      R5,#+0
   \      0x1F0   0x0A00'0002        BEQ      ??spi_nor_probe_16
   \      0x1F4   0xE5D5'0016        LDRB     R0,[R5, #+22]
   \      0x1F8   0xE310'0008        TST      R0,#0x8
   \      0x1FC   0x1A00'0002        BNE      ??spi_nor_probe_17
    363          				spi_nor_set_4bais(flash);
   \                     ??spi_nor_probe_16:
   \      0x200   0xE1B0'0004        MOVS     R0,R4
   \      0x204   0x....'....        BL       spi_nor_set_4bais
   \      0x208   0xEA00'0005        B        ??spi_nor_probe_15
    364          			else
    365          				trace_info("SF: WARNING: can't read above 16MiB\r\n");
   \                     ??spi_nor_probe_17:
   \      0x20C   0x....'....        LDR      R0,??DataTable7
   \      0x210   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x214   0xE350'0004        CMP      R0,#+4
   \      0x218   0x3A00'0001        BCC      ??spi_nor_probe_18
   \      0x21C   0x....'....        LDR      R0,??DataTable8_16
   \      0x220   0x....'....        BL       printf
    366          		}
    367          	}
    368          
    369          	return 0;
   \                     ??spi_nor_probe_18:
   \                     ??spi_nor_probe_15:
   \      0x224   0xE3A0'0000        MOV      R0,#+0
   \                     ??spi_nor_probe_1:
   \      0x228   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    370          }
    371          

   \                                 In section SOFTPACK, align 4, keep-with-next
    372          static int _bus_init(union spi_flash_priv* priv)
    373          {
   \                     _bus_init:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    374          	return 0;
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    375          }
    376          

   \                                 In section SOFTPACK, align 4, keep-with-next
    377          static int _bus_cleanup(union spi_flash_priv* priv)
    378          {
   \                     _bus_cleanup:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    379          	return 0;
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    380          }
    381          

   \                                 In section SOFTPACK, align 4, keep-with-next
    382          static int _bus_set_freq(union spi_flash_priv* priv, uint32_t freq)
    383          {
   \                     _bus_set_freq:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    384          	priv->spi.spi_dev.bitrate = freq;
   \        0xC   0xE584'5008        STR      R5,[R4, #+8]
    385          	return bus_configure_slave(priv->spi.bus, &priv->spi);
   \       0x10   0xE1B0'1004        MOVS     R1,R4
   \       0x14   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \       0x18   0x....'....        BL       bus_configure_slave
   \       0x1C   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    386          }
    387          

   \                                 In section SOFTPACK, align 4, keep-with-next
    388          static int _bus_set_mode(union spi_flash_priv* priv, uint8_t mode)
    389          {
   \                     _bus_set_mode:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    390          	priv->spi.spi_dev.spi_mode = mode;
                 	                           ^
Warning[Pe188]: enumerated type mixed with another type
   \        0xC   0xE5C4'5014        STRB     R5,[R4, #+20]
    391          	return bus_configure_slave(priv->spi.bus, &priv->spi);
   \       0x10   0xE1B0'1004        MOVS     R1,R4
   \       0x14   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \       0x18   0x....'....        BL       bus_configure_slave
   \       0x1C   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    392          }
    393          

   \                                 In section SOFTPACK, align 4, keep-with-next
    394          static int _bus_exec(union spi_flash_priv* priv, const struct spi_flash_command *cmd)
    395          {
   \                     _bus_exec:
   \        0x0   0xE92D'4FFE        PUSH     {R1-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    396          	int rc;
    397          	uint8_t buffers = 2;
   \        0xC   0xE3A0'6002        MOV      R6,#+2
   \       0x10   0xE1B0'7006        MOVS     R7,R6
    398          	uint8_t *data = _spi_flash_hdr;
   \       0x14   0x....'....        LDR      R8,??DataTable8_17
   \       0x18   0xE1B0'0008        MOVS     R0,R8
    399          
    400          
    401          	*data++ = cmd->inst;
   \       0x1C   0xE5D5'1008        LDRB     R1,[R5, #+8]
   \       0x20   0xE5C0'1000        STRB     R1,[R0, #+0]
   \       0x24   0xE290'9001        ADDS     R9,R0,#+1
    402          	switch (cmd->addr_len) {
   \       0x28   0xE5D5'000C        LDRB     R0,[R5, #+12]
   \       0x2C   0xE350'0003        CMP      R0,#+3
   \       0x30   0x0A00'0005        BEQ      ??_bus_exec_1
   \       0x34   0xE350'0004        CMP      R0,#+4
   \       0x38   0x1A00'000F        BNE      ??_bus_exec_2
    403          	case 4:
    404          		*data++ = (cmd->addr >> 24) & 0xff;
   \                     ??_bus_exec_3:
   \       0x3C   0xE595'0010        LDR      R0,[R5, #+16]
   \       0x40   0xE1B0'0C20        LSRS     R0,R0,#+24
   \       0x44   0xE5C9'0000        STRB     R0,[R9, #+0]
   \       0x48   0xE299'9001        ADDS     R9,R9,#+1
    405          	case 3:
    406          		*data++ = (cmd->addr >> 16) & 0xff;
   \                     ??_bus_exec_1:
   \       0x4C   0xE595'0010        LDR      R0,[R5, #+16]
   \       0x50   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x54   0xE5C9'0000        STRB     R0,[R9, #+0]
   \       0x58   0xE299'0001        ADDS     R0,R9,#+1
    407          		*data++ = (cmd->addr >> 8) & 0xff;
   \       0x5C   0xE595'1010        LDR      R1,[R5, #+16]
   \       0x60   0xE1B0'1421        LSRS     R1,R1,#+8
   \       0x64   0xE5C0'1000        STRB     R1,[R0, #+0]
   \       0x68   0xE290'0001        ADDS     R0,R0,#+1
    408          		*data++ = (cmd->addr >> 0) & 0xff;
   \       0x6C   0xE595'1010        LDR      R1,[R5, #+16]
   \       0x70   0xE5C0'1000        STRB     R1,[R0, #+0]
   \       0x74   0xE290'9001        ADDS     R9,R0,#+1
    409          		break;
   \       0x78   0xEAFF'FFFF        B        ??_bus_exec_4
    410          	case 0:
    411          	default:
    412          		break;
    413          	}
    414          	if (cmd->num_mode_cycles / 8)
   \                     ??_bus_exec_2:
   \                     ??_bus_exec_4:
   \       0x7C   0xE3A0'A008        MOV      R10,#+8
   \       0x80   0xE5D5'000A        LDRB     R0,[R5, #+10]
   \       0x84   0xE1B0'100A        MOVS     R1,R10
   \       0x88   0x....'....        BL       __aeabi_idiv
   \       0x8C   0xE350'0000        CMP      R0,#+0
   \       0x90   0x0A00'000B        BEQ      ??_bus_exec_5
    415          		memset(data, cmd->mode, cmd->num_mode_cycles / 8);
   \       0x94   0xE5D5'000A        LDRB     R0,[R5, #+10]
   \       0x98   0xE1B0'100A        MOVS     R1,R10
   \       0x9C   0x....'....        BL       __aeabi_idiv
   \       0xA0   0xE1B0'B000        MOVS     R11,R0
   \       0xA4   0xE5D5'0009        LDRB     R0,[R5, #+9]
   \       0xA8   0xE58D'0004        STR      R0,[SP, #+4]
   \       0xAC   0xE58D'9000        STR      R9,[SP, #+0]
   \       0xB0   0xE59D'2004        LDR      R2,[SP, #+4]
   \       0xB4   0xE1B0'100B        MOVS     R1,R11
   \       0xB8   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xBC   0x....'....        BL       __aeabi_memset
   \       0xC0   0xE59D'0000        LDR      R0,[SP, #+0]
    416          
    417          	_bus_exec_buffer[0].data = _spi_flash_hdr;
   \                     ??_bus_exec_5:
   \       0xC4   0x....'....        LDR      R11,??DataTable8_18
   \       0xC8   0xE58B'8000        STR      R8,[R11, #+0]
    418          	_bus_exec_buffer[0].attr = BUS_BUF_ATTR_TX;
   \       0xCC   0xE58B'6008        STR      R6,[R11, #+8]
    419          	_bus_exec_buffer[0].size = 1 + cmd->addr_len + cmd->num_mode_cycles / 8 + cmd->num_wait_states / 8;
   \       0xD0   0xE5D5'600C        LDRB     R6,[R5, #+12]
   \       0xD4   0xE5D5'000A        LDRB     R0,[R5, #+10]
   \       0xD8   0xE1B0'100A        MOVS     R1,R10
   \       0xDC   0x....'....        BL       __aeabi_idiv
   \       0xE0   0xE090'6006        ADDS     R6,R0,R6
   \       0xE4   0xE5D5'000B        LDRB     R0,[R5, #+11]
   \       0xE8   0xE1B0'100A        MOVS     R1,R10
   \       0xEC   0x....'....        BL       __aeabi_idiv
   \       0xF0   0xE090'0006        ADDS     R0,R0,R6
   \       0xF4   0xE290'0001        ADDS     R0,R0,#+1
   \       0xF8   0xE58B'0004        STR      R0,[R11, #+4]
    420          
    421          	switch (cmd->flags) {
   \       0xFC   0xE595'0004        LDR      R0,[R5, #+4]
   \      0x100   0xE350'0004        CMP      R0,#+4
   \      0x104   0x8A00'0026        BHI      ??_bus_exec_6
   \      0x108   0xE7DF'1000        LDRB     R1,[PC, R0]
   \      0x10C   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??_bus_exec_0:
   \      0x110   0x01 0x0E          DC8      0x1,0xE,0x1E,0x1

   \              0x1E 0x01
   \      0x114   0x0E 0x00          DC8      0xE,0x0,0x0,0x0

   \              0x00 0x00
    422          	case SFLASH_TYPE_READ:
    423          	case SFLASH_TYPE_READ_REG:
    424          #ifdef SPI_NOR_VERBOSE_DEBUG
    425          		trace_debug("spi-nor: READ*\r\n");
    426          #endif
    427          		_bus_exec_buffer[1].data = cmd->rx_data;
   \                     ??_bus_exec_7:
   \      0x118   0xE595'001C        LDR      R0,[R5, #+28]
   \      0x11C   0xE58B'000C        STR      R0,[R11, #+12]
    428          		_bus_exec_buffer[1].size = cmd->data_len;
   \      0x120   0xE595'0014        LDR      R0,[R5, #+20]
   \      0x124   0xE58B'0010        STR      R0,[R11, #+16]
    429          		_bus_exec_buffer[1].attr = BUS_BUF_ATTR_RX;
   \      0x128   0xE3A0'0001        MOV      R0,#+1
   \      0x12C   0xE58B'0014        STR      R0,[R11, #+20]
    430          		if (cmd->data_len)
   \      0x130   0xE595'0014        LDR      R0,[R5, #+20]
   \      0x134   0xE350'0000        CMP      R0,#+0
   \      0x138   0x0A00'0002        BEQ      ??_bus_exec_8
    431          			_bus_exec_buffer[1].attr |= BUS_SPI_BUF_ATTR_RELEASE_CS;
   \      0x13C   0xE59B'0014        LDR      R0,[R11, #+20]
   \      0x140   0xE390'0E80        ORRS     R0,R0,#0x800
   \      0x144   0xE58B'0014        STR      R0,[R11, #+20]
    432          		break;
   \                     ??_bus_exec_8:
   \      0x148   0xEA00'0017        B        ??_bus_exec_9
    433          	case SFLASH_TYPE_WRITE:
    434          	case SFLASH_TYPE_WRITE_REG:
    435          #ifdef SPI_NOR_VERBOSE_DEBUG
    436          		trace_debug("spi-nor: WRITE*\r\n");
    437          #endif
    438          		if (cmd->data_len) {
   \                     ??_bus_exec_10:
   \      0x14C   0xE595'0014        LDR      R0,[R5, #+20]
   \      0x150   0xE350'0000        CMP      R0,#+0
   \      0x154   0x0A00'0006        BEQ      ??_bus_exec_11
    439          			_bus_exec_buffer[1].data = (uint8_t*)cmd->tx_data;
   \      0x158   0xE595'0018        LDR      R0,[R5, #+24]
   \      0x15C   0xE58B'000C        STR      R0,[R11, #+12]
    440          			_bus_exec_buffer[1].size = cmd->data_len;
   \      0x160   0xE595'0014        LDR      R0,[R5, #+20]
   \      0x164   0xE58B'0010        STR      R0,[R11, #+16]
    441          			_bus_exec_buffer[1].attr = BUS_BUF_ATTR_TX | BUS_SPI_BUF_ATTR_RELEASE_CS;
   \      0x168   0xE300'0802        MOVW     R0,#+2050
   \      0x16C   0xE58B'0014        STR      R0,[R11, #+20]
   \      0x170   0xEA00'0004        B        ??_bus_exec_12
    442          		} else {
    443          			buffers = 1;
   \                     ??_bus_exec_11:
   \      0x174   0xE3A0'0001        MOV      R0,#+1
   \      0x178   0xE1B0'7000        MOVS     R7,R0
    444          			_bus_exec_buffer[0].attr |= BUS_SPI_BUF_ATTR_RELEASE_CS;
   \      0x17C   0xE59B'0008        LDR      R0,[R11, #+8]
   \      0x180   0xE390'0E80        ORRS     R0,R0,#0x800
   \      0x184   0xE58B'0008        STR      R0,[R11, #+8]
    445          		}
    446          		break;
   \                     ??_bus_exec_12:
   \      0x188   0xEA00'0007        B        ??_bus_exec_9
    447          	case SFLASH_TYPE_ERASE:
    448          #ifdef SPI_NOR_VERBOSE_DEBUG
    449          		trace_debug("spi-nor: ERASE\r\n");
    450          #endif
    451          		buffers = 1;
   \                     ??_bus_exec_13:
   \      0x18C   0xE3A0'0001        MOV      R0,#+1
   \      0x190   0xE1B0'7000        MOVS     R7,R0
    452          		_bus_exec_buffer[0].attr |= BUS_SPI_BUF_ATTR_RELEASE_CS;
   \      0x194   0xE59B'0008        LDR      R0,[R11, #+8]
   \      0x198   0xE390'0E80        ORRS     R0,R0,#0x800
   \      0x19C   0xE58B'0008        STR      R0,[R11, #+8]
    453          		break;
   \      0x1A0   0xEA00'0001        B        ??_bus_exec_9
    454          	default:
    455          		return -EINVAL;
   \                     ??_bus_exec_6:
   \      0x1A4   0xE3E0'001B        MVN      R0,#+27
   \      0x1A8   0xEA00'0011        B        ??_bus_exec_14
    456          	}
    457          
    458          #ifdef SPI_NOR_VERBOSE_DEBUG
    459          	trace_debug("spi-nor: inst: 0x%02x\r\n", cmd->inst);
    460          	if (cmd->addr_len) {
    461          		trace_debug("spi-nor: addr_len: %u\r\n", cmd->addr_len);
    462          		trace_debug("spi-nor: addr: %x\r\n", cmd->addr);
    463          	}
    464          	if (cmd->data_len) {
    465          		trace_debug("spi-nor: len: 0x%x\r\n", cmd->data_len);
    466          		trace_debug("spi-nor: buffer: %p\r\n", _bus_exec_buffer[1].data);
    467          	}
    468          #endif
    469          
    470          	bus_start_transaction(priv->spi.bus);
   \                     ??_bus_exec_9:
   \      0x1AC   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x1B0   0x....'....        BL       bus_start_transaction
    471          	rc = bus_transfer(priv->spi.bus, priv->spi.spi_dev.chip_select, _bus_exec_buffer, buffers, NULL);
   \      0x1B4   0xE3A0'0000        MOV      R0,#+0
   \      0x1B8   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x1BC   0xE1B0'3007        MOVS     R3,R7
   \      0x1C0   0xE6EF'3073        UXTB     R3,R3
   \      0x1C4   0xE6FF'3073        UXTH     R3,R3
   \      0x1C8   0xE1B0'200B        MOVS     R2,R11
   \      0x1CC   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \      0x1D0   0xE6FF'1071        UXTH     R1,R1
   \      0x1D4   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x1D8   0x....'....        BL       bus_transfer
   \      0x1DC   0xE1B0'6000        MOVS     R6,R0
    472          	bus_wait_transfer(priv->spi.bus);
   \      0x1E0   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x1E4   0x....'....        BL       bus_wait_transfer
    473          	bus_stop_transaction(priv->spi.bus);
   \      0x1E8   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x1EC   0x....'....        BL       bus_stop_transaction
    474          
    475          	return rc;
   \      0x1F0   0xE1B0'0006        MOVS     R0,R6
   \                     ??_bus_exec_14:
   \      0x1F4   0xE8BD'8FFE        POP      {R1-R11,PC}      ;; return
    476          }
    477          

   \                                 In section .rodata, align 4
    478          static const struct spi_ops _spi_bus_ops = {
   \                     _spi_bus_ops:
   \        0x0   0x....'....        DC32 _bus_init, _bus_cleanup, _bus_set_freq, _bus_set_mode, _bus_exec

   \              0x....'....  

   \              0x....'....  

   \              0x....'....  

   \              0x....'....
    479          	.init		= _bus_init,
    480          	.cleanup	= _bus_cleanup,
    481          	.set_freq	= _bus_set_freq,
    482          	.set_mode	= _bus_set_mode,
    483          	.exec		= _bus_exec,
    484          };
    485          
    486          /*----------------------------------------------------------------------------
    487           *        Exported Functions
    488           *----------------------------------------------------------------------------*/
    489          

   \                                 In section SOFTPACK, align 4, keep-with-next
    490          int spansion_quad_enable(struct spi_flash *flash)
    491          {
   \                     spansion_quad_enable:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    492          	uint8_t sr[2];
    493          	int rc;
    494          
    495          	/* Keep the current value of the Status Register. */
    496          	rc = spi_flash_read_sr(flash, &sr[0]);
   \        0x8   0xE1B0'100D        MOVS     R1,SP
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       spi_flash_read_sr
   \       0x14   0xE1B0'5000        MOVS     R5,R0
    497          	if (rc < 0)
   \       0x18   0xE355'0000        CMP      R5,#+0
   \       0x1C   0x5A00'0001        BPL      ??spansion_quad_enable_0
    498          		return rc;
   \       0x20   0xE1B0'0005        MOVS     R0,R5
   \       0x24   0xEA00'0014        B        ??spansion_quad_enable_1
    499          
    500          	/* Set the Status and Control/Status 2 Registers. */
    501          	sr[1] = CR_QE_SPAN;
   \                     ??spansion_quad_enable_0:
   \       0x28   0xE3A0'0002        MOV      R0,#+2
   \       0x2C   0xE5CD'0001        STRB     R0,[SP, #+1]
    502          	rc = spi_flash_write_enable(flash);
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0x....'....        BL       spi_flash_write_enable
   \       0x38   0xE1B0'6000        MOVS     R6,R0
    503          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, sr, 2);
   \       0x3C   0xE356'0000        CMP      R6,#+0
   \       0x40   0x5A00'0001        BPL      ??spansion_quad_enable_2
   \       0x44   0xE1B0'5006        MOVS     R5,R6
   \       0x48   0xEA00'0005        B        ??spansion_quad_enable_3
   \                     ??spansion_quad_enable_2:
   \       0x4C   0xE3A0'3002        MOV      R3,#+2
   \       0x50   0xE1B0'200D        MOVS     R2,SP
   \       0x54   0xE3A0'1001        MOV      R1,#+1
   \       0x58   0xE1B0'0004        MOVS     R0,R4
   \       0x5C   0x....'....        BL       spi_flash_write_reg
   \       0x60   0xE1B0'5000        MOVS     R5,R0
    504          	return rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??spansion_quad_enable_3:
   \       0x64   0xE355'0000        CMP      R5,#+0
   \       0x68   0x5A00'0001        BPL      ??spansion_quad_enable_4
   \       0x6C   0xE1B0'0005        MOVS     R0,R5
   \       0x70   0xEA00'0001        B        ??spansion_quad_enable_5
   \                     ??spansion_quad_enable_4:
   \       0x74   0xE1B0'0004        MOVS     R0,R4
   \       0x78   0x....'....        BL       spi_flash_wait_till_ready
   \                     ??spansion_quad_enable_5:
   \                     ??spansion_quad_enable_1:
   \       0x7C   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    505          }
    506          

   \                                 In section SOFTPACK, align 4, keep-with-next
    507          int spansion_new_quad_enable(struct spi_flash *flash)
    508          {
   \                     spansion_new_quad_enable:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    509          	uint8_t sr[2];
    510          	int rc;
    511          
    512          	/* Check the current Quand Enable bit value. */
    513          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_CR, &sr[1], 1);
   \        0x8   0xE3A0'3001        MOV      R3,#+1
   \        0xC   0xE28D'2001        ADD      R2,SP,#+1
   \       0x10   0xE3A0'1035        MOV      R1,#+53
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0x....'....        BL       spi_flash_read_reg
   \       0x1C   0xE1B0'6000        MOVS     R6,R0
    514          	if (rc < 0)
   \       0x20   0xE356'0000        CMP      R6,#+0
   \       0x24   0x5A00'0001        BPL      ??spansion_new_quad_enable_0
    515          		return rc;
   \       0x28   0xE1B0'0006        MOVS     R0,R6
   \       0x2C   0xEA00'0035        B        ??spansion_new_quad_enable_1
    516          
    517          	if (sr[1] & CR_QE_SPAN)
   \                     ??spansion_new_quad_enable_0:
   \       0x30   0xE1B0'500D        MOVS     R5,SP
   \       0x34   0xE5D5'0001        LDRB     R0,[R5, #+1]
   \       0x38   0xE310'0002        TST      R0,#0x2
   \       0x3C   0x0A00'0001        BEQ      ??spansion_new_quad_enable_2
    518          		return 0;
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \       0x44   0xEA00'002F        B        ??spansion_new_quad_enable_1
    519          
    520          	/* Keep the current value of the Status Register. */
    521          	rc = spi_flash_read_sr(flash, &sr[0]);
   \                     ??spansion_new_quad_enable_2:
   \       0x48   0xE1B0'100D        MOVS     R1,SP
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0x....'....        BL       spi_flash_read_sr
   \       0x54   0xE1B0'7000        MOVS     R7,R0
    522          	if (rc < 0)
   \       0x58   0xE357'0000        CMP      R7,#+0
   \       0x5C   0x5A00'0001        BPL      ??spansion_new_quad_enable_3
    523          		return rc;
   \       0x60   0xE1B0'0007        MOVS     R0,R7
   \       0x64   0xEA00'0027        B        ??spansion_new_quad_enable_1
    524          
    525          	/* Set the Status and Control/Status 2 Registers. */
    526          	sr[1] |= CR_QE_SPAN;
   \                     ??spansion_new_quad_enable_3:
   \       0x68   0xE5D5'0001        LDRB     R0,[R5, #+1]
   \       0x6C   0xE390'0002        ORRS     R0,R0,#0x2
   \       0x70   0xE5C5'0001        STRB     R0,[R5, #+1]
    527          	rc = spi_flash_write_enable(flash);
   \       0x74   0xE1B0'0004        MOVS     R0,R4
   \       0x78   0x....'....        BL       spi_flash_write_enable
   \       0x7C   0xE1B0'6000        MOVS     R6,R0
    528          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, sr, 2);
   \       0x80   0xE356'0000        CMP      R6,#+0
   \       0x84   0x5A00'0001        BPL      ??spansion_new_quad_enable_4
   \       0x88   0xE1B0'7006        MOVS     R7,R6
   \       0x8C   0xEA00'0005        B        ??spansion_new_quad_enable_5
   \                     ??spansion_new_quad_enable_4:
   \       0x90   0xE3A0'3002        MOV      R3,#+2
   \       0x94   0xE1B0'200D        MOVS     R2,SP
   \       0x98   0xE3A0'1001        MOV      R1,#+1
   \       0x9C   0xE1B0'0004        MOVS     R0,R4
   \       0xA0   0x....'....        BL       spi_flash_write_reg
   \       0xA4   0xE1B0'7000        MOVS     R7,R0
    529          	rc = rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??spansion_new_quad_enable_5:
   \       0xA8   0xE357'0000        CMP      R7,#+0
   \       0xAC   0x5A00'0001        BPL      ??spansion_new_quad_enable_6
   \       0xB0   0xE1B0'6007        MOVS     R6,R7
   \       0xB4   0xEA00'0002        B        ??spansion_new_quad_enable_7
   \                     ??spansion_new_quad_enable_6:
   \       0xB8   0xE1B0'0004        MOVS     R0,R4
   \       0xBC   0x....'....        BL       spi_flash_wait_till_ready
   \       0xC0   0xE1B0'6000        MOVS     R6,R0
    530          	if (rc < 0)
   \                     ??spansion_new_quad_enable_7:
   \       0xC4   0xE356'0000        CMP      R6,#+0
   \       0xC8   0x5A00'0001        BPL      ??spansion_new_quad_enable_8
    531          		return rc;
   \       0xCC   0xE1B0'0006        MOVS     R0,R6
   \       0xD0   0xEA00'000C        B        ??spansion_new_quad_enable_1
    532          
    533          	/* Read back and check. */
    534          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_CR, &sr[1], 1);
   \                     ??spansion_new_quad_enable_8:
   \       0xD4   0xE3A0'3001        MOV      R3,#+1
   \       0xD8   0xE28D'2001        ADD      R2,SP,#+1
   \       0xDC   0xE3A0'1035        MOV      R1,#+53
   \       0xE0   0xE1B0'0004        MOVS     R0,R4
   \       0xE4   0x....'....        BL       spi_flash_read_reg
    535          	if (rc < 0)
   \       0xE8   0xE350'0000        CMP      R0,#+0
   \       0xEC   0x4A00'0005        BMI      ??spansion_new_quad_enable_1
    536          		return rc;
    537          
    538          	return (sr[1] & CR_QE_SPAN) ? 0 : -1;
   \                     ??spansion_new_quad_enable_9:
   \       0xF0   0xE5D5'1001        LDRB     R1,[R5, #+1]
   \       0xF4   0xE311'0002        TST      R1,#0x2
   \       0xF8   0x0A00'0001        BEQ      ??spansion_new_quad_enable_10
   \       0xFC   0xE3A0'0000        MOV      R0,#+0
   \      0x100   0xEA00'0000        B        ??spansion_new_quad_enable_11
   \                     ??spansion_new_quad_enable_10:
   \      0x104   0xE3E0'0000        MVN      R0,#+0
   \                     ??spansion_new_quad_enable_11:
   \                     ??spansion_new_quad_enable_1:
   \      0x108   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    539          }
    540          

   \                                 In section SOFTPACK, align 4, keep-with-next
    541          int macronix_quad_enable(struct spi_flash *flash)
    542          {
   \                     macronix_quad_enable:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    543          	uint8_t sr;
    544          	int rc;
    545          
    546          	/* Check the current Quand Enable bit value. */
    547          	rc = spi_flash_read_sr(flash, &sr);
   \        0x8   0xE1B0'100D        MOVS     R1,SP
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       spi_flash_read_sr
   \       0x14   0xE1B0'5000        MOVS     R5,R0
    548          	if (rc < 0)
   \       0x18   0xE355'0000        CMP      R5,#+0
   \       0x1C   0x5A00'0001        BPL      ??macronix_quad_enable_0
    549          		return rc;
   \       0x20   0xE1B0'0005        MOVS     R0,R5
   \       0x24   0xEA00'002A        B        ??macronix_quad_enable_1
    550          
    551          	if (sr & SR_QE_MX)
   \                     ??macronix_quad_enable_0:
   \       0x28   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x2C   0xE310'0040        TST      R0,#0x40
   \       0x30   0x0A00'0001        BEQ      ??macronix_quad_enable_2
    552          		return 0;
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0xEA00'0025        B        ??macronix_quad_enable_1
    553          
    554          	/* Set the Status and Control/Status 2 Registers. */
    555          	sr |= SR_QE_MX;
   \                     ??macronix_quad_enable_2:
   \       0x3C   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x40   0xE390'0040        ORRS     R0,R0,#0x40
   \       0x44   0xE5CD'0000        STRB     R0,[SP, #+0]
    556          	rc = spi_flash_write_enable(flash);
   \       0x48   0xE1B0'0004        MOVS     R0,R4
   \       0x4C   0x....'....        BL       spi_flash_write_enable
   \       0x50   0xE1B0'6000        MOVS     R6,R0
    557          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, &sr, 1);
   \       0x54   0xE356'0000        CMP      R6,#+0
   \       0x58   0x5A00'0001        BPL      ??macronix_quad_enable_3
   \       0x5C   0xE1B0'5006        MOVS     R5,R6
   \       0x60   0xEA00'0005        B        ??macronix_quad_enable_4
   \                     ??macronix_quad_enable_3:
   \       0x64   0xE3A0'3001        MOV      R3,#+1
   \       0x68   0xE1B0'200D        MOVS     R2,SP
   \       0x6C   0xE3A0'1001        MOV      R1,#+1
   \       0x70   0xE1B0'0004        MOVS     R0,R4
   \       0x74   0x....'....        BL       spi_flash_write_reg
   \       0x78   0xE1B0'5000        MOVS     R5,R0
    558          	rc = rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??macronix_quad_enable_4:
   \       0x7C   0xE355'0000        CMP      R5,#+0
   \       0x80   0x5A00'0001        BPL      ??macronix_quad_enable_5
   \       0x84   0xE1B0'6005        MOVS     R6,R5
   \       0x88   0xEA00'0002        B        ??macronix_quad_enable_6
   \                     ??macronix_quad_enable_5:
   \       0x8C   0xE1B0'0004        MOVS     R0,R4
   \       0x90   0x....'....        BL       spi_flash_wait_till_ready
   \       0x94   0xE1B0'6000        MOVS     R6,R0
    559          	if (rc < 0)
   \                     ??macronix_quad_enable_6:
   \       0x98   0xE356'0000        CMP      R6,#+0
   \       0x9C   0x5A00'0001        BPL      ??macronix_quad_enable_7
    560          		return rc;
   \       0xA0   0xE1B0'0006        MOVS     R0,R6
   \       0xA4   0xEA00'000A        B        ??macronix_quad_enable_1
    561          
    562          	/* Read back and check. */
    563          	rc = spi_flash_read_sr(flash, &sr);
   \                     ??macronix_quad_enable_7:
   \       0xA8   0xE1B0'100D        MOVS     R1,SP
   \       0xAC   0xE1B0'0004        MOVS     R0,R4
   \       0xB0   0x....'....        BL       spi_flash_read_sr
    564          	if (rc < 0)
   \       0xB4   0xE350'0000        CMP      R0,#+0
   \       0xB8   0x4A00'0005        BMI      ??macronix_quad_enable_1
    565          		return rc;
    566          
    567          	return (sr & SR_QE_MX) ? 0 : -1;
   \                     ??macronix_quad_enable_8:
   \       0xBC   0xE5DD'1000        LDRB     R1,[SP, #+0]
   \       0xC0   0xE311'0040        TST      R1,#0x40
   \       0xC4   0x0A00'0001        BEQ      ??macronix_quad_enable_9
   \       0xC8   0xE3A0'0000        MOV      R0,#+0
   \       0xCC   0xEA00'0000        B        ??macronix_quad_enable_10
   \                     ??macronix_quad_enable_9:
   \       0xD0   0xE3E0'0000        MVN      R0,#+0
   \                     ??macronix_quad_enable_10:
   \                     ??macronix_quad_enable_1:
   \       0xD4   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    568          }
    569          

   \                                 In section SOFTPACK, align 4, keep-with-next
    570          int sr2_bit7_quad_enable(struct spi_flash *flash)
    571          {
   \                     sr2_bit7_quad_enable:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    572          	uint8_t sr2;
    573          	int rc;
    574          
    575          	/* Check the current Quand Enable bit value. */
    576          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_SR2, &sr2, 1);
   \        0x8   0xE3A0'3001        MOV      R3,#+1
   \        0xC   0xE1B0'200D        MOVS     R2,SP
   \       0x10   0xE3A0'103F        MOV      R1,#+63
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0x....'....        BL       spi_flash_read_reg
   \       0x1C   0xE1B0'5000        MOVS     R5,R0
    577          	if (rc < 0)
   \       0x20   0xE355'0000        CMP      R5,#+0
   \       0x24   0x5A00'0001        BPL      ??sr2_bit7_quad_enable_0
    578          		return rc;
   \       0x28   0xE1B0'0005        MOVS     R0,R5
   \       0x2C   0xEA00'002C        B        ??sr2_bit7_quad_enable_1
    579          
    580          	if (sr2 & SR2_QE_BIT7)
   \                     ??sr2_bit7_quad_enable_0:
   \       0x30   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x34   0xE310'0080        TST      R0,#0x80
   \       0x38   0x0A00'0001        BEQ      ??sr2_bit7_quad_enable_2
    581          		return 0;
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0xEA00'0027        B        ??sr2_bit7_quad_enable_1
    582          
    583          	/* Set the Status and Control/Status 2 Registers. */
    584          	sr2 |= SR2_QE_BIT7;
   \                     ??sr2_bit7_quad_enable_2:
   \       0x44   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x48   0xE390'0080        ORRS     R0,R0,#0x80
   \       0x4C   0xE5CD'0000        STRB     R0,[SP, #+0]
    585          	rc = spi_flash_write_enable(flash);
   \       0x50   0xE1B0'0004        MOVS     R0,R4
   \       0x54   0x....'....        BL       spi_flash_write_enable
   \       0x58   0xE1B0'6000        MOVS     R6,R0
    586          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR2, &sr2, 1);
   \       0x5C   0xE356'0000        CMP      R6,#+0
   \       0x60   0x5A00'0001        BPL      ??sr2_bit7_quad_enable_3
   \       0x64   0xE1B0'5006        MOVS     R5,R6
   \       0x68   0xEA00'0005        B        ??sr2_bit7_quad_enable_4
   \                     ??sr2_bit7_quad_enable_3:
   \       0x6C   0xE3A0'3001        MOV      R3,#+1
   \       0x70   0xE1B0'200D        MOVS     R2,SP
   \       0x74   0xE3A0'103E        MOV      R1,#+62
   \       0x78   0xE1B0'0004        MOVS     R0,R4
   \       0x7C   0x....'....        BL       spi_flash_write_reg
   \       0x80   0xE1B0'5000        MOVS     R5,R0
    587          	rc = rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??sr2_bit7_quad_enable_4:
   \       0x84   0xE355'0000        CMP      R5,#+0
   \       0x88   0x5A00'0001        BPL      ??sr2_bit7_quad_enable_5
   \       0x8C   0xE1B0'6005        MOVS     R6,R5
   \       0x90   0xEA00'0002        B        ??sr2_bit7_quad_enable_6
   \                     ??sr2_bit7_quad_enable_5:
   \       0x94   0xE1B0'0004        MOVS     R0,R4
   \       0x98   0x....'....        BL       spi_flash_wait_till_ready
   \       0x9C   0xE1B0'6000        MOVS     R6,R0
    588          	if (rc < 0)
   \                     ??sr2_bit7_quad_enable_6:
   \       0xA0   0xE356'0000        CMP      R6,#+0
   \       0xA4   0x5A00'0001        BPL      ??sr2_bit7_quad_enable_7
    589          		return rc;
   \       0xA8   0xE1B0'0006        MOVS     R0,R6
   \       0xAC   0xEA00'000C        B        ??sr2_bit7_quad_enable_1
    590          
    591          	/* Read back and check. */
    592          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_SR2, &sr2, 1);
   \                     ??sr2_bit7_quad_enable_7:
   \       0xB0   0xE3A0'3001        MOV      R3,#+1
   \       0xB4   0xE1B0'200D        MOVS     R2,SP
   \       0xB8   0xE3A0'103F        MOV      R1,#+63
   \       0xBC   0xE1B0'0004        MOVS     R0,R4
   \       0xC0   0x....'....        BL       spi_flash_read_reg
    593          	if (rc < 0)
   \       0xC4   0xE350'0000        CMP      R0,#+0
   \       0xC8   0x4A00'0005        BMI      ??sr2_bit7_quad_enable_1
    594          		return rc;
    595          
    596          	return (sr2 & SR2_QE_BIT7) ? 0 : -1;
   \                     ??sr2_bit7_quad_enable_8:
   \       0xCC   0xE5DD'1000        LDRB     R1,[SP, #+0]
   \       0xD0   0xE311'0080        TST      R1,#0x80
   \       0xD4   0x0A00'0001        BEQ      ??sr2_bit7_quad_enable_9
   \       0xD8   0xE3A0'0000        MOV      R0,#+0
   \       0xDC   0xEA00'0000        B        ??sr2_bit7_quad_enable_10
   \                     ??sr2_bit7_quad_enable_9:
   \       0xE0   0xE3E0'0000        MVN      R0,#+0
   \                     ??sr2_bit7_quad_enable_10:
   \                     ??sr2_bit7_quad_enable_1:
   \       0xE4   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    597          }
    598          

   \                                 In section SOFTPACK, align 4, keep-with-next
    599          int micron_enable_0_4_4(struct spi_flash *flash, bool enable)
    600          {
   \                     micron_enable_0_4_4:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    601          	uint8_t vcr, mask, value;
    602          	int rc;
    603          
    604          	mask = VCR_XIP;
   \        0xC   0xE3A0'6008        MOV      R6,#+8
    605          	value = (enable) ? 0 : VCR_XIP;
   \       0x10   0xE1B0'0005        MOVS     R0,R5
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0001        BEQ      ??micron_enable_0_4_4_0
   \       0x20   0xE3A0'7000        MOV      R7,#+0
   \       0x24   0xEA00'0000        B        ??micron_enable_0_4_4_1
   \                     ??micron_enable_0_4_4_0:
   \       0x28   0xE3A0'7008        MOV      R7,#+8
    606          
    607          	/* Check the current XIP bit value. */
    608          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_VCR, &vcr, 1);
   \                     ??micron_enable_0_4_4_1:
   \       0x2C   0xE3A0'3001        MOV      R3,#+1
   \       0x30   0xE1B0'200D        MOVS     R2,SP
   \       0x34   0xE3A0'1085        MOV      R1,#+133
   \       0x38   0xE1B0'0004        MOVS     R0,R4
   \       0x3C   0x....'....        BL       spi_flash_read_reg
   \       0x40   0xE1B0'8000        MOVS     R8,R0
    609          	if (rc < 0)
   \       0x44   0xE358'0000        CMP      R8,#+0
   \       0x48   0x5A00'0001        BPL      ??micron_enable_0_4_4_2
    610          		return rc;
   \       0x4C   0xE1B0'0008        MOVS     R0,R8
   \       0x50   0xEA00'0035        B        ??micron_enable_0_4_4_3
    611          
    612          	if ((vcr & mask) == value)
   \                     ??micron_enable_0_4_4_2:
   \       0x54   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x58   0xE1B0'1006        MOVS     R1,R6
   \       0x5C   0xE6EF'1071        UXTB     R1,R1
   \       0x60   0xE011'0000        ANDS     R0,R1,R0
   \       0x64   0xE1B0'1007        MOVS     R1,R7
   \       0x68   0xE6EF'1071        UXTB     R1,R1
   \       0x6C   0xE150'0001        CMP      R0,R1
   \       0x70   0x1A00'0001        BNE      ??micron_enable_0_4_4_4
    613          		return 0;
   \       0x74   0xE3A0'0000        MOV      R0,#+0
   \       0x78   0xEA00'002B        B        ??micron_enable_0_4_4_3
    614          
    615          	/* Update the XIP bit value. */
    616          	vcr = (vcr & ~mask) | value;
   \                     ??micron_enable_0_4_4_4:
   \       0x7C   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x80   0xE1D0'0006        BICS     R0,R0,R6
   \       0x84   0xE197'0000        ORRS     R0,R7,R0
   \       0x88   0xE5CD'0000        STRB     R0,[SP, #+0]
    617          	rc = spi_flash_write_enable(flash);
   \       0x8C   0xE1B0'0004        MOVS     R0,R4
   \       0x90   0x....'....        BL       spi_flash_write_enable
   \       0x94   0xE1B0'9000        MOVS     R9,R0
    618          	rc = rc < 0 ? rc : spi_flash_write_reg(flash, SFLASH_INST_WRITE_VCR, &vcr, 1);
   \       0x98   0xE359'0000        CMP      R9,#+0
   \       0x9C   0x5A00'0001        BPL      ??micron_enable_0_4_4_5
   \       0xA0   0xE1B0'8009        MOVS     R8,R9
   \       0xA4   0xEA00'0005        B        ??micron_enable_0_4_4_6
   \                     ??micron_enable_0_4_4_5:
   \       0xA8   0xE3A0'3001        MOV      R3,#+1
   \       0xAC   0xE1B0'200D        MOVS     R2,SP
   \       0xB0   0xE3A0'1081        MOV      R1,#+129
   \       0xB4   0xE1B0'0004        MOVS     R0,R4
   \       0xB8   0x....'....        BL       spi_flash_write_reg
   \       0xBC   0xE1B0'8000        MOVS     R8,R0
    619          	rc = rc < 0 ? rc : spi_flash_wait_till_ready(flash);
   \                     ??micron_enable_0_4_4_6:
   \       0xC0   0xE358'0000        CMP      R8,#+0
   \       0xC4   0x5A00'0001        BPL      ??micron_enable_0_4_4_7
   \       0xC8   0xE1B0'9008        MOVS     R9,R8
   \       0xCC   0xEA00'0002        B        ??micron_enable_0_4_4_8
   \                     ??micron_enable_0_4_4_7:
   \       0xD0   0xE1B0'0004        MOVS     R0,R4
   \       0xD4   0x....'....        BL       spi_flash_wait_till_ready
   \       0xD8   0xE1B0'9000        MOVS     R9,R0
    620          	if (rc < 0)
   \                     ??micron_enable_0_4_4_8:
   \       0xDC   0xE359'0000        CMP      R9,#+0
   \       0xE0   0x5A00'0001        BPL      ??micron_enable_0_4_4_9
    621          		return rc;
   \       0xE4   0xE1B0'0009        MOVS     R0,R9
   \       0xE8   0xEA00'000F        B        ??micron_enable_0_4_4_3
    622          
    623          	/* Read back and check. */
    624          	rc = spi_flash_read_reg(flash, SFLASH_INST_READ_VCR, &vcr, 1);
   \                     ??micron_enable_0_4_4_9:
   \       0xEC   0xE3A0'3001        MOV      R3,#+1
   \       0xF0   0xE1B0'200D        MOVS     R2,SP
   \       0xF4   0xE3A0'1085        MOV      R1,#+133
   \       0xF8   0xE1B0'0004        MOVS     R0,R4
   \       0xFC   0x....'....        BL       spi_flash_read_reg
    625          	if (rc < 0)
   \      0x100   0xE350'0000        CMP      R0,#+0
   \      0x104   0x4A00'0008        BMI      ??micron_enable_0_4_4_3
    626          		return rc;
    627          
    628          	return ((vcr & mask) == value) ? 0 : -1;
   \                     ??micron_enable_0_4_4_10:
   \      0x108   0xE5DD'1000        LDRB     R1,[SP, #+0]
   \      0x10C   0xE6EF'6076        UXTB     R6,R6
   \      0x110   0xE016'1001        ANDS     R1,R6,R1
   \      0x114   0xE6EF'7077        UXTB     R7,R7
   \      0x118   0xE151'0007        CMP      R1,R7
   \      0x11C   0x1A00'0001        BNE      ??micron_enable_0_4_4_11
   \      0x120   0xE3A0'0000        MOV      R0,#+0
   \      0x124   0xEA00'0000        B        ??micron_enable_0_4_4_12
   \                     ??micron_enable_0_4_4_11:
   \      0x128   0xE3E0'0000        MVN      R0,#+0
   \                     ??micron_enable_0_4_4_12:
   \                     ??micron_enable_0_4_4_3:
   \      0x12C   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    629          }
    630          

   \                                 In section SOFTPACK, align 4, keep-with-next
    631          int at25_set_protection(struct spi_flash *flash, bool protect)
    632          {
   \                     at25_set_protection:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    633          	uint8_t sr;
    634          	int rc;
    635          
    636          	rc = spi_flash_read_sr(flash, &sr);
   \        0xC   0xE1B0'100D        MOVS     R1,SP
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       spi_flash_read_sr
   \       0x18   0xE1B0'7000        MOVS     R7,R0
    637          	if (rc < 0)
   \       0x1C   0xE357'0000        CMP      R7,#+0
   \       0x20   0x5A00'0001        BPL      ??at25_set_protection_0
    638          		return rc;
   \       0x24   0xE1B0'0007        MOVS     R0,R7
   \       0x28   0xEA00'0036        B        ??at25_set_protection_1
    639          #ifdef SPI_NOR_VERBOSE_DEBUG
    640          	trace_info("spi-nor: protection: %s\r\n", sr & SR_SWP ? "on" : "off");
    641          #endif
    642          
    643          	rc = spi_flash_write_enable(flash);
   \                     ??at25_set_protection_0:
   \       0x2C   0xE1B0'0004        MOVS     R0,R4
   \       0x30   0x....'....        BL       spi_flash_write_enable
   \       0x34   0xE1B0'6000        MOVS     R6,R0
    644          	if (rc < 0)
   \       0x38   0xE356'0000        CMP      R6,#+0
   \       0x3C   0x5A00'0001        BPL      ??at25_set_protection_2
    645          		return rc;
   \       0x40   0xE1B0'0006        MOVS     R0,R6
   \       0x44   0xEA00'002F        B        ??at25_set_protection_1
    646          
    647          	if (protect) {
   \                     ??at25_set_protection_2:
   \       0x48   0xE1B0'0005        MOVS     R0,R5
   \       0x4C   0xE6EF'0070        UXTB     R0,R0
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'000C        BEQ      ??at25_set_protection_3
    648          #ifdef SPI_NOR_VERBOSE_DEBUG
    649          		trace_info("spi-nor: lock all\r\n");
    650          #endif
    651          		/* Perform a global protect command */
    652          		sr |= SR_SWP_PROTECT_ALL;
   \       0x58   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x5C   0xE390'000C        ORRS     R0,R0,#0xC
   \       0x60   0xE5CD'0000        STRB     R0,[SP, #+0]
    653          		rc = spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, &sr, 1);
   \       0x64   0xE3A0'3001        MOV      R3,#+1
   \       0x68   0xE1B0'200D        MOVS     R2,SP
   \       0x6C   0xE3A0'1001        MOV      R1,#+1
   \       0x70   0xE1B0'0004        MOVS     R0,R4
   \       0x74   0x....'....        BL       spi_flash_write_reg
   \       0x78   0xE1B0'1000        MOVS     R1,R0
    654          		if (rc < 0)
   \       0x7C   0xE351'0000        CMP      R1,#+0
   \       0x80   0x5A00'001F        BPL      ??at25_set_protection_4
    655          			return rc;
   \       0x84   0xE1B0'0001        MOVS     R0,R1
   \       0x88   0xEA00'001E        B        ??at25_set_protection_1
    656          	} else {
    657          #ifdef SPI_NOR_VERBOSE_DEBUG
    658          		trace_info("spi-nor: unlock all\r\n");
    659          #endif
    660          		/* Get the status register value to check the current protection */
    661          		if ((sr & SR_SWP) == SR_SWP_PROTECT_NONE)
   \                     ??at25_set_protection_3:
   \       0x8C   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x90   0xE310'000C        TST      R0,#0xC
   \       0x94   0x1A00'0001        BNE      ??at25_set_protection_5
    662          			return 0;
   \       0x98   0xE3A0'0000        MOV      R0,#+0
   \       0x9C   0xEA00'0019        B        ??at25_set_protection_1
    663          
    664          		/* Perform a global unprotect command */
    665          		sr = 0;
   \                     ??at25_set_protection_5:
   \       0xA0   0xE3A0'0000        MOV      R0,#+0
   \       0xA4   0xE5CD'0000        STRB     R0,[SP, #+0]
    666          		rc = spi_flash_write_reg(flash, SFLASH_INST_WRITE_SR, &sr, 1);
   \       0xA8   0xE3A0'3001        MOV      R3,#+1
   \       0xAC   0xE1B0'200D        MOVS     R2,SP
   \       0xB0   0xE3A0'1001        MOV      R1,#+1
   \       0xB4   0xE1B0'0004        MOVS     R0,R4
   \       0xB8   0x....'....        BL       spi_flash_write_reg
   \       0xBC   0xE1B0'7000        MOVS     R7,R0
    667          		if (rc < 0)
   \       0xC0   0xE357'0000        CMP      R7,#+0
   \       0xC4   0x5A00'0001        BPL      ??at25_set_protection_6
    668          			return rc;
   \       0xC8   0xE1B0'0007        MOVS     R0,R7
   \       0xCC   0xEA00'000D        B        ??at25_set_protection_1
    669          
    670          		/* Check the new status */
    671          		rc = spi_flash_read_sr(flash, &sr);
   \                     ??at25_set_protection_6:
   \       0xD0   0xE1B0'100D        MOVS     R1,SP
   \       0xD4   0xE1B0'0004        MOVS     R0,R4
   \       0xD8   0x....'....        BL       spi_flash_read_sr
   \       0xDC   0xE1B0'1000        MOVS     R1,R0
    672          		if (rc < 0)
   \       0xE0   0xE351'0000        CMP      R1,#+0
   \       0xE4   0x5A00'0001        BPL      ??at25_set_protection_7
    673          			return rc;
   \       0xE8   0xE1B0'0001        MOVS     R0,R1
   \       0xEC   0xEA00'0005        B        ??at25_set_protection_1
    674          		if (sr & (SR_SPRL_LOCKED | SR_SWP))
   \                     ??at25_set_protection_7:
   \       0xF0   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0xF4   0xE310'008C        TST      R0,#0x8C
   \       0xF8   0x0A00'0001        BEQ      ??at25_set_protection_4
    675          			return -EPERM;
   \       0xFC   0xE3E0'0042        MVN      R0,#+66
   \      0x100   0xEA00'0000        B        ??at25_set_protection_1
    676          	}
    677          
    678          #ifdef SPI_NOR_VERBOSE_DEBUG
    679          	trace_info("spi-nor: protection: %s\r\n", sr & SR_SWP ? "on" : "off");
    680          #endif
    681          
    682          	return 0;
   \                     ??at25_set_protection_4:
   \      0x104   0xE3A0'0000        MOV      R0,#+0
   \                     ??at25_set_protection_1:
   \      0x108   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    683          }
    684          

   \                                 In section SOFTPACK, align 4, keep-with-next
    685          int spi_nor_configure(struct spi_flash *flash, const struct spi_flash_cfg *cfg)
    686          {
   \                     spi_nor_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    687          	int rc;
    688          
    689          	memset(flash, 0, sizeof(struct spi_flash));
   \        0xC   0xE3A0'60B8        MOV      R6,#+184
   \       0x10   0xE3A0'7000        MOV      R7,#+0
   \       0x14   0xE1B0'8004        MOVS     R8,R4
   \       0x18   0xE1B0'2007        MOVS     R2,R7
   \       0x1C   0xE1B0'1006        MOVS     R1,R6
   \       0x20   0xE1B0'0008        MOVS     R0,R8
   \       0x24   0x....'....        BL       __aeabi_memset
   \       0x28   0xE1B0'0008        MOVS     R0,R8
    690          
    691          	switch (cfg->type) {
   \       0x2C   0xE5D5'0000        LDRB     R0,[R5, #+0]
   \       0x30   0xE350'0001        CMP      R0,#+1
   \       0x34   0x0A00'0002        BEQ      ??spi_nor_configure_0
   \       0x38   0xE350'0002        CMP      R0,#+2
   \       0x3C   0x0A00'000A        BEQ      ??spi_nor_configure_1
   \       0x40   0xEA00'000D        B        ??spi_nor_configure_2
    692          #ifdef CONFIG_HAVE_SPI_BUS
    693          	case SPI_FLASH_TYPE_SPI:
    694          		/* SPI bus already initialized in board_cfg_spi_bus() */
    695          		flash->ops = &_spi_bus_ops;
   \                     ??spi_nor_configure_0:
   \       0x44   0x....'....        LDR      R0,??DataTable8_19
   \       0x48   0xE584'00A0        STR      R0,[R4, #+160]
    696          		flash->priv.spi = cfg->spi.bus_cfg;
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0xE295'100C        ADDS     R1,R5,#+12
   \       0x54   0xE3A0'2018        MOV      R2,#+24
   \       0x58   0x....'....        BL       __aeabi_memcpy4
    697          		flash->hwcaps.mask = (SFLASH_HWCAPS_READ | SFLASH_HWCAPS_READ_FAST | SFLASH_HWCAPS_PP);
   \       0x5C   0xE3A0'0003        MOV      R0,#+3
   \       0x60   0xE380'0B40        ORR      R0,R0,#0x10000
   \       0x64   0xE584'0018        STR      R0,[R4, #+24]
    698          		break;
   \       0x68   0xEA00'0005        B        ??spi_nor_configure_3
    699          #endif
    700          #ifdef CONFIG_HAVE_QSPI
    701          	case SPI_FLASH_TYPE_QSPI:
    702          		qspi_configure(flash, cfg);
   \                     ??spi_nor_configure_1:
   \       0x6C   0xE1B0'1005        MOVS     R1,R5
   \       0x70   0xE1B0'0004        MOVS     R0,R4
   \       0x74   0x....'....        BL       qspi_configure
    703          		break;
   \       0x78   0xEA00'0001        B        ??spi_nor_configure_3
    704          #endif
    705          	default:
    706          		return -EINVAL;
   \                     ??spi_nor_configure_2:
   \       0x7C   0xE3E0'001B        MVN      R0,#+27
   \       0x80   0xEA00'002C        B        ??spi_nor_configure_4
    707          	}
    708          
    709          	/* Init the SPI controller. */
    710          	rc = spi_flash_init(flash);
   \                     ??spi_nor_configure_3:
   \       0x84   0xE1B0'0004        MOVS     R0,R4
   \       0x88   0x....'....        BL       spi_flash_init
   \       0x8C   0xE1B0'6000        MOVS     R6,R0
    711          	if (rc < 0) {
   \       0x90   0xE356'0000        CMP      R6,#+0
   \       0x94   0x5A00'0007        BPL      ??spi_nor_configure_5
    712          		trace_info("SF: Fail to initialize spi\r\n");
   \       0x98   0x....'....        LDR      R0,??DataTable8_20
   \       0x9C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xA0   0xE350'0004        CMP      R0,#+4
   \       0xA4   0x3A00'0001        BCC      ??spi_nor_configure_6
   \       0xA8   0x....'....        LDR      R0,??DataTable8_21
   \       0xAC   0x....'....        BL       printf
    713          		return rc;
   \                     ??spi_nor_configure_6:
   \       0xB0   0xE1B0'0006        MOVS     R0,R6
   \       0xB4   0xEA00'001F        B        ??spi_nor_configure_4
    714          	}
    715          
    716          	/* Set the SPI mode. */
    717          	rc = spi_flash_set_mode(flash, cfg->mode);
   \                     ??spi_nor_configure_5:
   \       0xB8   0xE5D5'1008        LDRB     R1,[R5, #+8]
   \       0xBC   0xE1B0'0004        MOVS     R0,R4
   \       0xC0   0x....'....        BL       spi_flash_set_mode
   \       0xC4   0xE1B0'7000        MOVS     R7,R0
    718          	if (rc < 0)
   \       0xC8   0xE357'0000        CMP      R7,#+0
   \       0xCC   0x5A00'0001        BPL      ??spi_nor_configure_7
    719          		return rc;
   \       0xD0   0xE1B0'0007        MOVS     R0,R7
   \       0xD4   0xEA00'0017        B        ??spi_nor_configure_4
    720          
    721          	/* Set the new baudrate. */
    722          	rc = spi_flash_set_freq(flash, cfg->baudrate);
   \                     ??spi_nor_configure_7:
   \       0xD8   0xE595'1004        LDR      R1,[R5, #+4]
   \       0xDC   0xE1B0'0004        MOVS     R0,R4
   \       0xE0   0x....'....        BL       spi_flash_set_freq
   \       0xE4   0xE1B0'6000        MOVS     R6,R0
    723          	if (rc < 0)
   \       0xE8   0xE356'0000        CMP      R6,#+0
   \       0xEC   0x5A00'0001        BPL      ??spi_nor_configure_8
    724          		return rc;
   \       0xF0   0xE1B0'0006        MOVS     R0,R6
   \       0xF4   0xEA00'000F        B        ??spi_nor_configure_4
    725          
    726          	/* Probe the SPI flash memory. */
    727          	rc = spi_nor_probe(flash);
   \                     ??spi_nor_configure_8:
   \       0xF8   0xE1B0'0004        MOVS     R0,R4
   \       0xFC   0x....'....        BL       spi_nor_probe
   \      0x100   0xE1B0'7000        MOVS     R7,R0
    728          	if (rc < 0) {
   \      0x104   0xE357'0000        CMP      R7,#+0
   \      0x108   0x5A00'0009        BPL      ??spi_nor_configure_9
    729          		trace_info("SF: Fail to probe SPI flash\r\n");
   \      0x10C   0x....'....        LDR      R0,??DataTable8_20
   \      0x110   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x114   0xE350'0004        CMP      R0,#+4
   \      0x118   0x3A00'0001        BCC      ??spi_nor_configure_10
   \      0x11C   0x....'....        LDR      R0,??DataTable8_22
   \      0x120   0x....'....        BL       printf
    730          		spi_flash_cleanup(flash);
   \                     ??spi_nor_configure_10:
   \      0x124   0xE1B0'0004        MOVS     R0,R4
   \      0x128   0x....'....        BL       spi_flash_cleanup
    731          		return rc;
   \      0x12C   0xE1B0'0007        MOVS     R0,R7
   \      0x130   0xEA00'0000        B        ??spi_nor_configure_4
    732          	}
    733          
    734          	return 0;
   \                     ??spi_nor_configure_9:
   \      0x134   0xE3A0'0000        MOV      R0,#+0
   \                     ??spi_nor_configure_4:
   \      0x138   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    735          }
    736          

   \                                 In section SOFTPACK, align 4, keep-with-next
    737          int spi_nor_read(struct spi_flash *flash, size_t from, uint8_t* buf, size_t len)
    738          {
   \                     spi_nor_read:
   \        0x0   0xE92D'40F0        PUSH     {R4-R7,LR}
   \        0x4   0xE24D'D024        SUB      SP,SP,#+36
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
    739          	struct spi_flash_command cmd;
    740          
    741          	spi_flash_command_init(&cmd, flash->read_inst, flash->addr_len, SFLASH_TYPE_READ);
   \       0x18   0xE3A0'3000        MOV      R3,#+0
   \       0x1C   0xE5D4'202C        LDRB     R2,[R4, #+44]
   \       0x20   0xE5D4'102D        LDRB     R1,[R4, #+45]
   \       0x24   0xE1B0'000D        MOVS     R0,SP
   \       0x28   0x....'....        BL       spi_flash_command_init
    742          	cmd.proto = flash->read_proto;
   \       0x2C   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x30   0xE58D'0000        STR      R0,[SP, #+0]
    743          	cmd.addr = from;
   \       0x34   0xE58D'5010        STR      R5,[SP, #+16]
    744          	cmd.mode = buf ? flash->normal_mode : flash->xip_mode;
   \       0x38   0xE356'0000        CMP      R6,#+0
   \       0x3C   0x0A00'0001        BEQ      ??spi_nor_read_0
   \       0x40   0xE5D4'002F        LDRB     R0,[R4, #+47]
   \       0x44   0xEA00'0000        B        ??spi_nor_read_1
   \                     ??spi_nor_read_0:
   \       0x48   0xE5D4'0030        LDRB     R0,[R4, #+48]
   \                     ??spi_nor_read_1:
   \       0x4C   0xE5CD'0009        STRB     R0,[SP, #+9]
    745          	cmd.num_mode_cycles = flash->num_mode_cycles;
   \       0x50   0xE5D4'0031        LDRB     R0,[R4, #+49]
   \       0x54   0xE5CD'000A        STRB     R0,[SP, #+10]
    746          	cmd.num_wait_states = flash->num_wait_states;
   \       0x58   0xE5D4'0032        LDRB     R0,[R4, #+50]
   \       0x5C   0xE5CD'000B        STRB     R0,[SP, #+11]
    747          	cmd.data_len = len;
   \       0x60   0xE58D'7014        STR      R7,[SP, #+20]
    748          	cmd.rx_data = buf;
   \       0x64   0xE58D'601C        STR      R6,[SP, #+28]
    749          #ifdef CONFIG_HAVE_AESB
    750          	cmd.use_aesb = flash->use_aesb;
    751          #endif
    752          	return spi_flash_exec(flash, &cmd);
   \       0x68   0xE1B0'100D        MOVS     R1,SP
   \       0x6C   0xE1B0'0004        MOVS     R0,R4
   \       0x70   0x....'....        BL       spi_flash_exec
   \       0x74   0xE28D'D024        ADD      SP,SP,#+36
   \       0x78   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return
    753          }
    754          

   \                                 In section SOFTPACK, align 4, keep-with-next
    755          int spi_nor_write(struct spi_flash *flash, size_t to, const uint8_t* buf, size_t len)
    756          {
   \                     spi_nor_write:
   \        0x0   0xE92D'47F8        PUSH     {R3-R10,LR}
   \        0x4   0xE24D'D024        SUB      SP,SP,#+36
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
    757          	struct spi_flash_command cmd;
    758          	int rc = 0;
   \       0x18   0xE3A0'9000        MOV      R9,#+0
    759          
    760          	rc = spi_flash_set_protection(flash, false);
   \       0x1C   0xE3A0'1000        MOV      R1,#+0
   \       0x20   0xE1B0'0004        MOVS     R0,R4
   \       0x24   0x....'....        BL       spi_flash_set_protection
   \       0x28   0xE1B0'8000        MOVS     R8,R0
    761          	if (rc < 0)
   \       0x2C   0xE358'0000        CMP      R8,#+0
   \       0x30   0x5A00'0001        BPL      ??spi_nor_write_0
    762          		return rc;
   \       0x34   0xE1B0'0008        MOVS     R0,R8
   \       0x38   0xEA00'002A        B        ??spi_nor_write_1
    763          
    764          	spi_flash_command_init(&cmd, flash->write_inst, flash->addr_len, SFLASH_TYPE_WRITE);
   \                     ??spi_nor_write_0:
   \       0x3C   0xE3A0'3001        MOV      R3,#+1
   \       0x40   0xE5D4'202C        LDRB     R2,[R4, #+44]
   \       0x44   0xE5D4'102E        LDRB     R1,[R4, #+46]
   \       0x48   0xE1B0'000D        MOVS     R0,SP
   \       0x4C   0x....'....        BL       spi_flash_command_init
    765          	cmd.proto = flash->write_proto;
   \       0x50   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x54   0xE58D'0000        STR      R0,[SP, #+0]
    766          #ifdef CONFIG_HAVE_AESB
    767          	cmd.use_aesb = flash->use_aesb;
    768          #endif
    769          	while (len) {
   \                     ??spi_nor_write_2:
   \       0x58   0xE357'0000        CMP      R7,#+0
   \       0x5C   0x0A00'0020        BEQ      ??spi_nor_write_3
    770          		size_t page_offset, page_remain;
    771          
    772          		page_offset = to & (flash->page_size - 1);
   \       0x60   0xE594'0044        LDR      R0,[R4, #+68]
   \       0x64   0xE250'0001        SUBS     R0,R0,#+1
   \       0x68   0xE010'9005        ANDS     R9,R0,R5
    773          		page_remain = min_u32(flash->page_size - page_offset, len);
   \       0x6C   0xE1B0'1007        MOVS     R1,R7
   \       0x70   0xE594'0044        LDR      R0,[R4, #+68]
   \       0x74   0xE050'0009        SUBS     R0,R0,R9
   \       0x78   0x....'....        BL       min_u32
   \       0x7C   0xE1B0'A000        MOVS     R10,R0
    774          
    775          		cmd.addr = to;
   \       0x80   0xE58D'5010        STR      R5,[SP, #+16]
    776          		cmd.data_len = page_remain;
   \       0x84   0xE58D'A014        STR      R10,[SP, #+20]
    777          		cmd.tx_data = buf;
   \       0x88   0xE58D'6018        STR      R6,[SP, #+24]
    778          		cmd.timeout = TIMEOUT_WRITE;
   \       0x8C   0xE3A0'0FC8        MOV      R0,#+800
   \       0x90   0xE58D'0020        STR      R0,[SP, #+32]
    779          		
    780          		rc = spi_flash_write_enable(flash);
   \       0x94   0xE1B0'0004        MOVS     R0,R4
   \       0x98   0x....'....        BL       spi_flash_write_enable
   \       0x9C   0xE1B0'8000        MOVS     R8,R0
    781          		if (rc < 0)
   \       0xA0   0xE358'0000        CMP      R8,#+0
   \       0xA4   0x4A00'000E        BMI      ??spi_nor_write_3
    782          			break;
    783          
    784          		rc = spi_flash_exec(flash, &cmd);
   \                     ??spi_nor_write_4:
   \       0xA8   0xE1B0'100D        MOVS     R1,SP
   \       0xAC   0xE1B0'0004        MOVS     R0,R4
   \       0xB0   0x....'....        BL       spi_flash_exec
   \       0xB4   0xE1B0'8000        MOVS     R8,R0
    785          		if (rc < 0)
   \       0xB8   0xE358'0000        CMP      R8,#+0
   \       0xBC   0x4A00'0008        BMI      ??spi_nor_write_3
    786          			break;
    787          
    788          		rc = spi_flash_wait_till_ready(flash);
   \                     ??spi_nor_write_5:
   \       0xC0   0xE1B0'0004        MOVS     R0,R4
   \       0xC4   0x....'....        BL       spi_flash_wait_till_ready
   \       0xC8   0xE1B0'8000        MOVS     R8,R0
    789          		if (rc < 0)
   \       0xCC   0xE358'0000        CMP      R8,#+0
   \       0xD0   0x4A00'0003        BMI      ??spi_nor_write_3
    790          			break;
    791          
    792          		buf += page_remain;
   \                     ??spi_nor_write_6:
   \       0xD4   0xE096'600A        ADDS     R6,R6,R10
    793          		to += page_remain;
   \       0xD8   0xE09A'5005        ADDS     R5,R10,R5
    794          		len -= page_remain;
   \       0xDC   0xE057'700A        SUBS     R7,R7,R10
   \       0xE0   0xEAFF'FFDC        B        ??spi_nor_write_2
    795          	}
    796          
    797          	return rc;
   \                     ??spi_nor_write_3:
   \       0xE4   0xE1B0'0008        MOVS     R0,R8
   \                     ??spi_nor_write_1:
   \       0xE8   0xE28D'D028        ADD      SP,SP,#+40
   \       0xEC   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    798          }
    799          

   \                                 In section SOFTPACK, align 4, keep-with-next
    800          int spi_nor_erase(struct spi_flash *flash, size_t offset, size_t len)
    801          {
   \                     spi_nor_erase:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE24D'D028        SUB      SP,SP,#+40
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
    802          	const struct spi_flash_erase_map *map = &flash->erase_map;
   \       0x14   0xE294'7048        ADDS     R7,R4,#+72
    803          	struct spi_flash_command cmd;
    804          	int rc = 0;
   \       0x18   0xE3A0'8000        MOV      R8,#+0
    805          
    806          	rc = spi_flash_set_protection(flash, false);
   \       0x1C   0xE3A0'1000        MOV      R1,#+0
   \       0x20   0xE1B0'0004        MOVS     R0,R4
   \       0x24   0x....'....        BL       spi_flash_set_protection
   \       0x28   0xE1B0'A000        MOVS     R10,R0
    807          	if (rc < 0)
   \       0x2C   0xE35A'0000        CMP      R10,#+0
   \       0x30   0x5A00'0001        BPL      ??spi_nor_erase_0
    808          		return rc;
   \       0x34   0xE1B0'000A        MOVS     R0,R10
   \       0x38   0xEA00'0053        B        ??spi_nor_erase_1
    809          
    810          	if (!spi_flash_has_uniform_erase(flash)) {
   \                     ??spi_nor_erase_0:
   \       0x3C   0xE1B0'0004        MOVS     R0,R4
   \       0x40   0x....'....        BL       spi_flash_has_uniform_erase
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x1A00'0001        BNE      ??spi_nor_erase_2
    811          		/* @TODO: add support to non uniform erase map. */
    812          		return -ENOTSUP;
   \       0x4C   0xE3E0'003C        MVN      R0,#+60
   \       0x50   0xEA00'004D        B        ??spi_nor_erase_1
    813          	}
    814          
    815          	rc = spi_flash_set_protection(flash, false);
   \                     ??spi_nor_erase_2:
   \       0x54   0xE3A0'1000        MOV      R1,#+0
   \       0x58   0xE1B0'0004        MOVS     R0,R4
   \       0x5C   0x....'....        BL       spi_flash_set_protection
   \       0x60   0xE1B0'9000        MOVS     R9,R0
    816          	if (rc < 0)
   \       0x64   0xE359'0000        CMP      R9,#+0
   \       0x68   0x5A00'0001        BPL      ??spi_nor_erase_3
    817          		return rc;
   \       0x6C   0xE1B0'0009        MOVS     R0,R9
   \       0x70   0xEA00'0045        B        ??spi_nor_erase_1
    818          
    819          	spi_flash_command_init(&cmd, 0, flash->addr_len, SFLASH_TYPE_ERASE);
   \                     ??spi_nor_erase_3:
   \       0x74   0xE3A0'3002        MOV      R3,#+2
   \       0x78   0xE5D4'202C        LDRB     R2,[R4, #+44]
   \       0x7C   0xE3A0'1000        MOV      R1,#+0
   \       0x80   0xE28D'0004        ADD      R0,SP,#+4
   \       0x84   0x....'....        BL       spi_flash_command_init
    820          	cmd.proto = flash->reg_proto;
   \       0x88   0xE594'0028        LDR      R0,[R4, #+40]
   \       0x8C   0xE58D'0004        STR      R0,[SP, #+4]
    821          #ifdef CONFIG_HAVE_AESB
    822          	cmd.use_aesb = flash->use_aesb;
    823          #endif
    824          	cmd.timeout = TIMEOUT_ERASE;
   \       0x90   0xE300'0BB8        MOVW     R0,#+3000
   \       0x94   0xE58D'0024        STR      R0,[SP, #+36]
    825          	while (len) {
   \                     ??spi_nor_erase_4:
   \       0x98   0xE356'0000        CMP      R6,#+0
   \       0x9C   0x0A00'0039        BEQ      ??spi_nor_erase_5
    826          		const struct spi_flash_erase_command *erase = NULL;
   \       0xA0   0xE3A0'0000        MOV      R0,#+0
   \       0xA4   0xE1B0'A000        MOVS     R10,R0
    827          		size_t i;
    828          
    829          		for (i = 0; i < SFLASH_CMD_ERASE_MAX; i++) {
   \       0xA8   0xE1B0'8000        MOVS     R8,R0
   \                     ??spi_nor_erase_6:
   \       0xAC   0xE358'0004        CMP      R8,#+4
   \       0xB0   0x2A00'0018        BCS      ??spi_nor_erase_7
    830          			const struct spi_flash_erase_command *e;
    831          			uint32_t rem;
    832          
    833          			if ((map->uniform_region.cmd_mask & (0x1UL << i))) {
   \       0xB4   0xE597'0040        LDR      R0,[R7, #+64]
   \       0xB8   0xE3A0'1001        MOV      R1,#+1
   \       0xBC   0xE111'0830        TST      R1,R0, LSR R8
   \       0xC0   0x0A00'0012        BEQ      ??spi_nor_erase_8
    834          				e = &map->commands[i];
   \       0xC4   0xE1B0'0208        LSLS     R0,R8,#+4
   \       0xC8   0xE097'B000        ADDS     R11,R7,R0
    835          				spi_flash_div_by_erase_size(e, offset, &rem);
   \       0xCC   0xE1B0'200D        MOVS     R2,SP
   \       0xD0   0xE1B0'1005        MOVS     R1,R5
   \       0xD4   0xE1B0'000B        MOVS     R0,R11
   \       0xD8   0x....'....        BL       spi_flash_div_by_erase_size
    836          				if (rem)
   \       0xDC   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xE0   0xE350'0000        CMP      R0,#+0
   \       0xE4   0x1A00'0009        BNE      ??spi_nor_erase_8
    837          					continue;
    838          
    839          				if (e->size <= len && (!erase || erase->size < e->size))
   \                     ??spi_nor_erase_9:
   \       0xE8   0xE59B'0000        LDR      R0,[R11, #+0]
   \       0xEC   0xE156'0000        CMP      R6,R0
   \       0xF0   0x3A00'0006        BCC      ??spi_nor_erase_8
   \       0xF4   0xE35A'0000        CMP      R10,#+0
   \       0xF8   0x0A00'0003        BEQ      ??spi_nor_erase_10
   \       0xFC   0xE59A'0000        LDR      R0,[R10, #+0]
   \      0x100   0xE59B'1000        LDR      R1,[R11, #+0]
   \      0x104   0xE150'0001        CMP      R0,R1
   \      0x108   0x2A00'0000        BCS      ??spi_nor_erase_8
    840          					erase = e;
   \                     ??spi_nor_erase_10:
   \      0x10C   0xE1B0'A00B        MOVS     R10,R11
    841          			}
    842          		}
   \                     ??spi_nor_erase_8:
   \      0x110   0xE298'8001        ADDS     R8,R8,#+1
   \      0x114   0xEAFF'FFE4        B        ??spi_nor_erase_6
    843          		if (!erase)
   \                     ??spi_nor_erase_7:
   \      0x118   0xE35A'0000        CMP      R10,#+0
   \      0x11C   0x1A00'0001        BNE      ??spi_nor_erase_11
    844          			return -1;
   \      0x120   0xE3E0'0000        MVN      R0,#+0
   \      0x124   0xEA00'0018        B        ??spi_nor_erase_1
    845          
    846          #ifdef SPI_NOR_VERBOSE_DEBUG
    847          		trace_info("spi-nor: erase params: inst=0x%x\r\n", erase->inst);
    848          		trace_info("spi-nor: erase params: size=%lu\r\n", erase->size);
    849          		trace_info("spi-nor: erase params: size_shift=%ld\r\n", erase->size_shift);
    850          		trace_info("spi-nor: erase params: size_mask=0x%lx\r\n", erase->size_mask);
    851          #endif
    852          		rc = spi_flash_write_enable(flash);
   \                     ??spi_nor_erase_11:
   \      0x128   0xE1B0'0004        MOVS     R0,R4
   \      0x12C   0x....'....        BL       spi_flash_write_enable
   \      0x130   0xE1B0'9000        MOVS     R9,R0
    853          		if (rc < 0)
   \      0x134   0xE359'0000        CMP      R9,#+0
   \      0x138   0x4A00'0012        BMI      ??spi_nor_erase_5
    854          			break;
    855          
    856          		cmd.inst = erase->inst;
   \                     ??spi_nor_erase_12:
   \      0x13C   0xE5DA'000C        LDRB     R0,[R10, #+12]
   \      0x140   0xE5CD'000C        STRB     R0,[SP, #+12]
    857          		cmd.addr = offset;
   \      0x144   0xE58D'5014        STR      R5,[SP, #+20]
    858          		rc = spi_flash_exec(flash, &cmd);
   \      0x148   0xE28D'1004        ADD      R1,SP,#+4
   \      0x14C   0xE1B0'0004        MOVS     R0,R4
   \      0x150   0x....'....        BL       spi_flash_exec
   \      0x154   0xE1B0'9000        MOVS     R9,R0
    859          		if (rc < 0)
   \      0x158   0xE359'0000        CMP      R9,#+0
   \      0x15C   0x4A00'0009        BMI      ??spi_nor_erase_5
    860          			break;
    861          
    862          		rc = spi_flash_wait_till_ready(flash);
   \                     ??spi_nor_erase_13:
   \      0x160   0xE1B0'0004        MOVS     R0,R4
   \      0x164   0x....'....        BL       spi_flash_wait_till_ready
   \      0x168   0xE1B0'9000        MOVS     R9,R0
    863          		if (rc < 0)
   \      0x16C   0xE359'0000        CMP      R9,#+0
   \      0x170   0x4A00'0004        BMI      ??spi_nor_erase_5
    864          			break;
    865          
    866          		offset += erase->size;
   \                     ??spi_nor_erase_14:
   \      0x174   0xE59A'0000        LDR      R0,[R10, #+0]
   \      0x178   0xE090'5005        ADDS     R5,R0,R5
    867          		len -= erase->size;
   \      0x17C   0xE59A'0000        LDR      R0,[R10, #+0]
   \      0x180   0xE056'6000        SUBS     R6,R6,R0
   \      0x184   0xEAFF'FFC3        B        ??spi_nor_erase_4
    868          	}
    869          
    870          	return rc;
   \                     ??spi_nor_erase_5:
   \      0x188   0xE1B0'0009        MOVS     R0,R9
   \                     ??spi_nor_erase_1:
   \      0x18C   0xE28D'D02C        ADD      SP,SP,#+44
   \      0x190   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    871          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     spi_nor_ids

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x0001'0101        DC32     0x10101

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     micron_enable_0_4_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     macronix_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     at25_set_protection

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     spansion_new_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     spansion_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     `spi_nor_convert_3to4_read::spi_nor_3to4_read`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     `spi_nor_convert_3to4_write::spi_nor_3to4_program`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     `spi_nor_convert_3to4_erase::spi_nor_3to4_erase`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x0004'0404        DC32     0x40404

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     spi_nor_read

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     spi_nor_write

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x....'....        DC32     spi_nor_erase

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x....'....        DC32     flash_name

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_13:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_14:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_15:
   \        0x0   0x....'....        DC32     params

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_16:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_17:
   \        0x0   0x....'....        DC32     _spi_flash_hdr

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_18:
   \        0x0   0x....'....        DC32     _bus_exec_buffer

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_19:
   \        0x0   0x....'....        DC32     _spi_bus_ops

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_20:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_21:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_22:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x49          DC8 "-I- SF: Got Manufacturer and Device ID: %s\015\012"

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20    

   \              0x47 0x6F    

   \              0x74 0x20    

   \              0x4D 0x61    

   \              0x6E 0x75    

   \              0x66 0x61    

   \              0x63 0x74    

   \              0x75 0x72    

   \              0x65 0x72    

   \              0x20 0x61    

   \              0x6E 0x64    

   \              0x20 0x44    

   \              0x65 0x76    

   \              0x69 0x63    

   \              0x65 0x20    

   \              0x49 0x44    

   \              0x3A 0x20    

   \              0x25 0x73    

   \              0x0D 0x0A    

   \              0x00
   \       0x2D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x49          DC8 0x2D, 0x49, 0x2D, 0x20, 0x53, 0x46, 0x3A, 0x20

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20
   \        0x8   0x57 0x41          DC8 0x57, 0x41, 0x52, 0x4E, 0x49, 0x4E, 0x47, 0x3A

   \              0x52 0x4E    

   \              0x49 0x4E    

   \              0x47 0x3A
   \       0x10   0x20 0x53          DC8 0x20, 0x53, 0x53, 0x54, 0x32, 0x36, 0x20, 0x2D

   \              0x53 0x54    

   \              0x32 0x36    

   \              0x20 0x2D
   \       0x18   0x20 0x63          DC8 0x20, 0x63, 0x61, 0x6E, 0x27, 0x74, 0x20, 0x75

   \              0x61 0x6E    

   \              0x27 0x74    

   \              0x20 0x75
   \       0x20   0x6E 0x6C          DC8 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x62, 0x6C

   \              0x6F 0x63    

   \              0x6B 0x20    

   \              0x62 0x6C
   \       0x28   0x6F 0x63          DC8 0x6F, 0x63, 0x6B, 0x20, 0x70, 0x72, 0x6F, 0x74

   \              0x6B 0x20    

   \              0x70 0x72    

   \              0x6F 0x74
   \       0x30   0x65 0x63          DC8 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0D, 0x0A

   \              0x74 0x69    

   \              0x6F 0x6E    

   \              0x0D 0x0A
   \       0x38   0x00               DC8 0
   \       0x39   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x53, 0x46, 0x3A, 0x20

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20
   \        0x8   0x57 0x41          DC8 0x57, 0x41, 0x52, 0x4E, 0x49, 0x4E, 0x47, 0x3A

   \              0x52 0x4E    

   \              0x49 0x4E    

   \              0x47 0x3A
   \       0x10   0x20 0x63          DC8 0x20, 0x63, 0x61, 0x6E, 0x27, 0x74, 0x20, 0x63

   \              0x61 0x6E    

   \              0x27 0x74    

   \              0x20 0x63
   \       0x18   0x6C 0x65          DC8 0x6C, 0x65, 0x61, 0x72, 0x20, 0x42, 0x6C, 0x6F

   \              0x61 0x72    

   \              0x20 0x42    

   \              0x6C 0x6F
   \       0x20   0x63 0x6B          DC8 0x63, 0x6B, 0x20, 0x50, 0x72, 0x6F, 0x74, 0x65

   \              0x20 0x50    

   \              0x72 0x6F    

   \              0x74 0x65
   \       0x28   0x63 0x74          DC8 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x69

   \              0x69 0x6F    

   \              0x6E 0x20    

   \              0x62 0x69
   \       0x30   0x74 0x73          DC8 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x53, 0x74

   \              0x20 0x69    

   \              0x6E 0x20    

   \              0x53 0x74
   \       0x38   0x61 0x74          DC8 0x61, 0x74, 0x75, 0x73, 0x20, 0x52, 0x65, 0x67

   \              0x75 0x73    

   \              0x20 0x52    

   \              0x65 0x67
   \       0x40   0x69 0x73          DC8 0x69, 0x73, 0x74, 0x65, 0x72, 0x0D, 0x0A, 0

   \              0x74 0x65    

   \              0x72 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x49          DC8 "-I- SF: WARNING: can't read above 16MiB\015\012"

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20    

   \              0x57 0x41    

   \              0x52 0x4E    

   \              0x49 0x4E    

   \              0x47 0x3A    

   \              0x20 0x63    

   \              0x61 0x6E    

   \              0x27 0x74    

   \              0x20 0x72    

   \              0x65 0x61    

   \              0x64 0x20    

   \              0x61 0x62    

   \              0x6F 0x76    

   \              0x65 0x20    

   \              0x31 0x36    

   \              0x4D 0x69    

   \              0x42 0x0D    

   \              0x0A 0x00
   \       0x2A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x49          DC8 "-I- SF: Fail to initialize spi\015\012"

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20    

   \              0x46 0x61    

   \              0x69 0x6C    

   \              0x20 0x74    

   \              0x6F 0x20    

   \              0x69 0x6E    

   \              0x69 0x74    

   \              0x69 0x61    

   \              0x6C 0x69    

   \              0x7A 0x65    

   \              0x20 0x73    

   \              0x70 0x69    

   \              0x0D 0x0A    

   \              0x00
   \       0x21   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x2D 0x49          DC8 "-I- SF: Fail to probe SPI flash\015\012"

   \              0x2D 0x20    

   \              0x53 0x46    

   \              0x3A 0x20    

   \              0x46 0x61    

   \              0x69 0x6C    

   \              0x20 0x74    

   \              0x6F 0x20    

   \              0x70 0x72    

   \              0x6F 0x62    

   \              0x65 0x20    

   \              0x53 0x50    

   \              0x49 0x20    

   \              0x66 0x6C    

   \              0x61 0x73    

   \              0x68 0x0D    

   \              0x0A 0x00
   \       0x22   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _bus_cleanup
      48   _bus_exec
        48   -> __aeabi_memset
        48   -> bus_start_transaction
        48   -> bus_stop_transaction
        48   -> bus_transfer
        48   -> bus_wait_transfer
        48 __aeabi_idiv
       0   _bus_init
      16   _bus_set_freq
        16   -> bus_configure_slave
      16   _bus_set_mode
        16   -> bus_configure_slave
      24   at25_set_protection
        24   -> spi_flash_read_sr
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
      24   macronix_quad_enable
        24   -> spi_flash_read_sr
        24   -> spi_flash_wait_till_ready
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
      32   micron_enable_0_4_4
        32   -> spi_flash_read_reg
        32   -> spi_flash_wait_till_ready
        32   -> spi_flash_write_enable
        32   -> spi_flash_write_reg
       0   min_u32
      24   spansion_new_quad_enable
        24   -> spi_flash_read_reg
        24   -> spi_flash_read_sr
        24   -> spi_flash_wait_till_ready
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
      24   spansion_quad_enable
        24   -> spi_flash_read_sr
        24   -> spi_flash_wait_till_ready
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
       0   spi_flash_set_pp_settings
       0   spi_flash_set_read_settings
      24   spi_nor_clear_sr_bp
        24   -> spi_flash_wait_till_ready
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
      24   spi_nor_configure
        24   -> __aeabi_memcpy4
        24   -> __aeabi_memset
        24   -> printf
        24   -> qspi_configure
        24   -> spi_flash_cleanup
        24   -> spi_flash_init
        24   -> spi_flash_set_freq
        24   -> spi_flash_set_mode
        24   -> spi_nor_probe
       8   spi_nor_convert_3to4_erase
         8   -> spi_nor_convert_inst
       8   spi_nor_convert_3to4_read
         8   -> spi_nor_convert_inst
       8   spi_nor_convert_3to4_write
         8   -> spi_nor_convert_inst
       4   spi_nor_convert_inst
      80   spi_nor_erase
        80   -> spi_flash_command_init
        80   -> spi_flash_div_by_erase_size
        80   -> spi_flash_exec
        80   -> spi_flash_has_uniform_erase
        80   -> spi_flash_set_protection
        80   -> spi_flash_wait_till_ready
        80   -> spi_flash_write_enable
      48   spi_nor_init_params
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> spi_flash_get_mfr
        48   -> spi_flash_init_uniform_erase_map
        48   -> spi_flash_parse_sfdp
        48   -> spi_flash_set_erase_command
        48   -> spi_flash_set_pp_settings
        48   -> spi_flash_set_read_settings
      24   spi_nor_probe
        24   -> printf
        24   -> spi_flash_reset
        24   -> spi_flash_setup
        24   -> spi_nor_clear_sr_bp
        24   -> spi_nor_init_params
        24   -> spi_nor_read_id
        24   -> spi_nor_set_4bais
        24   -> sst26_unlock_block_protection
        24   -> usleep
      56   spi_nor_read
        56   -> spi_flash_command_init
        56   -> spi_flash_exec
      32   spi_nor_read_id
        32   -> memcmp
        32   -> printf
        32   -> spi_flash_read_reg
      24   spi_nor_set_4bais
        24   -> spi_nor_convert_3to4_erase
        24   -> spi_nor_convert_3to4_read
        24   -> spi_nor_convert_3to4_write
      72   spi_nor_write
        72   -> min_u32
        72   -> spi_flash_command_init
        72   -> spi_flash_exec
        72   -> spi_flash_set_protection
        72   -> spi_flash_wait_till_ready
        72   -> spi_flash_write_enable
      24   sr2_bit7_quad_enable
        24   -> spi_flash_read_reg
        24   -> spi_flash_wait_till_ready
        24   -> spi_flash_write_enable
        24   -> spi_flash_write_reg
      16   sst26_unlock_block_protection
        16   -> spi_flash_wait_till_ready
        16   -> spi_flash_write_enable
        16   -> spi_flash_write_reg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      48  ?_0
      60  ?_1
      72  ?_2
      44  ?_3
      36  ?_4
      36  ?_5
      12  _bus_cleanup
     504  _bus_exec
      24  _bus_exec_buffer
      12  _bus_init
      32  _bus_set_freq
      32  _bus_set_mode
      20  _spi_bus_ops
      16  _spi_flash_hdr
     268  at25_set_protection
       8  flash_name
     216  macronix_quad_enable
     304  micron_enable_0_4_4
      28  min_u32
     112  params
     268  spansion_new_quad_enable
     128  spansion_quad_enable
      12  spi_flash_set_pp_settings
      24  spi_flash_set_read_settings
       8  spi_nor_3to4_erase
       8  spi_nor_3to4_program
      12  spi_nor_3to4_read
      96  spi_nor_clear_sr_bp
     316  spi_nor_configure
      32  spi_nor_convert_3to4_erase
      32  spi_nor_convert_3to4_read
      32  spi_nor_convert_3to4_write
      80  spi_nor_convert_inst
     404  spi_nor_erase
     748  spi_nor_init_params
     556  spi_nor_probe
     124  spi_nor_read
     280  spi_nor_read_id
      88  spi_nor_set_4bais
     240  spi_nor_write
     232  sr2_bit7_quad_enable
      88  sst26_unlock_block_protection

 
   152 bytes in section .bss
   352 bytes in section .rodata
 5'296 bytes in section SOFTPACK
 
 5'296 bytes of CODE  memory
   352 bytes of CONST memory
   152 bytes of DATA  memory

Errors: none
Warnings: 3
