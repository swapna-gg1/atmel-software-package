###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         18/Feb/2021  16:03:19
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EWB3A9.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_QSPI -D CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_NFC -D
#        CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D
#        CONFIG_HAVE_GMAC_QUEUES -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_MPDDRC_DDR3 -D CONFIG_HAVE_MPDDRC_LPDDR3 -D
#        CONFIG_HAVE_ADC_SETTLING_TIME -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_FAST_STARTUP -D
#        CONFIG_HAVE_PMC_GENERATED_CLOCKS -D CONFIG_HAVE_PMC_AUDIO_CLOCK -D
#        CONFIG_HAVE_PMC_PLLADIV2 -D CONFIG_HAVE_PMC_H32MXDIV -D
#        CONFIG_HAVE_PMC_UPLL_BIAS -D CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA
#        -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
#        -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_SFRBU
#        -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_TRNG -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\List\sfdp.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sama5d27-som1-ek\sram\Obj\sfdp.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2017, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           */
     28          
     29          /*----------------------------------------------------------------------------
     30           *        Headers
     31           *----------------------------------------------------------------------------*/
     32          
     33          #include "errno.h"
     34          #include "nvm/spi-nor/sfdp.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp uint32_t min_u32(uint32_t, uint32_t)
   \                     min_u32:
   \        0x0   0xE1B0'2000        MOVS     R2,R0
   \        0x4   0xE152'0001        CMP      R2,R1
   \        0x8   0x2A00'0001        BCS      ??min_u32_0
   \        0xC   0xE1B0'0002        MOVS     R0,R2
   \       0x10   0xEA00'0000        B        ??min_u32_1
   \                     ??min_u32_0:
   \       0x14   0xE1B0'0001        MOVS     R0,R1
   \                     ??min_u32_1:
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
     35          #include "nvm/spi-nor/spi-nor.h"
     36          #include "string.h"
     37          
     38          /*----------------------------------------------------------------------------
     39           *        Local Functions
     40           *----------------------------------------------------------------------------*/
     41          

   \                                 In section SOFTPACK, align 4, keep-with-next
     42          static int spi_flash_read_sfdp(struct spi_flash *flash, size_t from, size_t len, void *buf)
     43          {
   \                     spi_flash_read_sfdp:
   \        0x0   0xE92D'40F0        PUSH     {R4-R7,LR}
   \        0x4   0xE24D'D024        SUB      SP,SP,#+36
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
     44          	struct spi_flash_command cmd;
     45          
     46          	spi_flash_command_init(&cmd, SFLASH_INST_READ_SFDP, 3, SFLASH_TYPE_READ);
   \       0x18   0xE3A0'3000        MOV      R3,#+0
   \       0x1C   0xE3A0'2003        MOV      R2,#+3
   \       0x20   0xE3A0'105A        MOV      R1,#+90
   \       0x24   0xE1B0'000D        MOVS     R0,SP
   \       0x28   0x....'....        BL       spi_flash_command_init
     47          	cmd.proto = flash->read_proto;
   \       0x2C   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x30   0xE58D'0000        STR      R0,[SP, #+0]
     48          	cmd.addr = from;
   \       0x34   0xE58D'5010        STR      R5,[SP, #+16]
     49          	cmd.num_wait_states = 8;
   \       0x38   0xE3A0'0008        MOV      R0,#+8
   \       0x3C   0xE5CD'000B        STRB     R0,[SP, #+11]
     50          	cmd.data_len = len;
   \       0x40   0xE58D'6014        STR      R6,[SP, #+20]
     51          	cmd.rx_data = buf;
   \       0x44   0xE58D'701C        STR      R7,[SP, #+28]
     52          	return spi_flash_exec(flash, &cmd);
   \       0x48   0xE1B0'100D        MOVS     R1,SP
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0x....'....        BL       spi_flash_exec
   \       0x54   0xE28D'D024        ADD      SP,SP,#+36
   \       0x58   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return
     53          }
     54          
     55          struct sfdp_parameter_header {
     56          	uint8_t id_lsb;
     57          	uint8_t minor;
     58          	uint8_t major;
     59          	uint8_t length; /* in double words */
     60          	uint8_t parameter_table_pointer[3]; /* byte address */
     61          	uint8_t id_msb;
     62          };
     63          
     64          #define SFDP_PARAM_HEADER_ID(p)	((uint16_t)(((p)->id_msb << 8) | (p)->id_lsb))
     65          #define SFDP_PARAM_HEADER_PTP(p)				\
     66          	((uint32_t)(((p)->parameter_table_pointer[2] << 16) |	\
     67          	       ((p)->parameter_table_pointer[1] <<  8) |	\
     68          	       ((p)->parameter_table_pointer[0] <<  0)))
     69          
     70          
     71          #define SFDP_BFPT_ID		0xff00u	/* Basic Flash Parameter Table */
     72          #define SFDP_4BAIT_ID		0xff84u	/* 4-byte Address Instruction Table */
     73          
     74          #define SFDP_SIGNATURE		0x50444653u
     75          #define SFDP_JESD216_MAJOR	1
     76          #define SFDP_JESD216_MINOR	0
     77          #define SFDP_JESD216A_MINOR	5
     78          #define SFDP_JESD216B_MINOR	6
     79          
     80          struct sfdp_header {
     81          	uint32_t signature; /* Ox50444653 <=> "SFDP" */
     82          	uint8_t minor;
     83          	uint8_t major;
     84          	uint8_t nph; /* 0-base number of parameter headers */
     85          	uint8_t unused;
     86          
     87          	/* Basic Flash Parameter Table. */
     88          	struct sfdp_parameter_header bfpt_header;
     89          };
     90          
     91          /* Basic Flash Parameter Table */
     92          
     93          /*
     94           * JESD216B defines a Basic Flash Parameter Table of 16 DWORDs.
     95           * They are indexed from 1 but C arrays are indexed from 0.
     96           */
     97          enum sfdp_bfpt_dword {
     98          	BFPT_DWORD1 = 0,
     99          	BFPT_DWORD2,
    100          	BFPT_DWORD3,
    101          	BFPT_DWORD4,
    102          	BFPT_DWORD5,
    103          	BFPT_DWORD6,
    104          	BFPT_DWORD7,
    105          	BFPT_DWORD8,
    106          	BFPT_DWORD9,
    107          	BFPT_DWORD10,
    108          	BFPT_DWORD11,
    109          	BFPT_DWORD12,
    110          	BFPT_DWORD13,
    111          	BFPT_DWORD14,
    112          	BFPT_DWORD15,
    113          	BFPT_DWORD16,
    114          
    115          	BFPT_DWORD_MAX
    116          };
    117          
    118          /* The first revision of JESB216 defined only 9 DWORDs. */
    119          #define BFPT_DWORD_MAX_JESD216			9
    120          
    121          /* 1st DWORD. */
    122          #define BFPT_DWORD1_FAST_READ_1_1_2      (0x1UL << 16)
    123          #define BFPT_DWORD1_ADDRESS_BYTES_MASK   (0x3UL << 17)
    124          #define BFPT_DWORD1_ADDRESS_BYTES_3_ONLY (0x0UL << 17)
    125          #define BFPT_DWORD1_ADDRESS_BYTES_3_OR_4 (0x1UL << 17)
    126          #define BFPT_DWORD1_ADDRESS_BYTES_4_ONLY (0x2UL << 17)
    127          #define BFPT_DWORD1_DTR                  (0x1UL << 19)
    128          #define BFPT_DWORD1_FAST_READ_1_2_2      (0x1UL << 20)
    129          #define BFPT_DWORD1_FAST_READ_1_4_4      (0x1UL << 21)
    130          #define BFPT_DWORD1_FAST_READ_1_1_4      (0x1UL << 22)
    131          
    132          /* 5th DWORD. */
    133          #define BFPT_DWORD5_FAST_READ_2_2_2      (0x1UL << 0)
    134          #define BFPT_DWORD5_FAST_READ_4_4_4      (0x1UL << 4)
    135          
    136          /* 11th DWORD. */
    137          #define BFPT_DWORD11_PAGE_SIZE_SHIFT     4
    138          #define BFPT_DWORD11_PAGE_SIZE_MASK      (0xFUL << 4)
    139          
    140          /* 15th DWORD. */
    141          
    142          /*
    143           * (from JESD216B)
    144           * Quad Enable Requirements (QER):
    145           * - 000b: Device does not have a QE bit. Device detects 1-1-4 and 1-4-4
    146           *         reads based on instruction. DQ3/HOLD# functions are hold during
    147           *         instruction pahse.
    148           * - 001b: QE is bit 1 of status register 2. It is set via Write Status with
    149           *         two data bytes where bit 1 of the second byte is one.
    150           *         [...]
    151           *         Writing only one byte to the status register has the side-effect of
    152           *         clearing status register 2, including the QE bit. The 100b code is
    153           *         used if writing one byte to the status register does not modify
    154           *         status register 2.
    155           * - 010b: QE is bit 6 of status register 1. It is set via Write Status with
    156           *         one data byte where bit 6 is one.
    157           *         [...]
    158           * - 011b: QE is bit 7 of status register 2. It is set via Write status
    159           *         register 2 instruction 3Eh with one data byte where bit 7 is one.
    160           *         [...]
    161           *         The status register 2 is read using instruction 3Fh.
    162           * - 100b: QE is bit 1 of status register 2. It is set via Write Status with
    163           *         two data bytes where bit 1 of the second byte is one.
    164           *         [...]
    165           *         In contrast to the 001b code, writing one byte to the status
    166           *         register does not modify status register 2.
    167           * - 101b: QE is bit 1 of status register 2. Status register 1 is read using
    168           *         Read Status instruction 05h. Status register2 is read using
    169           *         instruction 35h. QE is set via Writ Status instruction 01h with
    170           *         two data bytes where bit 1 of the second byte is one.
    171           *         [...]
    172           */
    173          #define BFPT_DWORD15_QER_MASK           (0x7UL << 20)
    174          #define BFPT_DWORD15_QER_NONE           (0x0UL << 20) /* Micron */
    175          #define BFPT_DWORD15_QER_SR2_BIT1_BUGGY	(0x1UL << 20)
    176          #define BFPT_DWORD15_QER_SR1_BIT6       (0x2UL << 20) /* Macronix */
    177          #define BFPT_DWORD15_QER_SR2_BIT7       (0x3UL << 20)
    178          #define BFPT_DWORD15_QER_SR2_BIT1_NO_RD (0x4UL << 20)
    179          #define BFPT_DWORD15_QER_SR2_BIT1       (0x5UL << 20) /* Spansion */
    180          
    181          /*
    182           * (from JESD216B)
    183           * 0-4-4 Mode Entry Method:
    184           * - xxx1b: Mode Bits[7:0] = A5h Note: QE must be set prior to using the mode
    185           * - xx1xb: Read the 8-bit volatile configuration register with 85h, set XIP
    186           *          bit[3] in the data read, and write the modified data using the
    187           *          instruction 81h, then Mode Bits[7:0] = 01h
    188           * - x1xxb: Mode Bit[7:0] = AXh
    189           * - 1xxxb: Reserved
    190           */
    191          #define BFPT_DWORD15_0_4_4_MASK          (0xFUL << 16)
    192          #define BFPT_DWORD15_0_4_4_A5            (0x1UL << 16)
    193          #define BFPT_DWORD15_0_4_4_MICRON        (0x1UL << 17)
    194          #define BFPT_DWORD15_0_4_4_AX            (0x1UL << 18)
    195          
    196          struct sfdp_bfpt {
    197          	uint32_t dwords[BFPT_DWORD_MAX];
    198          };
    199          
    200          /* Fast Read settings. */
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          static inline void
    203          spi_flash_set_read_settings_from_bfpt(struct spi_flash_read_command *read, uint16_t half, enum spi_flash_protocol proto)
    204          {
    205          	read->num_mode_cycles = (half >> 5) & 0x07u;
   \                     spi_flash_set_read_settings_from_bfpt:
   \        0x0   0xE1B0'3001        MOVS     R3,R1
   \        0x4   0xE6EF'3073        UXTB     R3,R3
   \        0x8   0xE1B0'32A3        LSRS     R3,R3,#+5
   \        0xC   0xE5C0'3000        STRB     R3,[R0, #+0]
    206          	read->num_wait_states = (half >> 0) & 0x1Fu;
   \       0x10   0xE1B0'3001        MOVS     R3,R1
   \       0x14   0xE213'301F        ANDS     R3,R3,#0x1F
   \       0x18   0xE5C0'3001        STRB     R3,[R0, #+1]
    207          	read->inst = (half >> 8) & 0xFFu;
   \       0x1C   0xE1B0'3001        MOVS     R3,R1
   \       0x20   0xE6FF'3073        UXTH     R3,R3
   \       0x24   0xE1B0'3423        LSRS     R3,R3,#+8
   \       0x28   0xE5C0'3002        STRB     R3,[R0, #+2]
    208          	read->proto = proto;
   \       0x2C   0xE580'2004        STR      R2,[R0, #+4]
    209          }
   \       0x30   0xE12F'FF1E        BX       LR               ;; return
    210          
    211          struct sfdp_bfpt_read {
    212          	/* The Fast Read x-y-z hardware capability in params->hwcaps.mask. */
    213          	uint32_t hwcaps;
    214          
    215          	/*
    216          	 * The <supported_bit> bit in <supported_dword> BFPT DWORD tells us
    217          	 * whether the Fast Read x-y-z command is supported.
    218          	 */
    219          	enum sfdp_bfpt_dword supported_dword;
    220          	uint32_t supported_bit;
    221          
    222          	/*
    223          	 * The half-word at offset <setting_shift> in <setting_dword> BFPT DWORD
    224          	 * encodes the op code, the number of mode clocks and the number of wait
    225          	 * states to be used by Fast Read x-y-z command.
    226          	 */
    227          	enum sfdp_bfpt_dword settings_dword;
    228          	int settings_shift;
    229          
    230          	/* The SPI protocol for this Fast Read x-y-z command. */
    231          	enum spi_flash_protocol proto;
    232          };
    233          

   \                                 In section .rodata, align 4
    234          static const struct sfdp_bfpt_read sfdp_bfpt_reads[] = {
   \                     sfdp_bfpt_reads:
   \        0x0   0x0000'0004        DC32 4
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x8   0x0001'0000        DC32 65'536
   \        0xC   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x10   0x0000'0000        DC32 0, 65'794, 8

   \              0x0001'0102  

   \              0x0000'0008
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x20   0x0010'0000        DC32 1'048'576
   \       0x24   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x28   0x0000'0010        DC32 16, 66'050, 16

   \              0x0001'0202  

   \              0x0000'0010
   \       0x34   0x04 0x00          DC8 4, 0, 0, 0

   \              0x00 0x00
   \       0x38   0x0000'0001        DC32 1
   \       0x3C   0x05 0x00          DC8 5, 0, 0, 0

   \              0x00 0x00
   \       0x40   0x0000'0010        DC32 16, 131'586, 32

   \              0x0002'0202  

   \              0x0000'0020
   \       0x4C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x50   0x0040'0000        DC32 4'194'304
   \       0x54   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x58   0x0000'0010        DC32 16, 65'796, 64

   \              0x0001'0104  

   \              0x0000'0040
   \       0x64   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x68   0x0020'0000        DC32 2'097'152
   \       0x6C   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x70   0x0000'0000        DC32 0, 66'564, 128

   \              0x0001'0404  

   \              0x0000'0080
   \       0x7C   0x04 0x00          DC8 4, 0, 0, 0

   \              0x00 0x00
   \       0x80   0x0000'0010        DC32 16
   \       0x84   0x06 0x00          DC8 6, 0, 0, 0

   \              0x00 0x00
   \       0x88   0x0000'0010        DC32 16, 263'172

   \              0x0004'0404
    235          	/* Fast Read 1-1-2 */
    236          	{
    237          		SFLASH_HWCAPS_READ_1_1_2,
    238          		BFPT_DWORD1, (0x1UL << 16),
    239          		BFPT_DWORD4, 0,
    240          		SFLASH_PROTO_1_1_2,
    241          	},
    242          
    243          	/* Fast Read 1-2-2 */
    244          	{
    245          		SFLASH_HWCAPS_READ_1_2_2,
    246          		BFPT_DWORD1, (0x1UL << 20),
    247          		BFPT_DWORD4, 16,
    248          		SFLASH_PROTO_1_2_2,
    249          	},
    250          
    251          	/* Fast Read 2-2-2 */
    252          	{
    253          		SFLASH_HWCAPS_READ_2_2_2,
    254          		BFPT_DWORD5, (0x1UL << 0),
    255          		BFPT_DWORD6, 16,
    256          		SFLASH_PROTO_2_2_2,
    257          	},
    258          
    259          	/* Fast Read 1-1-4 */
    260          	{
    261          		SFLASH_HWCAPS_READ_1_1_4,
    262          		BFPT_DWORD1, (0x1UL << 22),
    263          		BFPT_DWORD3, 16,
    264          		SFLASH_PROTO_1_1_4,
    265          	},
    266          
    267          	/* Fast Read 1-4-4 */
    268          	{
    269          		SFLASH_HWCAPS_READ_1_4_4,
    270          		BFPT_DWORD1, (0x1UL << 21),
    271          		BFPT_DWORD3, 0,
    272          		SFLASH_PROTO_1_4_4,
    273          	},
    274          
    275          	/* Fast Read 4-4-4 */
    276          	{
    277          		SFLASH_HWCAPS_READ_4_4_4,
    278          		BFPT_DWORD5, (0x1UL << 4),
    279          		BFPT_DWORD7, 16,
    280          		SFLASH_PROTO_4_4_4,
    281          	},
    282          };
    283          
    284          
    285          /* Sector Erase settings. */
    286          

   \                                 In section SOFTPACK, align 4, keep-with-next
    287          static inline void spi_flash_set_erase_command_from_bfpt(struct spi_flash_erase_command *cmd, uint16_t half)
    288          {
   \                     spi_flash_set_erase_command_from_bfpt:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    289          	uint32_t size = (half >> 0) & 0xff;
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0xE6FF'0070        UXTH     R0,R0
   \       0x14   0xE210'60FF        ANDS     R6,R0,#0xFF
    290          	uint8_t inst = (half >> 8) & 0xff;
   \       0x18   0xE1B0'0005        MOVS     R0,R5
   \       0x1C   0xE6FF'0070        UXTH     R0,R0
   \       0x20   0xE1B0'7420        LSRS     R7,R0,#+8
    291          
    292          	/* size == 0 means this Erase Type is not supported. */
    293          	if (size)
   \       0x24   0xE356'0000        CMP      R6,#+0
   \       0x28   0x0A00'0001        BEQ      ??spi_flash_set_erase_command_from_bfpt_0
    294          		size = (0x1UL << size);
   \       0x2C   0xE3A0'0001        MOV      R0,#+1
   \       0x30   0xE1B0'6610        LSLS     R6,R0,R6
    295          	spi_flash_set_erase_command(cmd, size, inst);
   \                     ??spi_flash_set_erase_command_from_bfpt_0:
   \       0x34   0xE1B0'2007        MOVS     R2,R7
   \       0x38   0xE6EF'2072        UXTB     R2,R2
   \       0x3C   0xE1B0'1006        MOVS     R1,R6
   \       0x40   0xE1B0'0004        MOVS     R0,R4
   \       0x44   0x....'....        BL       spi_flash_set_erase_command
    296          }
   \       0x48   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    297          
    298          struct sfdp_bfpt_erase {
    299          	/*
    300          	 * The half-word at offset <shift> in DWORD <dword> encodes the
    301          	 * op code and erase sector size to be used by Sector Erase commands.
    302          	 */
    303          	enum sfdp_bfpt_dword	dword;
    304          	int			shift;
    305          };
    306          

   \                                 In section .rodata, align 4
    307          static const struct sfdp_bfpt_erase sfdp_bfpt_erases[SFLASH_CMD_ERASE_MAX] = {
   \                     sfdp_bfpt_erases:
   \        0x0   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'0000        DC32 0
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16
   \       0x10   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0000'0000        DC32 0
   \       0x18   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0010        DC32 16
    308          	/* Erase Type 1 in DWORD8 bits[15:0] */
    309          	{BFPT_DWORD8, 0},
    310          
    311          	/* Erase Type 2 in DWORD8 bits[31:16] */
    312          	{BFPT_DWORD8, 16},
    313          
    314          	/* Erase Type 3 in DWORD9 bits[15:0] */
    315          	{BFPT_DWORD9, 0},
    316          
    317          	/* Erase Type 4: in DWORD9 bits[31:16] */
    318          	{BFPT_DWORD9, 16},
    319          };
    320          

   \                                 In section SOFTPACK, align 4, keep-with-next
    321          static int spi_flash_parse_bfpt(struct spi_flash *flash,
    322          				const struct sfdp_parameter_header *bfpt_header,
    323          				struct spi_flash_parameters *params)
    324          {
   \                     spi_flash_parse_bfpt:
   \        0x0   0xE92D'4FF3        PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xE24D'D054        SUB      SP,SP,#+84
   \        0x8   0xE1B0'5000        MOVS     R5,R0
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    325          	struct spi_flash_erase_map *map = &flash->erase_map;
   \       0x10   0xE295'A048        ADDS     R10,R5,#+72
    326          	struct sfdp_bfpt bfpt;
    327          	size_t len;
    328          	int i, cmd, rc;
    329          	uint32_t addr, erase_mask;
    330          	uint16_t half;
    331          
    332          	/* JESD216 Basic Flash Parameter Table length is at least 9 DWORDs. */
    333          	if (bfpt_header->length < BFPT_DWORD_MAX_JESD216)
   \       0x14   0xE59D'0058        LDR      R0,[SP, #+88]
   \       0x18   0xE5D0'0003        LDRB     R0,[R0, #+3]
   \       0x1C   0xE350'0009        CMP      R0,#+9
   \       0x20   0xAA00'0001        BGE      ??spi_flash_parse_bfpt_0
    334          		return -EINVAL;
   \       0x24   0xE3E0'001B        MVN      R0,#+27
   \       0x28   0xEA00'00BC        B        ??spi_flash_parse_bfpt_1
    335          
    336          	/* Read the Basic Flash Parameter Table. */
    337          	len = min_u32(sizeof(bfpt), sizeof(uint32_t) * bfpt_header->length);
   \                     ??spi_flash_parse_bfpt_0:
   \       0x2C   0xE59D'0058        LDR      R0,[SP, #+88]
   \       0x30   0xE5D0'0003        LDRB     R0,[R0, #+3]
   \       0x34   0xE1B0'1100        LSLS     R1,R0,#+2
   \       0x38   0xE3A0'0040        MOV      R0,#+64
   \       0x3C   0x....'....        BL       min_u32
   \       0x40   0xE58D'0010        STR      R0,[SP, #+16]
    338          	addr = SFDP_PARAM_HEADER_PTP(bfpt_header);
   \       0x44   0xE59D'0058        LDR      R0,[SP, #+88]
   \       0x48   0xE5D0'0006        LDRB     R0,[R0, #+6]
   \       0x4C   0xE59D'1058        LDR      R1,[SP, #+88]
   \       0x50   0xE5D1'1005        LDRB     R1,[R1, #+5]
   \       0x54   0xE1B0'1401        LSLS     R1,R1,#+8
   \       0x58   0xE191'0800        ORRS     R0,R1,R0, LSL #+16
   \       0x5C   0xE59D'1058        LDR      R1,[SP, #+88]
   \       0x60   0xE5D1'1004        LDRB     R1,[R1, #+4]
   \       0x64   0xE191'0000        ORRS     R0,R1,R0
   \       0x68   0xE58D'000C        STR      R0,[SP, #+12]
    339          	memset(&bfpt, 0, sizeof(bfpt));
   \       0x6C   0xE3A0'7040        MOV      R7,#+64
   \       0x70   0xE3A0'8000        MOV      R8,#+0
   \       0x74   0xE28D'9014        ADD      R9,SP,#+20
   \       0x78   0xE1B0'2008        MOVS     R2,R8
   \       0x7C   0xE1B0'1007        MOVS     R1,R7
   \       0x80   0xE1B0'0009        MOVS     R0,R9
   \       0x84   0x....'....        BL       __aeabi_memset
   \       0x88   0xE1B0'0009        MOVS     R0,R9
    340          	rc = spi_flash_read_sfdp(flash,  addr, len, &bfpt);
   \       0x8C   0xE28D'3014        ADD      R3,SP,#+20
   \       0x90   0xE59D'2010        LDR      R2,[SP, #+16]
   \       0x94   0xE59D'100C        LDR      R1,[SP, #+12]
   \       0x98   0xE1B0'0005        MOVS     R0,R5
   \       0x9C   0x....'....        BL       spi_flash_read_sfdp
   \       0xA0   0xE58D'0004        STR      R0,[SP, #+4]
    341          	if (rc < 0)
   \       0xA4   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0xA8   0xE350'0000        CMP      R0,#+0
   \       0xAC   0x5A00'0001        BPL      ??spi_flash_parse_bfpt_2
    342          		return rc;
   \       0xB0   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0xB4   0xEA00'0099        B        ??spi_flash_parse_bfpt_1
    343          
    344          	/* Flash Memory Density (in bits). */
    345          	params->size = bfpt.dwords[BFPT_DWORD2];
   \                     ??spi_flash_parse_bfpt_2:
   \       0xB8   0xE59D'0018        LDR      R0,[SP, #+24]
   \       0xBC   0xE586'0000        STR      R0,[R6, #+0]
    346          	if (params->size & (0x1UL << 31)) {
   \       0xC0   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xC4   0xE310'0480        TST      R0,#0x80000000
   \       0xC8   0x0A00'0007        BEQ      ??spi_flash_parse_bfpt_3
    347          		params->size &= ~(0x1UL << 31);
   \       0xCC   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xD0   0xE3D0'0480        BICS     R0,R0,#0x80000000
   \       0xD4   0xE586'0000        STR      R0,[R6, #+0]
    348          		params->size = 1UL << params->size;
   \       0xD8   0xE3A0'0001        MOV      R0,#+1
   \       0xDC   0xE596'1000        LDR      R1,[R6, #+0]
   \       0xE0   0xE1B0'0110        LSLS     R0,R0,R1
   \       0xE4   0xE586'0000        STR      R0,[R6, #+0]
   \       0xE8   0xEA00'0002        B        ??spi_flash_parse_bfpt_4
    349          	} else {
    350          		params->size++;
   \                     ??spi_flash_parse_bfpt_3:
   \       0xEC   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xF0   0xE290'0001        ADDS     R0,R0,#+1
   \       0xF4   0xE586'0000        STR      R0,[R6, #+0]
    351          	}
    352          	params->size >>= 3; /* Convert to bytes. */
   \                     ??spi_flash_parse_bfpt_4:
   \       0xF8   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xFC   0xE1B0'01A0        LSRS     R0,R0,#+3
   \      0x100   0xE586'0000        STR      R0,[R6, #+0]
    353          
    354          	/* Fast Read settings. */
    355          	for (i = 0; i < ARRAY_SIZE(sfdp_bfpt_reads); i++) {
   \      0x104   0xE3A0'B000        MOV      R11,#+0
   \                     ??spi_flash_parse_bfpt_5:
   \      0x108   0xE35B'0006        CMP      R11,#+6
   \      0x10C   0x2A00'0023        BCS      ??spi_flash_parse_bfpt_6
    356          		const struct sfdp_bfpt_read *rd = &sfdp_bfpt_reads[i];
   \      0x110   0x....'....        LDR      R0,??DataTable2
   \      0x114   0xE08B'108B        ADD      R1,R11,R11, LSL #+1
   \      0x118   0xE090'7181        ADDS     R7,R0,R1, LSL #+3
    357          		struct spi_flash_read_command *read;
    358          
    359          		if (!(bfpt.dwords[rd->supported_dword] & rd->supported_bit))
   \      0x11C   0xE28D'0014        ADD      R0,SP,#+20
   \      0x120   0xE5D7'1004        LDRB     R1,[R7, #+4]
   \      0x124   0xE1B0'1101        LSLS     R1,R1,#+2
   \      0x128   0xE790'0001        LDR      R0,[R0, +R1]
   \      0x12C   0xE597'1008        LDR      R1,[R7, #+8]
   \      0x130   0xE111'0000        TST      R1,R0
   \      0x134   0x0A00'0017        BEQ      ??spi_flash_parse_bfpt_7
    360          			continue;
    361          
    362          		params->hwcaps.mask |= rd->hwcaps;
   \                     ??spi_flash_parse_bfpt_8:
   \      0x138   0xE596'0008        LDR      R0,[R6, #+8]
   \      0x13C   0xE597'1000        LDR      R1,[R7, #+0]
   \      0x140   0xE191'0000        ORRS     R0,R1,R0
   \      0x144   0xE586'0008        STR      R0,[R6, #+8]
    363          		cmd = spi_flash_hwcaps2cmd(rd->hwcaps);
   \      0x148   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x14C   0x....'....        BL       spi_flash_hwcaps2cmd
   \      0x150   0xE58D'0008        STR      R0,[SP, #+8]
    364          		read = &params->reads[cmd];
   \      0x154   0xE59D'0008        LDR      R0,[SP, #+8]
   \      0x158   0xE1B0'0180        LSLS     R0,R0,#+3
   \      0x15C   0xE096'0000        ADDS     R0,R6,R0
   \      0x160   0xE290'000C        ADDS     R0,R0,#+12
   \      0x164   0xE58D'0000        STR      R0,[SP, #+0]
    365          		half = bfpt.dwords[rd->settings_dword] >> rd->settings_shift;
   \      0x168   0xE28D'0014        ADD      R0,SP,#+20
   \      0x16C   0xE5D7'100C        LDRB     R1,[R7, #+12]
   \      0x170   0xE1B0'1101        LSLS     R1,R1,#+2
   \      0x174   0xE790'0001        LDR      R0,[R0, +R1]
   \      0x178   0xE597'1010        LDR      R1,[R7, #+16]
   \      0x17C   0xE1B0'0130        LSRS     R0,R0,R1
   \      0x180   0xE1B0'4000        MOVS     R4,R0
    366          		spi_flash_set_read_settings_from_bfpt(read, half, rd->proto);
   \      0x184   0xE597'2014        LDR      R2,[R7, #+20]
   \      0x188   0xE1B0'1004        MOVS     R1,R4
   \      0x18C   0xE6FF'1071        UXTH     R1,R1
   \      0x190   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x194   0x....'....        BL       spi_flash_set_read_settings_from_bfpt
    367          	}
   \                     ??spi_flash_parse_bfpt_7:
   \      0x198   0xE29B'B001        ADDS     R11,R11,#+1
   \      0x19C   0xEAFF'FFD9        B        ??spi_flash_parse_bfpt_5
    368          
    369          	/* Sector Erase settings. */
    370          	erase_mask = 0;
   \                     ??spi_flash_parse_bfpt_6:
   \      0x1A0   0xE3A0'7000        MOV      R7,#+0
   \      0x1A4   0xE1B0'8007        MOVS     R8,R7
    371          	for (i = 0; i < SFLASH_CMD_ERASE_MAX; i++) {
   \      0x1A8   0xE3A0'9000        MOV      R9,#+0
   \                     ??spi_flash_parse_bfpt_9:
   \      0x1AC   0xE359'0004        CMP      R9,#+4
   \      0x1B0   0xAA00'0016        BGE      ??spi_flash_parse_bfpt_10
    372          		const struct sfdp_bfpt_erase *er = &sfdp_bfpt_erases[i];
   \      0x1B4   0x....'....        LDR      R0,??DataTable2_1
   \      0x1B8   0xE1B0'1189        LSLS     R1,R9,#+3
   \      0x1BC   0xE090'B001        ADDS     R11,R0,R1
    373          
    374          		half = bfpt.dwords[er->dword] >> er->shift;
   \      0x1C0   0xE28D'0014        ADD      R0,SP,#+20
   \      0x1C4   0xE5DB'1000        LDRB     R1,[R11, #+0]
   \      0x1C8   0xE1B0'1101        LSLS     R1,R1,#+2
   \      0x1CC   0xE790'0001        LDR      R0,[R0, +R1]
   \      0x1D0   0xE59B'1004        LDR      R1,[R11, #+4]
   \      0x1D4   0xE1B0'0130        LSRS     R0,R0,R1
   \      0x1D8   0xE1B0'4000        MOVS     R4,R0
    375          		spi_flash_set_erase_command_from_bfpt(&map->commands[i], half);
   \      0x1DC   0xE1B0'1004        MOVS     R1,R4
   \      0x1E0   0xE6FF'1071        UXTH     R1,R1
   \      0x1E4   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x1E8   0xE09A'0000        ADDS     R0,R10,R0
   \      0x1EC   0x....'....        BL       spi_flash_set_erase_command_from_bfpt
    376          
    377          		if (map->commands[i].size)
   \      0x1F0   0xE1B0'0209        LSLS     R0,R9,#+4
   \      0x1F4   0xE79A'0000        LDR      R0,[R10, +R0]
   \      0x1F8   0xE350'0000        CMP      R0,#+0
   \      0x1FC   0x0A00'0001        BEQ      ??spi_flash_parse_bfpt_11
    378          			erase_mask |= (0x1UL << i);
   \      0x200   0xE3A0'0001        MOV      R0,#+1
   \      0x204   0xE198'8910        ORRS     R8,R8,R0, LSL R9
    379          	}
   \                     ??spi_flash_parse_bfpt_11:
   \      0x208   0xE299'9001        ADDS     R9,R9,#+1
   \      0x20C   0xEAFF'FFE6        B        ??spi_flash_parse_bfpt_9
    380          	spi_flash_init_uniform_erase_map(map, erase_mask, params->size);
   \                     ??spi_flash_parse_bfpt_10:
   \      0x210   0xE596'2000        LDR      R2,[R6, #+0]
   \      0x214   0xE3B0'3000        MOVS     R3,#+0
   \      0x218   0xE1B0'1008        MOVS     R1,R8
   \      0x21C   0xE1B0'000A        MOVS     R0,R10
   \      0x220   0x....'....        BL       spi_flash_init_uniform_erase_map
    381          
    382          	/* Stop here if not JESD216 rev A or later. */
    383          	if (bfpt_header->length < BFPT_DWORD_MAX)
   \      0x224   0xE59D'0058        LDR      R0,[SP, #+88]
   \      0x228   0xE5D0'0003        LDRB     R0,[R0, #+3]
   \      0x22C   0xE350'0010        CMP      R0,#+16
   \      0x230   0xAA00'0001        BGE      ??spi_flash_parse_bfpt_12
    384          		return 0;
   \      0x234   0xE3A0'0000        MOV      R0,#+0
   \      0x238   0xEA00'0038        B        ??spi_flash_parse_bfpt_1
    385          
    386          	/* Page size: this field specifies 'N' so the page size = 2^N bytes. */
    387          	params->page_size = bfpt.dwords[BFPT_DWORD11];
   \                     ??spi_flash_parse_bfpt_12:
   \      0x23C   0xE59D'003C        LDR      R0,[SP, #+60]
   \      0x240   0xE586'0004        STR      R0,[R6, #+4]
    388          	params->page_size &= BFPT_DWORD11_PAGE_SIZE_MASK;
   \      0x244   0xE5D6'0004        LDRB     R0,[R6, #+4]
   \      0x248   0xE210'00F0        ANDS     R0,R0,#0xF0
   \      0x24C   0xE586'0004        STR      R0,[R6, #+4]
    389          	params->page_size >>= BFPT_DWORD11_PAGE_SIZE_SHIFT;
   \      0x250   0xE596'0004        LDR      R0,[R6, #+4]
   \      0x254   0xE1B0'0220        LSRS     R0,R0,#+4
   \      0x258   0xE586'0004        STR      R0,[R6, #+4]
    390          	params->page_size = (0x1UL << params->page_size);
   \      0x25C   0xE3A0'0001        MOV      R0,#+1
   \      0x260   0xE596'1004        LDR      R1,[R6, #+4]
   \      0x264   0xE1B0'0110        LSLS     R0,R0,R1
   \      0x268   0xE586'0004        STR      R0,[R6, #+4]
    391          
    392          	/* Enable Quad I/O. */
    393          	switch (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_QER_MASK) {
   \      0x26C   0xE59D'004C        LDR      R0,[SP, #+76]
   \      0x270   0xE210'0870        ANDS     R0,R0,#0x700000
   \      0x274   0xE350'0940        CMP      R0,#+1048576
   \      0x278   0x0A00'0009        BEQ      ??spi_flash_parse_bfpt_13
   \      0x27C   0xE350'0980        CMP      R0,#+2097152
   \      0x280   0x0A00'000A        BEQ      ??spi_flash_parse_bfpt_14
   \      0x284   0xE350'09C0        CMP      R0,#+3145728
   \      0x288   0x0A00'000B        BEQ      ??spi_flash_parse_bfpt_15
   \      0x28C   0xE350'0840        CMP      R0,#+4194304
   \      0x290   0x0A00'0003        BEQ      ??spi_flash_parse_bfpt_13
   \      0x294   0xE350'0850        CMP      R0,#+5242880
   \      0x298   0x0A00'000A        BEQ      ??spi_flash_parse_bfpt_16
    394          	default:
    395          	case BFPT_DWORD15_QER_NONE:
    396          		params->quad_enable = NULL;
   \                     ??spi_flash_parse_bfpt_17:
   \      0x29C   0xE586'706C        STR      R7,[R6, #+108]
    397          		break;
   \      0x2A0   0xEA00'000A        B        ??spi_flash_parse_bfpt_18
    398          
    399          	case BFPT_DWORD15_QER_SR2_BIT1_BUGGY:
    400          	case BFPT_DWORD15_QER_SR2_BIT1_NO_RD:
    401          		params->quad_enable = spansion_quad_enable;
   \                     ??spi_flash_parse_bfpt_13:
   \      0x2A4   0x....'....        LDR      R0,??DataTable2_2
   \      0x2A8   0xE586'006C        STR      R0,[R6, #+108]
    402          		break;
   \      0x2AC   0xEA00'0007        B        ??spi_flash_parse_bfpt_18
    403          
    404          	case BFPT_DWORD15_QER_SR1_BIT6:
    405          		params->quad_enable = macronix_quad_enable;
   \                     ??spi_flash_parse_bfpt_14:
   \      0x2B0   0x....'....        LDR      R0,??DataTable2_3
   \      0x2B4   0xE586'006C        STR      R0,[R6, #+108]
    406          		break;
   \      0x2B8   0xEA00'0004        B        ??spi_flash_parse_bfpt_18
    407          
    408          	case BFPT_DWORD15_QER_SR2_BIT7:
    409          		params->quad_enable = sr2_bit7_quad_enable;
   \                     ??spi_flash_parse_bfpt_15:
   \      0x2BC   0x....'....        LDR      R0,??DataTable2_4
   \      0x2C0   0xE586'006C        STR      R0,[R6, #+108]
    410          		break;
   \      0x2C4   0xEA00'0001        B        ??spi_flash_parse_bfpt_18
    411          
    412          	case BFPT_DWORD15_QER_SR2_BIT1:
    413          		params->quad_enable = spansion_new_quad_enable;
   \                     ??spi_flash_parse_bfpt_16:
   \      0x2C8   0x....'....        LDR      R0,??DataTable2_5
   \      0x2CC   0xE586'006C        STR      R0,[R6, #+108]
    414          		break;
    415          	}
    416          
    417          	/* 0-4-4 Mode Entry Method. */
    418          	flash->enable_0_4_4 = NULL;
   \                     ??spi_flash_parse_bfpt_18:
   \      0x2D0   0xE585'70B0        STR      R7,[R5, #+176]
    419          	if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_MICRON) {
   \      0x2D4   0xE59D'004C        LDR      R0,[SP, #+76]
   \      0x2D8   0xE310'0B80        TST      R0,#0x20000
   \      0x2DC   0x0A00'0003        BEQ      ??spi_flash_parse_bfpt_19
    420          		flash->enable_0_4_4 = micron_enable_0_4_4;
   \      0x2E0   0x....'....        LDR      R0,??DataTable2_6
   \      0x2E4   0xE585'00B0        STR      R0,[R5, #+176]
    421          		flash->xip_mode = 0x00u;
   \      0x2E8   0xE5C5'7030        STRB     R7,[R5, #+48]
   \      0x2EC   0xEA00'000A        B        ??spi_flash_parse_bfpt_20
    422          	} else if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_A5) {
   \                     ??spi_flash_parse_bfpt_19:
   \      0x2F0   0xE59D'004C        LDR      R0,[SP, #+76]
   \      0x2F4   0xE310'0B40        TST      R0,#0x10000
   \      0x2F8   0x0A00'0002        BEQ      ??spi_flash_parse_bfpt_21
    423          		flash->xip_mode = 0xA5u;
   \      0x2FC   0xE3A0'00A5        MOV      R0,#+165
   \      0x300   0xE5C5'0030        STRB     R0,[R5, #+48]
   \      0x304   0xEA00'0004        B        ??spi_flash_parse_bfpt_20
    424          	} else if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_AX) {
   \                     ??spi_flash_parse_bfpt_21:
   \      0x308   0xE59D'004C        LDR      R0,[SP, #+76]
   \      0x30C   0xE310'0A40        TST      R0,#0x40000
   \      0x310   0x0A00'0001        BEQ      ??spi_flash_parse_bfpt_20
    425          		flash->xip_mode = 0xA0u;
   \      0x314   0xE3A0'00A0        MOV      R0,#+160
   \      0x318   0xE5C5'0030        STRB     R0,[R5, #+48]
    426          	}
    427          
    428          	return 0;
   \                     ??spi_flash_parse_bfpt_20:
   \      0x31C   0xE3A0'0000        MOV      R0,#+0
   \                     ??spi_flash_parse_bfpt_1:
   \      0x320   0xE28D'D05C        ADD      SP,SP,#+92
   \      0x324   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    429          }
    430          

   \                                 In section .bss, align 4
    431          static struct sfdp_header header;
   \                     header:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
    432          static struct sfdp_parameter_header param_header;
   \                     param_header:
   \        0x0                      DS8 8
    433          
    434          /*----------------------------------------------------------------------------
    435           *        Exported Functions
    436           *----------------------------------------------------------------------------*/
    437          

   \                                 In section SOFTPACK, align 4, keep-with-next
    438          int spi_flash_parse_sfdp(struct spi_flash *flash, struct spi_flash_parameters *params)
    439          {
   \                     spi_flash_parse_sfdp:
   \        0x0   0xE92D'4FF2        PUSH     {R1,R4-R11,LR}
   \        0x4   0xE24D'D008        SUB      SP,SP,#+8
   \        0x8   0xE1B0'4000        MOVS     R4,R0
    440          	struct sfdp_parameter_header bfpt_header;
    441          	int i, rc;
    442          
    443          	/* Get the SFDP header. */
    444          	rc = spi_flash_read_sfdp(flash, 0, sizeof(header), &header);
   \        0xC   0x....'....        LDR      R6,??DataTable2_7
   \       0x10   0xE1B0'3006        MOVS     R3,R6
   \       0x14   0xE3A0'2010        MOV      R2,#+16
   \       0x18   0xE3A0'1000        MOV      R1,#+0
   \       0x1C   0xE1B0'0004        MOVS     R0,R4
   \       0x20   0x....'....        BL       spi_flash_read_sfdp
   \       0x24   0xE1B0'5000        MOVS     R5,R0
    445          	if (rc < 0)
   \       0x28   0xE355'0000        CMP      R5,#+0
   \       0x2C   0x5A00'0001        BPL      ??spi_flash_parse_sfdp_0
    446          		return rc;
   \       0x30   0xE1B0'0005        MOVS     R0,R5
   \       0x34   0xEA00'0065        B        ??spi_flash_parse_sfdp_1
    447          
    448          	/* Check the SFDP header version. */
    449          	if (header.signature != SFDP_SIGNATURE ||
    450          	    header.major != SFDP_JESD216_MAJOR ||
    451          	    header.minor < SFDP_JESD216_MINOR)
                 	                 ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \                     ??spi_flash_parse_sfdp_0:
   \       0x38   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x3C   0x....'....        LDR      R1,??DataTable2_8  ;; 0x50444653
   \       0x40   0xE150'0001        CMP      R0,R1
   \       0x44   0x1A00'0002        BNE      ??spi_flash_parse_sfdp_2
   \       0x48   0xE5D6'0005        LDRB     R0,[R6, #+5]
   \       0x4C   0xE350'0001        CMP      R0,#+1
   \       0x50   0x0A00'0001        BEQ      ??spi_flash_parse_sfdp_3
    452          		return -EINVAL;
   \                     ??spi_flash_parse_sfdp_2:
   \       0x54   0xE3E0'001B        MVN      R0,#+27
   \       0x58   0xEA00'005C        B        ??spi_flash_parse_sfdp_1
    453          
    454          	/*
    455          	 * Verify that the first and only mandatory parameter header is a
    456          	 * Basic Flash Parameter Table header as specified in JESD216.
    457          	 */
    458          	memcpy(&bfpt_header, &header.bfpt_header, sizeof(bfpt_header));
   \                     ??spi_flash_parse_sfdp_3:
   \       0x5C   0xE3A0'7008        MOV      R7,#+8
   \       0x60   0xE1B0'8007        MOVS     R8,R7
   \       0x64   0xE296'9008        ADDS     R9,R6,#+8
   \       0x68   0xE1B0'A00D        MOVS     R10,SP
   \       0x6C   0xE1B0'2008        MOVS     R2,R8
   \       0x70   0xE1B0'1009        MOVS     R1,R9
   \       0x74   0xE1B0'000A        MOVS     R0,R10
   \       0x78   0x....'....        BL       __aeabi_memcpy
   \       0x7C   0xE1B0'000A        MOVS     R0,R10
    459          	if (SFDP_PARAM_HEADER_ID(&bfpt_header) != SFDP_BFPT_ID ||
    460          	    bfpt_header.major != SFDP_JESD216_MAJOR)
   \       0x80   0xE5DD'0007        LDRB     R0,[SP, #+7]
   \       0x84   0xE5DD'1000        LDRB     R1,[SP, #+0]
   \       0x88   0xE191'0400        ORRS     R0,R1,R0, LSL #+8
   \       0x8C   0xE6FF'0070        UXTH     R0,R0
   \       0x90   0xE350'0CFF        CMP      R0,#+65280
   \       0x94   0x1A00'0002        BNE      ??spi_flash_parse_sfdp_4
   \       0x98   0xE5DD'0002        LDRB     R0,[SP, #+2]
   \       0x9C   0xE350'0001        CMP      R0,#+1
   \       0xA0   0x0A00'0001        BEQ      ??spi_flash_parse_sfdp_5
    461          		return -EINVAL;
   \                     ??spi_flash_parse_sfdp_4:
   \       0xA4   0xE3E0'001B        MVN      R0,#+27
   \       0xA8   0xEA00'0048        B        ??spi_flash_parse_sfdp_1
    462          
    463          	/*
    464          	 * Check other parameter headers to get the latest revision of
    465          	 * the basic flash parameter table.
    466          	 */
    467          	for (i = 0; i < header.nph; i++) {
   \                     ??spi_flash_parse_sfdp_5:
   \       0xAC   0xE3A0'8000        MOV      R8,#+0
   \                     ??spi_flash_parse_sfdp_6:
   \       0xB0   0xE5D6'0006        LDRB     R0,[R6, #+6]
   \       0xB4   0xE158'0000        CMP      R8,R0
   \       0xB8   0xAA00'0029        BGE      ??spi_flash_parse_sfdp_7
    468          		rc = spi_flash_read_sfdp(flash, sizeof(header) +
    469          					 i * sizeof(param_header),
    470          					 sizeof(param_header),
    471          					 &param_header);
   \       0xBC   0x....'....        LDR      R11,??DataTable2_9
   \       0xC0   0xE1B0'300B        MOVS     R3,R11
   \       0xC4   0xE3A0'2008        MOV      R2,#+8
   \       0xC8   0xE3A0'0008        MOV      R0,#+8
   \       0xCC   0xE011'0890        MULS     R1,R0,R8
   \       0xD0   0xE291'1010        ADDS     R1,R1,#+16
   \       0xD4   0xE1B0'0004        MOVS     R0,R4
   \       0xD8   0x....'....        BL       spi_flash_read_sfdp
   \       0xDC   0xE1B0'5000        MOVS     R5,R0
    472          		if (rc < 0)
   \       0xE0   0xE355'0000        CMP      R5,#+0
   \       0xE4   0x4A00'0038        BMI      ??spi_flash_parse_sfdp_8
    473          			goto exit;
    474          
    475          		if (SFDP_PARAM_HEADER_ID(&param_header) == SFDP_BFPT_ID &&
    476          		    param_header.major == SFDP_JESD216_MAJOR &&
    477          		    (param_header.minor > bfpt_header.minor ||
    478          		     (param_header.minor == bfpt_header.minor &&
    479          		      param_header.length > bfpt_header.length)))
   \                     ??spi_flash_parse_sfdp_9:
   \       0xE8   0xE5DB'0007        LDRB     R0,[R11, #+7]
   \       0xEC   0xE5DB'1000        LDRB     R1,[R11, #+0]
   \       0xF0   0xE191'0400        ORRS     R0,R1,R0, LSL #+8
   \       0xF4   0xE6FF'0070        UXTH     R0,R0
   \       0xF8   0xE350'0CFF        CMP      R0,#+65280
   \       0xFC   0x1A00'0016        BNE      ??spi_flash_parse_sfdp_10
   \      0x100   0xE5DB'0002        LDRB     R0,[R11, #+2]
   \      0x104   0xE350'0001        CMP      R0,#+1
   \      0x108   0x1A00'0013        BNE      ??spi_flash_parse_sfdp_10
   \      0x10C   0xE5DD'0001        LDRB     R0,[SP, #+1]
   \      0x110   0xE5DB'1001        LDRB     R1,[R11, #+1]
   \      0x114   0xE150'0001        CMP      R0,R1
   \      0x118   0x3A00'0007        BCC      ??spi_flash_parse_sfdp_11
   \      0x11C   0xE5DB'0001        LDRB     R0,[R11, #+1]
   \      0x120   0xE5DD'1001        LDRB     R1,[SP, #+1]
   \      0x124   0xE150'0001        CMP      R0,R1
   \      0x128   0x1A00'000B        BNE      ??spi_flash_parse_sfdp_10
   \      0x12C   0xE5DD'0003        LDRB     R0,[SP, #+3]
   \      0x130   0xE5DB'1003        LDRB     R1,[R11, #+3]
   \      0x134   0xE150'0001        CMP      R0,R1
   \      0x138   0x2A00'0007        BCS      ??spi_flash_parse_sfdp_10
    480          			memcpy(&bfpt_header, &param_header, sizeof(bfpt_header));
   \                     ??spi_flash_parse_sfdp_11:
   \      0x13C   0xE1B0'9007        MOVS     R9,R7
   \      0x140   0xE1B0'A00B        MOVS     R10,R11
   \      0x144   0xE1B0'B00D        MOVS     R11,SP
   \      0x148   0xE1B0'2009        MOVS     R2,R9
   \      0x14C   0xE1B0'100A        MOVS     R1,R10
   \      0x150   0xE1B0'000B        MOVS     R0,R11
   \      0x154   0x....'....        BL       __aeabi_memcpy
   \      0x158   0xE1B0'000B        MOVS     R0,R11
    481          	}
   \                     ??spi_flash_parse_sfdp_10:
   \      0x15C   0xE298'8001        ADDS     R8,R8,#+1
   \      0x160   0xEAFF'FFD2        B        ??spi_flash_parse_sfdp_6
    482          	rc = spi_flash_parse_bfpt(flash, &bfpt_header, params);
   \                     ??spi_flash_parse_sfdp_7:
   \      0x164   0xE59D'2008        LDR      R2,[SP, #+8]
   \      0x168   0xE1B0'100D        MOVS     R1,SP
   \      0x16C   0xE1B0'0004        MOVS     R0,R4
   \      0x170   0x....'....        BL       spi_flash_parse_bfpt
   \      0x174   0xE1B0'5000        MOVS     R5,R0
    483          	if (rc < 0)
   \      0x178   0xE355'0000        CMP      R5,#+0
   \      0x17C   0x4A00'0012        BMI      ??spi_flash_parse_sfdp_8
    484          		goto exit;
    485          
    486          	/* Parse other parameter headers. */
    487          	for (i = 0; i < header.nph; i++) {
   \                     ??spi_flash_parse_sfdp_12:
   \      0x180   0xE3A0'0000        MOV      R0,#+0
   \      0x184   0xE1B0'8000        MOVS     R8,R0
   \                     ??spi_flash_parse_sfdp_13:
   \      0x188   0xE5D6'0006        LDRB     R0,[R6, #+6]
   \      0x18C   0xE158'0000        CMP      R8,R0
   \      0x190   0xAA00'000D        BGE      ??spi_flash_parse_sfdp_8
    488          		rc = spi_flash_read_sfdp(flash,
    489          					 sizeof(header) +
    490          					 i * sizeof(param_header),
    491          					 sizeof(param_header),
    492          					 &param_header);
   \      0x194   0x....'....        LDR      R3,??DataTable2_9
   \      0x198   0xE3A0'2008        MOV      R2,#+8
   \      0x19C   0xE3A0'0008        MOV      R0,#+8
   \      0x1A0   0xE011'0890        MULS     R1,R0,R8
   \      0x1A4   0xE291'1010        ADDS     R1,R1,#+16
   \      0x1A8   0xE1B0'0004        MOVS     R0,R4
   \      0x1AC   0x....'....        BL       spi_flash_read_sfdp
   \      0x1B0   0xE1B0'5000        MOVS     R5,R0
    493          		if (rc < 0)
   \      0x1B4   0xE355'0000        CMP      R5,#+0
   \      0x1B8   0x4A00'0003        BMI      ??spi_flash_parse_sfdp_8
    494          			goto exit;
    495          
    496          		switch (SFDP_PARAM_HEADER_ID(&param_header)) {
    497          		default:
    498          			break;
    499          		}
    500          
    501          		if (rc < 0)
   \                     ??spi_flash_parse_sfdp_14:
   \      0x1BC   0xE355'0000        CMP      R5,#+0
   \      0x1C0   0x4A00'0001        BMI      ??spi_flash_parse_sfdp_8
    502          			goto exit;
    503          	}
   \                     ??spi_flash_parse_sfdp_15:
   \      0x1C4   0xE298'8001        ADDS     R8,R8,#+1
   \      0x1C8   0xEAFF'FFEE        B        ??spi_flash_parse_sfdp_13
    504          
    505          exit:
    506          	return rc;
   \                     ??spi_flash_parse_sfdp_8:
   \      0x1CC   0xE1B0'0005        MOVS     R0,R5
   \                     ??spi_flash_parse_sfdp_1:
   \      0x1D0   0xE8BD'8FFE        POP      {R1-R11,PC}      ;; return
    507          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     sfdp_bfpt_reads

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     sfdp_bfpt_erases

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     spansion_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     macronix_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x....'....        DC32     sr2_bit7_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     spansion_new_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x....'....        DC32     micron_enable_0_4_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x....'....        DC32     header

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x5044'4653        DC32     0x50444653

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x....'....        DC32     param_header

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   min_u32
     128   spi_flash_parse_bfpt
       128   -> __aeabi_memset
       128   -> min_u32
       128   -> spi_flash_hwcaps2cmd
       128   -> spi_flash_init_uniform_erase_map
       128   -> spi_flash_read_sfdp
       128   -> spi_flash_set_erase_command_from_bfpt
       128   -> spi_flash_set_read_settings_from_bfpt
      48   spi_flash_parse_sfdp
        48   -> __aeabi_memcpy
        48   -> spi_flash_parse_bfpt
        48   -> spi_flash_read_sfdp
      56   spi_flash_read_sfdp
        56   -> spi_flash_command_init
        56   -> spi_flash_exec
      24   spi_flash_set_erase_command_from_bfpt
        24   -> spi_flash_set_erase_command
       0   spi_flash_set_read_settings_from_bfpt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      16  header
      28  min_u32
       8  param_header
      32  sfdp_bfpt_erases
     144  sfdp_bfpt_reads
     808  spi_flash_parse_bfpt
     468  spi_flash_parse_sfdp
      92  spi_flash_read_sfdp
      76  spi_flash_set_erase_command_from_bfpt
      52  spi_flash_set_read_settings_from_bfpt

 
    24 bytes in section .bss
   176 bytes in section .rodata
 1'564 bytes in section SOFTPACK
 
 1'564 bytes of CODE  memory
   176 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: 1
