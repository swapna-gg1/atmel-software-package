###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         17/Feb/2021  15:29:27
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\spi.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5458.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\spi.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_QSPI -D
#        CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_TRNG -D CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D
#        CONFIG_HAVE_OTPC -D CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List\spi.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\Obj\spi.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  int_specials
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\spi.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup spi_module Working with SPI
     31           * \section Purpose
     32           * The SPI driver provides the interface to configure and use the SPI
     33           * peripheral.
     34           *
     35           * The Serial Peripheral Interface (SPI) circuit is a synchronous serial
     36           * data link that provides communication with external devices in Master
     37           * or Slave Mode.
     38           *
     39           * \section Usage
     40           * To use the SPI, the user has to follow these few steps:
     41           * -# Enable the SPI pins required by the application (see pio.h).
     42           * -# Configure the SPI using the \ref spi_configure(). This enables the
     43           *    peripheral clock. The mode register is loaded with the given value.
     44           * -# Configure all the necessary chip selects with \ref spi_configure_npcs().
     45           * -# Enable the SPI by calling \ref spi_enable().
     46           * -# Send/receive data using \ref spi_write() and \ref
     47           * spi_read(). Note that \ref spi_read()
     48           *    must be called after \ref spi_write() to retrieve the last value read.
     49           * -# Disable the SPI by calling \ref spi_disable().
     50           *
     51           * For more accurate information, please look at the SPI section of the
     52           * Datasheet.
     53           *
     54           * Related files :\n
     55           * \ref spi.c\n
     56           * \ref spi.h\n
     57          */
     58          /*@{*/
     59          /*@}*/
     60          
     61          /**
     62           * \file
     63           *
     64           * Implementation of Serial Peripheral Interface (SPI) controller.
     65           *
     66           */
     67          
     68          /*----------------------------------------------------------------------------
     69           *        Headers
     70           *----------------------------------------------------------------------------*/
     71          
     72          #include "chip.h"
     73          
     74          #include "spi/spi.h"
     75          #include "peripherals/pmc.h"
     76          
     77          #include "io.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void writehw(void volatile *, uint16_t)
   \                     writehw:
   \        0x0   0xE1C0'10B0        STRH     R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
     78          #include "trace.h"
     79          
     80          #include <stdint.h>
     81          
     82          #include <assert.h>
     83          
     84          /*---------------------------------------------------------------------------
     85          *        Macros
     86          *----------------------------------------------------------------------------*/
     87          
     88          #define SPI_PCS(npcs)       SPI_MR_PCS((~(1 << npcs) & 0xF))
     89          
     90          /*----------------------------------------------------------------------------
     91           *        local functions
     92           *----------------------------------------------------------------------------*/
     93          

   \                                 In section SOFTPACK, align 4, keep-with-next
     94          static inline uint32_t _spi_compute_scbr(uint32_t bitrate, uint32_t id)
     95          {
   \                     _spi_compute_scbr:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     96          	uint32_t pclk = pmc_get_peripheral_clock(id);
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0x....'....        BL       pmc_get_peripheral_clock
   \       0x14   0xE1B0'1000        MOVS     R1,R0
     97          	if (bitrate == 0)
   \       0x18   0xE354'0000        CMP      R4,#+0
   \       0x1C   0x1A00'0001        BNE      ??_spi_compute_scbr_0
     98          		return 0;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xEA00'0005        B        ??_spi_compute_scbr_1
     99          	return SPI_CSR_SCBR(pclk / (bitrate * 1000));
   \                     ??_spi_compute_scbr_0:
   \       0x28   0xE1B0'0001        MOVS     R0,R1
   \       0x2C   0xE3A0'2FFA        MOV      R2,#+1000
   \       0x30   0xE011'0492        MULS     R1,R2,R4
   \       0x34   0x....'....        BL       __aeabi_uidiv
   \       0x38   0xE3A0'1CFF        MOV      R1,#+65280
   \       0x3C   0xE011'0400        ANDS     R0,R1,R0, LSL #+8
   \                     ??_spi_compute_scbr_1:
   \       0x40   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    100          }
    101          

   \                                 In section SOFTPACK, align 4, keep-with-next
    102          static inline uint32_t _spi_compute_dlybs(uint32_t delay, uint32_t id)
    103          {
   \                     _spi_compute_dlybs:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    104          	uint32_t pclk = pmc_get_peripheral_clock(id);
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0x....'....        BL       pmc_get_peripheral_clock
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    105          	uint32_t dlybs = ((pclk / 1000000u) * delay) / 100;
   \       0x18   0xE1B0'0006        MOVS     R0,R6
   \       0x1C   0xE3A0'1AF4        MOV      R1,#+999424
   \       0x20   0xE381'1F90        ORR      R1,R1,#0x240
   \       0x24   0x....'....        BL       __aeabi_uidiv
   \       0x28   0xE010'0094        MULS     R0,R4,R0
   \       0x2C   0xE3A0'1064        MOV      R1,#+100
   \       0x30   0x....'....        BL       __aeabi_uidiv
    106          	return SPI_CSR_DLYBS(dlybs);
   \       0x34   0xE3A0'18FF        MOV      R1,#+16711680
   \       0x38   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \       0x3C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    107          }
    108          

   \                                 In section SOFTPACK, align 4, keep-with-next
    109          static inline uint32_t _spi_compute_dlybct(uint32_t delay, uint32_t id)
    110          {
   \                     _spi_compute_dlybct:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    111          	uint32_t pclk = pmc_get_peripheral_clock(id);
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0x....'....        BL       pmc_get_peripheral_clock
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    112          	uint32_t dlybct = ((pclk / 32000u) * delay) / 100;
   \       0x18   0xE1B0'0006        MOVS     R0,R6
   \       0x1C   0xE3A0'1C7D        MOV      R1,#+32000
   \       0x20   0x....'....        BL       __aeabi_uidiv
   \       0x24   0xE010'0094        MULS     R0,R4,R0
   \       0x28   0xE3A0'1064        MOV      R1,#+100
   \       0x2C   0x....'....        BL       __aeabi_uidiv
    113          	return SPI_CSR_DLYBCT(dlybct);
   \       0x30   0xE1B0'0C00        LSLS     R0,R0,#+24
   \       0x34   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    114          }
    115          
    116          /*----------------------------------------------------------------------------
    117           *        Exported functions
    118           *----------------------------------------------------------------------------*/
    119          

   \                                 In section SOFTPACK, align 4, keep-with-next
    120          void spi_enable(Spi * spi)
    121          {
    122          	spi->SPI_CR = SPI_CR_SPIEN;
   \                     spi_enable:
   \        0x0   0xE3A0'1001        MOV      R1,#+1
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    123          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    124          

   \                                 In section SOFTPACK, align 4, keep-with-next
    125          void spi_disable(Spi * spi)
    126          {
    127          	spi->SPI_CR = SPI_CR_SPIDIS;
   \                     spi_disable:
   \        0x0   0xE3A0'1002        MOV      R1,#+2
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    128          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    129          

   \                                 In section SOFTPACK, align 4, keep-with-next
    130          void spi_enable_it(Spi * spi, uint32_t dwSources)
    131          {
    132          	spi->SPI_IER = dwSources;
   \                     spi_enable_it:
   \        0x0   0xE580'1014        STR      R1,[R0, #+20]
    133          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    134          

   \                                 In section SOFTPACK, align 4, keep-with-next
    135          void spi_disable_it(Spi * spi, uint32_t dwSources)
    136          {
    137          	spi->SPI_IDR = dwSources;
   \                     spi_disable_it:
   \        0x0   0xE580'1018        STR      R1,[R0, #+24]
    138          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    139          

   \                                 In section SOFTPACK, align 4, keep-with-next
    140          void spi_configure(Spi * spi)
    141          {
    142          	spi->SPI_CR = SPI_CR_SPIDIS;
   \                     spi_configure:
   \        0x0   0xE3A0'1002        MOV      R1,#+2
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    143          
    144          	spi->SPI_CR = SPI_CR_SWRST;
   \        0x8   0xE3A0'1080        MOV      R1,#+128
   \        0xC   0xE580'1000        STR      R1,[R0, #+0]
    145          
    146          	spi->SPI_MR = SPI_MR_WDRBT | SPI_MR_MODFDIS;
   \       0x10   0xE3A0'1030        MOV      R1,#+48
   \       0x14   0xE580'1004        STR      R1,[R0, #+4]
    147          
    148          	spi->SPI_RDR;
   \       0x18   0xE590'1008        LDR      R1,[R0, #+8]
    149          }
   \       0x1C   0xE12F'FF1E        BX       LR               ;; return
    150          

   \                                 In section SOFTPACK, align 4, keep-with-next
    151          void spi_mode_master_enable(Spi *spi, bool master)
    152          {
    153          	if (master)
   \                     spi_mode_master_enable:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0003        BEQ      ??spi_mode_master_enable_0
    154          		spi->SPI_MR |= SPI_MR_MSTR;
   \       0x10   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x14   0xE392'2001        ORRS     R2,R2,#0x1
   \       0x18   0xE580'2004        STR      R2,[R0, #+4]
   \       0x1C   0xEA00'0002        B        ??spi_mode_master_enable_1
    155          	else
    156          		spi->SPI_MR = spi->SPI_MR & ~SPI_MR_MSTR;
   \                     ??spi_mode_master_enable_0:
   \       0x20   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x24   0xE3D2'2001        BICS     R2,R2,#0x1
   \       0x28   0xE580'2004        STR      R2,[R0, #+4]
    157          }
   \                     ??spi_mode_master_enable_1:
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    158          

   \                                 In section SOFTPACK, align 4, keep-with-next
    159          void spi_select_cs(Spi * spi, uint8_t cs)
    160          {
    161          	uint32_t mr = spi->SPI_MR & ~SPI_MR_PCS_Msk;
   \                     spi_select_cs:
   \        0x0   0xE590'2004        LDR      R2,[R0, #+4]
   \        0x4   0xE3D2'2AF0        BICS     R2,R2,#0xF0000
    162          	spi->SPI_MR = mr | SPI_MR_PCS((1 << cs) - 1);
   \        0x8   0xE3A0'3001        MOV      R3,#+1
   \        0xC   0xE3E0'C000        MVN      R12,#+0
   \       0x10   0xE09C'3113        ADDS     R3,R12,R3, LSL R1
   \       0x14   0xE3A0'CAF0        MOV      R12,#+983040
   \       0x18   0xE01C'3803        ANDS     R3,R12,R3, LSL #+16
   \       0x1C   0xE193'3002        ORRS     R3,R3,R2
   \       0x20   0xE580'3004        STR      R3,[R0, #+4]
    163          }
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    164          

   \                                 In section SOFTPACK, align 4, keep-with-next
    165          void spi_release_cs(Spi * spi)
    166          {
    167          	spi->SPI_CR = SPI_CR_LASTXFER;
   \                     spi_release_cs:
   \        0x0   0xE3A0'1740        MOV      R1,#+16777216
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    168          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    169          

   \                                 In section SOFTPACK, align 4, keep-with-next
    170          void spi_configure_cs(Spi * spi, uint8_t cs, uint32_t bitrate,
    171          		      uint32_t delay_dlybs, uint32_t delay_dlybct,
    172          		      uint32_t spi_mode)
    173          {
   \                     spi_configure_cs:
   \        0x0   0xE92D'4FFE        PUSH     {R1-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE59D'6030        LDR      R6,[SP, #+48]
   \       0x10   0xE59D'7034        LDR      R7,[SP, #+52]
    174          	uint32_t csr = 0;
   \       0x14   0xE3A0'8000        MOV      R8,#+0
    175          	trace_debug("Spi: configuring chip select %u\r\n", (unsigned int)cs);
   \       0x18   0x....'....        LDR      R0,??DataTable3
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0xE350'0005        CMP      R0,#+5
   \       0x24   0x3A00'0003        BCC      ??spi_configure_cs_0
   \       0x28   0xE1B0'1005        MOVS     R1,R5
   \       0x2C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x30   0x....'....        LDR      R0,??DataTable3_1
   \       0x34   0x....'....        BL       printf
    176          	uint32_t id = get_spi_id_from_addr(spi);
   \                     ??spi_configure_cs_0:
   \       0x38   0xE1B0'0004        MOVS     R0,R4
   \       0x3C   0x....'....        BL       get_spi_id_from_addr
   \       0x40   0xE1B0'9000        MOVS     R9,R0
    177          	assert(id < ID_PERIPH_COUNT);
   \       0x44   0xE359'0033        CMP      R9,#+51
   \       0x48   0x3A00'0004        BCC      ??spi_configure_cs_1
   \       0x4C   0xE3A0'20B1        MOV      R2,#+177
   \       0x50   0x....'....        LDR      R1,??DataTable3_2
   \       0x54   0x....'....        LDR      R0,??DataTable3_3
   \       0x58   0x....'....        BL       __aeabi_assert
   \       0x5C   0x....'....        BL       __iar_EmptyStepPoint
    178          
    179          	csr |= _spi_compute_scbr(bitrate, id);
   \                     ??spi_configure_cs_1:
   \       0x60   0xE1B0'1009        MOVS     R1,R9
   \       0x64   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x68   0x....'....        BL       _spi_compute_scbr
   \       0x6C   0xE190'A008        ORRS     R10,R0,R8
    180          	csr |= _spi_compute_dlybs(delay_dlybs, id);
   \       0x70   0xE1B0'1009        MOVS     R1,R9
   \       0x74   0xE59D'0008        LDR      R0,[SP, #+8]
   \       0x78   0x....'....        BL       _spi_compute_dlybs
   \       0x7C   0xE190'B00A        ORRS     R11,R0,R10
    181          	csr |= _spi_compute_dlybct(delay_dlybct, id);
   \       0x80   0xE1B0'1009        MOVS     R1,R9
   \       0x84   0xE1B0'0006        MOVS     R0,R6
   \       0x88   0x....'....        BL       _spi_compute_dlybct
   \       0x8C   0xE190'000B        ORRS     R0,R0,R11
    182          	csr |= spi_mode & ~(SPI_CSR_SCBR_Msk | SPI_CSR_DLYBS_Msk | SPI_CSR_DLYBCT_Msk);
   \       0x90   0xE217'10FF        ANDS     R1,R7,#0xFF
   \       0x94   0xE191'0000        ORRS     R0,R1,R0
    183          
    184          	spi->SPI_CSR[cs] = csr;
   \       0x98   0xE1B0'1005        MOVS     R1,R5
   \       0x9C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0xA0   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0xA4   0xE094'1001        ADDS     R1,R4,R1
   \       0xA8   0xE581'0030        STR      R0,[R1, #+48]
    185          }
   \       0xAC   0xE8BD'8FF7        POP      {R0-R2,R4-R11,PC}  ;; return
    186          

   \                                 In section SOFTPACK, align 4, keep-with-next
    187          void spi_set_cs_bitrate(Spi * spi, uint8_t cs, uint32_t bitrate)
    188          {
   \                     spi_set_cs_bitrate:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    189          	uint32_t csr = spi->SPI_CSR[cs];
   \       0x10   0xE1B0'0005        MOVS     R0,R5
   \       0x14   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x18   0xE1B0'0100        LSLS     R0,R0,#+2
   \       0x1C   0xE094'0000        ADDS     R0,R4,R0
   \       0x20   0xE590'8030        LDR      R8,[R0, #+48]
    190          	uint32_t id = get_spi_id_from_addr(spi);
   \       0x24   0xE1B0'0004        MOVS     R0,R4
   \       0x28   0x....'....        BL       get_spi_id_from_addr
   \       0x2C   0xE1B0'7000        MOVS     R7,R0
    191          	assert(id < ID_PERIPH_COUNT);
   \       0x30   0xE357'0033        CMP      R7,#+51
   \       0x34   0x3A00'0004        BCC      ??spi_set_cs_bitrate_0
   \       0x38   0xE3A0'20BF        MOV      R2,#+191
   \       0x3C   0x....'....        LDR      R1,??DataTable3_2
   \       0x40   0x....'....        LDR      R0,??DataTable3_3
   \       0x44   0x....'....        BL       __aeabi_assert
   \       0x48   0x....'....        BL       __iar_EmptyStepPoint
    192          
    193          	csr &= ~SPI_CSR_SCBR_Msk;
   \                     ??spi_set_cs_bitrate_0:
   \       0x4C   0xE3D8'8CFF        BICS     R8,R8,#0xFF00
    194          	csr |= _spi_compute_scbr(bitrate, id);
   \       0x50   0xE1B0'1007        MOVS     R1,R7
   \       0x54   0xE1B0'0006        MOVS     R0,R6
   \       0x58   0x....'....        BL       _spi_compute_scbr
   \       0x5C   0xE190'0008        ORRS     R0,R0,R8
    195          
    196          	spi->SPI_CSR[cs] = csr;
   \       0x60   0xE1B0'1005        MOVS     R1,R5
   \       0x64   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x68   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x6C   0xE094'1001        ADDS     R1,R4,R1
   \       0x70   0xE581'0030        STR      R0,[R1, #+48]
    197          }
   \       0x74   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    198          

   \                                 In section SOFTPACK, align 4, keep-with-next
    199          uint32_t spi_get_status(Spi * spi)
    200          {
    201          	return spi->SPI_SR;
   \                     spi_get_status:
   \        0x0   0xE590'0010        LDR      R0,[R0, #+16]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    202          }
    203          

   \                                 In section SOFTPACK, align 4, keep-with-next
    204          uint32_t spi_get_masked_status(Spi *spi)
    205          {
   \                     spi_get_masked_status:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    206          	uint32_t status;
    207          	assert(spi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??spi_get_masked_status_0
   \       0x10   0xE3A0'20CF        MOV      R2,#+207
   \       0x14   0x....'....        LDR      R1,??DataTable3_2
   \       0x18   0x....'....        LDR      R0,??DataTable3_4
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    208          	status = spi->SPI_SR;
   \                     ??spi_get_masked_status_0:
   \       0x24   0xE594'0010        LDR      R0,[R4, #+16]
    209          	status &= spi->SPI_IMR;
   \       0x28   0xE594'101C        LDR      R1,[R4, #+28]
   \       0x2C   0xE011'0000        ANDS     R0,R1,R0
    210          	return status;
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    211          }
    212          

   \                                 In section SOFTPACK, align 4, keep-with-next
    213          void spi_write(Spi *spi, uint16_t tx)
    214          {
   \                     spi_write:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    215          	while ((spi->SPI_SR & SPI_SR_TDRE) == 0);
   \                     ??spi_write_0:
   \        0xC   0xE594'0010        LDR      R0,[R4, #+16]
   \       0x10   0xE310'0002        TST      R0,#0x2
   \       0x14   0x0AFF'FFFC        BEQ      ??spi_write_0
    216          
    217          	writehw(&spi->SPI_TDR, SPI_TDR_TD(tx));
   \       0x18   0xE1B0'1005        MOVS     R1,R5
   \       0x1C   0xE1A0'1801        LSL      R1,R1,#+16
   \       0x20   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x24   0xE294'000C        ADDS     R0,R4,#+12
   \       0x28   0x....'....        BL       writehw
    218          }
   \       0x2C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    219          

   \                                 In section SOFTPACK, align 4, keep-with-next
    220          uint16_t spi_read(Spi *spi)
    221          {
    222          	while ((spi->SPI_SR & SPI_SR_RDRF) == 0);
   \                     spi_read:
   \                     ??spi_read_0:
   \        0x0   0xE590'1010        LDR      R1,[R0, #+16]
   \        0x4   0xE311'0001        TST      R1,#0x1
   \        0x8   0x0AFF'FFFC        BEQ      ??spi_read_0
    223          
    224          	return (spi->SPI_RDR & SPI_RDR_RD_Msk);
   \        0xC   0xE590'0008        LDR      R0,[R0, #+8]
   \       0x10   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x14   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    225          }
    226          

   \                                 In section SOFTPACK, align 4, keep-with-next
    227          uint16_t spi_transfer(Spi *spi, uint16_t tx)
    228          {
   \                     spi_transfer:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    229          	spi_write(spi, tx);
   \        0xC   0xE1B0'1005        MOVS     R1,R5
   \       0x10   0xE1A0'1801        LSL      R1,R1,#+16
   \       0x14   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x18   0xE1B0'0004        MOVS     R0,R4
   \       0x1C   0x....'....        BL       spi_write
    230          
    231          	return spi_read(spi);
   \       0x20   0xE1B0'0004        MOVS     R0,R4
   \       0x24   0x....'....        BL       spi_read
   \       0x28   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    232          }
    233          

   \                                 In section SOFTPACK, align 4, keep-with-next
    234          bool spi_is_tx_finished(Spi * spi)
    235          {
    236          	return ((spi->SPI_SR & SPI_SR_TXEMPTY) != 0);
   \                     spi_is_tx_finished:
   \        0x0   0xE590'0010        LDR      R0,[R0, #+16]
   \        0x4   0xE1B0'04A0        LSRS     R0,R0,#+9
   \        0x8   0xE210'0001        ANDS     R0,R0,#0x1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    237          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x73, 0x70

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x73 0x70
   \       0x40   0x69 0x5C          DC8 0x69, 0x5C, 0x73, 0x70, 0x69, 0x2E, 0x63, 0x3A

   \              0x73 0x70    

   \              0x69 0x2E    

   \              0x63 0x3A
   \       0x48   0x31 0x37          DC8 0x31, 0x37, 0x35, 0x20, 0x53, 0x70, 0x69, 0x3A

   \              0x35 0x20    

   \              0x53 0x70    

   \              0x69 0x3A
   \       0x50   0x20 0x63          DC8 0x20, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75

   \              0x6F 0x6E    

   \              0x66 0x69    

   \              0x67 0x75
   \       0x58   0x72 0x69          DC8 0x72, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x68, 0x69

   \              0x6E 0x67    

   \              0x20 0x63    

   \              0x68 0x69
   \       0x60   0x70 0x20          DC8 0x70, 0x20, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74

   \              0x73 0x65    

   \              0x6C 0x65    

   \              0x63 0x74
   \       0x68   0x20 0x25          DC8 0x20, 0x25, 0x75, 0x0D, 0x0A, 0

   \              0x75 0x0D    

   \              0x0A 0x00
   \       0x6E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x69 0x64          DC8 "id < (51)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x35 0x31    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x73, 0x70, 0x69, 0x5C, 0x73, 0x70

   \              0x73 0x70    

   \              0x69 0x5C    

   \              0x73 0x70
   \       0x40   0x69 0x2E          DC8 0x69, 0x2E, 0x63, 0

   \              0x63 0x00

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x73 0x70          DC8 "spi != ((void*)0)"

   \              0x69 0x20    

   \              0x21 0x3D    

   \              0x20 0x28    

   \              0x28 0x76    

   \              0x6F 0x69    

   \              0x64 0x2A    

   \              0x29 0x30    

   \              0x29 0x00
   \       0x12   0x00 0x00          DC8 0, 0
    238          
    239          #ifdef CONFIG_HAVE_SPI_FIFO
    240          void spi_fifo_configure(Spi *spi, uint8_t tx_thres, uint8_t rx_thres)
    241          {
    242          	assert(spi != NULL);
    243          
    244          	/* Configure FIFO */
    245          	spi->SPI_FMR = SPI_FMR_TXFTHRES(tx_thres) | SPI_FMR_RXFTHRES(rx_thres)
    246          		| SPI_FMR_RXRDYM_ONE_DATA | SPI_FMR_TXRDYM_ONE_DATA;
    247          }
    248          
    249          void spi_fifo_enable(Spi *spi)
    250          {
    251          	assert(spi != NULL);
    252          
    253          	spi->SPI_CR = SPI_CR_SPIDIS;
    254          	spi->SPI_CR = SPI_CR_FIFOEN | SPI_CR_TXFCLR | SPI_CR_RXFCLR;
    255          
    256          	spi->SPI_CR = SPI_CR_SPIEN;
    257          }
    258          
    259          void spi_fifo_disable(Spi *spi)
    260          {
    261          	assert(spi != NULL);
    262          
    263          	spi->SPI_CR = SPI_CR_SPIDIS;
    264          	spi->SPI_CR = SPI_CR_FIFODIS | SPI_CR_TXFCLR | SPI_CR_RXFCLR;
    265          
    266          	spi->SPI_CR = SPI_CR_SPIEN;
    267          }
    268          
    269          uint32_t spi_fifo_get_rx_size(Spi *spi)
    270          {
    271          	assert(spi != NULL);
    272          
    273          	return (spi->SPI_FLR & SPI_FLR_RXFL_Msk) >> SPI_FLR_RXFL_Pos;
    274          }
    275          
    276          uint32_t spi_fifo_get_tx_size(Spi *spi)
    277          {
    278          	assert(spi != NULL);
    279          
    280          	return (spi->SPI_FLR & SPI_FLR_TXFL_Msk) >> SPI_FLR_TXFL_Pos;
    281          }
    282          
    283          void spi_fifo_flush_rx(Spi *spi)
    284          {
    285          	assert(spi != NULL);
    286          	spi->SPI_CR = SPI_CR_RXFCLR;
    287          }
    288          
    289          void spi_fifo_flush_tx(Spi *spi)
    290          {
    291          	assert(spi != NULL);
    292          	spi->SPI_CR = SPI_CR_TXFCLR;
    293          }
    294          
    295          #endif /* CONFIG_HAVE_SPI_FIFO */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _spi_compute_dlybct
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
      16   _spi_compute_dlybs
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
      16   _spi_compute_scbr
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
       0   spi_configure
      48   spi_configure_cs
        48   -> __aeabi_assert
        48   -> __iar_EmptyStepPoint
        48   -> _spi_compute_dlybct
        48   -> _spi_compute_dlybs
        48   -> _spi_compute_scbr
        48   -> get_spi_id_from_addr
        48   -> printf
       0   spi_disable
       0   spi_disable_it
       0   spi_enable
       0   spi_enable_it
       8   spi_get_masked_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   spi_get_status
       0   spi_is_tx_finished
       0   spi_mode_master_enable
       0   spi_read
       0   spi_release_cs
       0   spi_select_cs
      24   spi_set_cs_bitrate
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> _spi_compute_scbr
        24   -> get_spi_id_from_addr
      16   spi_transfer
        16   -> spi_read
        16   -> spi_write
      16   spi_write
        16   -> writehw
       0   writehw


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
     112  ?_0
      12  ?_1
      68  ?_2
      20  ?_3
      56  _spi_compute_dlybct
      64  _spi_compute_dlybs
      68  _spi_compute_scbr
      32  spi_configure
     176  spi_configure_cs
      12  spi_disable
       8  spi_disable_it
      12  spi_enable
       8  spi_enable_it
      52  spi_get_masked_status
       8  spi_get_status
      16  spi_is_tx_finished
      48  spi_mode_master_enable
      28  spi_read
      12  spi_release_cs
      40  spi_select_cs
     120  spi_set_cs_bitrate
      44  spi_transfer
      48  spi_write
       8  writehw

 
 212 bytes in section .rodata
 880 bytes in section SOFTPACK
 
 880 bytes of CODE  memory
 212 bytes of CONST memory

Errors: none
Warnings: none
