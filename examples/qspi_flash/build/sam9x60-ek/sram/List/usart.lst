###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         17/Feb/2021  15:29:28
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5A2C.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_QSPI -D
#        CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_TRNG -D CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D
#        CONFIG_HAVE_OTPC -D CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\List\usart.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\qspi_flash\build\sam9x60-ek\sram\Obj\usart.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup usart_module Working with USART
     31           * \section Purpose
     32           * The USART driver provides the interface to configure and use the USART peripheral.\n
     33           *
     34           * The USART supports several kinds of communication modes such as full-duplex asynchronous/
     35           * synchronous serial communication,RS485 with driver control signal,ISO7816,SPI and Test modes.
     36           *
     37           * To start a USART transfer with \ref dmad_module "DMA" support, the user could follow these steps:
     38           * <ul>
     39           * <li> Configure USART with expected mode and baudrate(see \ref usart_configure), which could be done by:
     40           * -# Resetting and disabling transmitter and receiver by setting US_CR(Control Register). </li>
     41           * -# Configuring the USART in a specific mode by setting USART_MODE bits in US_MR(Mode Register) </li>
     42           * -# Setting baudrate which is different from mode to mode.
     43             </li>
     44           * <li> Enable transmitter or receiver respectively by set US_CR_TXEN or US_CR_RXEN in US_CR.</li>
     45           * <li> Read from or write to the peripheral with  \ref dmad_module </li>
     46           * </ul>
     47           *
     48           * \section Usage
     49           * <ul>
     50           * <li>  Enable or disable USART transmitter or receiver using
     51           * usart_set_transmitter_enabled() and usart_set_receiver_enabled().
     52           * <li>  Enable or disable USART interrupt using usart_enable_it() or usart_disable_it().
     53           * </li>
     54           * </ul>
     55           *
     56           * For more accurate information, please look at the USART section of the
     57           * Datasheet.
     58           *
     59           * Related files :\n
     60           * \ref usart.c\n
     61           * \ref usart.h\n
     62          */
     63          
     64          /**
     65           * \file
     66           *
     67           * Implementation of USART (Universal Synchronous Asynchronous Receiver Transmitter)
     68           * controller.
     69           *
     70           */
     71          /*-----------------------------------------------------------------------------
     72          *         Headers
     73           *---------------------------------------------------------------------------*/
     74          
     75          #include "chip.h"
     76          #include "compiler.h"
     77          #include "serial/usart.h"
     78          #include "peripherals/pmc.h"
     79          
     80          #include "trace.h"
     81          #include "io.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void writeb(void volatile *, uint8_t)
   \                     writeb:
   \        0x0   0xE5C0'1000        STRB     R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void readb(void const volatile *, uint8_t *)
   \                     readb:
   \        0x0   0xE5D0'2000        LDRB     R2,[R0, #+0]
   \        0x4   0xE5C1'2000        STRB     R2,[R1, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     82          
     83          #include <assert.h>
     84          #include <string.h>
     85          
     86          /*-----------------------------------------------------------------------------
     87          *
     88           *---------------------------------------------------------------------------*/
     89          
     90          /* The CD value scope programmed in MR register. */
     91          #define MIN_CD_VALUE                  0x01
     92          #define MIN_CD_VALUE_SPI              0x04
     93          #define MAX_CD_VALUE                  US_BRGR_CD_Msk
     94          
     95          /* The receiver sampling divide of baudrate clock. */
     96          #define HIGH_FRQ_SAMPLE_DIV           16
     97          #define LOW_FRQ_SAMPLE_DIV            8
     98          
     99          /*----------------------------------------------------------------------------
    100           *         Exported functions
    101           *----------------------------------------------------------------------------*/
    102          

   \                                 In section SOFTPACK, align 4, keep-with-next
    103          void usart_reset_status(Usart *usart)
    104          {
    105          	usart->US_CR = US_CR_RSTSTA;
   \                     usart_reset_status:
   \        0x0   0xE3A0'1F40        MOV      R1,#+256
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    106          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    107          

   \                                 In section SOFTPACK, align 4, keep-with-next
    108          void usart_configure(Usart *usart, uint32_t mode, uint32_t baudrate)
    109          {
   \                     usart_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    110          	uint32_t clock = pmc_get_peripheral_clock(get_usart_id_from_addr(usart));
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       get_usart_id_from_addr
   \       0x18   0x....'....        BL       pmc_get_peripheral_clock
   \       0x1C   0xE1B0'7000        MOVS     R7,R0
    111          	/* Reset and disable receiver & transmitter */
    112          	uint32_t control = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
   \       0x20   0xE3A0'80AC        MOV      R8,#+172
    113          	/* apply */
    114          	usart->US_CR = control;
   \       0x24   0xE584'8000        STR      R8,[R4, #+0]
    115          	/* Configure mode */
    116          	usart->US_MR = mode;
   \       0x28   0xE584'5004        STR      R5,[R4, #+4]
    117          
    118          	/* Configure baudrate */
    119          	/* Asynchronous, no oversampling */
    120          	if (((mode & US_MR_SYNC) == 0) && ((mode & US_MR_OVER) == 0))
   \       0x2C   0xE3A0'0A80        MOV      R0,#+524288
   \       0x30   0xE380'0F40        ORR      R0,R0,#0x100
   \       0x34   0xE110'0005        TST      R0,R5
   \       0x38   0x1A00'0004        BNE      ??usart_configure_0
    121          		usart->US_BRGR = (clock / baudrate) / 16;
   \       0x3C   0xE1B0'0007        MOVS     R0,R7
   \       0x40   0xE1B0'1006        MOVS     R1,R6
   \       0x44   0x....'....        BL       __aeabi_uidiv
   \       0x48   0xE1B0'0220        LSRS     R0,R0,#+4
   \       0x4C   0xE584'0020        STR      R0,[R4, #+32]
    122          
    123          	/* Disable all interrupts */
    124          	usart->US_IDR = 0xFFFFFFFF;
   \                     ??usart_configure_0:
   \       0x50   0xE3E0'0000        MVN      R0,#+0
   \       0x54   0xE584'000C        STR      R0,[R4, #+12]
    125          	/* Enable receiver and transmitter */
    126          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
   \       0x58   0xE3A0'0050        MOV      R0,#+80
   \       0x5C   0xE584'0000        STR      R0,[R4, #+0]
    127          }
   \       0x60   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    128          

   \                                 In section SOFTPACK, align 4, keep-with-next
    129          uint32_t usart_get_status(Usart *usart)
    130          {
    131          	return usart->US_CSR;
   \                     usart_get_status:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    132          }
    133          

   \                                 In section SOFTPACK, align 4, keep-with-next
    134          uint32_t usart_get_masked_status(Usart *usart)
    135          {
   \                     usart_get_masked_status:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    136          	uint32_t status;
    137          	assert(usart != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??usart_get_masked_status_0
   \       0x10   0xE3A0'2089        MOV      R2,#+137
   \       0x14   0x....'....        LDR      R1,??DataTable5
   \       0x18   0x....'....        LDR      R0,??DataTable5_1
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    138          	status = usart->US_CSR;
   \                     ??usart_get_masked_status_0:
   \       0x24   0xE594'0014        LDR      R0,[R4, #+20]
    139          	status &= usart->US_IMR;
   \       0x28   0xE594'1010        LDR      R1,[R4, #+16]
   \       0x2C   0xE011'0000        ANDS     R0,R1,R0
    140          	return status;
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    141          }
    142          

   \                                 In section SOFTPACK, align 4, keep-with-next
    143          void usart_enable_it(Usart *usart, uint32_t mode)
    144          {
    145          	usart->US_IER = mode;
   \                     usart_enable_it:
   \        0x0   0xE580'1008        STR      R1,[R0, #+8]
    146          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    147          

   \                                 In section SOFTPACK, align 4, keep-with-next
    148          void usart_disable_it(Usart *usart, uint32_t mode)
    149          {
    150          	usart->US_IDR = mode;
   \                     usart_disable_it:
   \        0x0   0xE580'100C        STR      R1,[R0, #+12]
    151          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    152          

   \                                 In section SOFTPACK, align 4, keep-with-next
    153          uint32_t usart_get_it_mask(Usart *usart)
    154          {
    155          	return usart->US_IMR;
   \                     usart_get_it_mask:
   \        0x0   0xE590'0010        LDR      R0,[R0, #+16]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    156          }
    157          

   \                                 In section SOFTPACK, align 4, keep-with-next
    158          void usart_set_transmitter_enabled(Usart *usart, uint8_t enabled)
    159          {
    160          	if (enabled) {
   \                     usart_set_transmitter_enabled:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0002        BEQ      ??usart_set_transmitter_enabled_0
    161          		usart->US_CR = US_CR_TXEN;
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0xE580'2000        STR      R2,[R0, #+0]
   \       0x18   0xEA00'0001        B        ??usart_set_transmitter_enabled_1
    162          	} else {
    163          		usart->US_CR = US_CR_TXDIS;
   \                     ??usart_set_transmitter_enabled_0:
   \       0x1C   0xE3A0'2080        MOV      R2,#+128
   \       0x20   0xE580'2000        STR      R2,[R0, #+0]
    164          	}
    165          }
   \                     ??usart_set_transmitter_enabled_1:
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    166          

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void usart_set_receiver_enabled(Usart *usart, uint8_t enabled)
    168          {
    169          	if (enabled) {
   \                     usart_set_receiver_enabled:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0002        BEQ      ??usart_set_receiver_enabled_0
    170          		usart->US_CR = US_CR_RXEN;
   \       0x10   0xE3A0'2010        MOV      R2,#+16
   \       0x14   0xE580'2000        STR      R2,[R0, #+0]
   \       0x18   0xEA00'0001        B        ??usart_set_receiver_enabled_1
    171          	} else {
    172          		usart->US_CR = US_CR_RXDIS;
   \                     ??usart_set_receiver_enabled_0:
   \       0x1C   0xE3A0'2020        MOV      R2,#+32
   \       0x20   0xE580'2000        STR      R2,[R0, #+0]
    173          	}
    174          }
   \                     ??usart_set_receiver_enabled_1:
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    175          

   \                                 In section SOFTPACK, align 4, keep-with-next
    176          void usart_set_rts_enabled(Usart *usart, uint8_t enabled)
    177          {
    178          	if (enabled) {
   \                     usart_set_rts_enabled:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0002        BEQ      ??usart_set_rts_enabled_0
    179          		usart->US_CR = US_CR_RTSEN;
   \       0x10   0xE3A0'2A40        MOV      R2,#+262144
   \       0x14   0xE580'2000        STR      R2,[R0, #+0]
   \       0x18   0xEA00'0001        B        ??usart_set_rts_enabled_1
    180          	} else {
    181          		usart->US_CR = US_CR_RTSDIS;
   \                     ??usart_set_rts_enabled_0:
   \       0x1C   0xE3A0'2A80        MOV      R2,#+524288
   \       0x20   0xE580'2000        STR      R2,[R0, #+0]
    182          	}
    183          }
   \                     ??usart_set_rts_enabled_1:
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    184          

   \                                 In section SOFTPACK, align 4, keep-with-next
    185          void usart_reset_tx(Usart *usart)
    186          {
    187          	/* Reset transmitter */
    188          	usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
   \                     usart_reset_tx:
   \        0x0   0xE3A0'1088        MOV      R1,#+136
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    189          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    190          

   \                                 In section SOFTPACK, align 4, keep-with-next
    191          void usart_set_tx_timeguard(Usart *usart, uint32_t timeguard)
    192          {
    193          	usart->US_TTGR = timeguard;
   \                     usart_set_tx_timeguard:
   \        0x0   0xE580'1028        STR      R1,[R0, #+40]
    194          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    195          

   \                                 In section SOFTPACK, align 4, keep-with-next
    196          void usart_reset_rx(Usart *usart)
    197          {
    198          	/* Reset Receiver */
    199          	usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
   \                     usart_reset_rx:
   \        0x0   0xE3A0'1024        MOV      R1,#+36
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    200          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void usart_set_rx_timeout(Usart *usart, uint32_t baudrate, uint32_t timeout)
    203          {
   \                     usart_set_rx_timeout:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    204          	uint32_t to = ((timeout * 1000000) / ((1000000000 / baudrate) + 1));
   \       0x10   0x....'....        LDR      R0,??DataTable5_2  ;; 0x3b9aca00
   \       0x14   0xE1B0'1005        MOVS     R1,R5
   \       0x18   0x....'....        BL       __aeabi_uidiv
   \       0x1C   0xE290'1001        ADDS     R1,R0,#+1
   \       0x20   0xE3A0'2AF4        MOV      R2,#+999424
   \       0x24   0xE382'2F90        ORR      R2,R2,#0x240
   \       0x28   0xE010'0692        MULS     R0,R2,R6
   \       0x2C   0x....'....        BL       __aeabi_uidiv
    205          	if (to > US_RTOR_TO_Msk)
   \       0x30   0xE350'0B80        CMP      R0,#+131072
   \       0x34   0x3A00'0002        BCC      ??usart_set_rx_timeout_0
    206          		to = US_RTOR_TO_Msk;
   \       0x38   0xE3E0'14FF        MVN      R1,#-16777216
   \       0x3C   0xE3C1'18FE        BIC      R1,R1,#0xFE0000
   \       0x40   0xE1B0'0001        MOVS     R0,R1
    207          	usart->US_RTOR = US_RTOR_TO(to);
   \                     ??usart_set_rx_timeout_0:
   \       0x44   0xE1B0'1780        LSLS     R1,R0,#+15
   \       0x48   0xE1B0'17A1        LSRS     R1,R1,#+15
   \       0x4C   0xE584'1024        STR      R1,[R4, #+36]
    208          }
   \       0x50   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    209          

   \                                 In section SOFTPACK, align 4, keep-with-next
    210          void usart_start_tx_break(Usart *usart)
    211          {
    212          	usart->US_CR = US_CR_STTBRK;
   \                     usart_start_tx_break:
   \        0x0   0xE3A0'1F80        MOV      R1,#+512
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    213          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    214          

   \                                 In section SOFTPACK, align 4, keep-with-next
    215          void usart_stop_tx_break(Usart *usart)
    216          {
    217          	usart->US_CR = US_CR_STPBRK;
   \                     usart_stop_tx_break:
   \        0x0   0xE3A0'1E40        MOV      R1,#+1024
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    218          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    219          

   \                                 In section SOFTPACK, align 4, keep-with-next
    220          void usart_start_rx_timeout(Usart *usart)
    221          {
    222          	usart->US_CR = US_CR_STTTO;
   \                     usart_start_rx_timeout:
   \        0x0   0xE3A0'1E80        MOV      R1,#+2048
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    223          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    224          

   \                                 In section SOFTPACK, align 4, keep-with-next
    225          void usart_reset_iterations(Usart *usart)
    226          {
    227          	usart->US_CR = US_CR_RSTIT;
   \                     usart_reset_iterations:
   \        0x0   0xE3A0'1D80        MOV      R1,#+8192
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    228          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    229          

   \                                 In section SOFTPACK, align 4, keep-with-next
    230          void usart_reset_nack(Usart *usart)
    231          {
    232          	usart->US_CR = US_CR_RSTNACK;
   \                     usart_reset_nack:
   \        0x0   0xE3A0'1C40        MOV      R1,#+16384
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    233          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    234          

   \                                 In section SOFTPACK, align 4, keep-with-next
    235          void usart_restart_rx_timeout(Usart *usart)
    236          {
    237          	usart->US_CR = US_CR_RETTO;
   \                     usart_restart_rx_timeout:
   \        0x0   0xE3A0'1C80        MOV      R1,#+32768
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    238          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    239          

   \                                 In section SOFTPACK, align 4, keep-with-next
    240          void usart_write(Usart *usart, uint16_t data, volatile uint32_t timeout)
    241          {
   \                     usart_write:
   \        0x0   0xE92D'4034        PUSH     {R2,R4,R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    242          	if (timeout == 0) {
   \        0xC   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0003        BNE      ??usart_write_0
    243          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) ;
   \                     ??usart_write_1:
   \       0x18   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x1C   0xE310'0002        TST      R0,#0x2
   \       0x20   0x1A00'0011        BNE      ??usart_write_2
   \       0x24   0xEAFF'FFFB        B        ??usart_write_1
    244          	} else {
    245          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) {
   \                     ??usart_write_0:
   \       0x28   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x2C   0xE310'0002        TST      R0,#0x2
   \       0x30   0x1A00'000D        BNE      ??usart_write_2
    246          			if (timeout == 0) {
   \       0x34   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x1A00'0006        BNE      ??usart_write_3
    247          				trace_error("usart_write: Timed out.\n\r");
   \       0x40   0x....'....        LDR      R0,??DataTable5_3
   \       0x44   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x48   0xE350'0002        CMP      R0,#+2
   \       0x4C   0x3A00'0001        BCC      ??usart_write_4
   \       0x50   0x....'....        LDR      R0,??DataTable5_4
   \       0x54   0x....'....        BL       printf
    248          				return;
   \                     ??usart_write_4:
   \       0x58   0xEA00'0007        B        ??usart_write_5
    249          			}
    250          			timeout--;
   \                     ??usart_write_3:
   \       0x5C   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x60   0xE250'0001        SUBS     R0,R0,#+1
   \       0x64   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x68   0xEAFF'FFEE        B        ??usart_write_0
    251          		}
    252          	}
    253          	usart->US_THR = data;
   \                     ??usart_write_2:
   \       0x6C   0xE1B0'0005        MOVS     R0,R5
   \       0x70   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x74   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x78   0xE584'001C        STR      R0,[R4, #+28]
    254          }
   \                     ??usart_write_5:
   \       0x7C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    255          

   \                                 In section SOFTPACK, align 4, keep-with-next
    256          uint16_t usart_read(Usart *usart, volatile uint32_t timeout)
    257          {
   \                     usart_read:
   \        0x0   0xE92D'4013        PUSH     {R0,R1,R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    258          	if (timeout == 0) {
   \        0x8   0xE59D'0004        LDR      R0,[SP, #+4]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'0003        BNE      ??usart_read_0
    259          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) ;
   \                     ??usart_read_1:
   \       0x14   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x18   0xE310'0001        TST      R0,#0x1
   \       0x1C   0x1A00'0012        BNE      ??usart_read_2
   \       0x20   0xEAFF'FFFB        B        ??usart_read_1
    260          	} else {
    261          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) {
   \                     ??usart_read_0:
   \       0x24   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x28   0xE310'0001        TST      R0,#0x1
   \       0x2C   0x1A00'000E        BNE      ??usart_read_2
    262          			if (timeout == 0) {
   \       0x30   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x1A00'0007        BNE      ??usart_read_3
    263          				trace_error("usart_read: Timed out.\n\r");
   \       0x3C   0x....'....        LDR      R0,??DataTable5_3
   \       0x40   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x44   0xE350'0002        CMP      R0,#+2
   \       0x48   0x3A00'0001        BCC      ??usart_read_4
   \       0x4C   0x....'....        LDR      R0,??DataTable5_5
   \       0x50   0x....'....        BL       printf
    264          				return 0;
   \                     ??usart_read_4:
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0xEA00'0006        B        ??usart_read_5
    265          			}
    266          			timeout--;
   \                     ??usart_read_3:
   \       0x5C   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x60   0xE250'0001        SUBS     R0,R0,#+1
   \       0x64   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x68   0xEAFF'FFED        B        ??usart_read_0
    267          		}
    268          	}
    269          	return usart->US_RHR;
   \                     ??usart_read_2:
   \       0x6C   0xE594'0018        LDR      R0,[R4, #+24]
   \       0x70   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x74   0xE1B0'0820        LSRS     R0,R0,#+16
   \                     ??usart_read_5:
   \       0x78   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
    270          }
    271          

   \                                 In section SOFTPACK, align 4, keep-with-next
    272          bool usart_is_rx_ready(Usart *usart)
    273          {
    274          	return (usart->US_CSR & US_CSR_RXRDY) != 0;
   \                     usart_is_rx_ready:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE210'0001        ANDS     R0,R0,#0x1
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    275          }
    276          

   \                                 In section SOFTPACK, align 4, keep-with-next
    277          bool usart_is_tx_ready(Usart *usart)
    278          {
    279          	return (usart->US_CSR & US_CSR_TXRDY) != 0;
   \                     usart_is_tx_ready:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE1B0'00A0        LSRS     R0,R0,#+1
   \        0x8   0xE210'0001        ANDS     R0,R0,#0x1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    280          }
    281          

   \                                 In section SOFTPACK, align 4, keep-with-next
    282          bool usart_is_tx_empty(Usart *usart)
    283          {
    284          	return (usart->US_CSR & US_CSR_TXEMPTY) != 0;
   \                     usart_is_tx_empty:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE1B0'04A0        LSRS     R0,R0,#+9
   \        0x8   0xE210'0001        ANDS     R0,R0,#0x1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    285          }
    286          

   \                                 In section SOFTPACK, align 4, keep-with-next
    287          void usart_put_char(Usart *usart, uint8_t c)
    288          {
   \                     usart_put_char:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    289          	/* Wait for the transmitter to be ready */
    290          	while ((usart->US_CSR & US_CSR_TXEMPTY) == 0);
   \                     ??usart_put_char_0:
   \        0xC   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x10   0xE310'0F80        TST      R0,#0x200
   \       0x14   0x0AFF'FFFC        BEQ      ??usart_put_char_0
    291          	/* Send character */
    292          	/* Force an octet write to avoid race conditions with FIFO mode */
    293          	writeb(&usart->US_THR, c);
   \       0x18   0xE1B0'1005        MOVS     R1,R5
   \       0x1C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x20   0xE294'001C        ADDS     R0,R4,#+28
   \       0x24   0x....'....        BL       writeb
    294          }
   \       0x28   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    295          

   \                                 In section SOFTPACK, align 4, keep-with-next
    296          uint8_t usart_get_char(Usart *usart)
    297          {
   \                     usart_get_char:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    298          	while ((usart->US_CSR & US_CSR_RXRDY) == 0);
   \                     ??usart_get_char_0:
   \        0x8   0xE594'0014        LDR      R0,[R4, #+20]
   \        0xC   0xE310'0001        TST      R0,#0x1
   \       0x10   0x0AFF'FFFC        BEQ      ??usart_get_char_0
    299          	/* Force an octet read to avoid race conditions with FIFO mode */
    300          	uint8_t v;
    301          	readb(&usart->US_RHR, &v);
   \       0x14   0xE1B0'100D        MOVS     R1,SP
   \       0x18   0xE294'0018        ADDS     R0,R4,#+24
   \       0x1C   0x....'....        BL       readb
    302          	return v;
   \       0x20   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x24   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
    303          }
    304          

   \                                 In section SOFTPACK, align 4, keep-with-next
    305          void usart_set_irda_filter(Usart *usart, uint8_t filter)
    306          {
   \                     usart_set_irda_filter:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    307          	assert(usart != NULL);
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0005        BNE      ??usart_set_irda_filter_0
   \       0x14   0xE3A0'2033        MOV      R2,#+51
   \       0x18   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x1C   0x....'....        LDR      R1,??DataTable5
   \       0x20   0x....'....        LDR      R0,??DataTable5_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    308          
    309          	usart->US_IF = filter;
   \                     ??usart_set_irda_filter_0:
   \       0x2C   0xE1B0'0005        MOVS     R0,R5
   \       0x30   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x34   0xE584'004C        STR      R0,[R4, #+76]
    310          	/* Set IrDA mode. */
    311          	usart->US_MR = (usart->US_MR & ~US_MR_USART_MODE_Msk) | US_MR_USART_MODE_IRDA;
   \       0x38   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x3C   0xE3D0'000F        BICS     R0,R0,#0xF
   \       0x40   0xE390'0008        ORRS     R0,R0,#0x8
   \       0x44   0xE584'0004        STR      R0,[R4, #+4]
    312          }
   \       0x48   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    313          

   \                                 In section SOFTPACK, align 4, keep-with-next
    314          void usart_set_sync_slave_baudrate(Usart *usart)
    315          {
    316          	usart->US_MR = (usart->US_MR & ~US_MR_USCLKS_Msk) | US_MR_USCLKS_SCK | US_MR_SYNC;
   \                     usart_set_sync_slave_baudrate:
   \        0x0   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x4   0xE391'1F4C        ORRS     R1,R1,#0x130
   \        0x8   0xE580'1004        STR      R1,[R0, #+4]
    317          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    318          

   \                                 In section SOFTPACK, align 4, keep-with-next
    319          uint32_t usart_init_hw_handshaking(Usart *usart)
    320          {
   \                     usart_init_hw_handshaking:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    321          	/* The USART should be initialized first as standard RS232. */
    322          	/* Set hardware handshaking mode. */
    323          	usart->US_MR = (usart->US_MR & ~US_MR_USART_MODE_Msk) | US_MR_USART_MODE_HW_HANDSHAKING;
   \        0x4   0xE591'0004        LDR      R0,[R1, #+4]
   \        0x8   0xE3D0'000F        BICS     R0,R0,#0xF
   \        0xC   0xE390'0002        ORRS     R0,R0,#0x2
   \       0x10   0xE581'0004        STR      R0,[R1, #+4]
    324          	return 0;
   \       0x14   0xE3A0'0000        MOV      R0,#+0
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    325          }
    326          

   \                                 In section SOFTPACK, align 4, keep-with-next
    327          uint32_t usart_set_async_baudrate(Usart *usart, uint32_t baudrate)
    328          {
   \                     usart_set_async_baudrate:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    329          	uint32_t over, cd_fp, cd, fp;
    330          	uint32_t mck;
    331          
    332          	/* get peripheral clock */
    333          	mck = pmc_get_peripheral_clock(get_usart_id_from_addr(usart));
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       get_usart_id_from_addr
   \       0x14   0x....'....        BL       pmc_get_peripheral_clock
   \       0x18   0xE1B0'6000        MOVS     R6,R0
    334          
    335          	/* Calculate the receiver sampling divide of baudrate clock. */
    336          	if (mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
   \       0x1C   0xE1B0'0205        LSLS     R0,R5,#+4
   \       0x20   0xE156'0000        CMP      R6,R0
   \       0x24   0x3A00'0001        BCC      ??usart_set_async_baudrate_0
    337          		over = HIGH_FRQ_SAMPLE_DIV;
   \       0x28   0xE3A0'7010        MOV      R7,#+16
   \       0x2C   0xEA00'0000        B        ??usart_set_async_baudrate_1
    338          	} else {
    339          		over = LOW_FRQ_SAMPLE_DIV;
   \                     ??usart_set_async_baudrate_0:
   \       0x30   0xE3A0'7008        MOV      R7,#+8
    340          	}
    341          
    342          	/* Calculate clock divider according to the fraction calculated formula. */
    343          	cd_fp = (8 * mck + (over * baudrate) / 2) / (over * baudrate);
   \                     ??usart_set_async_baudrate_1:
   \       0x34   0xE3A0'0008        MOV      R0,#+8
   \       0x38   0xE011'0690        MULS     R1,R0,R6
   \       0x3C   0xE010'0795        MULS     R0,R5,R7
   \       0x40   0xE091'00A0        ADDS     R0,R1,R0, LSR #+1
   \       0x44   0xE011'0795        MULS     R1,R5,R7
   \       0x48   0x....'....        BL       __aeabi_uidiv
   \       0x4C   0xE1B0'1000        MOVS     R1,R0
    344          	cd = cd_fp >> 0x03;
   \       0x50   0xE1B0'21A1        LSRS     R2,R1,#+3
    345          	fp = cd_fp & 0x07;
   \       0x54   0xE211'3007        ANDS     R3,R1,#0x7
    346          	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   \       0x58   0xE352'0000        CMP      R2,#+0
   \       0x5C   0x0A00'0001        BEQ      ??usart_set_async_baudrate_2
   \       0x60   0xE352'0B40        CMP      R2,#+65536
   \       0x64   0x3A00'0001        BCC      ??usart_set_async_baudrate_3
    347          		return 1;
   \                     ??usart_set_async_baudrate_2:
   \       0x68   0xE3A0'0001        MOV      R0,#+1
   \       0x6C   0xEA00'0007        B        ??usart_set_async_baudrate_4
    348          	}
    349          
    350          	/* Configure the OVER bit in MR register. */
    351          	if (over == 8) {
   \                     ??usart_set_async_baudrate_3:
   \       0x70   0xE357'0008        CMP      R7,#+8
   \       0x74   0x1A00'0002        BNE      ??usart_set_async_baudrate_5
    352          		usart->US_MR |= US_MR_OVER;
   \       0x78   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x7C   0xE390'0A80        ORRS     R0,R0,#0x80000
   \       0x80   0xE584'0004        STR      R0,[R4, #+4]
    353          	}
    354          
    355          	/* Configure the baudrate generate register. */
    356          	usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
   \                     ??usart_set_async_baudrate_5:
   \       0x84   0xE192'0803        ORRS     R0,R2,R3, LSL #+16
   \       0x88   0xE584'0020        STR      R0,[R4, #+32]
    357          
    358          	return 0;
   \       0x8C   0xE3A0'0000        MOV      R0,#+0
   \                     ??usart_set_async_baudrate_4:
   \       0x90   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    359          }
    360          
    361          /*-----------------------------------------------------------------------------
    362          *        Functions if FIFO are used
    363           *---------------------------------------------------------------------------*/
    364          
    365          #ifdef CONFIG_HAVE_USART_FIFO

   \                                 In section SOFTPACK, align 4, keep-with-next
    366          void usart_fifo_configure(Usart *usart, uint8_t tx_thres, uint8_t rx_down_thres, uint8_t rx_up_thres)
    367          {
   \                     usart_fifo_configure:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    368          	/* Configure FIFO */
    369          	usart->US_FMR = US_FMR_TXFTHRES(tx_thres) | US_FMR_RXFTHRES(rx_down_thres)
    370          		| US_FMR_RXFTHRES2(rx_up_thres) | US_FMR_RXRDYM_ONE_DATA | US_FMR_TXRDYM_FOUR_DATA;
   \        0x4   0xE1B0'C001        MOVS     R12,R1
   \        0x8   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \        0xC   0xE3A0'EDFC        MOV      LR,#+16128
   \       0x10   0xE01E'C40C        ANDS     R12,LR,R12, LSL #+8
   \       0x14   0xE1B0'E002        MOVS     LR,R2
   \       0x18   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x1C   0xE3A0'49FC        MOV      R4,#+4128768
   \       0x20   0xE014'E80E        ANDS     LR,R4,LR, LSL #+16
   \       0x24   0xE19E'C00C        ORRS     R12,LR,R12
   \       0x28   0xE1B0'E003        MOVS     LR,R3
   \       0x2C   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x30   0xE3A0'45FC        MOV      R4,#+1056964608
   \       0x34   0xE014'EC0E        ANDS     LR,R4,LR, LSL #+24
   \       0x38   0xE19E'C00C        ORRS     R12,LR,R12
   \       0x3C   0xE39C'C002        ORRS     R12,R12,#0x2
   \       0x40   0xE580'C0A0        STR      R12,[R0, #+160]
    371          
    372          	/* Disable all fifo related interrupts */
    373          	usart->US_FIDR = 0xFFFFFFFF;
   \       0x44   0xE3E0'C000        MVN      R12,#+0
   \       0x48   0xE580'C0AC        STR      R12,[R0, #+172]
    374          }
   \       0x4C   0xE8BD'8010        POP      {R4,PC}          ;; return
    375          

   \                                 In section SOFTPACK, align 4, keep-with-next
    376          void usart_fifo_enable(Usart *usart)
    377          {
    378          	/* Reset and disable receiver & transmitter */
    379          	usart->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_FIFOEN;
   \                     usart_fifo_enable:
   \        0x0   0xE3A0'10AC        MOV      R1,#+172
   \        0x4   0xE381'1440        ORR      R1,R1,#0x40000000
   \        0x8   0xE580'1000        STR      R1,[R0, #+0]
    380          
    381          	/* Reenable receiver & transmitter */
    382          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
   \        0xC   0xE3A0'1050        MOV      R1,#+80
   \       0x10   0xE580'1000        STR      R1,[R0, #+0]
    383          }
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    384          

   \                                 In section SOFTPACK, align 4, keep-with-next
    385          void usart_fifo_disable(Usart *usart)
    386          {
    387          	/* Reset and disable receiver & transmitter */
    388          	usart->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
   \                     usart_fifo_disable:
   \        0x0   0xE3A0'10AC        MOV      R1,#+172
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    389          
    390          	/* Reenable receiver & transmitter */
    391          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
   \        0x8   0xE3A0'1050        MOV      R1,#+80
   \        0xC   0xE580'1000        STR      R1,[R0, #+0]
    392          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    393          

   \                                 In section SOFTPACK, align 4, keep-with-next
    394          void usart_fifo_enable_it(Usart *usart, uint32_t interrupt_mask)
    395          {
    396          	usart->US_FIER = interrupt_mask;
   \                     usart_fifo_enable_it:
   \        0x0   0xE580'10A8        STR      R1,[R0, #+168]
    397          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    398          

   \                                 In section SOFTPACK, align 4, keep-with-next
    399          void usart_fifo_disable_it(Usart *usart, uint32_t interrupt_mask)
    400          {
    401          	usart->US_FIDR = interrupt_mask;
   \                     usart_fifo_disable_it:
   \        0x0   0xE580'10AC        STR      R1,[R0, #+172]
    402          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    403          

   \                                 In section SOFTPACK, align 4, keep-with-next
    404          uint32_t usart_fifo_get_rx_size(Usart *usart)
    405          {
    406          	return (usart->US_FLR & US_FLR_RXFL_Msk) >> US_FLR_RXFL_Pos;
   \                     usart_fifo_get_rx_size:
   \        0x0   0xE590'00A4        LDR      R0,[R0, #+164]
   \        0x4   0xE3A0'103F        MOV      R1,#+63
   \        0x8   0xE011'0820        ANDS     R0,R1,R0, LSR #+16
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    407          }
    408          

   \                                 In section SOFTPACK, align 4, keep-with-next
    409          uint32_t usart_fifo_get_tx_size(Usart *usart)
    410          {
    411          	return (usart->US_FLR & US_FLR_TXFL_Msk) >> US_FLR_TXFL_Pos;
   \                     usart_fifo_get_tx_size:
   \        0x0   0xE590'00A4        LDR      R0,[R0, #+164]
   \        0x4   0xE210'003F        ANDS     R0,R0,#0x3F
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    412          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x3B9A'CA00        DC32     0x3b9aca00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x75 0x73          DC8 "usart != ((void*)0)"

   \              0x61 0x72    

   \              0x74 0x20    

   \              0x21 0x3D    

   \              0x20 0x28    

   \              0x28 0x76    

   \              0x6F 0x69    

   \              0x64 0x2A    

   \              0x29 0x30    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6C

   \              0x73 0x65    

   \              0x72 0x69    

   \              0x61 0x6C
   \       0x40   0x5C 0x75          DC8 0x5C, 0x75, 0x73, 0x61, 0x72, 0x74, 0x2E, 0x63

   \              0x73 0x61    

   \              0x72 0x74    

   \              0x2E 0x63
   \       0x48   0x00               DC8 0
   \       0x49   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x45          DC8 "-E- usart_write: Timed out.\012\015"

   \              0x2D 0x20    

   \              0x75 0x73    

   \              0x61 0x72    

   \              0x74 0x5F    

   \              0x77 0x72    

   \              0x69 0x74    

   \              0x65 0x3A    

   \              0x20 0x54    

   \              0x69 0x6D    

   \              0x65 0x64    

   \              0x20 0x6F    

   \              0x75 0x74    

   \              0x2E 0x0A    

   \              0x0D 0x00
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x45          DC8 "-E- usart_read: Timed out.\012\015"

   \              0x2D 0x20    

   \              0x75 0x73    

   \              0x61 0x72    

   \              0x74 0x5F    

   \              0x72 0x65    

   \              0x61 0x64    

   \              0x3A 0x20    

   \              0x54 0x69    

   \              0x6D 0x65    

   \              0x64 0x20    

   \              0x6F 0x75    

   \              0x74 0x2E    

   \              0x0A 0x0D    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00
    413          
    414          #endif /* CONFIG_HAVE_USART_FIFO */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   readb
      24   usart_configure
        24   -> get_usart_id_from_addr
        24   -> pmc_get_peripheral_clock
        24 __aeabi_uidiv
       0   usart_disable_it
       0   usart_enable_it
       8   usart_fifo_configure
       0   usart_fifo_disable
       0   usart_fifo_disable_it
       0   usart_fifo_enable
       0   usart_fifo_enable_it
       0   usart_fifo_get_rx_size
       0   usart_fifo_get_tx_size
      16   usart_get_char
        16   -> readb
       0   usart_get_it_mask
       8   usart_get_masked_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   usart_get_status
       0   usart_init_hw_handshaking
       0   usart_is_rx_ready
       0   usart_is_tx_empty
       0   usart_is_tx_ready
      16   usart_put_char
        16   -> writeb
      16   usart_read
        16   -> printf
       0   usart_reset_iterations
       0   usart_reset_nack
       0   usart_reset_rx
       0   usart_reset_status
       0   usart_reset_tx
       0   usart_restart_rx_timeout
      24   usart_set_async_baudrate
        24   -> get_usart_id_from_addr
        24   -> pmc_get_peripheral_clock
        24 __aeabi_uidiv
      16   usart_set_irda_filter
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   usart_set_receiver_enabled
       0   usart_set_rts_enabled
      16   usart_set_rx_timeout
        16 __aeabi_uidiv
       0   usart_set_sync_slave_baudrate
       0   usart_set_transmitter_enabled
       0   usart_set_tx_timeguard
       0   usart_start_rx_timeout
       0   usart_start_tx_break
       0   usart_stop_tx_break
      16   usart_write
        16   -> printf
       0   writeb


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
      20  ?_0
      76  ?_1
      32  ?_2
      32  ?_3
      12  readb
     100  usart_configure
       8  usart_disable_it
       8  usart_enable_it
      80  usart_fifo_configure
      20  usart_fifo_disable
       8  usart_fifo_disable_it
      24  usart_fifo_enable
       8  usart_fifo_enable_it
      16  usart_fifo_get_rx_size
      12  usart_fifo_get_tx_size
      40  usart_get_char
       8  usart_get_it_mask
      52  usart_get_masked_status
       8  usart_get_status
      28  usart_init_hw_handshaking
      12  usart_is_rx_ready
      16  usart_is_tx_empty
      16  usart_is_tx_ready
      44  usart_put_char
     124  usart_read
      12  usart_reset_iterations
      12  usart_reset_nack
      12  usart_reset_rx
      12  usart_reset_status
      12  usart_reset_tx
      12  usart_restart_rx_timeout
     148  usart_set_async_baudrate
      76  usart_set_irda_filter
      40  usart_set_receiver_enabled
      40  usart_set_rts_enabled
      84  usart_set_rx_timeout
      16  usart_set_sync_slave_baudrate
      40  usart_set_transmitter_enabled
       8  usart_set_tx_timeguard
      12  usart_start_rx_timeout
      12  usart_start_tx_break
      12  usart_stop_tx_break
     128  usart_write
       8  writeb

 
   160 bytes in section .rodata
 1'364 bytes in section SOFTPACK
 
 1'364 bytes of CODE  memory
   160 bytes of CONST memory

Errors: none
Warnings: none
