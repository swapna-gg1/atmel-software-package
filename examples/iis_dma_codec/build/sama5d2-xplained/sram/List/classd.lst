###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         10/Dec/2020  08:15:45
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWBB95.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_PDMIC -D CONFIG_HAVE_AUDIO_AD1934 -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D CONFIG_HAVE_SPI_FIFO -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D
#        CONFIG_HAVE_USART -D CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_I2C_BUS -D
#        CONFIG_HAVE_I2SC -D CONFIG_HAVE_AUDIO_WM8731 --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sama5d2-xplained\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sama5d2-xplained\sram\List\classd.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sama5d2-xplained\sram\Obj\classd.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  int_specials
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <assert.h>
     35          #include <stdio.h>
     36          #include <string.h>
     37          
     38          #include "audio/classd.h"
     39          #include "callback.h"
     40          #include "chip.h"
     41          #include "errno.h"
     42          #include "io.h"
     43          #include "mm/cache.h"
     44          #include "peripherals/pmc.h"
     45          #include "trace.h"
     46          
     47          /*----------------------------------------------------------------------------
     48           *        Local constants
     49           *----------------------------------------------------------------------------*/
     50          
     51          static const struct {
     52          	uint32_t rate;
     53          	uint32_t sample_rate;
     54          	uint32_t dsp_clk;

   \                                 In section .rodata, align 4
     55          } audio_info[] = {
   \                     audio_info:
   \        0x0   0x0000'1F40        DC32 8'000, 0, 0, 16'000, 1'048'576, 0, 32'000, 2'097'152, 0, 48'000

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'3E80  

   \              0x0010'0000  

   \              0x0000'0000  

   \              0x0000'7D00  

   \              0x0020'0000  

   \              0x0000'0000  

   \              0x0000'BB80
   \       0x28   0x0030'0000        DC32 3'145'728, 0, 96'000, 4'194'304, 0, 22'050, 5'242'880, 65'536

   \              0x0000'0000  

   \              0x0001'7700  

   \              0x0040'0000  

   \              0x0000'0000  

   \              0x0000'5622  

   \              0x0050'0000  

   \              0x0001'0000
   \       0x48   0x0000'AC44        DC32 44'100, 6'291'456, 65'536, 88'200, 7'340'032, 65'536

   \              0x0060'0000  

   \              0x0001'0000  

   \              0x0001'5888  

   \              0x0070'0000  

   \              0x0001'0000
   \       0x60   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \       0x68   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x70   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x78   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x80   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x88   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x90   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x98   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x61, 0x75

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x61 0x75
   \       0xA0   0x64 0x69          DC8 0x64, 0x69, 0x6F, 0x5C, 0x63, 0x6C, 0x61, 0x73

   \              0x6F 0x5C    

   \              0x63 0x6C    

   \              0x61 0x73
   \       0xA8   0x73 0x64          DC8 0x73, 0x64, 0x2E, 0x63, 0x3A, 0x31, 0x30, 0x36

   \              0x2E 0x63    

   \              0x3A 0x31    

   \              0x30 0x36
   \       0xB0   0x20 0x43          DC8 0x20, 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75

   \              0x6F 0x6E    

   \              0x66 0x69    

   \              0x67 0x75
   \       0xB8   0x72 0x65          DC8 0x72, 0x65, 0x64, 0x20, 0x41, 0x75, 0x64, 0x69

   \              0x64 0x20    

   \              0x41 0x75    

   \              0x64 0x69
   \       0xC0   0x6F 0x20          DC8 0x6F, 0x20, 0x50, 0x4C, 0x4C, 0x20, 0x50, 0x4D

   \              0x50 0x4C    

   \              0x4C 0x20    

   \              0x50 0x4D
   \       0xC8   0x43 0x20          DC8 0x43, 0x20, 0x43, 0x6C, 0x6F, 0x63, 0x6B, 0x3A

   \              0x43 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x3A
   \       0xD0   0x20 0x25          DC8 0x20, 0x25, 0x75, 0x20, 0x28, 0x3D, 0x20, 0x38

   \              0x75 0x20    

   \              0x28 0x3D    

   \              0x20 0x38
   \       0xD8   0x20 0x2A          DC8 0x20, 0x2A, 0x20, 0x25, 0x75, 0x29, 0x0D, 0x0A

   \              0x20 0x25    

   \              0x75 0x29    

   \              0x0D 0x0A
   \       0xE0   0x00               DC8 0
   \       0xE1   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \       0xE4   0x2D 0x57          DC8 "-W- classd: invalid mono mode %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6D 0x6F    

   \              0x6E 0x6F    

   \              0x20 0x6D    

   \              0x6F 0x64    

   \              0x65 0x20    

   \              0x25 0x75    

   \              0x0D 0x0A    

   \              0x00
   \      0x107   0x00               DC8 0
   \      0x108   0x2D 0x57          DC8 "-W- classd: invalid non overlap value %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6E 0x6F    

   \              0x6E 0x20    

   \              0x6F 0x76    

   \              0x65 0x72    

   \              0x6C 0x61    

   \              0x70 0x20    

   \              0x76 0x61    

   \              0x6C 0x75    

   \              0x65 0x20    

   \              0x25 0x75    

   \              0x0D 0x0A    

   \              0x00
   \      0x133   0x00               DC8 0
   \      0x134   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \      0x13C   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \      0x144   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \      0x14C   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \      0x154   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \      0x15C   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \      0x164   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \      0x16C   0x73 0x5C          DC8 0x73, 0x5C, 0x61, 0x75, 0x64, 0x69, 0x6F, 0x5C

   \              0x61 0x75    

   \              0x64 0x69    

   \              0x6F 0x5C
   \      0x174   0x63 0x6C          DC8 0x63, 0x6C, 0x61, 0x73, 0x73, 0x64, 0x2E, 0x63

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x2E 0x63
   \      0x17C   0x00               DC8 0
   \      0x17D   0x00 0x00          DC8 0, 0, 0

   \              0x00
     56          	{ 8000,  CLASSD_INTPMR_FRAME_FRAME_8K,  CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     57          	{ 16000, CLASSD_INTPMR_FRAME_FRAME_16K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     58          	{ 32000, CLASSD_INTPMR_FRAME_FRAME_32K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     59          	{ 48000, CLASSD_INTPMR_FRAME_FRAME_48K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     60          	{ 96000, CLASSD_INTPMR_FRAME_FRAME_96K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     61          	{ 22050, CLASSD_INTPMR_FRAME_FRAME_22K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     62          	{ 44100, CLASSD_INTPMR_FRAME_FRAME_44K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     63          	{ 88200, CLASSD_INTPMR_FRAME_FRAME_88K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     64          };
     65          
     66          /*----------------------------------------------------------------------------
     67           *        Local functions
     68           *----------------------------------------------------------------------------*/
     69          
     70          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
     71          static bool _dspclk_configure(uint32_t dsp_clk)
     72          {
     73          	struct _pmc_audio_cfg cfg;
     74          
     75          	/* Pad Clock: not used */
     76          	cfg.div = 0;
     77          	cfg.qdaudio = 0;
     78          
     79          	/* PMC Clock: */
     80          	/* 12Mhz * (ND + 1 + FRACR/2^22) / (QDPMC + 1) = 8 * DSPCLK */
     81          	switch (dsp_clk) {
     82          	case CLASSD_INTPMR_DSPCLKFREQ_12M288:
     83          		/* 12Mhz * (56 + 1 + 1442841/2^22) / (6 + 1) = 8 * 12.288Mhz */
     84          		cfg.nd = 56;
     85          		cfg.fracr = 1442841;
     86          		cfg.qdpmc = 6;
     87          		break;
     88          	case CLASSD_INTPMR_DSPCLKFREQ_11M2896:
     89          		/* 12Mhz * (59 + 1 + 885837/2^22) / (7 + 1) = 8 * 11.2896Mhz */
     90          		cfg.nd = 59;
     91          		cfg.fracr = 885837;
     92          		cfg.qdpmc = 7;
     93          		break;
     94          	default:
     95          		return false;
     96          	}
     97          
     98          	pmc_configure_audio(&cfg);
     99          	pmc_enable_audio(true, false);
    100          
    101          #if (TRACE_LEVEL >= TRACE_LEVEL_DEBUG)
    102          	{
    103          		uint32_t clk;
    104          		clk = pmc_get_audio_pmc_clock();
    105          		trace_debug("Configured Audio PLL PMC Clock: %u (= 8 * %u)\r\n",
    106          			    (unsigned)clk, (unsigned)(clk >> 3));
    107          	}
    108          #endif
    109          	return true;
    110          }
    111          #endif
    112          
    113          static bool _set_eqcfg_bits(enum _classd_eqcfg eqcfg, volatile uint32_t *intpmr)
    114          {
    115          	uint32_t mask = CLASSD_INTPMR_EQCFG_Msk;
    116          	uint32_t bits = 0;
    117          
    118          	switch (eqcfg) {
    119          	case CLASSD_EQCFG_FLAT:
    120          		bits = CLASSD_INTPMR_EQCFG_FLAT;
    121          		break;
    122          	case CLASSD_EQCFG_BBOOST12:
    123          		bits = CLASSD_INTPMR_EQCFG_BBOOST12;
    124          		break;
    125          	case CLASSD_EQCFG_BBOOST6:
    126          		bits = CLASSD_INTPMR_EQCFG_BBOOST6;
    127          		break;
    128          	case CLASSD_EQCFG_BCUT12:
    129          		bits = CLASSD_INTPMR_EQCFG_BCUT12;
    130          		break;
    131          	case CLASSD_EQCFG_BCUT6:
    132          		bits = CLASSD_INTPMR_EQCFG_BCUT6;
    133          		break;
    134          	case CLASSD_EQCFG_MBOOST3:
    135          		bits = CLASSD_INTPMR_EQCFG_MBOOST3;
    136          		break;
    137          	case CLASSD_EQCFG_MBOOST8:
    138          		bits = CLASSD_INTPMR_EQCFG_MBOOST8;
    139          		break;
    140          	case CLASSD_EQCFG_MCUT3:
    141          		bits = CLASSD_INTPMR_EQCFG_MCUT3;
    142          		break;
    143          	case CLASSD_EQCFG_MCUT8:
    144          		bits = CLASSD_INTPMR_EQCFG_MCUT8;
    145          		break;
    146          	case CLASSD_EQCFG_TBOOST12:
    147          		bits = CLASSD_INTPMR_EQCFG_TBOOST12;
    148          		break;
    149          	case CLASSD_EQCFG_TBOOST6:
    150          		bits = CLASSD_INTPMR_EQCFG_TBOOST6;
    151          		break;
    152          	case CLASSD_EQCFG_TCUT12:
    153          		bits = CLASSD_INTPMR_EQCFG_TCUT12;
    154          		break;
    155          	case CLASSD_EQCFG_TCUT6:
    156          		bits = CLASSD_INTPMR_EQCFG_TCUT6;
    157          		break;
    158          	default:
    159          		trace_warning("classd: invalid equalizer config %u\r\n",
    160          			      (unsigned)eqcfg);
    161          		return false;
    162          	};
    163          
    164          	*intpmr = (*intpmr & ~mask) | bits;
    165          	return true;
    166          }
    167          
    168          static bool _set_mono_bits(bool mono, enum _classd_mono mono_mode, volatile uint32_t *intpmr)
    169          {
    170          	uint32_t mask = CLASSD_INTPMR_MONO_ENABLED | CLASSD_INTPMR_MONOMODE_Msk;
    171          	uint32_t bits = 0;
    172          
    173          	if (mono) {
    174          		bits = CLASSD_INTPMR_MONO_ENABLED;
    175          		switch (mono_mode) {
    176          		case CLASSD_MONO_MIXED:
    177          			bits |= CLASSD_INTPMR_MONOMODE_MONOMIX;
    178          			break;
    179          		case CLASSD_MONO_SAT:
    180          			bits |= CLASSD_INTPMR_MONOMODE_MONOSAT;
    181          			break;
    182          		case CLASSD_MONO_LEFT:
    183          			bits |= CLASSD_INTPMR_MONOMODE_MONOLEFT;
    184          			break;
    185          		case CLASSD_MONO_RIGHT:
    186          			bits |= CLASSD_INTPMR_MONOMODE_MONORIGHT;
    187          			break;
    188          		default:
    189          			trace_warning("classd: invalid mono mode %u\r\n",
    190          				      (unsigned)mono_mode);
    191          			return false;
    192          		}
    193          	}
    194          
    195          	*intpmr = (*intpmr & ~mask) | bits;
    196          	return true;
    197          }
    198          

   \                                 In section SOFTPACK, align 4, keep-with-next
    199          static int _classd_dma_transfer_callback(void* arg, void* arg2)
    200          {
   \                     _classd_dma_transfer_callback:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    201          	struct _classd_desc* desc = (struct _classd_desc*)arg;
    202          
    203          	dma_reset_channel(desc->tx.dma.channel);
   \        0x8   0xE594'002C        LDR      R0,[R4, #+44]
   \        0xC   0x....'....        BL       dma_reset_channel
    204          
    205          	mutex_unlock(&desc->tx.mutex);
   \       0x10   0xE284'0010        ADD      R0,R4,#+16
   \       0x14   0x....'....        BL       mutex_unlock
    206          
    207          	return callback_call(&desc->tx.callback, NULL);
   \       0x18   0xE284'0024        ADD      R0,R4,#+36
   \       0x1C   0xE3A0'1000        MOV      R1,#+0
   \       0x20   0xE8BD'4010        POP      {R4,LR}
   \       0x24   0x....'....        B        callback_call    ;; tailcall
    208          }
    209          
    210          static void _classd_dma_transfer(struct _classd_desc* desc, struct _buffer* buffer)
    211          {
    212          	struct _callback _cb;
    213          
    214          	memset(&desc->tx.dma.cfg, 0x0, sizeof(desc->tx.dma.cfg));
    215          
    216          	desc->tx.dma.cfg.saddr = buffer->data;
    217          	desc->tx.dma.cfg.daddr = (void*)&desc->addr->CLASSD_THR;
    218          
    219          	if (desc->left_enable && desc->right_enable) {
    220          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
    221          		desc->tx.dma.cfg.len = buffer->size / 4;
    222          	} else {
    223          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
    224          		desc->tx.dma.cfg.len = buffer->size / 2;
    225          	}
    226          	dma_configure_transfer(desc->tx.dma.channel, &desc->tx.dma.cfg_dma, &desc->tx.dma.cfg, 1);
    227          	callback_set(&_cb, _classd_dma_transfer_callback, (void*)desc);
    228          	dma_set_callback(desc->tx.dma.channel, &_cb);
    229          	cache_clean_region(desc->tx.dma.cfg.saddr, desc->tx.dma.cfg.len);
    230          	dma_start_transfer(desc->tx.dma.channel);
    231          }
    232          
    233          static void _classd_polling_transfer(struct _classd_desc* desc, struct _buffer* buffer)
    234          {
    235          	uint16_t* start = (uint16_t*)buffer->data;
    236          	uint32_t  length = buffer->size / sizeof(uint16_t);
    237          	uint16_t* end = start + length;
    238          	uint16_t* current = start;
    239          
    240          	while (1) {
    241          		if (desc->addr->CLASSD_ISR & CLASSD_ISR_DATRDY) {
    242          			uint16_t left = 0, right = 0;
    243          			if (desc->left_enable)
    244          				left = *current++;
    245          			if (desc->right_enable)
    246          				right = *current++;
    247          			desc->addr->CLASSD_THR = CLASSD_THR_RDATA(right)
    248          			                       | CLASSD_THR_LDATA(left);
    249          		}
    250          		if (current >= end)
    251          			break;
    252          	}
    253          
    254          	mutex_unlock(&desc->tx.mutex);
    255          
    256          	callback_call(&desc->tx.callback, NULL);
    257          }
    258          
    259          /*----------------------------------------------------------------------------
    260           *        Exported functions
    261           *----------------------------------------------------------------------------*/
    262          

   \                                 In section SOFTPACK, align 4, keep-with-next
    263          int classd_configure(struct _classd_desc *desc)
    264          {
   \                     classd_configure:
   \        0x0   0xE92D'4FF0        PUSH     {R4-R11,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE24D'D014        SUB      SP,SP,#+20
    265          	uint8_t i;
    266          	uint32_t mr, intpmr, dsp_clk_set, frame_set;
    267          	uint32_t id = get_classd_id_from_addr(desc->addr);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_classd_id_from_addr
   \       0x14   0xE1A0'5000        MOV      R5,R0
    268          
    269          	if (!desc->left_enable && !desc->right_enable)
   \       0x18   0xE5D4'000E        LDRB     R0,[R4, #+14]
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x1A00'0002        BNE      ??classd_configure_3
   \       0x24   0xE5D4'100F        LDRB     R1,[R4, #+15]
   \       0x28   0xE351'0000        CMP      R1,#+0
   \       0x2C   0x0A00'000C        BEQ      ??classd_configure_4
    270          		return -EINVAL;
    271          
    272          	for (i = 0; i < ARRAY_SIZE(audio_info); i++) {
   \                     ??classd_configure_3:
   \       0x30   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x34   0xE3A0'0000        MOV      R0,#+0
    273          		if (audio_info[i].rate == desc->sample_rate) {
   \       0x38   0xE351'0D7D        CMP      R1,#+8000
   \       0x3C   0x1A00'000B        BNE      ??classd_configure_5
    274          			dsp_clk_set  = audio_info[i].dsp_clk;
   \                     ??classd_configure_6:
   \       0x40   0xE080'1080        ADD      R1,R0,R0, LSL #+1
   \       0x44   0x....'....        LDR      R6,??DataTable6
   \       0x48   0xE286'2008        ADD      R2,R6,#+8
    275          			frame_set = audio_info[i].sample_rate;
   \       0x4C   0xE286'3004        ADD      R3,R6,#+4
   \       0x50   0xE1A0'1101        LSL      R1,R1,#+2
    276          			break;
    277          		}
    278          	}
    279          	if (i == ARRAY_SIZE(audio_info))
   \       0x54   0xE350'0008        CMP      R0,#+8
   \       0x58   0xE792'7001        LDR      R7,[R2, +R1]
   \       0x5C   0xE793'A001        LDR      R10,[R3, +R1]
   \       0x60   0x1A00'001D        BNE      ??classd_configure_7
    280          		return -EINVAL;
    281          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    282          	if (!_dspclk_configure(dsp_clk_set))
    283          		return -EINVAL;
    284          #endif
    285          	struct _pmc_periph_cfg cfg = {
    286          		.gck = {
    287          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    288          			.css = PMC_PCR_GCKCSS_AUDIO_CLK,
    289          			.div = 1,
    290          #else
    291          			.css = PMC_PCR_GCKCSS_MCK_CLK,
    292          			.div = 2,
    293          #endif	
    294          		},
    295          	};
    296          	pmc_configure_peripheral(id, &cfg, true);
    297          
    298          	/* perform soft reset */
    299          	desc->addr->CLASSD_CR  = CLASSD_CR_SWRST;
    300          	desc->addr->CLASSD_IDR = CLASSD_IDR_DATRDY;
    301          
    302          	/* initial MR/INTPMR values */
    303          	mr = 0;
    304          	intpmr = dsp_clk_set | frame_set;
    305          
    306          	/* configure output mode */
    307          	switch (desc->mode) {
    308          	case CLASSD_OUTPUT_SINGLE_ENDED:
    309          		break;
    310          	case CLASSD_OUTPUT_DIFFERENTIAL:
    311          		mr |= CLASSD_MR_PWMTYP;
    312          		break;
    313          	case CLASSD_OUTPUT_HALF_BRIDGE:
    314          		mr |= CLASSD_MR_NON_OVERLAP;
    315          		break;
    316          	case CLASSD_OUTPUT_FULL_BRIDGE:
    317          		mr |= CLASSD_MR_PWMTYP | CLASSD_MR_NON_OVERLAP;
    318          		break;
    319          	default:
    320          		trace_warning("classd: invalid mode %u\n", (unsigned)desc->mode);
    321          		return -EINVAL;
    322          	}
    323          
    324          	/* configure non-overlapping time */
    325          	if (mr & CLASSD_MR_NON_OVERLAP) {
    326          		switch (desc->non_ovr) {
    327          		case CLASSD_NONOVR_5NS:
    328          			mr |= CLASSD_MR_NOVRVAL_5NS;
    329          			break;
    330          		case CLASSD_NONOVR_10NS:
    331          			mr |= CLASSD_MR_NOVRVAL_10NS;
    332          			break;
    333          		case CLASSD_NONOVR_15NS:
    334          			mr |= CLASSD_MR_NOVRVAL_15NS;
    335          			break;
    336          		case CLASSD_NONOVR_20NS:
    337          			mr |= CLASSD_MR_NOVRVAL_20NS;
    338          			break;
    339          		default:
    340          			trace_warning("classd: invalid non overlap value %u\r\n",
    341          				      (unsigned)desc->non_ovr);
    342          			return -EINVAL;
    343          		}
    344          	}
    345          
    346          	/* configure mono/stereo */
    347          	if (desc->swap_channels)
    348          		intpmr |= CLASSD_INTPMR_SWAP;
    349          	if (!_set_mono_bits(desc->mono, desc->mono_mode, &intpmr))
    350          		return -EINVAL;
   \                     ??classd_configure_4:
   \       0x64   0xE3E0'001B        MVN      R0,#+27
   \       0x68   0xE28D'D014        ADD      SP,SP,#+20
   \       0x6C   0xE8BD'8FF0        POP      {R4-R11,PC}
   \                     ??classd_configure_5:
   \       0x70   0xE351'0DFA        CMP      R1,#+16000
   \       0x74   0xE3A0'0001        MOV      R0,#+1
   \       0x78   0x0AFF'FFF0        BEQ      ??classd_configure_6
   \       0x7C   0xE351'0C7D        CMP      R1,#+32000
   \       0x80   0xE3A0'0002        MOV      R0,#+2
   \       0x84   0x0AFF'FFED        BEQ      ??classd_configure_6
   \       0x88   0xE30B'2B80        MOVW     R2,#+48000
   \       0x8C   0xE3A0'0003        MOV      R0,#+3
   \       0x90   0xE151'0002        CMP      R1,R2
   \       0x94   0x0AFF'FFE9        BEQ      ??classd_configure_6
   \       0x98   0xE1A0'3082        MOV      R3,R2, LSL #+1
   \       0x9C   0xE3A0'0004        MOV      R0,#+4
   \       0xA0   0xE151'0003        CMP      R1,R3
   \       0xA4   0x0AFF'FFE5        BEQ      ??classd_configure_6
   \       0xA8   0xE305'2622        MOVW     R2,#+22050
   \       0xAC   0xE3A0'0005        MOV      R0,#+5
   \       0xB0   0xE151'0002        CMP      R1,R2
   \       0xB4   0x0AFF'FFE1        BEQ      ??classd_configure_6
   \       0xB8   0xE1A0'3082        MOV      R3,R2, LSL #+1
   \       0xBC   0xE3A0'0006        MOV      R0,#+6
   \       0xC0   0xE151'0003        CMP      R1,R3
   \       0xC4   0x0AFF'FFDD        BEQ      ??classd_configure_6
   \       0xC8   0xE1A0'2102        MOV      R2,R2, LSL #+2
   \       0xCC   0xE3A0'0007        MOV      R0,#+7
   \       0xD0   0xE151'0002        CMP      R1,R2
   \       0xD4   0x1AFF'FFE2        BNE      ??classd_configure_4
   \       0xD8   0xEAFF'FFD8        B        ??classd_configure_6
   \                     ??classd_configure_7:
   \       0xDC   0xE1B0'2007        MOVS     R2,R7
   \       0xE0   0xE3A0'8000        MOV      R8,#+0
   \       0xE4   0xE58D'800C        STR      R8,[SP, #+12]
   \       0xE8   0xE58D'8010        STR      R8,[SP, #+16]
   \       0xEC   0x0A00'0008        BEQ      ??classd_configure_8
   \       0xF0   0xE357'0B40        CMP      R7,#+65536
   \       0xF4   0x1AFF'FFDA        BNE      ??classd_configure_4
   \       0xF8   0xE3A0'C03B        MOV      R12,#+59
   \       0xFC   0x....'....        LDR      LR,??DataTable6_1  ;; 0xd844d
   \      0x100   0xE3A0'2007        MOV      R2,#+7
   \      0x104   0xE58D'C000        STR      R12,[SP, #+0]
   \      0x108   0xE58D'E004        STR      LR,[SP, #+4]
   \      0x10C   0xE58D'2008        STR      R2,[SP, #+8]
   \      0x110   0xEA00'0005        B        ??classd_configure_9
   \                     ??classd_configure_8:
   \      0x114   0xE3A0'0038        MOV      R0,#+56
   \      0x118   0x....'....        LDR      R2,??DataTable6_2  ;; 0x160419
   \      0x11C   0xE3A0'C006        MOV      R12,#+6
   \      0x120   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x124   0xE58D'2004        STR      R2,[SP, #+4]
   \      0x128   0xE58D'C008        STR      R12,[SP, #+8]
   \                     ??classd_configure_9:
   \      0x12C   0xE1A0'000D        MOV      R0,SP
   \      0x130   0x....'....        LDR      R9,??DataTable6_3
   \      0x134   0x....'....        BL       pmc_configure_audio
   \      0x138   0xE3A0'1000        MOV      R1,#+0
   \      0x13C   0xE3A0'0001        MOV      R0,#+1
   \      0x140   0x....'....        BL       pmc_enable_audio
   \      0x144   0x....'....        BL       pmc_get_audio_pmc_clock
   \      0x148   0xE1A0'1000        MOV      R1,R0
   \      0x14C   0xE599'0000        LDR      R0,[R9, #+0]
   \      0x150   0xE350'0005        CMP      R0,#+5
   \      0x154   0x3A00'0002        BCC      ??classd_configure_10
   \      0x158   0xE1A0'21A1        LSR      R2,R1,#+3
   \      0x15C   0xE286'0060        ADD      R0,R6,#+96
   \      0x160   0x....'....        BL       printf
   \                     ??classd_configure_10:
   \      0x164   0x....'....        LDR      R2,??DataTable6_4
   \      0x168   0xE892'0003        LDM      R2,{R0,R1}
   \      0x16C   0xE1CD'00F0        STRD     R0,R1,[SP, #+0]
   \      0x170   0xE3A0'2001        MOV      R2,#+1
   \      0x174   0xE1A0'100D        MOV      R1,SP
   \      0x178   0xE1A0'0005        MOV      R0,R5
   \      0x17C   0xE3A0'B001        MOV      R11,#+1
   \      0x180   0x....'....        BL       pmc_configure_peripheral
   \      0x184   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x188   0xE18A'2007        ORR      R2,R10,R7
   \      0x18C   0xE580'B000        STR      R11,[R0, #+0]
   \      0x190   0xE594'1000        LDR      R1,[R4, #+0]
   \      0x194   0xE3A0'0000        MOV      R0,#+0
   \      0x198   0xE581'B018        STR      R11,[R1, #+24]
   \      0x19C   0xE5D4'1009        LDRB     R1,[R4, #+9]
   \      0x1A0   0xE1A0'3001        MOV      R3,R1
   \      0x1A4   0xE353'0003        CMP      R3,#+3
   \      0x1A8   0x8A00'0049        BHI      ??classd_configure_11
   \      0x1AC   0xE7DF'C003        LDRB     R12,[PC, R3]
   \      0x1B0   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??classd_configure_0:
   \      0x1B4   0x01 0x00          DC8      0x1,0x0,0x42,0x44

   \              0x42 0x44
   \                     ??classd_configure_12:
   \      0x1B8   0xE3A0'0F40        MOV      R0,#+256
   \                     ??classd_configure_13:
   \      0x1BC   0xE310'0B40        TST      R0,#0x10000
   \      0x1C0   0x0A00'0007        BEQ      ??classd_configure_14
   \      0x1C4   0xE5D4'100A        LDRB     R1,[R4, #+10]
   \      0x1C8   0xE1A0'3001        MOV      R3,R1
   \      0x1CC   0xE353'0003        CMP      R3,#+3
   \      0x1D0   0x8A00'0049        BHI      ??classd_configure_15
   \      0x1D4   0xE7DF'C003        LDRB     R12,[PC, R3]
   \      0x1D8   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??classd_configure_1:
   \      0x1DC   0x01 0x00          DC8      0x1,0x0,0x43,0x45

   \              0x43 0x45
   \                     ??classd_configure_16:
   \      0x1E0   0xE380'0940        ORR      R0,R0,#0x100000
   \                     ??classd_configure_14:
   \      0x1E4   0xE5D4'100B        LDRB     R1,[R4, #+11]
   \      0x1E8   0xE5D4'C00C        LDRB     R12,[R4, #+12]
   \      0x1EC   0xE3A0'3000        MOV      R3,#+0
   \      0x1F0   0xE351'0000        CMP      R1,#+0
   \      0x1F4   0xE5D4'100D        LDRB     R1,[R4, #+13]
   \      0x1F8   0x1382'2A80        ORRNE    R2,R2,#0x80000
   \      0x1FC   0xE35C'0000        CMP      R12,#+0
   \      0x200   0x0A00'0007        BEQ      ??classd_configure_17
   \      0x204   0xE1A0'E001        MOV      LR,R1
   \      0x208   0xE3A0'3540        MOV      R3,#+268435456
   \      0x20C   0xE35E'0003        CMP      LR,#+3
   \      0x210   0x8A00'0042        BHI      ??classd_configure_18
   \      0x214   0xE7DF'700E        LDRB     R7,[PC, LR]
   \      0x218   0xE08F'F107        ADD      PC,PC,R7, LSL #+2
   \                     ??classd_configure_2:
   \      0x21C   0x01 0x3E          DC8      0x1,0x3E,0x3C,0x0

   \              0x3C 0x00
   \                     ??classd_configure_19:
   \      0x220   0xE3A0'3470        MOV      R3,#+1879048192
   \                     ??classd_configure_17:
   \      0x224   0xE3C2'1470        BIC      R1,R2,#0x70000000
    351          
    352          	/* configure left channel (muted, max attn) */
    353          	if (desc->left_enable)
   \      0x228   0xE5D4'200E        LDRB     R2,[R4, #+14]
   \      0x22C   0xE183'1001        ORR      R1,R3,R1
    354          		mr |= CLASSD_MR_LEN;
    355          	mr |= CLASSD_MR_LMUTE;
    356          	intpmr |= CLASSD_INTPMR_ATTL(CLASSD_INTPMR_ATTL_Msk);
   \      0x230   0xE381'107F        ORR      R1,R1,#0x7F
   \      0x234   0xE352'0000        CMP      R2,#+0
    357          
    358          	/* configure right channel (muted, max attn)  */
    359          	if (desc->right_enable)
   \      0x238   0xE5D4'200F        LDRB     R2,[R4, #+15]
   \      0x23C   0x1380'0001        ORRNE    R0,R0,#0x1
    360          		mr |= CLASSD_MR_REN;
    361          	mr |= CLASSD_MR_RMUTE;
    362          	intpmr |= CLASSD_INTPMR_ATTR(CLASSD_INTPMR_ATTL_Msk);
    363          
    364          	/* write configuration */
    365          	desc->addr->CLASSD_MR = mr;
    366          	desc->addr->CLASSD_INTPMR = intpmr;
   \      0x240   0xE381'1C7F        ORR      R1,R1,#0x7F00
   \      0x244   0xE380'0002        ORR      R0,R0,#0x2
   \      0x248   0xE352'0000        CMP      R2,#+0
   \      0x24C   0xE594'2000        LDR      R2,[R4, #+0]
   \      0x250   0x1380'0010        ORRNE    R0,R0,#0x10
   \      0x254   0xE380'0020        ORR      R0,R0,#0x20
   \      0x258   0xE582'0004        STR      R0,[R2, #+4]
   \      0x25C   0xE594'3000        LDR      R3,[R4, #+0]
    367          
    368          	desc->tx.dma.channel = dma_allocate_channel(DMA_PERIPH_MEMORY, id);
   \      0x260   0xE3A0'00FF        MOV      R0,#+255
   \      0x264   0xE583'1008        STR      R1,[R3, #+8]
   \      0x268   0xE6EF'1075        UXTB     R1,R5
   \      0x26C   0x....'....        BL       dma_allocate_channel
    369          	assert(desc->tx.dma.channel != NULL);
   \      0x270   0xE350'0000        CMP      R0,#+0
   \      0x274   0xE584'002C        STR      R0,[R4, #+44]
   \      0x278   0x1A00'0004        BNE      ??classd_configure_20
   \      0x27C   0xE38B'2F5C        ORR      R2,R11,#0x170
   \      0x280   0xE286'1F4D        ADD      R1,R6,#+308
   \      0x284   0x....'....        LDR      R0,??DataTable6_5
   \      0x288   0x....'....        BL       __aeabi_assert
   \      0x28C   0x....'....        BL       __iar_EmptyStepPoint
    370          
    371          	desc->tx.dma.cfg_dma.incr_saddr = true;
   \                     ??classd_configure_20:
   \      0x290   0xE5C4'B038        STRB     R11,[R4, #+56]
    372          	desc->tx.dma.cfg_dma.incr_daddr = false;
   \      0x294   0xE5C4'8039        STRB     R8,[R4, #+57]
    373          	desc->tx.dma.cfg_dma.loop = false;
   \      0x298   0xE5C4'803A        STRB     R8,[R4, #+58]
    374          	desc->tx.dma.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x29C   0xE584'8034        STR      R8,[R4, #+52]
    375          
    376          	desc->tx.mutex = 0;
   \      0x2A0   0xE584'8010        STR      R8,[R4, #+16]
    377          
    378          	if ((desc->addr->CLASSD_INTSR & CLASSD_INTSR_CFGERR) != 0)
   \      0x2A4   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x2A8   0xE590'100C        LDR      R1,[R0, #+12]
    379          		return -ENODEV;
    380          
    381          	return 0;
   \      0x2AC   0xE28D'D014        ADD      SP,SP,#+20
   \      0x2B0   0xE311'0001        TST      R1,#0x1
   \      0x2B4   0x13E0'002B        MVNNE    R0,#+43
   \      0x2B8   0x03A0'0000        MOVEQ    R0,#+0
   \      0x2BC   0xE8BD'8FF0        POP      {R4-R11,PC}
   \                     ??classd_configure_21:
   \      0x2C0   0xE3A0'0B40        MOV      R0,#+65536
   \      0x2C4   0xEAFF'FFBC        B        ??classd_configure_13
   \                     ??classd_configure_22:
   \      0x2C8   0xE3A0'0B40        MOV      R0,#+65536
   \      0x2CC   0xE380'0F40        ORR      R0,R0,#0x100
   \      0x2D0   0xEAFF'FFB9        B        ??classd_configure_13
   \                     ??classd_configure_11:
   \      0x2D4   0xE599'0000        LDR      R0,[R9, #+0]
   \      0x2D8   0xE350'0002        CMP      R0,#+2
   \      0x2DC   0x9AFF'FF60        BLS      ??classd_configure_4
   \      0x2E0   0x....'....        LDR      R0,??DataTable6_6
   \                     ??classd_configure_23:
   \      0x2E4   0x....'....        BL       printf
   \      0x2E8   0xEAFF'FF5D        B        ??classd_configure_4
   \                     ??classd_configure_24:
   \      0x2EC   0xE380'0980        ORR      R0,R0,#0x200000
   \      0x2F0   0xEAFF'FFBB        B        ??classd_configure_14
   \                     ??classd_configure_25:
   \      0x2F4   0xE380'09C0        ORR      R0,R0,#0x300000
   \      0x2F8   0xEAFF'FFB9        B        ??classd_configure_14
   \                     ??classd_configure_15:
   \      0x2FC   0xE599'0000        LDR      R0,[R9, #+0]
   \      0x300   0xE350'0002        CMP      R0,#+2
   \      0x304   0x9AFF'FF56        BLS      ??classd_configure_4
   \      0x308   0xE286'0F42        ADD      R0,R6,#+264
   \      0x30C   0xEAFF'FFF4        B        ??classd_configure_23
   \                     ??classd_configure_26:
   \      0x310   0xE3A0'3450        MOV      R3,#+1342177280
   \      0x314   0xEAFF'FFC2        B        ??classd_configure_17
   \                     ??classd_configure_27:
   \      0x318   0xE3A0'35C0        MOV      R3,#+805306368
   \      0x31C   0xEAFF'FFC0        B        ??classd_configure_17
   \                     ??classd_configure_18:
   \      0x320   0xE599'0000        LDR      R0,[R9, #+0]
   \      0x324   0xE350'0002        CMP      R0,#+2
   \      0x328   0x9AFF'FF4D        BLS      ??classd_configure_4
   \      0x32C   0xE286'00E4        ADD      R0,R6,#+228
   \      0x330   0xEAFF'FFEB        B        ??classd_configure_23
    382          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x0000'0500        DC32 1'280, 1

   \              0x0000'0001
    383          

   \                                 In section SOFTPACK, align 4, keep-with-next
    384          void classd_disable(struct _classd_desc *desc)
    385          {
   \                     classd_disable:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    386          	uint32_t id = get_classd_id_from_addr(desc->addr);
   \        0x4   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x8   0x....'....        BL       get_classd_id_from_addr
   \        0xC   0xE1A0'4000        MOV      R4,R0
    387          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    388          	pmc_disable_audio();
   \       0x10   0x....'....        BL       pmc_disable_audio
    389          #endif
    390          	pmc_disable_gck(id);
   \       0x14   0xE1A0'0004        MOV      R0,R4
   \       0x18   0x....'....        BL       pmc_disable_gck
    391          	pmc_disable_peripheral(id);
   \       0x1C   0xE1A0'0004        MOV      R0,R4
   \       0x20   0xE8BD'4010        POP      {R4,LR}
   \       0x24   0x....'....        B        pmc_disable_peripheral  ;; tailcall
    392          }
    393          

   \                                 In section SOFTPACK, align 4, keep-with-next
    394          void classd_swap_channels(struct _classd_desc *desc, bool swap)
    395          {
    396          	if (swap) {
   \                     classd_swap_channels:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE351'0000        CMP      R1,#+0
    397          		desc->addr->CLASSD_INTPMR |= CLASSD_INTPMR_SWAP;
   \        0x8   0x1590'1008        LDRNE    R1,[R0, #+8]
   \        0xC   0x1381'2A80        ORRNE    R2,R1,#0x80000
   \       0x10   0x1580'2008        STRNE    R2,[R0, #+8]
    398          	} else {
    399          		desc->addr->CLASSD_INTPMR &= ~CLASSD_INTPMR_SWAP;
   \       0x14   0x0590'3008        LDREQ    R3,[R0, #+8]
   \       0x18   0x03C3'1A80        BICEQ    R1,R3,#0x80000
   \       0x1C   0x0580'1008        STREQ    R1,[R0, #+8]
    400          	}
    401          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
    402          

   \                                 In section SOFTPACK, align 4, keep-with-next
    403          void classd_set_equalizer(struct _classd_desc *desc, enum _classd_eqcfg eqcfg)
    404          {
    405          	_set_eqcfg_bits(eqcfg, &desc->addr->CLASSD_INTPMR);
   \                     classd_set_equalizer:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE1A0'3001        MOV      R3,R1
   \        0x8   0xE3A0'2000        MOV      R2,#+0
   \        0xC   0xE353'000C        CMP      R3,#+12
   \       0x10   0xE280'0008        ADD      R0,R0,#+8
   \       0x14   0x8A00'0021        BHI      ??classd_set_equalizer_1
   \       0x18   0xE7DF'C003        LDRB     R12,[PC, R3]
   \       0x1C   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??classd_set_equalizer_0:
   \       0x20   0x1A 0x19          DC8      0x1A,0x19,0x17,0x15

   \              0x17 0x15
   \       0x24   0x13 0x11          DC8      0x13,0x11,0xF,0xD

   \              0x0F 0x0D
   \       0x28   0x0B 0x09          DC8      0xB,0x9,0x7,0x5

   \              0x07 0x05
   \       0x2C   0x03 0x00          DC8      0x3,0x0,0x0,0x0

   \              0x00 0x00
   \                     ??classd_set_equalizer_2:
   \       0x30   0xE3A0'26C0        MOV      R2,#+201326592
   \       0x34   0xEA00'0014        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_4:
   \       0x38   0xE3A0'26B0        MOV      R2,#+184549376
   \       0x3C   0xEA00'0012        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_5:
   \       0x40   0xE3A0'26A0        MOV      R2,#+167772160
   \       0x44   0xEA00'0010        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_6:
   \       0x48   0xE3A0'2690        MOV      R2,#+150994944
   \       0x4C   0xEA00'000E        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_7:
   \       0x50   0xE3A0'2680        MOV      R2,#+134217728
   \       0x54   0xEA00'000C        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_8:
   \       0x58   0xE3A0'2670        MOV      R2,#+117440512
   \       0x5C   0xEA00'000A        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_9:
   \       0x60   0xE3A0'2660        MOV      R2,#+100663296
   \       0x64   0xEA00'0008        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_10:
   \       0x68   0xE3A0'2650        MOV      R2,#+83886080
   \       0x6C   0xEA00'0006        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_11:
   \       0x70   0xE3A0'2640        MOV      R2,#+67108864
   \       0x74   0xEA00'0004        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_12:
   \       0x78   0xE3A0'27C0        MOV      R2,#+50331648
   \       0x7C   0xEA00'0002        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_13:
   \       0x80   0xE3A0'2780        MOV      R2,#+33554432
   \       0x84   0xEA00'0000        B        ??classd_set_equalizer_3
   \                     ??classd_set_equalizer_14:
   \       0x88   0xE3A0'2740        MOV      R2,#+16777216
   \                     ??classd_set_equalizer_3:
   \       0x8C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x90   0xE3C1'36F0        BIC      R3,R1,#0xF000000
   \       0x94   0xE182'2003        ORR      R2,R2,R3
   \       0x98   0xE580'2000        STR      R2,[R0, #+0]
   \       0x9C   0xE12F'FF1E        BX       LR
   \                     ??classd_set_equalizer_1:
   \       0xA0   0x....'....        LDR      R0,??DataTable6_3
   \       0xA4   0xE590'C000        LDR      R12,[R0, #+0]
   \       0xA8   0xE35C'0003        CMP      R12,#+3
   \       0xAC   0x....'....        LDRCS    R0,??DataTable6_7
   \       0xB0   0x....'....        BCS      printf           ;; tailcall
    406          }
   \       0xB4   0xE12F'FF1E        BX       LR               ;; return
    407          

   \                                 In section SOFTPACK, align 4, keep-with-next
    408          void classd_enable_channels(struct _classd_desc *desc, bool left, bool right)
    409          {
    410          	uint32_t bits = 0;
    411          	if (left)
    412          		bits |= CLASSD_MR_LEN;
    413          	if (right)
    414          		bits |= CLASSD_MR_REN;
    415          	desc->addr->CLASSD_MR |= bits;
   \                     classd_enable_channels:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xE351'0000        CMP      R1,#+0
   \        0xC   0x13A0'3001        MOVNE    R3,#+1
   \       0x10   0xE352'0000        CMP      R2,#+0
   \       0x14   0x1383'3010        ORRNE    R3,R3,#0x10
   \       0x18   0x....'....        B        ?Subroutine0
    416          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x4   0xE183'1001        ORR      R1,R3,R1
   \        0x8                      REQUIRE ??Subroutine2_0
   \        0x8                      ;; // Fall through to label ??Subroutine2_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??Subroutine2_0:
   \        0x0   0xE580'1004        STR      R1,[R0, #+4]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    417          

   \                                 In section SOFTPACK, align 4, keep-with-next
    418          void classd_disable_channels(struct _classd_desc *desc, bool left, bool right)
    419          {
    420          	uint32_t bits = 0;
    421          	if (left)
    422          		bits |= CLASSD_MR_LEN;
    423          	if (right)
    424          		bits |= CLASSD_MR_REN;
    425          	desc->addr->CLASSD_MR &= ~bits;
   \                     classd_disable_channels:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xE351'0000        CMP      R1,#+0
   \        0xC   0x13A0'3001        MOVNE    R3,#+1
   \       0x10   0xE352'0000        CMP      R2,#+0
   \       0x14   0x1383'3010        ORRNE    R3,R3,#0x10
   \       0x18   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x1C   0xE1C1'1003        BIC      R1,R1,R3
   \       0x20   0x....'....        B        ??Subroutine2_0
    426          }
    427          

   \                                 In section SOFTPACK, align 4, keep-with-next
    428          void classd_set_left_attenuation(struct _classd_desc *desc, uint8_t attn)
    429          {
    430          	if (attn > (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos))
    431          		attn = (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos);
    432          
    433          	uint32_t intpmr = desc->addr->CLASSD_INTPMR & ~CLASSD_INTPMR_ATTL_Msk;
   \                     classd_set_left_attenuation:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE351'007F        CMP      R1,#+127
   \        0x8   0x83A0'107F        MOVHI    R1,#+127
    434          	desc->addr->CLASSD_INTPMR = intpmr | CLASSD_INTPMR_ATTL(attn);
   \        0xC   0xE201'107F        AND      R1,R1,#0x7F
   \       0x10   0xE590'2008        LDR      R2,[R0, #+8]
   \       0x14   0xE1A0'23A2        LSR      R2,R2,#+7
   \       0x18   0xE181'1382        ORR      R1,R1,R2, LSL #+7
   \       0x1C   0x....'....        B        ?Subroutine1
    435          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE580'1008        STR      R1,[R0, #+8]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    436          

   \                                 In section SOFTPACK, align 4, keep-with-next
    437          void classd_set_right_attenuation(struct _classd_desc *desc, uint8_t attn)
    438          {
    439          	if (attn > (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos))
    440          		attn = (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos);
    441          
    442          	uint32_t intpmr = desc->addr->CLASSD_INTPMR & ~CLASSD_INTPMR_ATTR_Msk;
   \                     classd_set_right_attenuation:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE351'0080        CMP      R1,#+128
    443          	desc->addr->CLASSD_INTPMR = intpmr | CLASSD_INTPMR_ATTR(attn);
   \        0x8   0xE3A0'3C7F        MOV      R3,#+32512
   \        0xC   0x23A0'107F        MOVCS    R1,#+127
   \       0x10   0xE003'1401        AND      R1,R3,R1, LSL #+8
   \       0x14   0xE590'2008        LDR      R2,[R0, #+8]
   \       0x18   0xE3C2'2C7F        BIC      R2,R2,#0x7F00
   \       0x1C   0xE181'1002        ORR      R1,R1,R2
   \       0x20                      REQUIRE ?Subroutine1
   \       0x20                      ;; // Fall through to label ?Subroutine1
    444          }
    445          

   \                                 In section SOFTPACK, align 4, keep-with-next
    446          void classd_volume_mute(struct _classd_desc *desc, bool left, bool right)
    447          {
    448          	uint32_t bits = 0;
    449          	if (left)
    450          		bits |= CLASSD_MR_LMUTE;
    451          	if (right)
    452          		bits |= CLASSD_MR_RMUTE;
    453          	desc->addr->CLASSD_MR |= bits;
   \                     classd_volume_mute:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xE351'0000        CMP      R1,#+0
   \        0xC   0x13A0'3002        MOVNE    R3,#+2
   \       0x10   0xE352'0000        CMP      R2,#+0
   \       0x14   0x1383'3020        ORRNE    R3,R3,#0x20
   \       0x18                      REQUIRE ?Subroutine0
   \       0x18                      ;; // Fall through to label ?Subroutine0
    454          }
    455          

   \                                 In section SOFTPACK, align 4, keep-with-next
    456          void classd_volume_unmute(struct _classd_desc *desc, bool left, bool right)
    457          {
    458          	uint32_t bits = 0;
    459          	if (left)
    460          		bits |= CLASSD_MR_LMUTE;
    461          	if (right)
    462          		bits |= CLASSD_MR_RMUTE;
    463          	desc->addr->CLASSD_MR &= ~bits;
   \                     classd_volume_unmute:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xE351'0000        CMP      R1,#+0
   \        0xC   0x13A0'3002        MOVNE    R3,#+2
   \       0x10   0xE352'0000        CMP      R2,#+0
   \       0x14   0x1383'3020        ORRNE    R3,R3,#0x20
   \       0x18   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x1C   0xE1C1'1003        BIC      R1,R1,R3
   \       0x20   0x....'....        B        ??Subroutine2_0
    464          }
    465          

   \                                 In section SOFTPACK, align 4, keep-with-next
    466          int classd_transfer(struct _classd_desc* desc, struct _buffer* buf, struct _callback* cb)
    467          {
   \                     classd_transfer:
   \        0x0   0xE92D'41FC        PUSH     {R2-R8,LR}
   \        0x4   0xE1A0'5000        MOV      R5,R0
   \        0x8   0xE1B0'6001        MOVS     R6,R1
   \        0xC   0xE1A0'8002        MOV      R8,R2
    468          	uint8_t tmode;
    469          
    470          	tmode = desc->transfer_mode;
   \       0x10   0xE5D5'7008        LDRB     R7,[R5, #+8]
    471          
    472          	if ((buf == NULL) || (buf->size == 0))
   \       0x14   0x0A00'0002        BEQ      ??classd_transfer_0
   \       0x18   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x1A00'0001        BNE      ??classd_transfer_1
    473          		return -EINVAL;
   \                     ??classd_transfer_0:
   \       0x24   0xE3E0'001B        MVN      R0,#+27
   \       0x28   0xE8BD'81F6        POP      {R1,R2,R4-R8,PC}
    474          
    475          	if (buf->attr & CLASSD_BUF_ATTR_WRITE) {
   \                     ??classd_transfer_1:
   \       0x2C   0xE5D6'0008        LDRB     R0,[R6, #+8]
   \       0x30   0xE310'0001        TST      R0,#0x1
   \       0x34   0x0A00'0056        BEQ      ??classd_transfer_2
    476          		mutex_lock(&desc->tx.mutex);
   \       0x38   0xE285'0010        ADD      R0,R5,#+16
   \       0x3C   0xE3A0'4000        MOV      R4,#+0
   \       0x40   0x....'....        BL       mutex_lock
    477          
    478          		desc->tx.transferred = 0;
   \       0x44   0xE1C5'42B0        STRH     R4,[R5, #+32]
    479          		desc->tx.buffer.data = buf->data;
   \       0x48   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x4C   0xE585'0014        STR      R0,[R5, #+20]
    480          		desc->tx.buffer.size = buf->size;
   \       0x50   0xE596'1004        LDR      R1,[R6, #+4]
   \       0x54   0xE585'1018        STR      R1,[R5, #+24]
    481          		desc->tx.buffer.attr = buf->attr;
   \       0x58   0xE596'0008        LDR      R0,[R6, #+8]
    482          
    483          		callback_copy(&desc->tx.callback, cb);
   \       0x5C   0xE1A0'1008        MOV      R1,R8
   \       0x60   0xE585'001C        STR      R0,[R5, #+28]
   \       0x64   0xE285'0024        ADD      R0,R5,#+36
   \       0x68   0x....'....        BL       callback_copy
    484          
    485          		if (tmode == CLASSD_MODE_DMA)
   \       0x6C   0xE357'0001        CMP      R7,#+1
   \       0x70   0x1A00'002B        BNE      ??classd_transfer_3
    486          			_classd_dma_transfer(desc, buf);
   \       0x74   0xE285'003C        ADD      R0,R5,#+60
   \       0x78   0xE3A0'1000        MOV      R1,#+0
   \       0x7C   0xE3A0'2000        MOV      R2,#+0
   \       0x80   0xE3A0'3000        MOV      R3,#+0
   \       0x84   0xE880'000E        STM      R0,{R1-R3}
   \       0x88   0xE596'1000        LDR      R1,[R6, #+0]
   \       0x8C   0xE5D5'000E        LDRB     R0,[R5, #+14]
   \       0x90   0xE585'103C        STR      R1,[R5, #+60]
   \       0x94   0xE595'2000        LDR      R2,[R5, #+0]
   \       0x98   0xE350'0000        CMP      R0,#+0
   \       0x9C   0xE282'3010        ADD      R3,R2,#+16
   \       0xA0   0xE585'3040        STR      R3,[R5, #+64]
   \       0xA4   0x0A00'0007        BEQ      ??classd_transfer_4
   \       0xA8   0xE5D5'100F        LDRB     R1,[R5, #+15]
   \       0xAC   0xE351'0000        CMP      R1,#+0
   \       0xB0   0x0A00'0004        BEQ      ??classd_transfer_4
   \       0xB4   0xE3A0'0002        MOV      R0,#+2
   \       0xB8   0xE585'0030        STR      R0,[R5, #+48]
   \       0xBC   0xE596'1004        LDR      R1,[R6, #+4]
   \       0xC0   0xE1A0'2121        LSR      R2,R1,#+2
   \       0xC4   0xEA00'0003        B        ??classd_transfer_5
   \                     ??classd_transfer_4:
   \       0xC8   0xE3A0'0001        MOV      R0,#+1
   \       0xCC   0xE585'0030        STR      R0,[R5, #+48]
   \       0xD0   0xE596'1004        LDR      R1,[R6, #+4]
   \       0xD4   0xE1A0'20A1        LSR      R2,R1,#+1
   \                     ??classd_transfer_5:
   \       0xD8   0xE595'002C        LDR      R0,[R5, #+44]
   \       0xDC   0xE585'2044        STR      R2,[R5, #+68]
   \       0xE0   0xE3A0'3001        MOV      R3,#+1
   \       0xE4   0xE285'203C        ADD      R2,R5,#+60
   \       0xE8   0xE285'1030        ADD      R1,R5,#+48
   \       0xEC   0x....'....        BL       dma_configure_transfer
   \       0xF0   0xE1A0'2005        MOV      R2,R5
   \       0xF4   0x....'....        LDR      R1,??DataTable6_8
   \       0xF8   0xE1A0'000D        MOV      R0,SP
   \       0xFC   0x....'....        BL       callback_set
   \      0x100   0xE595'002C        LDR      R0,[R5, #+44]
   \      0x104   0xE1A0'100D        MOV      R1,SP
   \      0x108   0x....'....        BL       dma_set_callback
   \      0x10C   0xE595'1044        LDR      R1,[R5, #+68]
   \      0x110   0xE595'003C        LDR      R0,[R5, #+60]
   \      0x114   0x....'....        BL       cache_clean_region
   \      0x118   0xE595'002C        LDR      R0,[R5, #+44]
   \      0x11C   0x....'....        BL       dma_start_transfer
   \      0x120   0xEA00'001B        B        ??classd_transfer_2
    487          		else if (tmode == CLASSD_MODE_POLLING)
   \                     ??classd_transfer_3:
   \      0x124   0xE357'0000        CMP      R7,#+0
   \      0x128   0x1A00'0019        BNE      ??classd_transfer_2
    488          			_classd_polling_transfer(desc, buf);
   \      0x12C   0xE596'1004        LDR      R1,[R6, #+4]
   \      0x130   0xE596'0000        LDR      R0,[R6, #+0]
   \      0x134   0xE1A0'20A1        LSR      R2,R1,#+1
   \      0x138   0xE080'1082        ADD      R1,R0,R2, LSL #+1
   \                     ??classd_transfer_6:
   \      0x13C   0xE595'2000        LDR      R2,[R5, #+0]
   \      0x140   0xE592'3020        LDR      R3,[R2, #+32]
   \      0x144   0xE313'0001        TST      R3,#0x1
   \      0x148   0x0A00'000A        BEQ      ??classd_transfer_7
   \      0x14C   0xE5D5'E00E        LDRB     LR,[R5, #+14]
   \      0x150   0xE3A0'3000        MOV      R3,#+0
   \      0x154   0xE3A0'C000        MOV      R12,#+0
   \      0x158   0xE35E'0000        CMP      LR,#+0
   \      0x15C   0xE5D5'E00F        LDRB     LR,[R5, #+15]
   \      0x160   0x10D0'30B2        LDRHNE   R3,[R0], #+2
   \      0x164   0xE35E'0000        CMP      LR,#+0
   \      0x168   0x10D0'C0B2        LDRHNE   R12,[R0], #+2
   \      0x16C   0x11A0'C80C        LSLNE    R12,R12,#+16
   \      0x170   0xE183'300C        ORR      R3,R3,R12
   \      0x174   0xE582'3010        STR      R3,[R2, #+16]
   \                     ??classd_transfer_7:
   \      0x178   0xE150'0001        CMP      R0,R1
   \      0x17C   0x3AFF'FFEE        BCC      ??classd_transfer_6
   \      0x180   0xE285'0010        ADD      R0,R5,#+16
   \      0x184   0x....'....        BL       mutex_unlock
   \      0x188   0xE3A0'1000        MOV      R1,#+0
   \      0x18C   0xE285'0024        ADD      R0,R5,#+36
   \      0x190   0x....'....        BL       callback_call
    489          	}
    490          	return 0;
   \                     ??classd_transfer_2:
   \      0x194   0xE3A0'0000        MOV      R0,#+0
   \      0x198   0xE8BD'81F6        POP      {R1,R2,R4-R8,PC}  ;; return
    491          }
    492          

   \                                 In section SOFTPACK, align 4, keep-with-next
    493          bool classd_tx_transfer_is_done(struct _classd_desc* desc)
    494          {
   \                     classd_tx_transfer_is_done:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    495          	return (!mutex_is_locked(&desc->tx.mutex));
   \        0x4   0xE280'0010        ADD      R0,R0,#+16
   \        0x8   0x....'....        BL       mutex_is_locked
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x03A0'0001        MOVEQ    R0,#+1
   \       0x14   0x13A0'0000        MOVNE    R0,#+0
   \       0x18   0xE8BD'8002        POP      {R1,PC}          ;; return
    496          }
    497          

   \                                 In section SOFTPACK, align 4, keep-with-next
    498          void classd_tx_stop(struct _classd_desc* desc)
    499          {
   \                     classd_tx_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    500          	if (desc->transfer_mode == CLASSD_MODE_DMA) {
   \        0x8   0xE5D4'0008        LDRB     R0,[R4, #+8]
   \        0xC   0xE350'0001        CMP      R0,#+1
   \       0x10   0x1A00'0006        BNE      ??classd_tx_stop_0
    501          		if (desc->tx.dma.channel){
   \       0x14   0xE594'002C        LDR      R0,[R4, #+44]
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0003        BEQ      ??classd_tx_stop_0
    502          			dma_stop_transfer(desc->tx.dma.channel);
   \       0x20   0x....'....        BL       dma_stop_transfer
    503          			mutex_unlock(&desc->tx.mutex);
   \       0x24   0xE284'0010        ADD      R0,R4,#+16
   \       0x28   0xE8BD'4010        POP      {R4,LR}
   \       0x2C   0x....'....        B        mutex_unlock     ;; tailcall
    504          		}
    505          	}
    506          }
   \                     ??classd_tx_stop_0:
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     audio_info

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x000D'844D        DC32     0xd844d

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x0016'0419        DC32     0x160419

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x....'....        DC32     _classd_dma_transfer_callback

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid equalizer config %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x65 0x71    

   \              0x75 0x61    

   \              0x6C 0x69    

   \              0x7A 0x65    

   \              0x72 0x20    

   \              0x63 0x6F    

   \              0x6E 0x66    

   \              0x69 0x67    

   \              0x20 0x25    

   \              0x75 0x0D    

   \              0x0A 0x00
   \       0x2A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid mode %u\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6D 0x6F    

   \              0x64 0x65    

   \              0x20 0x25    

   \              0x75 0x0A    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x64 0x65          DC8 "desc->tx.dma.channel != 0"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x74 0x78    

   \              0x2E 0x64    

   \              0x6D 0x61    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x20 0x21    

   \              0x3D 0x20    

   \              0x30 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _classd_dma_transfer_callback
         0   -> callback_call
         8   -> dma_reset_channel
         8   -> mutex_unlock
      56   classd_configure
        56   -> __aeabi_assert
        56   -> __iar_EmptyStepPoint
        56   -> dma_allocate_channel
        56   -> get_classd_id_from_addr
        56   -> pmc_configure_audio
        56   -> pmc_configure_peripheral
        56   -> pmc_enable_audio
        56   -> pmc_get_audio_pmc_clock
        56   -> printf
       8   classd_disable
         8   -> get_classd_id_from_addr
         8   -> pmc_disable_audio
         8   -> pmc_disable_gck
         0   -> pmc_disable_peripheral
       0   classd_disable_channels
       0   classd_enable_channels
       0   classd_set_equalizer
         0   -> printf
       0   classd_set_left_attenuation
       0   classd_set_right_attenuation
       0   classd_swap_channels
      32   classd_transfer
        32   -> cache_clean_region
        32   -> callback_call
        32   -> callback_copy
        32   -> callback_set
        32   -> dma_configure_transfer
        32   -> dma_set_callback
        32   -> dma_start_transfer
        32   -> mutex_lock
        32   -> mutex_unlock
       8   classd_tx_stop
         8   -> dma_stop_transfer
         0   -> mutex_unlock
       8   classd_tx_transfer_is_done
         8   -> mutex_is_locked
       0   classd_volume_mute
       0   classd_volume_unmute


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       8  ??Subroutine2_0
       8  ?Subroutine0
       8  ?Subroutine1
      44  ?_4
      32  ?_5
      28  ?_6
       8  ?_7
      40  _classd_dma_transfer_callback
     384  audio_info
     820  classd_configure
      40  classd_disable
      36  classd_disable_channels
      28  classd_enable_channels
     184  classd_set_equalizer
      32  classd_set_left_attenuation
      32  classd_set_right_attenuation
      36  classd_swap_channels
     412  classd_transfer
      52  classd_tx_stop
      28  classd_tx_transfer_is_done
      24  classd_volume_mute
      36  classd_volume_unmute

 
   496 bytes in section .rodata
 1'860 bytes in section SOFTPACK
 
 1'860 bytes of CODE  memory
   496 bytes of CONST memory

Errors: none
Warnings: none
