###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         30/Nov/2020  13:24:58
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW62B9.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List\usart.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\Obj\usart.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usart.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup usart_module Working with USART
     31           * \section Purpose
     32           * The USART driver provides the interface to configure and use the USART peripheral.\n
     33           *
     34           * The USART supports several kinds of communication modes such as full-duplex asynchronous/
     35           * synchronous serial communication,RS485 with driver control signal,ISO7816,SPI and Test modes.
     36           *
     37           * To start a USART transfer with \ref dmad_module "DMA" support, the user could follow these steps:
     38           * <ul>
     39           * <li> Configure USART with expected mode and baudrate(see \ref usart_configure), which could be done by:
     40           * -# Resetting and disabling transmitter and receiver by setting US_CR(Control Register). </li>
     41           * -# Configuring the USART in a specific mode by setting USART_MODE bits in US_MR(Mode Register) </li>
     42           * -# Setting baudrate which is different from mode to mode.
     43             </li>
     44           * <li> Enable transmitter or receiver respectively by set US_CR_TXEN or US_CR_RXEN in US_CR.</li>
     45           * <li> Read from or write to the peripheral with  \ref dmad_module </li>
     46           * </ul>
     47           *
     48           * \section Usage
     49           * <ul>
     50           * <li>  Enable or disable USART transmitter or receiver using
     51           * usart_set_transmitter_enabled() and usart_set_receiver_enabled().
     52           * <li>  Enable or disable USART interrupt using usart_enable_it() or usart_disable_it().
     53           * </li>
     54           * </ul>
     55           *
     56           * For more accurate information, please look at the USART section of the
     57           * Datasheet.
     58           *
     59           * Related files :\n
     60           * \ref usart.c\n
     61           * \ref usart.h\n
     62          */
     63          
     64          /**
     65           * \file
     66           *
     67           * Implementation of USART (Universal Synchronous Asynchronous Receiver Transmitter)
     68           * controller.
     69           *
     70           */
     71          /*-----------------------------------------------------------------------------
     72          *         Headers
     73           *---------------------------------------------------------------------------*/
     74          
     75          #include "chip.h"
     76          #include "compiler.h"
     77          #include "serial/usart.h"
     78          #include "peripherals/pmc.h"
     79          
     80          #include "trace.h"
     81          #include "io.h"
     82          
     83          #include <assert.h>
     84          #include <string.h>
     85          
     86          /*-----------------------------------------------------------------------------
     87          *
     88           *---------------------------------------------------------------------------*/
     89          
     90          /* The CD value scope programmed in MR register. */
     91          #define MIN_CD_VALUE                  0x01
     92          #define MIN_CD_VALUE_SPI              0x04
     93          #define MAX_CD_VALUE                  US_BRGR_CD_Msk
     94          
     95          /* The receiver sampling divide of baudrate clock. */
     96          #define HIGH_FRQ_SAMPLE_DIV           16
     97          #define LOW_FRQ_SAMPLE_DIV            8
     98          
     99          /*----------------------------------------------------------------------------
    100           *         Exported functions
    101           *----------------------------------------------------------------------------*/
    102          

   \                                 In section SOFTPACK, align 4, keep-with-next
    103          void usart_reset_status(Usart *usart)
    104          {
    105          	usart->US_CR = US_CR_RSTSTA;
   \                     usart_reset_status:
   \        0x0   0xE3A0'1F40        MOV      R1,#+256
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    106          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    107          

   \                                 In section SOFTPACK, align 4, keep-with-next
    108          void usart_configure(Usart *usart, uint32_t mode, uint32_t baudrate)
    109          {
   \                     usart_configure:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
    110          	uint32_t clock = pmc_get_peripheral_clock(get_usart_id_from_addr(usart));
   \       0x10   0x....'....        BL       get_usart_id_from_addr
   \       0x14   0x....'....        BL       pmc_get_peripheral_clock
    111          	/* Reset and disable receiver & transmitter */
    112          	uint32_t control = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
    113          	/* apply */
    114          	usart->US_CR = control;
   \       0x18   0xE3A0'10AC        MOV      R1,#+172
    115          	/* Configure mode */
    116          	usart->US_MR = mode;
    117          
    118          	/* Configure baudrate */
    119          	/* Asynchronous, no oversampling */
    120          	if (((mode & US_MR_SYNC) == 0) && ((mode & US_MR_OVER) == 0))
   \       0x1C   0xE3A0'2A80        MOV      R2,#+524288
   \       0x20   0xE584'1000        STR      R1,[R4, #+0]
   \       0x24   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x28   0xE584'5004        STR      R5,[R4, #+4]
   \       0x2C   0xE112'0005        TST      R2,R5
   \       0x30   0x1A00'0003        BNE      ??usart_configure_0
    121          		usart->US_BRGR = (clock / baudrate) / 16;
   \       0x34   0xE1A0'1006        MOV      R1,R6
   \       0x38   0x....'....        BL       __aeabi_uidiv
   \       0x3C   0xE1A0'0220        LSR      R0,R0,#+4
   \       0x40   0xE584'0020        STR      R0,[R4, #+32]
    122          
    123          	/* Disable all interrupts */
    124          	usart->US_IDR = 0xFFFFFFFF;
   \                     ??usart_configure_0:
   \       0x44   0xE3E0'1000        MVN      R1,#+0
   \       0x48   0xE584'100C        STR      R1,[R4, #+12]
    125          	/* Enable receiver and transmitter */
    126          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
   \       0x4C   0xE3A0'0050        MOV      R0,#+80
   \       0x50   0xE584'0000        STR      R0,[R4, #+0]
    127          }
   \       0x54   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    128          

   \                                 In section SOFTPACK, align 4, keep-with-next
    129          uint32_t usart_get_status(Usart *usart)
    130          {
    131          	return usart->US_CSR;
   \                     usart_get_status:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    132          }
    133          

   \                                 In section SOFTPACK, align 4, keep-with-next
    134          uint32_t usart_get_masked_status(Usart *usart)
    135          {
   \                     usart_get_masked_status:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    136          	uint32_t status;
    137          	assert(usart != NULL);
   \        0x8   0x1A00'0004        BNE      ??usart_get_masked_status_0
   \        0xC   0xE3A0'2089        MOV      R2,#+137
   \       0x10   0x....'....        LDR      R1,??DataTable8
   \       0x14   0x....'....        ADR      R0,?_1
   \       0x18   0x....'....        BL       __aeabi_assert
   \       0x1C   0x....'....        BL       __iar_EmptyStepPoint
    138          	status = usart->US_CSR;
   \                     ??usart_get_masked_status_0:
   \       0x20   0xE594'0014        LDR      R0,[R4, #+20]
    139          	status &= usart->US_IMR;
   \       0x24   0xE594'1010        LDR      R1,[R4, #+16]
    140          	return status;
   \       0x28   0xE001'0000        AND      R0,R1,R0
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
    141          }
    142          

   \                                 In section SOFTPACK, align 4, keep-with-next
    143          void usart_enable_it(Usart *usart, uint32_t mode)
    144          {
    145          	usart->US_IER = mode;
   \                     usart_enable_it:
   \        0x0   0xE580'1008        STR      R1,[R0, #+8]
    146          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    147          

   \                                 In section SOFTPACK, align 4, keep-with-next
    148          void usart_disable_it(Usart *usart, uint32_t mode)
    149          {
    150          	usart->US_IDR = mode;
   \                     usart_disable_it:
   \        0x0   0xE580'100C        STR      R1,[R0, #+12]
    151          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    152          

   \                                 In section SOFTPACK, align 4, keep-with-next
    153          uint32_t usart_get_it_mask(Usart *usart)
    154          {
    155          	return usart->US_IMR;
   \                     usart_get_it_mask:
   \        0x0   0xE590'0010        LDR      R0,[R0, #+16]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    156          }
    157          

   \                                 In section SOFTPACK, align 4, keep-with-next
    158          void usart_set_transmitter_enabled(Usart *usart, uint8_t enabled)
    159          {
    160          	if (enabled) {
   \                     usart_set_transmitter_enabled:
   \        0x0   0xE351'0000        CMP      R1,#+0
    161          		usart->US_CR = US_CR_TXEN;
   \        0x4   0x13A0'1040        MOVNE    R1,#+64
   \        0x8   0x1580'1000        STRNE    R1,[R0, #+0]
    162          	} else {
    163          		usart->US_CR = US_CR_TXDIS;
   \        0xC   0x03A0'2080        MOVEQ    R2,#+128
   \       0x10   0x0580'2000        STREQ    R2,[R0, #+0]
    164          	}
    165          }
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    166          

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void usart_set_receiver_enabled(Usart *usart, uint8_t enabled)
    168          {
    169          	if (enabled) {
   \                     usart_set_receiver_enabled:
   \        0x0   0xE351'0000        CMP      R1,#+0
    170          		usart->US_CR = US_CR_RXEN;
   \        0x4   0x13A0'1010        MOVNE    R1,#+16
   \        0x8   0x1580'1000        STRNE    R1,[R0, #+0]
    171          	} else {
    172          		usart->US_CR = US_CR_RXDIS;
   \        0xC   0x03A0'2020        MOVEQ    R2,#+32
   \       0x10   0x0580'2000        STREQ    R2,[R0, #+0]
    173          	}
    174          }
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    175          

   \                                 In section SOFTPACK, align 4, keep-with-next
    176          void usart_set_rts_enabled(Usart *usart, uint8_t enabled)
    177          {
    178          	if (enabled) {
   \                     usart_set_rts_enabled:
   \        0x0   0xE351'0000        CMP      R1,#+0
    179          		usart->US_CR = US_CR_RTSEN;
   \        0x4   0x13A0'1A40        MOVNE    R1,#+262144
   \        0x8   0x1580'1000        STRNE    R1,[R0, #+0]
    180          	} else {
    181          		usart->US_CR = US_CR_RTSDIS;
   \        0xC   0x03A0'2A80        MOVEQ    R2,#+524288
   \       0x10   0x0580'2000        STREQ    R2,[R0, #+0]
    182          	}
    183          }
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    184          

   \                                 In section SOFTPACK, align 4, keep-with-next
    185          void usart_reset_tx(Usart *usart)
    186          {
    187          	/* Reset transmitter */
    188          	usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
   \                     usart_reset_tx:
   \        0x0   0xE3A0'1088        MOV      R1,#+136
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    189          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    190          

   \                                 In section SOFTPACK, align 4, keep-with-next
    191          void usart_set_tx_timeguard(Usart *usart, uint32_t timeguard)
    192          {
    193          	usart->US_TTGR = timeguard;
   \                     usart_set_tx_timeguard:
   \        0x0   0xE580'1028        STR      R1,[R0, #+40]
    194          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    195          

   \                                 In section SOFTPACK, align 4, keep-with-next
    196          void usart_reset_rx(Usart *usart)
    197          {
    198          	/* Reset Receiver */
    199          	usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
   \                     usart_reset_rx:
   \        0x0   0xE3A0'1024        MOV      R1,#+36
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    200          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void usart_set_rx_timeout(Usart *usart, uint32_t baudrate, uint32_t timeout)
    203          {
   \                     usart_set_rx_timeout:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5002        MOV      R5,R2
    204          	uint32_t to = ((timeout * 1000000) / ((1000000000 / baudrate) + 1));
   \        0xC   0x....'....        LDR      R0,??DataTable8_1  ;; 0x3b9aca00
   \       0x10   0x....'....        BL       __aeabi_uidiv
   \       0x14   0xE3A0'2AF4        MOV      R2,#+999424
   \       0x18   0xE280'1001        ADD      R1,R0,#+1
   \       0x1C   0xE382'2F90        ORR      R2,R2,#0x240
   \       0x20   0xE000'0592        MUL      R0,R2,R5
   \       0x24   0x....'....        BL       __aeabi_uidiv
    205          	if (to > US_RTOR_TO_Msk)
   \       0x28   0xE3E0'14FF        MVN      R1,#-16777216
   \       0x2C   0xE3C1'18FE        BIC      R1,R1,#0xFE0000
   \       0x30   0xE150'0001        CMP      R0,R1
    206          		to = US_RTOR_TO_Msk;
   \       0x34   0x81A0'0001        MOVHI    R0,R1
    207          	usart->US_RTOR = US_RTOR_TO(to);
   \       0x38   0xE001'0000        AND      R0,R1,R0
   \       0x3C   0xE584'0024        STR      R0,[R4, #+36]
    208          }
   \       0x40   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    209          

   \                                 In section SOFTPACK, align 4, keep-with-next
    210          void usart_start_tx_break(Usart *usart)
    211          {
    212          	usart->US_CR = US_CR_STTBRK;
   \                     usart_start_tx_break:
   \        0x0   0xE3A0'1F80        MOV      R1,#+512
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    213          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    214          

   \                                 In section SOFTPACK, align 4, keep-with-next
    215          void usart_stop_tx_break(Usart *usart)
    216          {
    217          	usart->US_CR = US_CR_STPBRK;
   \                     usart_stop_tx_break:
   \        0x0   0xE3A0'1E40        MOV      R1,#+1024
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    218          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    219          

   \                                 In section SOFTPACK, align 4, keep-with-next
    220          void usart_start_rx_timeout(Usart *usart)
    221          {
    222          	usart->US_CR = US_CR_STTTO;
   \                     usart_start_rx_timeout:
   \        0x0   0xE3A0'1E80        MOV      R1,#+2048
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    223          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    224          

   \                                 In section SOFTPACK, align 4, keep-with-next
    225          void usart_reset_iterations(Usart *usart)
    226          {
    227          	usart->US_CR = US_CR_RSTIT;
   \                     usart_reset_iterations:
   \        0x0   0xE3A0'1D80        MOV      R1,#+8192
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    228          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    229          

   \                                 In section SOFTPACK, align 4, keep-with-next
    230          void usart_reset_nack(Usart *usart)
    231          {
    232          	usart->US_CR = US_CR_RSTNACK;
   \                     usart_reset_nack:
   \        0x0   0xE3A0'1C40        MOV      R1,#+16384
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    233          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    234          

   \                                 In section SOFTPACK, align 4, keep-with-next
    235          void usart_restart_rx_timeout(Usart *usart)
    236          {
    237          	usart->US_CR = US_CR_RETTO;
   \                     usart_restart_rx_timeout:
   \        0x0   0xE3A0'1C80        MOV      R1,#+32768
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    238          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    239          

   \                                 In section SOFTPACK, align 4, keep-with-next
    240          void usart_write(Usart *usart, uint16_t data, volatile uint32_t timeout)
    241          {
   \                     usart_write:
   \        0x0   0xE92D'001E        PUSH     {R1-R4}
    242          	if (timeout == 0) {
   \        0x4   0xE59D'2004        LDR      R2,[SP, #+4]
   \        0x8   0xE1A0'4001        MOV      R4,R1
   \        0xC   0xE352'0000        CMP      R2,#+0
   \       0x10   0x1A00'0009        BNE      ??usart_write_0
    243          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) ;
   \                     ??usart_write_1:
   \       0x14   0xE590'1014        LDR      R1,[R0, #+20]
   \       0x18   0xE311'0002        TST      R1,#0x2
   \       0x1C   0x0AFF'FFFC        BEQ      ??usart_write_1
    244          	} else {
    245          		while ((usart->US_CSR & US_CSR_TXRDY) == 0) {
    246          			if (timeout == 0) {
    247          				trace_error("usart_write: Timed out.\n\r");
    248          				return;
    249          			}
    250          			timeout--;
    251          		}
    252          	}
    253          	usart->US_THR = data;
   \                     ??usart_write_2:
   \       0x20   0xE580'401C        STR      R4,[R0, #+28]
    254          }
   \                     ??usart_write_3:
   \       0x24   0xE28D'D00C        ADD      SP,SP,#+12
   \       0x28   0xE8BD'0010        POP      {R4}
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
   \                     ??usart_write_4:
   \       0x30   0xE59D'2004        LDR      R2,[SP, #+4]
   \       0x34   0xE242'3001        SUB      R3,R2,#+1
   \       0x38   0xE58D'3004        STR      R3,[SP, #+4]
   \                     ??usart_write_0:
   \       0x3C   0xE590'1014        LDR      R1,[R0, #+20]
   \       0x40   0xE311'0002        TST      R1,#0x2
   \       0x44   0x1AFF'FFF5        BNE      ??usart_write_2
   \       0x48   0xE59D'2004        LDR      R2,[SP, #+4]
   \       0x4C   0xE352'0000        CMP      R2,#+0
   \       0x50   0x1AFF'FFF6        BNE      ??usart_write_4
   \       0x54   0x....'....        LDR      R0,??DataTable8_2
   \       0x58   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x5C   0xE351'0002        CMP      R1,#+2
   \       0x60   0x3AFF'FFEF        BCC      ??usart_write_3
   \       0x64   0xE28D'D00C        ADD      SP,SP,#+12
   \       0x68   0xE8BD'0010        POP      {R4}
   \       0x6C   0x....'....        ADR      R0,?_2
   \       0x70   0x....'....        B        printf           ;; tailcall
    255          

   \                                 In section SOFTPACK, align 4, keep-with-next
    256          uint16_t usart_read(Usart *usart, volatile uint32_t timeout)
    257          {
   \                     usart_read:
   \        0x0   0xE92D'4002        PUSH     {R1,LR}
    258          	if (timeout == 0) {
   \        0x4   0xE59D'2000        LDR      R2,[SP, #+0]
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x1A00'0009        BNE      ??usart_read_0
    259          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) ;
   \                     ??usart_read_1:
   \       0x10   0xE590'1014        LDR      R1,[R0, #+20]
   \       0x14   0xE311'0001        TST      R1,#0x1
   \       0x18   0x0AFF'FFFC        BEQ      ??usart_read_1
    260          	} else {
    261          		while ((usart->US_CSR & US_CSR_RXRDY) == 0) {
    262          			if (timeout == 0) {
    263          				trace_error("usart_read: Timed out.\n\r");
    264          				return 0;
    265          			}
    266          			timeout--;
    267          		}
    268          	}
    269          	return usart->US_RHR;
   \                     ??usart_read_2:
   \       0x1C   0xE590'0018        LDR      R0,[R0, #+24]
   \       0x20   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x24   0xE1A0'0820        LSR      R0,R0,#+16
   \       0x28   0xE8BD'8002        POP      {R1,PC}          ;; return
   \                     ??usart_read_3:
   \       0x2C   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x30   0xE242'3001        SUB      R3,R2,#+1
   \       0x34   0xE58D'3000        STR      R3,[SP, #+0]
   \                     ??usart_read_0:
   \       0x38   0xE590'1014        LDR      R1,[R0, #+20]
   \       0x3C   0xE311'0001        TST      R1,#0x1
   \       0x40   0x1AFF'FFF5        BNE      ??usart_read_2
   \       0x44   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x48   0xE352'0000        CMP      R2,#+0
   \       0x4C   0x1AFF'FFF6        BNE      ??usart_read_3
   \       0x50   0x....'....        LDR      R0,??DataTable8_2
   \       0x54   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x58   0xE351'0001        CMP      R1,#+1
   \       0x5C   0x9A00'0001        BLS      ??usart_read_4
   \       0x60   0x....'....        ADR      R0,?_3
   \       0x64   0x....'....        BL       printf
   \                     ??usart_read_4:
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xE8BD'8002        POP      {R1,PC}
    270          }
    271          

   \                                 In section SOFTPACK, align 4, keep-with-next
    272          bool usart_is_rx_ready(Usart *usart)
    273          {
    274          	return (usart->US_CSR & US_CSR_RXRDY) != 0;
   \                     usart_is_rx_ready:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE200'0001        AND      R0,R0,#0x1
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    275          }
    276          

   \                                 In section SOFTPACK, align 4, keep-with-next
    277          bool usart_is_tx_ready(Usart *usart)
    278          {
    279          	return (usart->US_CSR & US_CSR_TXRDY) != 0;
   \                     usart_is_tx_ready:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE1A0'10A0        LSR      R1,R0,#+1
   \        0x8   0xE201'0001        AND      R0,R1,#0x1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    280          }
    281          

   \                                 In section SOFTPACK, align 4, keep-with-next
    282          bool usart_is_tx_empty(Usart *usart)
    283          {
    284          	return (usart->US_CSR & US_CSR_TXEMPTY) != 0;
   \                     usart_is_tx_empty:
   \        0x0   0xE590'0014        LDR      R0,[R0, #+20]
   \        0x4   0xE1A0'14A0        LSR      R1,R0,#+9
   \        0x8   0xE201'0001        AND      R0,R1,#0x1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    285          }
    286          

   \                                 In section SOFTPACK, align 4, keep-with-next
    287          void usart_put_char(Usart *usart, uint8_t c)
    288          {
    289          	/* Wait for the transmitter to be ready */
    290          	while ((usart->US_CSR & US_CSR_TXEMPTY) == 0);
   \                     usart_put_char:
   \                     ??usart_put_char_0:
   \        0x0   0xE590'2014        LDR      R2,[R0, #+20]
   \        0x4   0xE312'0F80        TST      R2,#0x200
   \        0x8   0x0AFF'FFFC        BEQ      ??usart_put_char_0
    291          	/* Send character */
    292          	/* Force an octet write to avoid race conditions with FIFO mode */
    293          	writeb(&usart->US_THR, c);
   \        0xC   0xE5C0'101C        STRB     R1,[R0, #+28]
    294          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    295          

   \                                 In section SOFTPACK, align 4, keep-with-next
    296          uint8_t usart_get_char(Usart *usart)
    297          {
    298          	while ((usart->US_CSR & US_CSR_RXRDY) == 0);
   \                     usart_get_char:
   \                     ??usart_get_char_0:
   \        0x0   0xE590'1014        LDR      R1,[R0, #+20]
   \        0x4   0xE311'0001        TST      R1,#0x1
   \        0x8   0x0AFF'FFFC        BEQ      ??usart_get_char_0
    299          	/* Force an octet read to avoid race conditions with FIFO mode */
    300          	uint8_t v;
    301          	readb(&usart->US_RHR, &v);
   \        0xC   0xE5D0'0018        LDRB     R0,[R0, #+24]
    302          	return v;
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    303          }
    304          

   \                                 In section SOFTPACK, align 4, keep-with-next
    305          void usart_set_irda_filter(Usart *usart, uint8_t filter)
    306          {
   \                     usart_set_irda_filter:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    307          	assert(usart != NULL);
   \        0xC   0x1A00'0005        BNE      ??usart_set_irda_filter_0
   \       0x10   0xE3A0'2033        MOV      R2,#+51
   \       0x14   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x18   0x....'....        LDR      R1,??DataTable8
   \       0x1C   0x....'....        ADR      R0,?_1
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    308          
    309          	usart->US_IF = filter;
   \                     ??usart_set_irda_filter_0:
   \       0x28   0xE584'504C        STR      R5,[R4, #+76]
    310          	/* Set IrDA mode. */
    311          	usart->US_MR = (usart->US_MR & ~US_MR_USART_MODE_Msk) | US_MR_USART_MODE_IRDA;
   \       0x2C   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x30   0xE3C0'100F        BIC      R1,R0,#0xF
   \       0x34   0xE381'2008        ORR      R2,R1,#0x8
   \       0x38   0xE584'2004        STR      R2,[R4, #+4]
    312          }
   \       0x3C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    313          

   \                                 In section SOFTPACK, align 4, keep-with-next
    314          void usart_set_sync_slave_baudrate(Usart *usart)
    315          {
    316          	usart->US_MR = (usart->US_MR & ~US_MR_USCLKS_Msk) | US_MR_USCLKS_SCK | US_MR_SYNC;
   \                     usart_set_sync_slave_baudrate:
   \        0x0   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x4   0xE381'2F4C        ORR      R2,R1,#0x130
   \        0x8   0xE580'2004        STR      R2,[R0, #+4]
    317          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    318          

   \                                 In section SOFTPACK, align 4, keep-with-next
    319          uint32_t usart_init_hw_handshaking(Usart *usart)
    320          {
    321          	/* The USART should be initialized first as standard RS232. */
    322          	/* Set hardware handshaking mode. */
    323          	usart->US_MR = (usart->US_MR & ~US_MR_USART_MODE_Msk) | US_MR_USART_MODE_HW_HANDSHAKING;
   \                     usart_init_hw_handshaking:
   \        0x0   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x4   0xE3C1'200F        BIC      R2,R1,#0xF
   \        0x8   0xE382'3002        ORR      R3,R2,#0x2
   \        0xC   0xE580'3004        STR      R3,[R0, #+4]
    324          	return 0;
   \       0x10   0xE3A0'0000        MOV      R0,#+0
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    325          }
    326          

   \                                 In section SOFTPACK, align 4, keep-with-next
    327          uint32_t usart_set_async_baudrate(Usart *usart, uint32_t baudrate)
    328          {
   \                     usart_set_async_baudrate:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'6001        MOV      R6,R1
    329          	uint32_t over, cd_fp, cd, fp;
    330          	uint32_t mck;
    331          
    332          	/* get peripheral clock */
    333          	mck = pmc_get_peripheral_clock(get_usart_id_from_addr(usart));
   \        0xC   0x....'....        BL       get_usart_id_from_addr
   \       0x10   0x....'....        BL       pmc_get_peripheral_clock
    334          
    335          	/* Calculate the receiver sampling divide of baudrate clock. */
    336          	if (mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
   \       0x14   0xE150'0206        CMP      R0,R6, LSL #+4
    337          		over = HIGH_FRQ_SAMPLE_DIV;
   \       0x18   0x23A0'5010        MOVCS    R5,#+16
    338          	} else {
    339          		over = LOW_FRQ_SAMPLE_DIV;
   \       0x1C   0x33A0'5008        MOVCC    R5,#+8
    340          	}
    341          
    342          	/* Calculate clock divider according to the fraction calculated formula. */
    343          	cd_fp = (8 * mck + (over * baudrate) / 2) / (over * baudrate);
   \       0x20   0xE001'0596        MUL      R1,R6,R5
   \       0x24   0xE1A0'20A1        LSR      R2,R1,#+1
   \       0x28   0xE082'0180        ADD      R0,R2,R0, LSL #+3
   \       0x2C   0x....'....        BL       __aeabi_uidiv
    344          	cd = cd_fp >> 0x03;
   \       0x30   0xE1B0'11A0        LSRS     R1,R0,#+3
    345          	fp = cd_fp & 0x07;
   \       0x34   0xE200'0007        AND      R0,R0,#0x7
    346          	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   \       0x38   0x0A00'0001        BEQ      ??usart_set_async_baudrate_0
   \       0x3C   0xE351'0B40        CMP      R1,#+65536
   \       0x40   0x3A00'0001        BCC      ??usart_set_async_baudrate_1
    347          		return 1;
   \                     ??usart_set_async_baudrate_0:
   \       0x44   0xE3A0'0001        MOV      R0,#+1
   \       0x48   0xE8BD'8070        POP      {R4-R6,PC}
    348          	}
    349          
    350          	/* Configure the OVER bit in MR register. */
    351          	if (over == 8) {
   \                     ??usart_set_async_baudrate_1:
   \       0x4C   0xE355'0008        CMP      R5,#+8
    352          		usart->US_MR |= US_MR_OVER;
   \       0x50   0x0594'2004        LDREQ    R2,[R4, #+4]
    353          	}
    354          
    355          	/* Configure the baudrate generate register. */
    356          	usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
   \       0x54   0xE181'0800        ORR      R0,R1,R0, LSL #+16
   \       0x58   0x0382'3A80        ORREQ    R3,R2,#0x80000
   \       0x5C   0x0584'3004        STREQ    R3,[R4, #+4]
   \       0x60   0xE584'0020        STR      R0,[R4, #+32]
    357          
    358          	return 0;
   \       0x64   0xE3A0'0000        MOV      R0,#+0
   \       0x68   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    359          }
    360          
    361          /*-----------------------------------------------------------------------------
    362          *        Functions if FIFO are used
    363           *---------------------------------------------------------------------------*/
    364          
    365          #ifdef CONFIG_HAVE_USART_FIFO

   \                                 In section SOFTPACK, align 4, keep-with-next
    366          void usart_fifo_configure(Usart *usart, uint8_t tx_thres, uint8_t rx_down_thres, uint8_t rx_up_thres)
    367          {
   \                     usart_fifo_configure:
   \        0x0   0xE92D'4000        PUSH     {LR}
    368          	/* Configure FIFO */
    369          	usart->US_FMR = US_FMR_TXFTHRES(tx_thres) | US_FMR_RXFTHRES(rx_down_thres)
    370          		| US_FMR_RXFTHRES2(rx_up_thres) | US_FMR_RXRDYM_ONE_DATA | US_FMR_TXRDYM_FOUR_DATA;
   \        0x4   0xE3A0'CDFC        MOV      R12,#+16128
   \        0x8   0xE3A0'E9FC        MOV      LR,#+4128768
   \        0xC   0xE00C'1401        AND      R1,R12,R1, LSL #+8
   \       0x10   0xE00E'2802        AND      R2,LR,R2, LSL #+16
   \       0x14   0xE182'2001        ORR      R2,R2,R1
   \       0x18   0xE3A0'15FC        MOV      R1,#+1056964608
   \       0x1C   0xE001'1C03        AND      R1,R1,R3, LSL #+24
   \       0x20   0xE181'1002        ORR      R1,R1,R2
   \       0x24   0xE381'3002        ORR      R3,R1,#0x2
   \       0x28   0xE580'30A0        STR      R3,[R0, #+160]
    371          
    372          	/* Disable all fifo related interrupts */
    373          	usart->US_FIDR = 0xFFFFFFFF;
   \       0x2C   0xE3E0'2000        MVN      R2,#+0
   \       0x30   0xE580'20AC        STR      R2,[R0, #+172]
    374          }
   \       0x34   0xE8BD'8000        POP      {PC}             ;; return
    375          

   \                                 In section SOFTPACK, align 4, keep-with-next
    376          void usart_fifo_enable(Usart *usart)
    377          {
    378          	/* Reset and disable receiver & transmitter */
    379          	usart->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_FIFOEN;
   \                     usart_fifo_enable:
   \        0x0   0xE3A0'10AC        MOV      R1,#+172
   \        0x4   0xE381'1440        ORR      R1,R1,#0x40000000
   \        0x8   0x....'....        B        ?Subroutine0
    380          
    381          	/* Reenable receiver & transmitter */
    382          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
    383          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE580'1000        STR      R1,[R0, #+0]
   \        0x4   0xE3A0'2050        MOV      R2,#+80
   \        0x8   0xE580'2000        STR      R2,[R0, #+0]
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    384          

   \                                 In section SOFTPACK, align 4, keep-with-next
    385          void usart_fifo_disable(Usart *usart)
    386          {
    387          	/* Reset and disable receiver & transmitter */
    388          	usart->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS;
   \                     usart_fifo_disable:
   \        0x0   0xE3A0'10AC        MOV      R1,#+172
   \        0x4                      REQUIRE ?Subroutine0
   \        0x4                      ;; // Fall through to label ?Subroutine0
    389          
    390          	/* Reenable receiver & transmitter */
    391          	usart->US_CR = US_CR_RXEN | US_CR_TXEN;
    392          }
    393          

   \                                 In section SOFTPACK, align 4, keep-with-next
    394          void usart_fifo_enable_it(Usart *usart, uint32_t interrupt_mask)
    395          {
    396          	usart->US_FIER = interrupt_mask;
   \                     usart_fifo_enable_it:
   \        0x0   0xE580'10A8        STR      R1,[R0, #+168]
    397          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    398          

   \                                 In section SOFTPACK, align 4, keep-with-next
    399          void usart_fifo_disable_it(Usart *usart, uint32_t interrupt_mask)
    400          {
    401          	usart->US_FIDR = interrupt_mask;
   \                     usart_fifo_disable_it:
   \        0x0   0xE580'10AC        STR      R1,[R0, #+172]
    402          }
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    403          

   \                                 In section SOFTPACK, align 4, keep-with-next
    404          uint32_t usart_fifo_get_rx_size(Usart *usart)
    405          {
    406          	return (usart->US_FLR & US_FLR_RXFL_Msk) >> US_FLR_RXFL_Pos;
   \                     usart_fifo_get_rx_size:
   \        0x0   0xE590'00A4        LDR      R0,[R0, #+164]
   \        0x4   0xE3A0'103F        MOV      R1,#+63
   \        0x8   0xE001'0820        AND      R0,R1,R0, LSR #+16
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    407          }
    408          

   \                                 In section SOFTPACK, align 4, keep-with-next
    409          uint32_t usart_fifo_get_tx_size(Usart *usart)
    410          {
    411          	return (usart->US_FLR & US_FLR_TXFL_Msk) >> US_FLR_TXFL_Pos;
   \                     usart_fifo_get_tx_size:
   \        0x0   0xE590'00A4        LDR      R0,[R0, #+164]
   \        0x4   0xE200'003F        AND      R0,R0,#0x3F
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    412          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x3B9A'CA00        DC32     0x3b9aca00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6C

   \              0x73 0x65    

   \              0x72 0x69    

   \              0x61 0x6C
   \       0x40   0x5C 0x75          DC8 0x5C, 0x75, 0x73, 0x61, 0x72, 0x74, 0x2E, 0x63

   \              0x73 0x61    

   \              0x72 0x74    

   \              0x2E 0x63
   \       0x48   0x00               DC8 0
   \       0x49   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x75 0x73          DC8 "usart != ((void*)0)"

   \              0x61 0x72    

   \              0x74 0x20    

   \              0x21 0x3D    

   \              0x20 0x28    

   \              0x28 0x76    

   \              0x6F 0x69    

   \              0x64 0x2A    

   \              0x29 0x30    

   \              0x29 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x2D 0x45          DC8 "-E- usart_write: Timed out.\012\015"

   \              0x2D 0x20    

   \              0x75 0x73    

   \              0x61 0x72    

   \              0x74 0x5F    

   \              0x77 0x72    

   \              0x69 0x74    

   \              0x65 0x3A    

   \              0x20 0x54    

   \              0x69 0x6D    

   \              0x65 0x64    

   \              0x20 0x6F    

   \              0x75 0x74    

   \              0x2E 0x0A    

   \              0x0D 0x00
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x2D 0x45          DC8 "-E- usart_read: Timed out.\012\015"

   \              0x2D 0x20    

   \              0x75 0x73    

   \              0x61 0x72    

   \              0x74 0x5F    

   \              0x72 0x65    

   \              0x61 0x64    

   \              0x3A 0x20    

   \              0x54 0x69    

   \              0x6D 0x65    

   \              0x64 0x20    

   \              0x6F 0x75    

   \              0x74 0x2E    

   \              0x0A 0x0D    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00
    413          
    414          #endif /* CONFIG_HAVE_USART_FIFO */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   usart_configure
        16   -> get_usart_id_from_addr
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
       0   usart_disable_it
       0   usart_enable_it
       4   usart_fifo_configure
       0   usart_fifo_disable
       0   usart_fifo_disable_it
       0   usart_fifo_enable
       0   usart_fifo_enable_it
       0   usart_fifo_get_rx_size
       0   usart_fifo_get_tx_size
       0   usart_get_char
       0   usart_get_it_mask
       8   usart_get_masked_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   usart_get_status
       0   usart_init_hw_handshaking
       0   usart_is_rx_ready
       0   usart_is_tx_empty
       0   usart_is_tx_ready
       0   usart_put_char
       8   usart_read
         8   -> printf
       0   usart_reset_iterations
       0   usart_reset_nack
       0   usart_reset_rx
       0   usart_reset_status
       0   usart_reset_tx
       0   usart_restart_rx_timeout
      16   usart_set_async_baudrate
        16   -> get_usart_id_from_addr
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
      16   usart_set_irda_filter
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   usart_set_receiver_enabled
       0   usart_set_rts_enabled
      12   usart_set_rx_timeout
        12 __aeabi_uidiv
       0   usart_set_sync_slave_baudrate
       0   usart_set_transmitter_enabled
       0   usart_set_tx_timeguard
       0   usart_start_rx_timeout
       0   usart_start_tx_break
       0   usart_stop_tx_break
      16   usart_write
         0   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      16  ?Subroutine0
      76  ?_0
      20  ?_1
      32  ?_2
      32  ?_3
      88  usart_configure
       8  usart_disable_it
       8  usart_enable_it
      56  usart_fifo_configure
       4  usart_fifo_disable
       8  usart_fifo_disable_it
      12  usart_fifo_enable
       8  usart_fifo_enable_it
      16  usart_fifo_get_rx_size
      12  usart_fifo_get_tx_size
      20  usart_get_char
       8  usart_get_it_mask
      48  usart_get_masked_status
       8  usart_get_status
      24  usart_init_hw_handshaking
      12  usart_is_rx_ready
      16  usart_is_tx_empty
      16  usart_is_tx_ready
      20  usart_put_char
     112  usart_read
      12  usart_reset_iterations
      12  usart_reset_nack
      12  usart_reset_rx
      12  usart_reset_status
      12  usart_reset_tx
      12  usart_restart_rx_timeout
     108  usart_set_async_baudrate
      64  usart_set_irda_filter
      24  usart_set_receiver_enabled
      24  usart_set_rts_enabled
      68  usart_set_rx_timeout
      16  usart_set_sync_slave_baudrate
      24  usart_set_transmitter_enabled
       8  usart_set_tx_timeguard
      12  usart_start_rx_timeout
      12  usart_start_tx_break
      12  usart_stop_tx_break
     116  usart_write

 
    76 bytes in section .rodata
 1'176 bytes in section SOFTPACK
 
 1'176 bytes of CODE  memory
    76 bytes of CONST memory

Errors: none
Warnings: none
