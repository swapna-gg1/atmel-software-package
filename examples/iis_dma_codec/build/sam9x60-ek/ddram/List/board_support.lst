###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         30/Nov/2020  13:24:51
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW4699.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\iis_dma_codec\build\sam9x60-ek\ddram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  int_specials,qualifiers
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2018, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "timer.h"
     44          #include "trace.h"
     45          
     46          #include "irq/irq.h"
     47          #include "gpio/pio.h"
     48          #include "peripherals/pmc.h"
     49          #include "sdmmc/sdmmc.h"
     50          #include "extram/smc.h"
     51          #include "peripherals/wdt.h"
     52          #ifdef BOARD_DDRAM_TYPE
     53          	#include "extram/ddram.h"
     54          #endif
     55          #ifdef BOARD_SDRAM_TYPE
     56          	#include "extram/sdram.h"
     57          #endif
     58          #include "arm/mmu_cp15.h"
     59          #include "mm/l1cache.h"
     60          
     61          #include "board_support.h"
     62          #include "string.h"
     63          /*----------------------------------------------------------------------------
     64           *        Local constants
     65           *----------------------------------------------------------------------------*/
     66          #define PLLA_DIV 1
     67          #define PLLA_COUNT 0x3f
     68          #define PLLA_LOOP_FILTER 0
     69          
     70          #define PLLA_CFG(_mul, _fracr)			\
     71          	{									\
     72          		.mul = (_mul),					\
     73          		.div = PLLA_DIV,				\
     74          		.count = PLLA_COUNT,			\
     75          		.fracr = (_fracr),				\
     76          		.loop_filter = PLLA_LOOP_FILTER,\
     77          	}
     78          
     79          #define PLLA_FRACR(_p, _q) ((uint32_t)((((uint64_t)(_p)) << 22) / (_q)))
     80          
     81          /*----------------------------------------------------------------------------
     82           *        Local variables
     83           *----------------------------------------------------------------------------*/

   \                                 In section .data, align 4
   \        0x0   0x....'....        DC32 ?_3
     84          static const char* board_name = BOARD_NAME;
     85          

   \                                 In section .region_ddr, align 16384
     86          SECTION(".region_ddr") ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     87          
     88          /*----------------------------------------------------------------------------
     89           *        Exported functions
     90           *----------------------------------------------------------------------------*/
     91          

   \                                 In section SOFTPACK, align 4, keep-with-next
     92          const char* get_board_name(void)
     93          {
     94          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable12
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
     95          }
     96          

   \                                 In section SOFTPACK, align 4, keep-with-next
     97          void board_cfg_clocks_for_preset(uint32_t preset)
     98          {
   \                     board_cfg_clocks_for_preset:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1A0'4000        MOV      R4,R0
     99          	struct _pmc_plla_cfg plla_config;
    100          
    101          #define MAX_PRESET 2 /* PCK/MCK (MHz) = { 600/200, 500/167 } */
    102          
    103          	static const struct _pmc_plla_cfg plla_configs[][MAX_PRESET] = {
    104          		/* MAINCK = 12MHz */
    105          		{ PLLA_CFG(99, 0), PLLA_CFG(82, PLLA_FRACR(1, 3)) },
    106          
    107          		/* MAINCK = 16MHz */
    108          		{ PLLA_CFG(74, 0), PLLA_CFG(61, PLLA_FRACR(1, 2)) },
    109          
    110          		/* MAINCK = 24MHz */
    111          #ifdef CONFIG_HAVE_CLASSD
    112          		{ PLLA_CFG(48, 0x9ba5e), PLLA_CFG(40, PLLA_FRACR(2, 3)) },
    113          #else
    114          		{ PLLA_CFG(49, 0), PLLA_CFG(40, PLLA_FRACR(2, 3)) },
    115          #endif
    116          		/* MAINCK = 48MHz */
    117          		{ PLLA_CFG(24, 0), PLLA_CFG(19, PLLA_FRACR(5, 6)) },
    118          	};
    119          	uint32_t row;
    120          
    121          	switch (pmc_get_main_oscillator_freq()) {
   \        0xC   0x....'....        BL       pmc_get_main_oscillator_freq
   \       0x10   0xE3A0'18F4        MOV      R1,#+15990784
   \       0x14   0xE381'1D90        ORR      R1,R1,#0x2400
   \       0x18   0xE150'0001        CMP      R0,R1
   \       0x1C   0x0A00'0007        BEQ      ??board_cfg_clocks_for_preset_0
   \       0x20   0x....'....        LDR      R1,??DataTable12_1  ;; 0x16e3600
   \       0x24   0xE150'0001        CMP      R0,R1
   \       0x28   0x0A00'0006        BEQ      ??board_cfg_clocks_for_preset_1
   \       0x2C   0xE1A0'1081        MOV      R1,R1, LSL #+1
   \       0x30   0xE150'0001        CMP      R0,R1
    122          	default:
    123          	case 12000000:
    124          		row = 0;
   \       0x34   0x13A0'0000        MOVNE    R0,#+0
    125          		break;
    126          	case 16000000:
    127          		row = 1;
    128          		break;
    129          	case 24000000:
    130          		row = 2;
    131          		break;
    132          	case 48000000:
    133          		row = 3;
   \       0x38   0x03A0'0090        MOVEQ    R0,#+144
   \       0x3C   0xEA00'0002        B        ??board_cfg_clocks_for_preset_2
   \                     ??board_cfg_clocks_for_preset_0:
   \       0x40   0xE3A0'0030        MOV      R0,#+48
   \       0x44   0xEA00'0000        B        ??board_cfg_clocks_for_preset_2
   \                     ??board_cfg_clocks_for_preset_1:
   \       0x48   0xE3A0'0060        MOV      R0,#+96
    134          		break;
    135          	}
    136          
    137          	if (preset >= MAX_PRESET)
   \                     ??board_cfg_clocks_for_preset_2:
   \       0x4C   0xE354'0002        CMP      R4,#+2
   \       0x50   0x3A00'0008        BCC      ??board_cfg_clocks_for_preset_3
    138          		trace_fatal("Invalid preset for board: %lu (max %d).\r\n", preset, MAX_PRESET);
   \       0x54   0x....'....        LDR      R0,??DataTable12_2
   \       0x58   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x5C   0xE351'0000        CMP      R1,#+0
   \       0x60   0x0A00'0003        BEQ      ??board_cfg_clocks_for_preset_4
   \       0x64   0xE3A0'2002        MOV      R2,#+2
   \       0x68   0xE1A0'1004        MOV      R1,R4
   \       0x6C   0x....'....        LDR      R0,??DataTable12_3
   \       0x70   0x....'....        BL       printf
   \                     ??board_cfg_clocks_for_preset_4:
   \       0x74   0xEAFF'FFFE        B        ??board_cfg_clocks_for_preset_4
    139          	memcpy(&plla_config, &plla_configs[row][preset], sizeof(plla_config));
   \                     ??board_cfg_clocks_for_preset_3:
   \       0x78   0x....'....        LDR      R1,??DataTable12_3
   \       0x7C   0xE084'3084        ADD      R3,R4,R4, LSL #+1
   \       0x80   0xE081'0000        ADD      R0,R1,R0
   \       0x84   0xE080'3183        ADD      R3,R0,R3, LSL #+3
   \       0x88   0xE3A0'2018        MOV      R2,#+24
   \       0x8C   0xE283'1030        ADD      R1,R3,#+48
   \       0x90   0xE1A0'000D        MOV      R0,SP
   \       0x94   0x....'....        BL       __aeabi_memcpy
    140          
    141          	pmc_switch_mck_to_main();
   \       0x98   0x....'....        BL       pmc_switch_mck_to_main
    142          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x9C   0xE3A0'0000        MOV      R0,#+0
   \       0xA0   0x....'....        BL       pmc_set_mck_prescaler
    143          	pmc_select_external_osc(false);
   \       0xA4   0xE3A0'0000        MOV      R0,#+0
   \       0xA8   0x....'....        BL       pmc_select_external_osc
    144          	pmc_configure_plla(&plla_config);
   \       0xAC   0xE1A0'000D        MOV      R0,SP
   \       0xB0   0x....'....        BL       pmc_configure_plla
    145          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV3);
   \       0xB4   0xE3A0'0FC0        MOV      R0,#+768
   \       0xB8   0x....'....        BL       pmc_set_mck_divider
    146          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0xBC   0xE3A0'0000        MOV      R0,#+0
   \       0xC0   0x....'....        BL       pmc_set_mck_prescaler
    147          	pmc_switch_mck_to_pll();
   \       0xC4   0x....'....        BL       pmc_switch_mck_to_pll
    148          }
   \       0xC8   0xE28D'D018        ADD      SP,SP,#+24
   \       0xCC   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x46          DC8 "-F- Invalid preset for board: %lu (max %d).\015\012"

   \              0x2D 0x20    

   \              0x49 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x65 0x74    

   \              0x20 0x66    

   \              0x6F 0x72    

   \              0x20 0x62    

   \              0x6F 0x61    

   \              0x72 0x64    

   \              0x3A 0x20    

   \              0x25 0x6C    

   \              0x75 0x20    

   \              0x28 0x6D    

   \              0x61 0x78    

   \              0x20 0x25    

   \              0x64 0x29    

   \              0x2E 0x0D    

   \              0x0A 0x00
   \       0x2E   0x00 0x00          DC8 0, 0
   \       0x30   0x0000'0063        DC32 99, 1, 63, 0, 0, 0, 82, 1, 63, 0, 1'398'101, 0, 74, 1, 63, 0, 0, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0052  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0015'5555  

   \              0x0000'0000  

   \              0x0000'004A  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000
   \       0x78   0x0000'003D        DC32 61, 1, 63, 0, 2'097'152, 0, 48, 1, 63, 0, 637'534, 0, 40, 1, 63, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0020'0000  

   \              0x0000'0000  

   \              0x0000'0030  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0009'BA5E  

   \              0x0000'0000  

   \              0x0000'0028  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000
   \       0xB8   0x002A'AAAA        DC32 2'796'202, 0, 24, 1, 63, 0, 0, 0, 19, 1, 63, 0, 3'495'253, 0

   \              0x0000'0000  

   \              0x0000'0018  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0013  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0035'5555  

   \              0x0000'0000
    149          

   \                                 In section SOFTPACK, align 4, keep-with-next
    150          void board_cfg_clocks(void)
    151          {
   \                     board_cfg_clocks:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
    152          	board_cfg_clocks_for_preset(0);
   \        0x8   0x....'....        BL       pmc_get_main_oscillator_freq
   \        0xC   0xE3A0'18F4        MOV      R1,#+15990784
   \       0x10   0xE381'1D90        ORR      R1,R1,#0x2400
   \       0x14   0xE150'0001        CMP      R0,R1
   \       0x18   0x0A00'0009        BEQ      ??board_cfg_clocks_0
   \       0x1C   0x....'....        LDR      R1,??DataTable12_1  ;; 0x16e3600
   \       0x20   0xE150'0001        CMP      R0,R1
   \       0x24   0x0A00'0004        BEQ      ??board_cfg_clocks_1
   \       0x28   0xE1A0'1081        MOV      R1,R1, LSL #+1
   \       0x2C   0xE150'0001        CMP      R0,R1
   \       0x30   0x03A0'0090        MOVEQ    R0,#+144
   \       0x34   0x13A0'0000        MOVNE    R0,#+0
   \       0x38   0xEA00'0002        B        ??board_cfg_clocks_2
   \                     ??board_cfg_clocks_1:
   \       0x3C   0xE3A0'0060        MOV      R0,#+96
   \       0x40   0xEA00'0000        B        ??board_cfg_clocks_2
   \                     ??board_cfg_clocks_0:
   \       0x44   0xE3A0'0030        MOV      R0,#+48
   \                     ??board_cfg_clocks_2:
   \       0x48   0x....'....        LDR      R1,??DataTable12_3
   \       0x4C   0xE3A0'2018        MOV      R2,#+24
   \       0x50   0xE081'0000        ADD      R0,R1,R0
   \       0x54   0xE280'1030        ADD      R1,R0,#+48
   \       0x58   0xE1A0'000D        MOV      R0,SP
   \       0x5C   0x....'....        BL       __aeabi_memcpy
   \       0x60   0x....'....        BL       pmc_switch_mck_to_main
   \       0x64   0xE3A0'0000        MOV      R0,#+0
   \       0x68   0x....'....        BL       pmc_set_mck_prescaler
   \       0x6C   0xE3A0'0000        MOV      R0,#+0
   \       0x70   0x....'....        BL       pmc_select_external_osc
   \       0x74   0xE1A0'000D        MOV      R0,SP
   \       0x78   0x....'....        BL       pmc_configure_plla
   \       0x7C   0xE3A0'0FC0        MOV      R0,#+768
   \       0x80   0x....'....        BL       pmc_set_mck_divider
   \       0x84   0xE3A0'0000        MOV      R0,#+0
   \       0x88   0x....'....        BL       pmc_set_mck_prescaler
   \       0x8C   0x....'....        BL       pmc_switch_mck_to_pll
    153          }
   \       0x90   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x94   0xE8BD'8000        POP      {PC}             ;; return
    154          

   \                                 In section SOFTPACK, align 4, keep-with-next
    155          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    156          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE1A0'6001        MOV      R6,R1
   \       0x10   0xE1A0'4002        MOV      R4,R2
    157          	/* Disable Watchdog */
    158          	wdt_disable();
   \       0x14   0x....'....        BL       wdt_disable
    159          
    160          	/* Disable all PIO interrupts */
    161          	pio_reset_all_it();
   \       0x18   0x....'....        BL       pio_reset_all_it
    162          
    163          	/* Set the external oscillator frequency */
    164          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x1C   0x....'....        LDR      R0,??DataTable12_1  ;; 0x16e3600
   \       0x20   0x....'....        BL       pmc_set_main_oscillator_freq
    165          
    166          	if (clocks) {
   \       0x24   0xE355'0000        CMP      R5,#+0
   \       0x28   0x0A00'0021        BEQ      ??board_cfg_lowlevel_0
    167          		/* Configure system clocks */
    168          		board_cfg_clocks();
   \       0x2C   0x....'....        BL       pmc_get_main_oscillator_freq
   \       0x30   0xE3A0'18F4        MOV      R1,#+15990784
   \       0x34   0xE381'1D90        ORR      R1,R1,#0x2400
   \       0x38   0xE150'0001        CMP      R0,R1
   \       0x3C   0x0A00'0009        BEQ      ??board_cfg_lowlevel_1
   \       0x40   0x....'....        LDR      R1,??DataTable12_1  ;; 0x16e3600
   \       0x44   0xE150'0001        CMP      R0,R1
   \       0x48   0x0A00'0004        BEQ      ??board_cfg_lowlevel_2
   \       0x4C   0xE1A0'1081        MOV      R1,R1, LSL #+1
   \       0x50   0xE150'0001        CMP      R0,R1
   \       0x54   0x03A0'0090        MOVEQ    R0,#+144
   \       0x58   0x13A0'0000        MOVNE    R0,#+0
   \       0x5C   0xEA00'0002        B        ??board_cfg_lowlevel_3
   \                     ??board_cfg_lowlevel_2:
   \       0x60   0xE3A0'0060        MOV      R0,#+96
   \       0x64   0xEA00'0000        B        ??board_cfg_lowlevel_3
   \                     ??board_cfg_lowlevel_1:
   \       0x68   0xE3A0'0030        MOV      R0,#+48
   \                     ??board_cfg_lowlevel_3:
   \       0x6C   0x....'....        LDR      R1,??DataTable12_3
   \       0x70   0xE3A0'2018        MOV      R2,#+24
   \       0x74   0xE081'0000        ADD      R0,R1,R0
   \       0x78   0xE280'1030        ADD      R1,R0,#+48
   \       0x7C   0xE1A0'000D        MOV      R0,SP
   \       0x80   0x....'....        BL       __aeabi_memcpy
   \       0x84   0x....'....        BL       pmc_switch_mck_to_main
   \       0x88   0xE3A0'0000        MOV      R0,#+0
   \       0x8C   0x....'....        BL       pmc_set_mck_prescaler
   \       0x90   0xE3A0'0000        MOV      R0,#+0
   \       0x94   0x....'....        BL       pmc_select_external_osc
   \       0x98   0xE1A0'000D        MOV      R0,SP
   \       0x9C   0x....'....        BL       pmc_configure_plla
   \       0xA0   0xE3A0'0FC0        MOV      R0,#+768
   \       0xA4   0x....'....        BL       pmc_set_mck_divider
   \       0xA8   0xE3A0'0000        MOV      R0,#+0
   \       0xAC   0x....'....        BL       pmc_set_mck_prescaler
   \       0xB0   0x....'....        BL       pmc_switch_mck_to_pll
    169          	}
    170          
    171          	/* Setup default interrupt handlers */
    172          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0xB4   0x....'....        BL       irq_initialize
    173          
    174          	/* Configure system timer */
    175          	board_cfg_timer();
   \       0xB8   0x....'....        BL       board_cfg_timer
    176          
    177          	if (ddram) {
   \       0xBC   0xE356'0000        CMP      R6,#+0
   \       0xC0   0x0A00'000C        BEQ      ??board_cfg_lowlevel_4
    178          		/* Configure DDRAM */
    179          		board_cfg_ddram();
   \       0xC4   0x....'....        LDR      R0,??DataTable12_4  ;; 0xf8050004
   \       0xC8   0xE590'1000        LDR      R1,[R0, #+0]
   \       0xCC   0xE381'2002        ORR      R2,R1,#0x2
   \       0xD0   0xE580'2000        STR      R2,[R0, #+0]
   \       0xD4   0xE590'10B0        LDR      R1,[R0, #+176]
   \       0xD8   0xE3C1'10FF        BIC      R1,R1,#0xFF
   \       0xDC   0xE381'2F69        ORR      R2,R1,#0x1A4
   \       0xE0   0xE580'20B0        STR      R2,[R0, #+176]
   \       0xE4   0xE3A0'1000        MOV      R1,#+0
   \       0xE8   0xE1A0'000D        MOV      R0,SP
   \       0xEC   0x....'....        BL       ddram_init_descriptor
   \       0xF0   0xE1A0'000D        MOV      R0,SP
   \       0xF4   0x....'....        BL       ddram_configure
    180          	}
    181          
    182          	if (mmu) {
   \                     ??board_cfg_lowlevel_4:
   \       0xF8   0xE354'0000        CMP      R4,#+0
   \       0xFC   0x0A00'0000        BEQ      ??board_cfg_lowlevel_5
    183          		/* Setup MMU */
    184          		board_cfg_mmu();
   \      0x100   0x....'....        BL       board_cfg_mmu
    185          	}
    186          }
   \                     ??board_cfg_lowlevel_5:
   \      0x104   0xE28D'D030        ADD      SP,SP,#+48
   \      0x108   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    187          

   \                                 In section SOFTPACK, align 4, keep-with-next
    188          void board_restore_pio_reset_state(void)
    189          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    190          	int i;
    191          
    192          	/* all pins */
    193          	struct _pin pins[] = {
    194          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    195          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    196          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    197          		{ PIO_GROUP_D, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    198          	};
   \        0x8   0xE1A0'000D        MOV      R0,SP
   \        0xC   0x....'....        LDR      R1,??DataTable12_5
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    199          
    200          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1A0'000D        MOV      R0,SP
   \       0x20   0x....'....        BL       pio_configure
    201          	for (i = 0; i < ARRAY_SIZE(pins); i++)
    202          		pio_clear(&pins[i]);
   \       0x24   0xE1A0'000D        MOV      R0,SP
   \       0x28   0x....'....        BL       pio_clear
   \       0x2C   0xE28D'0010        ADD      R0,SP,#+16
   \       0x30   0x....'....        BL       pio_clear
   \       0x34   0xE28D'0020        ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       pio_clear
   \       0x3C   0xE28D'0030        ADD      R0,SP,#+48
   \       0x40   0x....'....        BL       pio_clear
    203          }
   \       0x44   0xE28D'D044        ADD      SP,SP,#+68
   \       0x48   0xE8BD'8000        POP      {PC}             ;; return
    204          

   \                                 In section SOFTPACK, align 4, keep-with-next
    205          void board_save_misc_power(void)
    206          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    207          	int i;
    208          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'04F8        MOV      R0,#-134217728
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0xE380'0CC0        ORR      R0,R0,#0xC000
   \       0x10   0x....'....        BL       get_tc_id_from_addr
   \       0x14   0xE1A0'4000        MOV      R4,R0
    209          
    210          	/* disable USB clock */
    211          	pmc_disable_upll_clock();
   \       0x18   0x....'....        BL       pmc_disable_upll_clock
    212          
    213          	/* disable system clocks */
    214          #ifdef VARIANT_SRAM
    215          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    216          #endif
    217          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x1C   0xE3A0'0003        MOV      R0,#+3
   \       0x20   0x....'....        BL       pmc_disable_system_clock
    218          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x24   0xE3A0'0005        MOV      R0,#+5
   \       0x28   0x....'....        BL       pmc_disable_system_clock
    219          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x2C   0xE3A0'0006        MOV      R0,#+6
   \       0x30   0x....'....        BL       pmc_disable_system_clock
    220          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_QSPI);
   \       0x34   0xE3A0'000D        MOV      R0,#+13
   \       0x38   0x....'....        BL       pmc_disable_system_clock
    221          
    222          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    223          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x3C   0xE3A0'5001        MOV      R5,#+1
   \       0x40   0xEA00'0001        B        ??board_save_misc_power_0
    224          		if (i == ID_PIOA)
   \                     ??board_save_misc_power_1:
   \       0x44   0xE355'0002        CMP      R5,#+2
   \       0x48   0x0A00'0005        BEQ      ??board_save_misc_power_2
    225          			continue;
    226          		if (i == tc_id)
   \                     ??board_save_misc_power_0:
   \       0x4C   0xE155'0004        CMP      R5,R4
   \       0x50   0x0A00'0003        BEQ      ??board_save_misc_power_2
    227          			continue;
    228          #ifdef VARIANT_DDRAM
    229          		if (i == ID_MPDDRC)
   \       0x54   0xE355'0031        CMP      R5,#+49
   \       0x58   0x0A00'0001        BEQ      ??board_save_misc_power_2
    230          			continue;
    231          #endif
    232          		pmc_disable_peripheral(i);
   \       0x5C   0xE1A0'0005        MOV      R0,R5
   \       0x60   0x....'....        BL       pmc_disable_peripheral
    233          	}
   \                     ??board_save_misc_power_2:
   \       0x64   0xE285'5001        ADD      R5,R5,#+1
   \       0x68   0xE355'0033        CMP      R5,#+51
   \       0x6C   0xBAFF'FFF4        BLT      ??board_save_misc_power_1
    234          }
   \       0x70   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    235          

   \                                 In section SOFTPACK, align 4, keep-with-next
    236          void board_cfg_mmu(void)
    237          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    238          	uint32_t addr;
    239          
    240          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'00BF        BNE      ??board_cfg_mmu_0
    241          		return;
    242          
    243          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    244          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    245          	   be verified for correct operation when write-back is enabled */
    246          
    247          	/* Reset table entries */
    248          	for (addr = 0; addr < 4096; addr++)
    249          		tlb[addr] = 0;
   \       0x10   0x....'....        LDR      R4,??DataTable12_6
   \       0x14   0xE3A0'1C40        MOV      R1,#+16384
   \       0x18   0xE1A0'0004        MOV      R0,R4
   \       0x1C   0x....'....        BL       __aeabi_memclr4
    250          
    251          	/* 0x00000000: SRAM (Remapped) */
    252          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    253          	           | TTB_SECT_AP_FULL_ACCESS
    254          	           | TTB_SECT_DOMAIN(0xf)
    255          	           | TTB_SECT_CACHEABLE_WB
    256          	           | TTB_SECT_SBO
    257          	           | TTB_TYPE_SECT;
   \       0x20   0xE3A0'10FE        MOV      R1,#+254
   \       0x24   0xE381'1ED0        ORR      R1,R1,#0xD00
    258          
    259          	/* 0x00100000: ROM */
    260          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    261          	           | TTB_SECT_AP_FULL_ACCESS
    262          	           | TTB_SECT_DOMAIN(0xf)
    263          	           | TTB_SECT_CACHEABLE_WB
    264          	           | TTB_SECT_SBO
    265          	           | TTB_TYPE_SECT;
   \       0x28   0xE381'0940        ORR      R0,R1,#0x100000
   \       0x2C   0xE584'0004        STR      R0,[R4, #+4]
    266          
    267          	/* 0x00300000: SRAM0 */
    268          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    269          	           | TTB_SECT_AP_FULL_ACCESS
    270          	           | TTB_SECT_DOMAIN(0xf)
    271          	           | TTB_SECT_CACHEABLE_WB
    272          	           | TTB_SECT_SBO
    273          	           | TTB_TYPE_SECT;
   \       0x30   0xE380'2980        ORR      R2,R0,#0x200000
    274          
    275          	/* 0x00400000: SRAM1 */
    276          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    277          	           | TTB_SECT_AP_FULL_ACCESS
    278          	           | TTB_SECT_DOMAIN(0xf)
    279          	           | TTB_SECT_SHAREABLE_DEVICE
    280          	           | TTB_SECT_SBO
    281          	           | TTB_TYPE_SECT;
   \       0x34   0x....'....        LDR      R0,??DataTable12_7  ;; 0x400df6
   \       0x38   0xE584'200C        STR      R2,[R4, #+12]
   \       0x3C   0xE584'0010        STR      R0,[R4, #+16]
   \       0x40   0xE584'1000        STR      R1,[R4, #+0]
    282          
    283          #ifdef CONFIG_HAVE_UDPHS
    284          	/* 0x00500000: UDPHS RAM */
    285          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    286          	           | TTB_SECT_AP_FULL_ACCESS
    287          	           | TTB_SECT_DOMAIN(0xf)
    288          	           | TTB_SECT_SHAREABLE_DEVICE
    289          	           | TTB_SECT_SBO
    290          	           | TTB_TYPE_SECT;
    291          
    292          	/* 0x00600000: UHP (OHCI) */
    293          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    294          	           | TTB_SECT_AP_FULL_ACCESS
    295          	           | TTB_SECT_DOMAIN(0xf)
    296          	           | TTB_SECT_SHAREABLE_DEVICE
    297          	           | TTB_SECT_SBO
    298          	           | TTB_TYPE_SECT;
    299          
    300          	/* 0x00700000: UHP (EHCI) */
    301          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    302          	           | TTB_SECT_AP_FULL_ACCESS
    303          	           | TTB_SECT_DOMAIN(0xf)
    304          	           | TTB_SECT_SHAREABLE_DEVICE
    305          	           | TTB_SECT_SBO
    306          	           | TTB_TYPE_SECT;
    307          #endif /* CONFIG_HAVE_UDPHS */
    308          
    309          	/* 0x10000000: EBI Chip Select 0 */
    310          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x44   0xE3A0'2F40        MOV      R2,#+256
   \       0x48   0xE284'3E40        ADD      R3,R4,#+1024
   \       0x4C   0xE3C1'000C        BIC      R0,R1,#0xC
    311          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    312          	                  | TTB_SECT_AP_FULL_ACCESS
    313          	                  | TTB_SECT_DOMAIN(0xf)
    314          	                  | TTB_SECT_STRONGLY_ORDERED
    315          	                  | TTB_SECT_SBO
    316          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_1:
   \       0x50   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \       0x54   0xE282'2001        ADD      R2,R2,#+1
   \       0x58   0xE483'C004        STR      R12,[R3], #+4
   \       0x5C   0xE180'EA02        ORR      LR,R0,R2, LSL #+20
   \       0x60   0xE282'2001        ADD      R2,R2,#+1
   \       0x64   0xE483'E004        STR      LR,[R3], #+4
   \       0x68   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \       0x6C   0xE282'2001        ADD      R2,R2,#+1
   \       0x70   0xE483'C004        STR      R12,[R3], #+4
   \       0x74   0xE180'EA02        ORR      LR,R0,R2, LSL #+20
   \       0x78   0xE282'2001        ADD      R2,R2,#+1
   \       0x7C   0xE483'E004        STR      LR,[R3], #+4
   \       0x80   0xE352'0F80        CMP      R2,#+512
   \       0x84   0x3AFF'FFF1        BCC      ??board_cfg_mmu_1
    317          
    318          	/* 0x20000000: EBI Chip Select 1 / DDR CS */
    319          	/* (64MB cacheable, 192MB strongly ordered) */
    320          	for (addr = 0x200; addr < 0x240; addr++)
   \       0x88   0xE3A0'2F80        MOV      R2,#+512
   \       0x8C   0xE284'3E80        ADD      R3,R4,#+2048
    321          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    322          	                  | TTB_SECT_AP_FULL_ACCESS
    323          	                  | TTB_SECT_DOMAIN(0xf)
    324          	                  | TTB_SECT_CACHEABLE_WB
    325          	                  | TTB_SECT_SBO
    326          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_2:
   \       0x90   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0x94   0xE282'2001        ADD      R2,R2,#+1
   \       0x98   0xE483'C004        STR      R12,[R3], #+4
   \       0x9C   0xE181'EA02        ORR      LR,R1,R2, LSL #+20
   \       0xA0   0xE282'2001        ADD      R2,R2,#+1
   \       0xA4   0xE483'E004        STR      LR,[R3], #+4
   \       0xA8   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xAC   0xE282'2001        ADD      R2,R2,#+1
   \       0xB0   0xE483'C004        STR      R12,[R3], #+4
   \       0xB4   0xE181'EA02        ORR      LR,R1,R2, LSL #+20
   \       0xB8   0xE282'2001        ADD      R2,R2,#+1
   \       0xBC   0xE483'E004        STR      LR,[R3], #+4
   \       0xC0   0xE352'0F90        CMP      R2,#+576
   \       0xC4   0x3AFF'FFF1        BCC      ??board_cfg_mmu_2
    327          	for (addr = 0x240; addr < 0x300; addr++)
   \       0xC8   0xE3A0'1F90        MOV      R1,#+576
   \       0xCC   0xE284'2E90        ADD      R2,R4,#+2304
    328          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    329          	                  | TTB_SECT_AP_FULL_ACCESS
    330          	                  | TTB_SECT_DOMAIN(0xf)
    331          	                  | TTB_SECT_STRONGLY_ORDERED
    332          	                  | TTB_SECT_SBO
    333          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0xD0   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0xD4   0xE281'1001        ADD      R1,R1,#+1
   \       0xD8   0xE482'3004        STR      R3,[R2], #+4
   \       0xDC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \       0xE0   0xE281'1001        ADD      R1,R1,#+1
   \       0xE4   0xE482'C004        STR      R12,[R2], #+4
   \       0xE8   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0xEC   0xE281'1001        ADD      R1,R1,#+1
   \       0xF0   0xE482'3004        STR      R3,[R2], #+4
   \       0xF4   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \       0xF8   0xE281'1001        ADD      R1,R1,#+1
   \       0xFC   0xE482'C004        STR      R12,[R2], #+4
   \      0x100   0xE351'0FC0        CMP      R1,#+768
   \      0x104   0x3AFF'FFF1        BCC      ??board_cfg_mmu_3
    334          
    335          	/* 0x30000000: EBI Chip Select 2 */
    336          	for (addr = 0x300; addr < 0x400; addr++)
   \      0x108   0xE3A0'1FC0        MOV      R1,#+768
   \      0x10C   0xE284'2EC0        ADD      R2,R4,#+3072
    337          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    338          	                  | TTB_SECT_AP_FULL_ACCESS
    339          	                  | TTB_SECT_DOMAIN(0xf)
    340          	                  | TTB_SECT_STRONGLY_ORDERED
    341          	                  | TTB_SECT_SBO
    342          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_4:
   \      0x110   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x114   0xE281'1001        ADD      R1,R1,#+1
   \      0x118   0xE482'3004        STR      R3,[R2], #+4
   \      0x11C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x120   0xE281'1001        ADD      R1,R1,#+1
   \      0x124   0xE482'C004        STR      R12,[R2], #+4
   \      0x128   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x12C   0xE281'1001        ADD      R1,R1,#+1
   \      0x130   0xE482'3004        STR      R3,[R2], #+4
   \      0x134   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x138   0xE281'1001        ADD      R1,R1,#+1
   \      0x13C   0xE482'C004        STR      R12,[R2], #+4
   \      0x140   0xE351'0E40        CMP      R1,#+1024
   \      0x144   0x3AFF'FFF1        BCC      ??board_cfg_mmu_4
    343          
    344          	/* 0x40000000: EBI Chip Select 3 */
    345          	for (addr = 0x400; addr < 0x500; addr++)
   \      0x148   0xE3A0'1E40        MOV      R1,#+1024
   \      0x14C   0xE284'2D40        ADD      R2,R4,#+4096
    346          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    347          	                  | TTB_SECT_AP_FULL_ACCESS
    348          	                  | TTB_SECT_DOMAIN(0xf)
    349          	                  | TTB_SECT_STRONGLY_ORDERED
    350          	                  | TTB_SECT_SBO
    351          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_5:
   \      0x150   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x154   0xE281'1001        ADD      R1,R1,#+1
   \      0x158   0xE482'3004        STR      R3,[R2], #+4
   \      0x15C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x160   0xE281'1001        ADD      R1,R1,#+1
   \      0x164   0xE482'C004        STR      R12,[R2], #+4
   \      0x168   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x16C   0xE281'1001        ADD      R1,R1,#+1
   \      0x170   0xE482'3004        STR      R3,[R2], #+4
   \      0x174   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x178   0xE281'1001        ADD      R1,R1,#+1
   \      0x17C   0xE482'C004        STR      R12,[R2], #+4
   \      0x180   0xE351'0E50        CMP      R1,#+1280
   \      0x184   0x3AFF'FFF1        BCC      ??board_cfg_mmu_5
    352          
    353          	/* 0x50000000: EBI Chip Select 4 */
    354          	for (addr = 0x500; addr < 0x600; addr++)
   \      0x188   0xE3A0'1E50        MOV      R1,#+1280
   \      0x18C   0xE284'2D50        ADD      R2,R4,#+5120
    355          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    356          	                  | TTB_SECT_AP_FULL_ACCESS
    357          	                  | TTB_SECT_DOMAIN(0xf)
    358          	                  | TTB_SECT_STRONGLY_ORDERED
    359          	                  | TTB_SECT_SBO
    360          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_6:
   \      0x190   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x194   0xE281'1001        ADD      R1,R1,#+1
   \      0x198   0xE482'3004        STR      R3,[R2], #+4
   \      0x19C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1A0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1A4   0xE482'C004        STR      R12,[R2], #+4
   \      0x1A8   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x1AC   0xE281'1001        ADD      R1,R1,#+1
   \      0x1B0   0xE482'3004        STR      R3,[R2], #+4
   \      0x1B4   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1B8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1BC   0xE482'C004        STR      R12,[R2], #+4
   \      0x1C0   0xE351'0E60        CMP      R1,#+1536
   \      0x1C4   0x3AFF'FFF1        BCC      ??board_cfg_mmu_6
    361          
    362          	/* 0x60000000: EBI Chip Select 5 */
    363          	for (addr = 0x600; addr < 0x700; addr++)
   \      0x1C8   0xE3A0'1E60        MOV      R1,#+1536
   \      0x1CC   0xE284'2D60        ADD      R2,R4,#+6144
    364          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    365          	                  | TTB_SECT_AP_FULL_ACCESS
    366          	                  | TTB_SECT_DOMAIN(0xf)
    367          	                  | TTB_SECT_STRONGLY_ORDERED
    368          	                  | TTB_SECT_SBO
    369          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_7:
   \      0x1D0   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x1D4   0xE281'1001        ADD      R1,R1,#+1
   \      0x1D8   0xE482'3004        STR      R3,[R2], #+4
   \      0x1DC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1E0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1E4   0xE482'C004        STR      R12,[R2], #+4
   \      0x1E8   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x1EC   0xE281'1001        ADD      R1,R1,#+1
   \      0x1F0   0xE482'3004        STR      R3,[R2], #+4
   \      0x1F4   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1F8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1FC   0xE482'C004        STR      R12,[R2], #+4
   \      0x200   0xE351'0E70        CMP      R1,#+1792
   \      0x204   0x3AFF'FFF1        BCC      ??board_cfg_mmu_7
    370          
    371          	/* 0x70000000: QSPI0/1 AESB MEM */
    372          	for (addr = 0x700; addr < 0x800; addr++)
   \      0x208   0xE3A0'1E70        MOV      R1,#+1792
   \      0x20C   0xE284'2D70        ADD      R2,R4,#+7168
   \      0x210   0xE3C0'0010        BIC      R0,R0,#0x10
    373          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    374          	                  | TTB_SECT_AP_FULL_ACCESS
    375          	                  | TTB_SECT_DOMAIN(0xf)
    376          #if defined(VARIANT_QSPI0)
    377          	                  | TTB_SECT_CACHEABLE_WB
    378          #else
    379          	                  | TTB_SECT_STRONGLY_ORDERED
    380          #endif
    381          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_8:
   \      0x214   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x218   0xE281'1001        ADD      R1,R1,#+1
   \      0x21C   0xE482'3004        STR      R3,[R2], #+4
   \      0x220   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x224   0xE281'1001        ADD      R1,R1,#+1
   \      0x228   0xE482'C004        STR      R12,[R2], #+4
   \      0x22C   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x230   0xE281'1001        ADD      R1,R1,#+1
   \      0x234   0xE482'3004        STR      R3,[R2], #+4
   \      0x238   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x23C   0xE281'1001        ADD      R1,R1,#+1
   \      0x240   0xE482'C004        STR      R12,[R2], #+4
   \      0x244   0xE351'0E80        CMP      R1,#+2048
   \      0x248   0x3AFF'FFF1        BCC      ??board_cfg_mmu_8
    382          
    383          	/* 0x80000000: SDMMC0 */
    384          	for (addr = 0x800; addr < 0x900; addr++)
   \      0x24C   0xE3A0'1E80        MOV      R1,#+2048
   \      0x250   0xE284'2D80        ADD      R2,R4,#+8192
    385          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    386          	                  | TTB_SECT_AP_FULL_ACCESS
    387          	                  | TTB_SECT_DOMAIN(0xf)
    388          	                  | TTB_SECT_STRONGLY_ORDERED
    389          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_9:
   \      0x254   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x258   0xE281'1001        ADD      R1,R1,#+1
   \      0x25C   0xE482'3004        STR      R3,[R2], #+4
   \      0x260   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x264   0xE281'1001        ADD      R1,R1,#+1
   \      0x268   0xE482'C004        STR      R12,[R2], #+4
   \      0x26C   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x270   0xE281'1001        ADD      R1,R1,#+1
   \      0x274   0xE482'3004        STR      R3,[R2], #+4
   \      0x278   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x27C   0xE281'1001        ADD      R1,R1,#+1
   \      0x280   0xE482'C004        STR      R12,[R2], #+4
   \      0x284   0xE351'0E90        CMP      R1,#+2304
   \      0x288   0x3AFF'FFF1        BCC      ??board_cfg_mmu_9
    390          
    391          	/* 0x90000000: SDMMC1 */
    392          	for (addr = 0x900; addr < 0xa00; addr++)
   \      0x28C   0xE3A0'1E90        MOV      R1,#+2304
   \      0x290   0xE284'2D90        ADD      R2,R4,#+9216
    393          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    394          	                  | TTB_SECT_AP_FULL_ACCESS
    395          	                  | TTB_SECT_DOMAIN(0xf)
    396          	                  | TTB_SECT_STRONGLY_ORDERED
    397          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_10:
   \      0x294   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x298   0xE281'1001        ADD      R1,R1,#+1
   \      0x29C   0xE482'3004        STR      R3,[R2], #+4
   \      0x2A0   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2A4   0xE281'1001        ADD      R1,R1,#+1
   \      0x2A8   0xE482'C004        STR      R12,[R2], #+4
   \      0x2AC   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \      0x2B0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2B4   0xE482'3004        STR      R3,[R2], #+4
   \      0x2B8   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2BC   0xE281'1001        ADD      R1,R1,#+1
   \      0x2C0   0xE482'C004        STR      R12,[R2], #+4
   \      0x2C4   0xE351'0EA0        CMP      R1,#+2560
   \      0x2C8   0x3AFF'FFF1        BCC      ??board_cfg_mmu_10
    398          
    399          	/* 0xeff00000: OTPC */
    400          	tlb[0xeff] = TTB_SECT_ADDR(0xeff00000)
    401          	           | TTB_SECT_AP_FULL_ACCESS
    402          	           | TTB_SECT_DOMAIN(0xf)
    403          	           | TTB_SECT_STRONGLY_ORDERED
    404          	           | TTB_SECT_SBO
    405          	           | TTB_TYPE_SECT;
   \      0x2CC   0xE3A0'00FC        MOV      R0,#+252
   \      0x2D0   0x....'....        LDR      R1,??DataTable12_8  ;; 0xeff00df2
   \      0x2D4   0xE380'0DEC        ORR      R0,R0,#0x3B00
   \      0x2D8   0xE784'1000        STR      R1,[R4, +R0]
    406          
    407          	/* 0xf0000000: Peripherals */
    408          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    409          	           | TTB_SECT_AP_FULL_ACCESS
    410          	           | TTB_SECT_DOMAIN(0xf)
    411          	           | TTB_SECT_STRONGLY_ORDERED
    412          	           | TTB_SECT_SBO
    413          	           | TTB_TYPE_SECT;
   \      0x2DC   0xE084'0000        ADD      R0,R4,R0
   \      0x2E0   0xE281'2940        ADD      R2,R1,#+1048576
    414          
    415          	/* 0xf8000000: Peripherals */
    416          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    417          	           | TTB_SECT_AP_FULL_ACCESS
    418          	           | TTB_SECT_DOMAIN(0xf)
    419          	           | TTB_SECT_STRONGLY_ORDERED
    420          	           | TTB_SECT_SBO
    421          	           | TTB_TYPE_SECT;
   \      0x2E4   0xE281'3681        ADD      R3,R1,#+135266304
    422          
    423          	/* 0xfff0000: System Controller */
    424          	tlb[0xfff] = TTB_SECT_ADDR(0xfff00000)
    425          	           | TTB_SECT_AP_FULL_ACCESS
    426          	           | TTB_SECT_DOMAIN(0xf)
    427          	           | TTB_SECT_STRONGLY_ORDERED
    428          	           | TTB_SECT_SBO
    429          	           | TTB_TYPE_SECT;
   \      0x2E8   0xE381'1540        ORR      R1,R1,#0x10000000
   \      0x2EC   0xE580'2004        STR      R2,[R0, #+4]
   \      0x2F0   0xE580'3204        STR      R3,[R0, #+516]
   \      0x2F4   0xE580'1400        STR      R1,[R0, #+1024]
    430          
    431          	/* Enable MMU, I-Cache and D-Cache */
    432          	mmu_configure(tlb);
   \      0x2F8   0xE1A0'0004        MOV      R0,R4
   \      0x2FC   0x....'....        BL       mmu_configure
    433          	icache_enable();
   \      0x300   0x....'....        BL       icache_enable
    434          	mmu_enable();
   \      0x304   0x....'....        BL       mmu_enable
    435          	dcache_enable();
   \      0x308   0xE8BD'4010        POP      {R4,LR}
   \      0x30C   0x....'....        B        dcache_enable    ;; tailcall
   \                     ??board_cfg_mmu_0:
   \      0x310   0xE8BD'8010        POP      {R4,PC}          ;; return
    436          }
    437          
    438          
    439          #define VDDIOM_1V8_OUT_Z_CALN_TYP 4
    440          #define VDDIOM_1V8_OUT_Z_CALP_TYP 10
    441          

   \                                 In section SOFTPACK, align 4, keep-with-next
    442          void board_cfg_matrix_for_ddr(void)
    443          {
    444          	uint32_t reg;
    445          
    446          	SFR->SFR_CCFG_EBICSA |= SFR_CCFG_EBICSA_EBI_CS1A;
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0x....'....        LDR      R0,??DataTable12_4  ;; 0xf8050004
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE381'2002        ORR      R2,R1,#0x2
   \        0xC   0xE580'2000        STR      R2,[R0, #+0]
    447          	/*
    448          	 * On the first SAM9X60 V/DWB samples, automatic calibration computes
    449          	 * wrong value. Calibrate output impedance manually.
    450          	 */
    451          	reg = SFR->SFR_CAL1;
   \       0x10   0xE590'10B0        LDR      R1,[R0, #+176]
    452          	reg &= ~(SFR_CAL1_CALN_M_Msk | SFR_CAL1_CALP_M_Msk);
    453          	reg |= SFR_CAL1_TEST_M | SFR_CAL1_CALN_M(VDDIOM_1V8_OUT_Z_CALN_TYP) | SFR_CAL1_CALP_M(VDDIOM_1V8_OUT_Z_CALP_TYP);
    454          	SFR->SFR_CAL1 = reg;
   \       0x14   0xE3C1'10FF        BIC      R1,R1,#0xFF
   \       0x18   0xE381'2F69        ORR      R2,R1,#0x1A4
   \       0x1C   0xE580'20B0        STR      R2,[R0, #+176]
    455          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
    456          

   \                                 In section SOFTPACK, align 4, keep-with-next
    457          void board_cfg_matrix_for_nand(void)
    458          {
    459          	uint32_t mask = SFR_CCFG_EBICSA_EBI_CS3A | SFR_CCFG_EBICSA_NFD0_ON_D16;
    460          	uint32_t value = SFR_CCFG_EBICSA_EBI_CS3A;
    461          	uint32_t reg;
    462          
    463          	value |= SFR_CCFG_EBICSA_NFD0_ON_D16;
    464          
    465          	reg = SFR->SFR_CCFG_EBICSA;
   \                     board_cfg_matrix_for_nand:
   \        0x0   0x....'....        LDR      R0,??DataTable12_4  ;; 0xf8050004
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
    466          	reg = (reg & ~mask) | value;
    467          	SFR->SFR_CCFG_EBICSA = reg;
   \        0x8   0xE381'1008        ORR      R1,R1,#0x8
   \        0xC   0xE381'1740        ORR      R1,R1,#0x1000000
   \       0x10   0xE580'1000        STR      R1,[R0, #+0]
    468          }
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
    469          

   \                                 In section SOFTPACK, align 4, keep-with-next
    470          void board_cfg_matrix_for_nand_ex(bool nfd0_on_d16)
    471          {
    472          	uint32_t mask = SFR_CCFG_EBICSA_EBI_CS3A | SFR_CCFG_EBICSA_NFD0_ON_D16;
    473          	uint32_t value = SFR_CCFG_EBICSA_EBI_CS3A;
    474          	uint32_t reg;
    475          
    476          	if (nfd0_on_d16)
    477          		value |= SFR_CCFG_EBICSA_NFD0_ON_D16;
    478          
    479          	reg = SFR->SFR_CCFG_EBICSA;
    480          	reg = (reg & ~mask) | value;
    481          	SFR->SFR_CCFG_EBICSA = reg;
   \                     board_cfg_matrix_for_nand_ex:
   \        0x0   0xE3E0'3008        MVN      R3,#+8
   \        0x4   0xE3A0'1008        MOV      R1,#+8
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x....'....        LDR      R0,??DataTable12_4  ;; 0xf8050004
   \       0x10   0xE3C3'3740        BIC      R3,R3,#0x1000000
   \       0x14   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x18   0x1381'1740        ORRNE    R1,R1,#0x1000000
   \       0x1C   0xE003'2002        AND      R2,R3,R2
   \       0x20   0xE181'1002        ORR      R1,R1,R2
   \       0x24   0xE580'1000        STR      R1,[R0, #+0]
    482          }
   \       0x28   0xE12F'FF1E        BX       LR               ;; return
    483          

   \                                 In section SOFTPACK, align 4, keep-with-next
    484          void board_cfg_ddram(void)
    485          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    486          	board_cfg_matrix_for_ddr();
   \        0x4   0x....'....        LDR      R0,??DataTable12_4  ;; 0xf8050004
   \        0x8   0xE24D'D030        SUB      SP,SP,#+48
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x10   0xE381'2002        ORR      R2,R1,#0x2
   \       0x14   0xE580'2000        STR      R2,[R0, #+0]
   \       0x18   0xE590'10B0        LDR      R1,[R0, #+176]
   \       0x1C   0xE3C1'10FF        BIC      R1,R1,#0xFF
   \       0x20   0xE381'2F69        ORR      R2,R1,#0x1A4
   \       0x24   0xE580'20B0        STR      R2,[R0, #+176]
    487          #ifdef BOARD_DDRAM_TYPE
    488          	struct _mpddrc_desc desc;
    489          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \       0x28   0xE3A0'1000        MOV      R1,#+0
   \       0x2C   0xE1A0'000D        MOV      R0,SP
   \       0x30   0x....'....        BL       ddram_init_descriptor
    490          	ddram_configure(&desc);
   \       0x34   0xE1A0'000D        MOV      R0,SP
   \       0x38   0x....'....        BL       ddram_configure
    491          #endif
    492          #ifdef BOARD_SDRAM_TYPE
    493          	struct _sdramc_desc desc;
    494          	sdram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
    495          	sdram_configure(&desc);
    496          #endif
    497          }
   \       0x3C   0xE28D'D034        ADD      SP,SP,#+52
   \       0x40   0xE8BD'8000        POP      {PC}             ;; return
    498          
    499          #ifdef CONFIG_HAVE_NAND_FLASH
    500          void board_cfg_nand_flash(void)
    501          {
    502          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    503          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    504          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
    505          	board_cfg_matrix_for_nand();
    506          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
    507          #else
    508          	trace_fatal("Cannot configure NAND: target board has no NAND definitions!");
    509          #endif
    510          }
    511          #endif /* CONFIG_HAVE_NAND_FLASH */
    512          
    513          #if defined(BOARD_SDMMC0_PINS) || defined(BOARD_SDMMC1_PINS)
    514          static void board_cfg_sd_clk_caps(uint32_t periph_id, uint32_t *caps0)
    515          {
    516          		uint32_t base_freq, mult_freq, val;
    517          
    518          		/* Retrieve the frequency of MULTCLK.
    519          		 * Usual values of this frequency are 100 MHz, 104 MHz. */
    520          		mult_freq = pmc_get_gck_clock(periph_id);
    521          
    522          		/* Retrieve the frequency of BASECLK and TEOCLK.
    523          		 * Usual values of this frequency are 50 MHz, 52 MHz. */
    524          		base_freq = ROUND_INT_DIV(mult_freq, 2 * 1000000lu);
    525          		val = base_freq > (SDMMC_CA0R_BASECLKF_Msk >> SDMMC_CA0R_BASECLKF_Pos)
    526          		    ? 0 : base_freq;
    527          		*caps0 |= SDMMC_CA0R_BASECLKF(val);
    528          		val = base_freq > (SDMMC_CA0R_TEOCLKF_Msk >> SDMMC_CA0R_TEOCLKF_Pos)
    529          		    ? 0 : base_freq;
    530          		*caps0 |= SDMMC_CA0R_TEOCLKF(val) | SDMMC_CA0R_TEOCLKU;
    531          }
    532          #endif
    533          

   \                                 In section SOFTPACK, align 4, keep-with-next
    534          bool board_cfg_sdmmc(uint32_t periph_id)
    535          {
   \                     board_cfg_sdmmc:
   \        0x0   0xE92D'4000        PUSH     {LR}
   \        0x4   0xE24D'D044        SUB      SP,SP,#+68
    536          	switch (periph_id) {
   \        0x8   0xE350'000C        CMP      R0,#+12
   \        0xC   0x0A00'0002        BEQ      ??board_cfg_sdmmc_0
   \       0x10   0xE350'001A        CMP      R0,#+26
   \       0x14   0x0A00'002D        BEQ      ??board_cfg_sdmmc_1
   \       0x18   0xEA00'004C        B        ??board_cfg_sdmmc_2
    537          	case ID_SDMMC0:
    538          	{
    539          #if defined(BOARD_SDMMC0_CAPS0) && defined(BOARD_SDMMC0_PINS)
    540          		struct _pin pins[] = BOARD_SDMMC0_PINS;
   \                     ??board_cfg_sdmmc_0:
   \       0x1C   0xE28D'0004        ADD      R0,SP,#+4
   \       0x20   0x....'....        LDR      R1,??DataTable12_9
   \       0x24   0xE3A0'2040        MOV      R2,#+64
   \       0x28   0x....'....        BL       __aeabi_memcpy4
    541          		uint32_t caps0 = BOARD_SDMMC0_CAPS0;
    542          #ifdef BOARD_SDMMC0_PIO_ATTR
    543          		uint8_t ix;
    544          #endif
    545          
    546          		/* Program capabilities for SDMMC0 */
    547          		board_cfg_sd_clk_caps(ID_SDMMC0, &caps0);
   \       0x2C   0xE3A0'000C        MOV      R0,#+12
   \       0x30   0x....'....        BL       pmc_get_gck_clock
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x1A00'0006        BNE      ??board_cfg_sdmmc_3
   \                     ??board_cfg_sdmmc_4:
   \       0x3C   0xE3A0'1CFF        MOV      R1,#+65280
   \       0x40   0xE001'1400        AND      R1,R1,R0, LSL #+8
   \       0x44   0xE350'003F        CMP      R0,#+63
   \       0x48   0xE381'1740        ORR      R1,R1,#0x1000000
   \       0x4C   0x9200'003F        ANDLS    R0,R0,#0x3F
   \       0x50   0x9180'1001        ORRLS    R1,R0,R1
   \       0x54   0xEA00'0008        B        ??board_cfg_sdmmc_5
   \                     ??board_cfg_sdmmc_3:
   \       0x58   0xE3A0'1AF4        MOV      R1,#+999424
   \       0x5C   0xE381'1F90        ORR      R1,R1,#0x240
   \       0x60   0x....'....        LDR      R3,??DataTable12_10  ;; 0x8637bd06
   \       0x64   0xE081'0000        ADD      R0,R1,R0
   \       0x68   0xE082'3390        UMULL    R3,R2,R0,R3
   \       0x6C   0xE1A0'0A22        LSR      R0,R2,#+20
   \       0x70   0xE350'0F40        CMP      R0,#+256
   \       0x74   0x3AFF'FFF0        BCC      ??board_cfg_sdmmc_4
   \       0x78   0xE3A0'1740        MOV      R1,#+16777216
    548          		sdmmc_set_capabilities(SDMMC0, caps0, SDMMC_CA0R_SLTYPE_Msk |
    549          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    550          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    551          		    SDMMC_CA0R_TEOCLKF_Msk, 0, 0);
   \                     ??board_cfg_sdmmc_5:
   \       0x7C   0xE3A0'2000        MOV      R2,#+0
   \       0x80   0xE58D'2000        STR      R2,[SP, #+0]
   \       0x84   0xE3A0'3000        MOV      R3,#+0
   \       0x88   0x....'....        LDR      R2,??DataTable12_11  ;; 0xc700ffbf
   \       0x8C   0xE381'1080        ORR      R1,R1,#0x80
   \       0x90   0xE3A0'0480        MOV      R0,#-2147483648
   \       0x94   0x....'....        BL       sdmmc_set_capabilities
    552          
    553          		/* Configure SDMMC0 pins */
    554          #ifdef BOARD_SDMMC0_PIO_ATTR
    555          		/* Tune the attributes of CMD, CK and DAT* peripheral outputs */
    556          		for (ix = 0; ix < ARRAY_SIZE(pins); ix++) {
   \       0x98   0xE28D'0004        ADD      R0,SP,#+4
   \       0x9C   0xE3A0'1004        MOV      R1,#+4
    557          			if (pins[ix].type == PIO_INPUT)
   \                     ??board_cfg_sdmmc_6:
   \       0xA0   0xE5D0'2008        LDRB     R2,[R0, #+8]
   \       0xA4   0xE352'0007        CMP      R2,#+7
    558          				continue;
    559          			pins[ix].attribute |= BOARD_SDMMC0_PIO_ATTR;
   \       0xA8   0x1590'200C        LDRNE    R2,[R0, #+12]
   \       0xAC   0x1382'3EA0        ORRNE    R3,R2,#0xA00
   \       0xB0   0x1580'300C        STRNE    R3,[R0, #+12]
    560          		}
   \       0xB4   0xE280'0010        ADD      R0,R0,#+16
   \       0xB8   0xE251'1001        SUBS     R1,R1,#+1
   \       0xBC   0x1AFF'FFF7        BNE      ??board_cfg_sdmmc_6
    561          #endif
    562          		pio_configure(pins, ARRAY_SIZE(pins));
   \       0xC0   0xE3A0'1004        MOV      R1,#+4
   \       0xC4   0xE28D'0004        ADD      R0,SP,#+4
   \       0xC8   0x....'....        BL       pio_configure
    563          		return true;
   \       0xCC   0xEA00'001C        B        ??board_cfg_sdmmc_7
    564          #else
    565          		trace_fatal("Cannot configure SDMMC0: target board has no SDMMC0 definitions!");
    566          		return false;
    567          #endif
    568          	}
    569          	case ID_SDMMC1:
    570          	{
    571          #if defined(BOARD_SDMMC1_CAPS0) && defined(BOARD_SDMMC1_PINS)
    572          		const struct _pin pins[] = BOARD_SDMMC1_PINS;
    573          		uint32_t caps0 = BOARD_SDMMC1_CAPS0;
    574          
    575          		/* Program capabilities for SDMMC1 */
    576          		board_cfg_sd_clk_caps(ID_SDMMC1, &caps0);
   \                     ??board_cfg_sdmmc_1:
   \       0xD0   0x....'....        BL       pmc_get_gck_clock
   \       0xD4   0xE350'0000        CMP      R0,#+0
   \       0xD8   0x1A00'0006        BNE      ??board_cfg_sdmmc_8
   \                     ??board_cfg_sdmmc_9:
   \       0xDC   0xE3A0'1CFF        MOV      R1,#+65280
   \       0xE0   0xE001'1400        AND      R1,R1,R0, LSL #+8
   \       0xE4   0xE350'003F        CMP      R0,#+63
   \       0xE8   0xE381'1441        ORR      R1,R1,#0x41000000
   \       0xEC   0x9200'003F        ANDLS    R0,R0,#0x3F
   \       0xF0   0x9180'1001        ORRLS    R1,R0,R1
   \       0xF4   0xEA00'0008        B        ??board_cfg_sdmmc_10
   \                     ??board_cfg_sdmmc_8:
   \       0xF8   0xE3A0'1AF4        MOV      R1,#+999424
   \       0xFC   0xE381'1F90        ORR      R1,R1,#0x240
   \      0x100   0x....'....        LDR      R3,??DataTable12_10  ;; 0x8637bd06
   \      0x104   0xE081'0000        ADD      R0,R1,R0
   \      0x108   0xE082'3390        UMULL    R3,R2,R0,R3
   \      0x10C   0xE1A0'0A22        LSR      R0,R2,#+20
   \      0x110   0xE350'0F40        CMP      R0,#+256
   \      0x114   0x3AFF'FFF0        BCC      ??board_cfg_sdmmc_9
   \      0x118   0xE3A0'1441        MOV      R1,#+1090519040
    577          		sdmmc_set_capabilities(SDMMC1, caps0, SDMMC_CA0R_SLTYPE_Msk |
    578          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    579          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    580          		    SDMMC_CA0R_TEOCLKF_Msk, 0, 0);
   \                     ??board_cfg_sdmmc_10:
   \      0x11C   0xE3A0'2000        MOV      R2,#+0
   \      0x120   0xE58D'2000        STR      R2,[SP, #+0]
   \      0x124   0xE3A0'3000        MOV      R3,#+0
   \      0x128   0x....'....        LDR      R2,??DataTable12_11  ;; 0xc700ffbf
   \      0x12C   0xE381'1080        ORR      R1,R1,#0x80
   \      0x130   0xE3A0'0490        MOV      R0,#-1879048192
   \      0x134   0x....'....        BL       sdmmc_set_capabilities
    581          
    582          		/* Configure SDMMC1 pins */
    583          		pio_configure(pins, ARRAY_SIZE(pins));
   \      0x138   0xE3A0'1003        MOV      R1,#+3
   \      0x13C   0x....'....        LDR      R0,??DataTable12_12
   \      0x140   0x....'....        BL       pio_configure
    584          		return true;
   \                     ??board_cfg_sdmmc_7:
   \      0x144   0xE3A0'0001        MOV      R0,#+1
   \      0x148   0xE28D'D044        ADD      SP,SP,#+68
   \      0x14C   0xE8BD'8000        POP      {PC}
    585          #else
    586          		trace_fatal("Cannot configure SDMMC1: target board has no SDMMC1 definitions!");
    587          		return false;
    588          #endif
    589          	}
    590          	default:
    591          		return false;
   \                     ??board_cfg_sdmmc_2:
   \      0x150   0xE3A0'0000        MOV      R0,#+0
   \      0x154   0xE28D'D044        ADD      SP,SP,#+68
   \      0x158   0xE8BD'8000        POP      {PC}             ;; return
    592          	}
    593          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0080'0000        DC32 8'388'608
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0002'0000        DC32 131'072
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0000        DC32 0
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x0001'0000        DC32 65'536
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x34   0x001C'8000        DC32 1'867'776
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x44   0x0000'2000        DC32 8'192
   \       0x48   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x4C   0x0000'0000        DC32 0
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x54   0x0000'1000        DC32 4'096
   \       0x58   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x5C   0x0000'0001        DC32 1
   \       0x60   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x64   0x0000'081C        DC32 2'076
   \       0x68   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x6C   0x0000'0001        DC32 1
    594          

   \                                 In section SOFTPACK, align 4, keep-with-next
    595          bool board_get_sdmmc_card_detect_status(uint32_t periph_id)
    596          {
   \                     board_get_sdmmc_card_detect_status:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    597          	const struct _pin *cd_input = NULL;
    598          
    599          #ifdef BOARD_SDMMC0_PIN_CD
    600          	const struct _pin cd0_input = BOARD_SDMMC0_PIN_CD;
    601          	cd_input = periph_id == ID_SDMMC0 ? &cd0_input : cd_input;
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0x1A00'0004        BNE      ??board_get_sdmmc_card_detect_status_0
    602          #endif
    603          
    604          #ifdef BOARD_SDMMC1_PIN_CD
    605          	const struct _pin cd1_input = BOARD_SDMMC1_PIN_CD;
    606          	cd_input = periph_id == ID_SDMMC1 ? &cd1_input : cd_input;
    607          #endif
    608          
    609          	if (periph_id != ID_SDMMC0 && periph_id != ID_SDMMC1)
    610          		return false;
    611          
    612          	/* No detection; assume the card/device is always present */
    613          	if (!cd_input)
    614          		return true;
    615          
    616          	return pio_get(cd_input) ? false : true;
   \        0xC   0x....'....        ADR      R0,`board_get_sdmmc_card_detect_status::cd0_input`
   \       0x10   0x....'....        BL       pio_get
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x1A00'0004        BNE      ??board_get_sdmmc_card_detect_status_1
   \       0x1C   0xEA00'0001        B        ??board_get_sdmmc_card_detect_status_2
   \                     ??board_get_sdmmc_card_detect_status_0:
   \       0x20   0xE350'001A        CMP      R0,#+26
   \       0x24   0x1A00'0001        BNE      ??board_get_sdmmc_card_detect_status_1
   \                     ??board_get_sdmmc_card_detect_status_2:
   \       0x28   0xE3A0'0001        MOV      R0,#+1
   \       0x2C   0xE8BD'8002        POP      {R1,PC}
   \                     ??board_get_sdmmc_card_detect_status_1:
   \       0x30   0xE3A0'0000        MOV      R0,#+0
   \       0x34   0xE8BD'8002        POP      {R1,PC}          ;; return
    617          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_get_sdmmc_card_detect_status::cd0_input`:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0080'0000        DC32 8'388'608
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0xF805'0004        DC32     0xf8050004

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x0040'0DF6        DC32     0x400df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0xEFF0'0DF2        DC32     0xeff00df2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x8637'BD06        DC32     0x8637bd06

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0xC700'FFBF        DC32     0xc700ffbf

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     ?_2+0x40

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x73 0x61          DC8 "sam9x60-ek"

   \              0x6D 0x39    

   \              0x78 0x36    

   \              0x30 0x2D    

   \              0x65 0x6B    

   \              0x00
   \        0xB   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   board_cfg_clocks
        32   -> __aeabi_memcpy
        32   -> pmc_configure_plla
        32   -> pmc_get_main_oscillator_freq
        32   -> pmc_select_external_osc
        32   -> pmc_set_mck_divider
        32   -> pmc_set_mck_prescaler
        32   -> pmc_switch_mck_to_main
        32   -> pmc_switch_mck_to_pll
      32   board_cfg_clocks_for_preset
        32   -> __aeabi_memcpy
        32   -> pmc_configure_plla
        32   -> pmc_get_main_oscillator_freq
        32   -> pmc_select_external_osc
        32   -> pmc_set_mck_divider
        32   -> pmc_set_mck_prescaler
        32   -> pmc_switch_mck_to_main
        32   -> pmc_switch_mck_to_pll
        32   -> printf
      56   board_cfg_ddram
        56   -> ddram_configure
        56   -> ddram_init_descriptor
      64   board_cfg_lowlevel
        64   -> __aeabi_memcpy
        64   -> board_cfg_mmu
        64   -> board_cfg_timer
        64   -> ddram_configure
        64   -> ddram_init_descriptor
        64   -> irq_initialize
        64   -> pio_reset_all_it
        64   -> pmc_configure_plla
        64   -> pmc_get_main_oscillator_freq
        64   -> pmc_select_external_osc
        64   -> pmc_set_main_oscillator_freq
        64   -> pmc_set_mck_divider
        64   -> pmc_set_mck_prescaler
        64   -> pmc_switch_mck_to_main
        64   -> pmc_switch_mck_to_pll
        64   -> wdt_disable
       0   board_cfg_matrix_for_ddr
       0   board_cfg_matrix_for_nand
       0   board_cfg_matrix_for_nand_ex
       8   board_cfg_mmu
         8   -> __aeabi_memclr4
         0   -> dcache_enable
         8   -> icache_enable
         8   -> mmu_configure
         8   -> mmu_enable
         8   -> mmu_is_enabled
      72   board_cfg_sdmmc
        72   -> __aeabi_memcpy4
        72   -> pio_configure
        72   -> pmc_get_gck_clock
        72   -> sdmmc_set_capabilities
       8   board_get_sdmmc_card_detect_status
         8   -> pio_get
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_clock
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable12
        4  ??DataTable12_1
        4  ??DataTable12_10
        4  ??DataTable12_11
        4  ??DataTable12_12
        4  ??DataTable12_2
        4  ??DataTable12_3
        4  ??DataTable12_4
        4  ??DataTable12_5
        4  ??DataTable12_6
        4  ??DataTable12_7
        4  ??DataTable12_8
        4  ??DataTable12_9
       64  ?_1
       12  ?_3
      152  board_cfg_clocks
      208  board_cfg_clocks_for_preset
       68  board_cfg_ddram
      268  board_cfg_lowlevel
       36  board_cfg_matrix_for_ddr
       24  board_cfg_matrix_for_nand
       44  board_cfg_matrix_for_nand_ex
      788  board_cfg_mmu
      348  board_cfg_sdmmc
       56  board_get_sdmmc_card_detect_status
        4  board_name
       76  board_restore_pio_reset_state
      116  board_save_misc_power
       16  cd0_input
        8  get_board_name
      112  pins
      240  plla_configs
   16'384  tlb

 
      4 bytes in section .data
 16'384 bytes in section .region_ddr
    428 bytes in section .rodata
  2'260 bytes in section SOFTPACK
 
  2'260 bytes of CODE  memory
    428 bytes of CONST memory
 16'388 bytes of DATA  memory

Errors: none
Warnings: none
