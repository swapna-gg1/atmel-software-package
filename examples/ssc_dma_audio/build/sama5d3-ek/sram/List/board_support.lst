###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         08/Dec/2020  16:47:01
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d3\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW40D2.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d3\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D3 -D
#        CONFIG_CHIP_SAMA5D36 -D CONFIG_BOARD_SAMA5D3_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_PIO3 -D CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_INPUT_OFFSET -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_PLLA_CHARGE_PUMP -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_PMC_PERIPH_DIV -D CONFIG_HAVE_SCKC -D
#        CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_DMAC
#        -D CONFIG_HAVE_DMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_SMD -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_MT47H128M16 -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_TC_FAULT_MODE -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC
#        -D CONFIG_HAVE_AUDIO_WM8904 -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_USART --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d3-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d3-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d3-ek\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\target\sama5d3\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d3-ek\sram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d3-ek\sram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d3\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "timer.h"
     44          #include "trace.h"
     45          
     46          #include "irq/irq.h"
     47          #include "peripherals/matrix.h"
     48          #include "gpio/pio.h"
     49          #include "peripherals/pmc.h"
     50          #include "extram/smc.h"
     51          #include "peripherals/wdt.h"
     52          
     53          #include "extram/ddram.h"
     54          
     55          #include "arm/mmu_cp15.h"
     56          #include "mm/l1cache.h"
     57          
     58          #include "board_support.h"
     59          
     60          #ifdef CONFIG_HAVE_PMIC_ACT8865
     61          #include "power/act8865.h"
     62          #endif
     63          
     64          /*----------------------------------------------------------------------------
     65           *        Local constants
     66           *----------------------------------------------------------------------------*/
     67          
     68          #ifdef CONFIG_HAVE_PMIC_ACT8865
     69          static struct _act8865 pmic = {
     70          	.bus = BOARD_ACT8865_TWI_BUS,
     71          	.addr = BOARD_ACT8865_TWI_ADDR,
     72          };
     73          #endif
     74          

   \                                 In section .data, align 4
   \        0x0   0x....'....        DC32 ?_5
     75          static const char* board_name = BOARD_NAME;
     76          
     77          /*----------------------------------------------------------------------------
     78           *        Local variables
     79           *----------------------------------------------------------------------------*/
     80          

   \                                 In section .bss, align 16384
     81          ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     82          
     83          
     84          /*----------------------------------------------------------------------------
     85           *        Local functions
     86           *----------------------------------------------------------------------------*/
     87          

   \                                 In section SOFTPACK, align 4, keep-with-next
     88          static bool board_cfg_sd_dev_pins(uint32_t periph_id, bool down, bool up)
     89          {
   \                     board_cfg_sd_dev_pins:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE24D'D060        SUB      SP,SP,#+96
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE1A0'6001        MOV      R6,R1
   \       0x10   0xE1A0'4002        MOV      R4,R2
     90          	struct _pin *dev_pins = NULL;
     91          	uint32_t count = 0, pin;
     92          
     93          #ifdef BOARD_HSMCI0_DEV_PINS
     94          	struct _pin dev0_pins[] = BOARD_HSMCI0_DEV_PINS;
   \       0x14   0xE28D'0030        ADD      R0,SP,#+48
   \       0x18   0x....'....        LDR      R1,??DataTable14
   \       0x1C   0xE3A0'2030        MOV      R2,#+48
   \       0x20   0x....'....        BL       __aeabi_memcpy4
     95          	if (periph_id == ID_HSMCI0) {
   \       0x24   0xE355'0015        CMP      R5,#+21
   \       0x28   0x....'....        LDR      R1,??DataTable14_1
   \       0x2C   0x1A00'000C        BNE      ??board_cfg_sd_dev_pins_0
     96          		dev_pins = dev0_pins;
     97          		count = ARRAY_SIZE(dev0_pins);
   \       0x30   0xE1A0'000D        MOV      R0,SP
   \       0x34   0xE3A0'2030        MOV      R2,#+48
   \       0x38   0x....'....        BL       __aeabi_memcpy4
   \       0x3C   0xE28D'5030        ADD      R5,SP,#+48
     98          	}
     99          #endif
    100          
    101          #ifdef BOARD_HSMCI1_DEV_PINS
    102          	struct _pin dev1_pins[] = BOARD_HSMCI1_DEV_PINS;
    103          	if (periph_id == ID_HSMCI1) {
    104          		dev_pins = dev1_pins;
    105          		count = ARRAY_SIZE(dev1_pins);
    106          	}
    107          #endif
    108          
    109          #ifdef BOARD_HSMCI2_DEV_PINS
    110          	struct _pin dev2_pins[] = BOARD_HSMCI2_DEV_PINS;
    111          	if (periph_id == ID_HSMCI2) {
    112          		dev_pins = dev2_pins;
    113          		count = ARRAY_SIZE(dev2_pins);
    114          	}
    115          #endif
    116          
    117          	if (count == 0)
    118          		return false;
    119          
    120          	for (pin = 0; (down || up) && pin < count; pin++) {
   \                     ??board_cfg_sd_dev_pins_1:
   \       0x40   0xE194'3006        ORRS     R3,R4,R6
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0xE285'100C        ADD      R1,R5,#+12
   \       0x4C   0xE3A0'2000        MOV      R2,#+0
   \       0x50   0x0A00'0010        BEQ      ??board_cfg_sd_dev_pins_2
    121          		dev_pins[pin].type = up ? PIO_OUTPUT_1 : PIO_OUTPUT_0;
   \                     ??board_cfg_sd_dev_pins_3:
   \       0x54   0xE1B0'3004        MOVS     R3,R4
   \       0x58   0x13A0'3009        MOVNE    R3,#+9
   \       0x5C   0x03A0'3008        MOVEQ    R3,#+8
   \       0x60   0xEA00'0007        B        ??board_cfg_sd_dev_pins_4
   \                     ??board_cfg_sd_dev_pins_0:
   \       0x64   0xE1A0'000D        MOV      R0,SP
   \       0x68   0xE3A0'2030        MOV      R2,#+48
   \       0x6C   0x....'....        BL       __aeabi_memcpy4
   \       0x70   0xE355'0016        CMP      R5,#+22
   \       0x74   0x01A0'500D        MOVEQ    R5,SP
   \       0x78   0x0AFF'FFF0        BEQ      ??board_cfg_sd_dev_pins_1
   \       0x7C   0xE3A0'0000        MOV      R0,#+0
   \       0x80   0x....'....        B        ?Subroutine0
    122          		dev_pins[pin].attribute = PIO_DEFAULT;
    123          	}
   \                     ??board_cfg_sd_dev_pins_4:
   \       0x84   0xE280'0001        ADD      R0,R0,#+1
   \       0x88   0xE541'3004        STRB     R3,[R1, #-4]
   \       0x8C   0xE350'0003        CMP      R0,#+3
   \       0x90   0xE481'2010        STR      R2,[R1], #+16
   \       0x94   0x3AFF'FFEE        BCC      ??board_cfg_sd_dev_pins_3
    124          
    125          	pio_configure(dev_pins, count);
   \                     ??board_cfg_sd_dev_pins_2:
   \       0x98   0xE3A0'1003        MOV      R1,#+3
   \       0x9C   0xE1A0'0005        MOV      R0,R5
   \       0xA0   0x....'....        BL       pio_configure
    126          	return true;
   \       0xA4   0xE3A0'0001        MOV      R0,#+1
   \       0xA8                      REQUIRE ?Subroutine0
   \       0xA8                      ;; // Fall through to label ?Subroutine0
    127          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE28D'D060        ADD      SP,SP,#+96
   \        0x4   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    128          
    129          /*----------------------------------------------------------------------------
    130           *        Exported functions
    131           *----------------------------------------------------------------------------*/
    132          

   \                                 In section SOFTPACK, align 4, keep-with-next
    133          const char* get_board_name(void)
    134          {
    135          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable14_2
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    136          }
    137          

   \                                 In section SOFTPACK, align 4, keep-with-next
    138          void board_cfg_clocks(void)
    139          {
    140          	struct _pmc_plla_cfg plla_config = {
    141          		.mul = 43,
    142          		.div = 1,
    143          		.count = 0x3f,
    144          		.icp = 3,
    145          	};
   \                     board_cfg_clocks:
   \        0x0   0x....'....        LDR      R1,??DataTable14_3
   \        0x4   0xE92D'5000        PUSH     {R12,LR}
   \        0x8   0xE891'500C        LDM      R1,{R2,R3,R12,LR}
   \        0xC   0xE24D'D010        SUB      SP,SP,#+16
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0xE880'500C        STM      R0,{R2,R3,R12,LR}
    146          	pmc_select_external_osc(false);
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0x....'....        BL       pmc_select_external_osc
    147          	pmc_switch_mck_to_main();
   \       0x20   0x....'....        BL       pmc_switch_mck_to_main
    148          	pmc_set_mck_plladiv2(false);
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0x....'....        BL       pmc_set_mck_plladiv2
    149          	pmc_configure_plla(&plla_config);
   \       0x2C   0xE1A0'000D        MOV      R0,SP
   \       0x30   0x....'....        BL       pmc_configure_plla
    150          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0x....'....        BL       pmc_set_mck_prescaler
    151          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV4);
   \       0x3C   0xE3A0'0F80        MOV      R0,#+512
   \       0x40   0x....'....        BL       pmc_set_mck_divider
    152          	pmc_switch_mck_to_pll();
   \       0x44   0x....'....        BL       pmc_switch_mck_to_pll
    153          }
   \       0x48   0xE28D'D014        ADD      SP,SP,#+20
   \       0x4C   0xE8BD'8000        POP      {PC}             ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x0000'002B        DC32 43, 1, 63, 3

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0003
    154          

   \                                 In section SOFTPACK, align 4, keep-with-next
    155          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    156          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4078        PUSH     {R3-R6,LR}
   \        0x4   0xE24D'D02C        SUB      SP,SP,#+44
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'5001        MOV      R5,R1
   \       0x10   0xE1A0'6002        MOV      R6,R2
    157          	/* Disable Watchdog */
    158          	wdt_disable();
   \       0x14   0x....'....        BL       wdt_disable
    159          
    160          	/* Disable all PIO interrupts */
    161          	pio_reset_all_it();
   \       0x18   0x....'....        BL       pio_reset_all_it
    162          
    163          	/* Set external oscillator frequency */
    164          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x1C   0xE3A0'08B7        MOV      R0,#+11993088
   \       0x20   0xE380'0D6C        ORR      R0,R0,#0x1B00
   \       0x24   0x....'....        BL       pmc_set_main_oscillator_freq
    165          
    166          	if (clocks) {
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_0
    167          		/* Configure system clocks */
    168          		board_cfg_clocks();
   \       0x30   0x....'....        BL       board_cfg_clocks
    169          	}
    170          
    171          	/* Setup default interrupt handlers */
    172          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0x34   0x....'....        BL       irq_initialize
    173          
    174          	/* Configure system timer */
    175          	board_cfg_timer();
   \       0x38   0x....'....        BL       board_cfg_timer
    176          
    177          	if (ddram) {
   \       0x3C   0xE355'0000        CMP      R5,#+0
   \       0x40   0x0A00'0004        BEQ      ??board_cfg_lowlevel_1
    178          		/* Configure DDRAM */
    179          		board_cfg_ddram();
   \       0x44   0xE3A0'1000        MOV      R1,#+0
   \       0x48   0xE1A0'000D        MOV      R0,SP
   \       0x4C   0x....'....        BL       ddram_init_descriptor
   \       0x50   0xE1A0'000D        MOV      R0,SP
   \       0x54   0x....'....        BL       ddram_configure
    180          	}
    181          
    182          	if (mmu) {
   \                     ??board_cfg_lowlevel_1:
   \       0x58   0xE356'0000        CMP      R6,#+0
   \       0x5C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_2
    183          		/* Setup MMU */
    184          		board_cfg_mmu();
   \       0x60   0x....'....        BL       board_cfg_mmu
    185          	}
    186          }
   \                     ??board_cfg_lowlevel_2:
   \       0x64   0xE28D'D030        ADD      SP,SP,#+48
   \       0x68   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    187          

   \                                 In section SOFTPACK, align 4, keep-with-next
    188          void board_restore_pio_reset_state(void)
    189          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    190          	int i;
    191          
    192          	/* all pins, excluding JTAG and NTRST */
    193          	struct _pin pins[] = {
    194          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    195          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    196          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    197          		{ PIO_GROUP_D, 0xFFF83FFF, PIO_INPUT, PIO_PULLUP },
    198          	};
   \        0x8   0x....'....        LDR      R1,??DataTable14_4
   \        0xC   0xE1A0'000D        MOV      R0,SP
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    199          
    200          	/* For low_power_mode example, power consumption results can be affected
    201          	* by IOs setting. To generate power consumption numbers in datasheet,
    202          	* most IOs must be disconnected from external devices just like on
    203          	* VB board. Then putting IOs to reset state are OK.
    204          	* On SAMA5D3-XULT board, please put IOs to output state as below.
    205          	*/
    206          	//struct _pin pins[] = {
    207          	//	{ PIO_GROUP_A, 0xFFFFFFFF, PIO_OUTPUT, PIO_PULLUP },
    208          	//	{ PIO_GROUP_B, 0xFFFFFFFF, PIO_OUTPUT, PIO_PULLUP },
    209          	//	{ PIO_GROUP_C, 0xFFFFFFFF, PIO_OUTPUT, PIO_PULLUP },
    210          	//	{ PIO_GROUP_D, 0xFFF83FFF, PIO_OUTPUT, PIO_PULLUP },
    211          	//};
    212          
    213          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1A0'000D        MOV      R0,SP
   \       0x20   0x....'....        BL       pio_configure
    214          	for (i = 0; i < ARRAY_SIZE(pins); i++)
    215          		pio_clear(&pins[i]);
   \       0x24   0xE1A0'000D        MOV      R0,SP
   \       0x28   0x....'....        BL       pio_clear
   \       0x2C   0xE28D'0010        ADD      R0,SP,#+16
   \       0x30   0x....'....        BL       pio_clear
   \       0x34   0xE28D'0020        ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       pio_clear
   \       0x3C   0xE28D'0030        ADD      R0,SP,#+48
   \       0x40   0x....'....        BL       pio_clear
    216          }
   \       0x44   0xE28D'D044        ADD      SP,SP,#+68
   \       0x48   0xE8BD'8000        POP      {PC}             ;; return
    217          

   \                                 In section SOFTPACK, align 4, keep-with-next
    218          void board_save_misc_power(void)
    219          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    220          	int i;
    221          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'04F8        MOV      R0,#-134217728
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0xE380'0B50        ORR      R0,R0,#0x14000
   \       0x10   0xE3A0'5003        MOV      R5,#+3
   \       0x14   0x....'....        BL       get_tc_id_from_addr
   \       0x18   0xE1A0'4000        MOV      R4,R0
    222          
    223          	/* disable USB clock */
    224          	pmc_disable_upll_clock();
   \       0x1C   0x....'....        BL       pmc_disable_upll_clock
    225          	pmc_disable_upll_bias();
   \       0x20   0x....'....        BL       pmc_disable_upll_bias
    226          
    227          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    228          	/* Disable audio clock */
    229          	pmc_disable_audio();
    230          #endif
    231          
    232          	/* disable system clocks */
    233          #ifdef VARIANT_SRAM
    234          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0x....'....        BL       pmc_disable_system_clock
    235          #endif
    236          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0x2C   0xE3A0'0001        MOV      R0,#+1
   \       0x30   0x....'....        BL       pmc_disable_system_clock
    237          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_SMD);
   \       0x34   0xE3A0'0002        MOV      R0,#+2
   \       0x38   0x....'....        BL       pmc_disable_system_clock
    238          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x3C   0xE3A0'0003        MOV      R0,#+3
   \       0x40   0x....'....        BL       pmc_disable_system_clock
    239          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UDP);
   \       0x44   0xE3A0'0004        MOV      R0,#+4
   \       0x48   0x....'....        BL       pmc_disable_system_clock
    240          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x4C   0xE3A0'0005        MOV      R0,#+5
   \       0x50   0x....'....        BL       pmc_disable_system_clock
    241          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x54   0xE3A0'0006        MOV      R0,#+6
   \       0x58   0x....'....        BL       pmc_disable_system_clock
    242          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK2);
   \       0x5C   0xE3A0'0007        MOV      R0,#+7
   \       0x60   0x....'....        BL       pmc_disable_system_clock
    243          #ifdef PMC_SCER_ISCCK
    244          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_ISC);
    245          #endif
    246          
    247          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    248          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x64   0xEA00'0001        B        ??board_save_misc_power_0
    249          		if (i == ID_PIOA)
   \                     ??board_save_misc_power_1:
   \       0x68   0xE355'0006        CMP      R5,#+6
   \       0x6C   0x0A00'0003        BEQ      ??board_save_misc_power_2
    250          			continue;
    251          		if (i == tc_id)
   \                     ??board_save_misc_power_0:
   \       0x70   0xE155'0004        CMP      R5,R4
   \       0x74   0x0A00'0001        BEQ      ??board_save_misc_power_2
    252          			continue;
    253          #ifdef VARIANT_DDRAM
    254          		if (i == ID_MPDDRC)
    255          			continue;
    256          #endif
    257          		pmc_disable_peripheral(i);
   \       0x78   0xE1A0'0005        MOV      R0,R5
   \       0x7C   0x....'....        BL       pmc_disable_peripheral
    258          	}
   \                     ??board_save_misc_power_2:
   \       0x80   0xE285'5001        ADD      R5,R5,#+1
   \       0x84   0xE355'0032        CMP      R5,#+50
   \       0x88   0xBAFF'FFF6        BLT      ??board_save_misc_power_1
    259          }
   \       0x8C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    260          

   \                                 In section SOFTPACK, align 4, keep-with-next
    261          void board_cfg_mmu(void)
    262          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    263          	uint32_t addr;
    264          
    265          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'0092        BNE      ??board_cfg_mmu_0
    266          		return;
    267          
    268          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    269          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    270          	   be verified for correct operation when write-back is enabled */
    271          
    272          	/* Reset table entries */
    273          	for (addr = 0; addr < 4096; addr++)
    274          		tlb[addr] = 0;
   \       0x10   0x....'....        LDR      R4,??DataTable14_5
   \       0x14   0xE3A0'1C40        MOV      R1,#+16384
   \       0x18   0xE1A0'0004        MOV      R0,R4
   \       0x1C   0x....'....        BL       __aeabi_memclr4
    275          
    276          	/* 0x00000000: BOOT MEMORY */
    277          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    278          	           | TTB_SECT_AP_READ_ONLY
    279          	           | TTB_SECT_DOMAIN(0xf)
    280          	           | TTB_SECT_EXEC
    281          	           | TTB_SECT_CACHEABLE_WB
    282          	           | TTB_TYPE_SECT;
   \       0x20   0xE308'09EE        MOVW     R0,#+35310
    283          
    284          	/* 0x00100000: ROM */
    285          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    286          	           | TTB_SECT_AP_READ_ONLY
    287          	           | TTB_SECT_DOMAIN(0xf)
    288          	           | TTB_SECT_EXEC
    289          	           | TTB_SECT_CACHEABLE_WB
    290          	           | TTB_TYPE_SECT;
    291          
    292          	/* 0x00200000: NFC SRAM */
    293          	tlb[0x002] = TTB_SECT_ADDR(0x00200000)
    294          	           | TTB_SECT_AP_FULL_ACCESS
    295          	           | TTB_SECT_DOMAIN(0xf)
    296          	           | TTB_SECT_EXEC
    297          	           | TTB_SECT_SHAREABLE_DEVICE
    298          	           | TTB_TYPE_SECT;
   \       0x24   0x....'....        LDR      R2,??DataTable14_6  ;; 0x200de6
   \       0x28   0xE380'1940        ORR      R1,R0,#0x100000
   \       0x2C   0xE584'0000        STR      R0,[R4, #+0]
   \       0x30   0xE584'1004        STR      R1,[R4, #+4]
   \       0x34   0xE584'2008        STR      R2,[R4, #+8]
    299          
    300          	/* 0x00300000: SRAM0 - SRAM1 */
    301          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    302          	           | TTB_SECT_AP_FULL_ACCESS
    303          	           | TTB_SECT_DOMAIN(0xf)
    304          	           | TTB_SECT_EXEC
    305          	           | TTB_SECT_CACHEABLE_WB
    306          	           | TTB_TYPE_SECT;
    307          
    308          	/* 0x00400000: SMD */
    309          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    310          	           | TTB_SECT_AP_FULL_ACCESS
    311          	           | TTB_SECT_DOMAIN(0xf)
    312          	           | TTB_SECT_EXEC_NEVER
    313          	           | TTB_SECT_SHAREABLE_DEVICE
    314          	           | TTB_TYPE_SECT;
   \       0x38   0x....'....        LDR      R0,??DataTable14_7  ;; 0x400df6
    315          
    316          #ifdef CONFIG_HAVE_UDPHS
    317          	/* 0x00500000: UDPHS (RAM) */
    318          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    319          	           | TTB_SECT_AP_FULL_ACCESS
    320          	           | TTB_SECT_DOMAIN(0xf)
    321          	           | TTB_SECT_EXEC_NEVER
    322          	           | TTB_SECT_SHAREABLE_DEVICE
    323          	           | TTB_TYPE_SECT;
    324          
    325          	/* 0x00600000: UHP (OHCI) */
    326          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    327          	           | TTB_SECT_AP_FULL_ACCESS
    328          	           | TTB_SECT_DOMAIN(0xf)
    329          	           | TTB_SECT_EXEC_NEVER
    330          	           | TTB_SECT_SHAREABLE_DEVICE
    331          	           | TTB_TYPE_SECT;
    332          
    333          	/* 0x00700000: UHP (EHCI) */
    334          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    335          	           | TTB_SECT_AP_FULL_ACCESS
    336          	           | TTB_SECT_DOMAIN(0xf)
    337          	           | TTB_SECT_EXEC_NEVER
    338          	           | TTB_SECT_SHAREABLE_DEVICE
    339          	           | TTB_TYPE_SECT;
    340          #endif /* CONFIG_HAVE_UDPHS */
    341          
    342          	/* 0x00800000: AXI Matrix */
    343          	tlb[0x008] = TTB_SECT_ADDR(0x00800000)
    344          	           | TTB_SECT_AP_FULL_ACCESS
    345          	           | TTB_SECT_DOMAIN(0xf)
    346          	           | TTB_SECT_EXEC_NEVER
    347          	           | TTB_SECT_SHAREABLE_DEVICE
    348          	           | TTB_TYPE_SECT;
   \       0x3C   0xE280'1840        ADD      R1,R0,#+4194304
    349          
    350          	/* 0x00900000: DAP */
    351          	tlb[0x009] = TTB_SECT_ADDR(0x00900000)
    352          	           | TTB_SECT_AP_FULL_ACCESS
    353          	           | TTB_SECT_DOMAIN(0xf)
    354          	           | TTB_SECT_EXEC_NEVER
    355          	           | TTB_SECT_SHAREABLE_DEVICE
    356          	           | TTB_TYPE_SECT;
   \       0x40   0xE280'2850        ADD      R2,R0,#+5242880
   \       0x44   0x....'....        LDR      R3,??DataTable14_8  ;; 0x300dee
   \       0x48   0xE584'0010        STR      R0,[R4, #+16]
   \       0x4C   0xE584'1020        STR      R1,[R4, #+32]
   \       0x50   0xE584'2024        STR      R2,[R4, #+36]
   \       0x54   0xE584'300C        STR      R3,[R4, #+12]
    357          
    358          	/* 0x10000000: EBI Chip Select 0 */
    359          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x58   0xE3A0'1F40        MOV      R1,#+256
   \       0x5C   0xE284'2E40        ADD      R2,R4,#+1024
   \       0x60   0xE300'0DF2        MOVW     R0,#+3570
    360          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    361          	                  | TTB_SECT_AP_FULL_ACCESS
    362          	                  | TTB_SECT_DOMAIN(0xf)
    363          	                  | TTB_SECT_EXEC_NEVER
    364          	                  | TTB_SECT_STRONGLY_ORDERED
    365          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_1:
   \       0x64   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x68   0xE281'1001        ADD      R1,R1,#+1
   \       0x6C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \       0x70   0xE281'1001        ADD      R1,R1,#+1
   \       0x74   0xE482'3004        STR      R3,[R2], #+4
   \       0x78   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \       0x7C   0xE281'1001        ADD      R1,R1,#+1
   \       0x80   0xE482'C004        STR      R12,[R2], #+4
   \       0x84   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x88   0xE281'1001        ADD      R1,R1,#+1
   \       0x8C   0xE351'0F80        CMP      R1,#+512
   \       0x90   0xE482'E004        STR      LR,[R2], #+4
   \       0x94   0xE482'3004        STR      R3,[R2], #+4
   \       0x98   0x3AFF'FFF1        BCC      ??board_cfg_mmu_1
    366          
    367          	/* 0x20000000: DDR CS */
    368          	/* (64MB cacheable, 448MB strongly ordered) */
    369          	for (addr = 0x200; addr < 0x240; addr++)
   \       0x9C   0xE3A0'1F80        MOV      R1,#+512
   \       0xA0   0xE284'2E80        ADD      R2,R4,#+2048
   \       0xA4   0xE240'3004        SUB      R3,R0,#+4
    370          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    371          	                  | TTB_SECT_AP_FULL_ACCESS
    372          	                  | TTB_SECT_DOMAIN(0xf)
    373          	                  | TTB_SECT_EXEC
    374          	                  | TTB_SECT_CACHEABLE_WB
    375          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_2:
   \       0xA8   0xE183'CA01        ORR      R12,R3,R1, LSL #+20
   \       0xAC   0xE281'1001        ADD      R1,R1,#+1
   \       0xB0   0xE183'EA01        ORR      LR,R3,R1, LSL #+20
   \       0xB4   0xE281'1001        ADD      R1,R1,#+1
   \       0xB8   0xE482'C004        STR      R12,[R2], #+4
   \       0xBC   0xE183'5A01        ORR      R5,R3,R1, LSL #+20
   \       0xC0   0xE281'1001        ADD      R1,R1,#+1
   \       0xC4   0xE482'E004        STR      LR,[R2], #+4
   \       0xC8   0xE183'CA01        ORR      R12,R3,R1, LSL #+20
   \       0xCC   0xE281'1001        ADD      R1,R1,#+1
   \       0xD0   0xE351'0F90        CMP      R1,#+576
   \       0xD4   0xE482'5004        STR      R5,[R2], #+4
   \       0xD8   0xE482'C004        STR      R12,[R2], #+4
   \       0xDC   0x3AFF'FFF1        BCC      ??board_cfg_mmu_2
    376          	for (addr = 0x240; addr < 0x400; addr++)
   \       0xE0   0xE3A0'2F90        MOV      R2,#+576
   \       0xE4   0xE284'3E90        ADD      R3,R4,#+2304
   \       0xE8   0xE3C0'1010        BIC      R1,R0,#0x10
    377          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    378          	                  | TTB_SECT_AP_FULL_ACCESS
    379          	                  | TTB_SECT_DOMAIN(0xf)
    380          	                  | TTB_SECT_EXEC
    381          	                  | TTB_SECT_STRONGLY_ORDERED
    382          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0xEC   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xF0   0xE282'2001        ADD      R2,R2,#+1
   \       0xF4   0xE181'EA02        ORR      LR,R1,R2, LSL #+20
   \       0xF8   0xE282'2001        ADD      R2,R2,#+1
   \       0xFC   0xE483'C004        STR      R12,[R3], #+4
   \      0x100   0xE181'5A02        ORR      R5,R1,R2, LSL #+20
   \      0x104   0xE282'2001        ADD      R2,R2,#+1
   \      0x108   0xE483'E004        STR      LR,[R3], #+4
   \      0x10C   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \      0x110   0xE282'2001        ADD      R2,R2,#+1
   \      0x114   0xE352'0E40        CMP      R2,#+1024
   \      0x118   0xE483'5004        STR      R5,[R3], #+4
   \      0x11C   0xE483'C004        STR      R12,[R3], #+4
   \      0x120   0x3AFF'FFF1        BCC      ??board_cfg_mmu_3
    383          
    384          	/* 0x40000000: EBI Chip Select 1 */
    385          	for (addr = 0x400; addr < 0x500; addr++)
   \      0x124   0xE3A0'2E40        MOV      R2,#+1024
   \      0x128   0xE284'3D40        ADD      R3,R4,#+4096
    386          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    387          	                  | TTB_SECT_AP_FULL_ACCESS
    388          	                  | TTB_SECT_DOMAIN(0xf)
    389          	                  | TTB_SECT_EXEC_NEVER
    390          	                  | TTB_SECT_STRONGLY_ORDERED
    391          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_4:
   \      0x12C   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x130   0xE282'2001        ADD      R2,R2,#+1
   \      0x134   0xE180'EA02        ORR      LR,R0,R2, LSL #+20
   \      0x138   0xE282'2001        ADD      R2,R2,#+1
   \      0x13C   0xE483'C004        STR      R12,[R3], #+4
   \      0x140   0xE180'5A02        ORR      R5,R0,R2, LSL #+20
   \      0x144   0xE282'2001        ADD      R2,R2,#+1
   \      0x148   0xE483'E004        STR      LR,[R3], #+4
   \      0x14C   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x150   0xE282'2001        ADD      R2,R2,#+1
   \      0x154   0xE352'0E50        CMP      R2,#+1280
   \      0x158   0xE483'5004        STR      R5,[R3], #+4
   \      0x15C   0xE483'C004        STR      R12,[R3], #+4
   \      0x160   0x3AFF'FFF1        BCC      ??board_cfg_mmu_4
    392          
    393          	/* 0x50000000: EBI Chip Select 2 */
    394          	for (addr = 0x500; addr < 0x600; addr++)
   \      0x164   0xE3A0'2E50        MOV      R2,#+1280
   \      0x168   0xE284'3D50        ADD      R3,R4,#+5120
    395          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    396          	                  | TTB_SECT_AP_FULL_ACCESS
    397          	                  | TTB_SECT_DOMAIN(0xf)
    398          	                  | TTB_SECT_EXEC_NEVER
    399          	                  | TTB_SECT_STRONGLY_ORDERED
    400          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_5:
   \      0x16C   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x170   0xE282'2001        ADD      R2,R2,#+1
   \      0x174   0xE180'EA02        ORR      LR,R0,R2, LSL #+20
   \      0x178   0xE282'2001        ADD      R2,R2,#+1
   \      0x17C   0xE483'C004        STR      R12,[R3], #+4
   \      0x180   0xE180'5A02        ORR      R5,R0,R2, LSL #+20
   \      0x184   0xE282'2001        ADD      R2,R2,#+1
   \      0x188   0xE483'E004        STR      LR,[R3], #+4
   \      0x18C   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x190   0xE282'2001        ADD      R2,R2,#+1
   \      0x194   0xE352'0E60        CMP      R2,#+1536
   \      0x198   0xE483'5004        STR      R5,[R3], #+4
   \      0x19C   0xE483'C004        STR      R12,[R3], #+4
   \      0x1A0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_5
    401          
    402          	/* 0x60000000: EBI Chip Select 3 */
    403          	for (addr = 0x600; addr < 0x700; addr++)
   \      0x1A4   0xE3A0'2E60        MOV      R2,#+1536
   \      0x1A8   0xE284'3D60        ADD      R3,R4,#+6144
    404          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    405          	                  | TTB_SECT_AP_FULL_ACCESS
    406          	                  | TTB_SECT_DOMAIN(0xf)
    407          	                  | TTB_SECT_EXEC_NEVER
    408          	                  | TTB_SECT_STRONGLY_ORDERED
    409          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_6:
   \      0x1AC   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x1B0   0xE282'2001        ADD      R2,R2,#+1
   \      0x1B4   0xE180'EA02        ORR      LR,R0,R2, LSL #+20
   \      0x1B8   0xE282'2001        ADD      R2,R2,#+1
   \      0x1BC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1C0   0xE180'5A02        ORR      R5,R0,R2, LSL #+20
   \      0x1C4   0xE282'2001        ADD      R2,R2,#+1
   \      0x1C8   0xE483'E004        STR      LR,[R3], #+4
   \      0x1CC   0xE180'CA02        ORR      R12,R0,R2, LSL #+20
   \      0x1D0   0xE282'2001        ADD      R2,R2,#+1
   \      0x1D4   0xE352'0E70        CMP      R2,#+1792
   \      0x1D8   0xE483'5004        STR      R5,[R3], #+4
   \      0x1DC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1E0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_6
    410          
    411          	/* 0x90000000: NFC Command Registers */
    412          	for (addr = 0x700; addr < 0x800; addr++)
   \      0x1E4   0xE3A0'0E70        MOV      R0,#+1792
   \      0x1E8   0xE284'2D70        ADD      R2,R4,#+7168
    413          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    414          	                  | TTB_SECT_AP_FULL_ACCESS
    415          	                  | TTB_SECT_DOMAIN(0xf)
    416          	                  | TTB_SECT_EXEC
    417          	                  //| TTB_SECT_SHAREABLE_DEVICE
    418          	                  | TTB_SECT_STRONGLY_ORDERED
    419          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_7:
   \      0x1EC   0xE181'3A00        ORR      R3,R1,R0, LSL #+20
   \      0x1F0   0xE280'0001        ADD      R0,R0,#+1
   \      0x1F4   0xE181'CA00        ORR      R12,R1,R0, LSL #+20
   \      0x1F8   0xE280'0001        ADD      R0,R0,#+1
   \      0x1FC   0xE482'3004        STR      R3,[R2], #+4
   \      0x200   0xE181'EA00        ORR      LR,R1,R0, LSL #+20
   \      0x204   0xE280'0001        ADD      R0,R0,#+1
   \      0x208   0xE482'C004        STR      R12,[R2], #+4
   \      0x20C   0xE181'3A00        ORR      R3,R1,R0, LSL #+20
   \      0x210   0xE280'0001        ADD      R0,R0,#+1
   \      0x214   0xE350'0E80        CMP      R0,#+2048
   \      0x218   0xE482'E004        STR      LR,[R2], #+4
   \      0x21C   0xE482'3004        STR      R3,[R2], #+4
   \      0x220   0x3AFF'FFF1        BCC      ??board_cfg_mmu_7
    420          
    421          	/* 0xf0000000: Internal Peripherals */
    422          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    423          	           | TTB_SECT_AP_FULL_ACCESS
    424          	           | TTB_SECT_DOMAIN(0xf)
    425          	           | TTB_SECT_EXEC
    426          	           | TTB_SECT_STRONGLY_ORDERED
    427          	           | TTB_TYPE_SECT;
   \      0x224   0xE3A0'0DF0        MOV      R0,#+15360
   \      0x228   0xE381'14F0        ORR      R1,R1,#0xF0000000
   \      0x22C   0xE784'1000        STR      R1,[R4, +R0]
    428          
    429          	/* 0xf8000000: Internal Peripherals */
    430          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    431          	           | TTB_SECT_AP_FULL_ACCESS
    432          	           | TTB_SECT_DOMAIN(0xf)
    433          	           | TTB_SECT_EXEC
    434          	           | TTB_SECT_STRONGLY_ORDERED
    435          	           | TTB_TYPE_SECT;
   \      0x230   0xE084'0000        ADD      R0,R4,R0
   \      0x234   0xE381'2680        ORR      R2,R1,#0x8000000
    436          
    437          	/* 0xfff00000: Internal Peripherals */
    438          	tlb[0xfff] = TTB_SECT_ADDR(0xfff00000)
    439          	           | TTB_SECT_AP_FULL_ACCESS
    440          	           | TTB_SECT_DOMAIN(0xf)
    441          	           | TTB_SECT_EXEC
    442          	           | TTB_SECT_STRONGLY_ORDERED
    443          	           | TTB_TYPE_SECT;
   \      0x238   0xE381'36FF        ORR      R3,R1,#0xFF00000
   \      0x23C   0xE580'2200        STR      R2,[R0, #+512]
   \      0x240   0xE580'33FC        STR      R3,[R0, #+1020]
    444          
    445          	/* Enable MMU, I-Cache and D-Cache */
    446          	mmu_configure(tlb);
   \      0x244   0xE1A0'0004        MOV      R0,R4
   \      0x248   0x....'....        BL       mmu_configure
    447          	icache_enable();
   \      0x24C   0x....'....        BL       icache_enable
    448          	mmu_enable();
   \      0x250   0x....'....        BL       mmu_enable
    449          	dcache_enable();
   \      0x254   0xE8BD'4031        POP      {R0,R4,R5,LR}
   \      0x258   0x....'....        B        dcache_enable    ;; tailcall
   \                     ??board_cfg_mmu_0:
   \      0x25C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    450          }
    451          

   \                                 In section SOFTPACK, align 4, keep-with-next
    452          void board_cfg_l2cc(void)
    453          {
    454          	/* N/A on SAMA5D3x */
    455          }
   \                     board_cfg_l2cc:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    456          

   \                                 In section SOFTPACK, align 4, keep-with-next
    457          void board_cfg_matrix_for_ddr(void)
    458          {
    459          	/* N/A on SAMA5D3x */
    460          }
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    461          

   \                                 In section SOFTPACK, align 4, keep-with-next
    462          void board_cfg_matrix_for_nand(void)
    463          {
    464          	/* N/A on SAMA5D3x */
    465          }
   \                     board_cfg_matrix_for_nand:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    466          

   \                                 In section SOFTPACK, align 4, keep-with-next
    467          void board_cfg_ddram(void)
    468          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'4000        PUSH     {LR}
   \        0x4   0xE24D'D02C        SUB      SP,SP,#+44
    469          #ifdef BOARD_DDRAM_TYPE
    470          	board_cfg_matrix_for_ddr();
    471          	struct _mpddrc_desc desc;
    472          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0xE1A0'000D        MOV      R0,SP
   \       0x10   0x....'....        BL       ddram_init_descriptor
    473          	ddram_configure(&desc);
   \       0x14   0xE1A0'000D        MOV      R0,SP
   \       0x18   0x....'....        BL       ddram_configure
    474          #endif
    475          }
   \       0x1C   0xE28D'D02C        ADD      SP,SP,#+44
   \       0x20   0xE8BD'8000        POP      {PC}             ;; return
    476          

   \                                 In section SOFTPACK, align 4, keep-with-next
    477          void board_cfg_nand_flash(void)
    478          {
   \                     board_cfg_nand_flash:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    479          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    480          	board_cfg_matrix_for_nand();
    481          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    482          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
   \        0x4   0xE3A0'1001        MOV      R1,#+1
   \        0x8   0x....'....        ADR      R0,`board_cfg_nand_flash::pins_nandflash`
   \        0xC   0x....'....        BL       pio_configure
    483          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
   \       0x10   0xE8BD'4002        POP      {R1,LR}
   \       0x14   0xE3A0'0008        MOV      R0,#+8
   \       0x18   0x....'....        B        smc_nand_configure  ;; tailcall
    484          #else
    485          	trace_fatal("Cannot configure NAND: target board have no NAND definitions!");
    486          #endif
    487          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_cfg_nand_flash::pins_nandflash`:
   \        0x0   0x04 0x00          DC8 4, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0060'0000        DC32 6'291'456
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
    488          

   \                                 In section SOFTPACK, align 4, keep-with-next
    489          void board_cfg_nor_flash(void)
    490          {
   \                     board_cfg_nor_flash:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    491          #if defined(BOARD_NORFLASH_CS) && defined(BOARD_NORFLASH_BUS_WIDTH)
    492          	smc_nor_configure(BOARD_NORFLASH_CS, BOARD_NORFLASH_BUS_WIDTH);
    493          #else
    494          	trace_fatal("Cannot configure NOR: target board have no NOR definitions!");
   \        0x4   0x....'....        LDR      R0,??DataTable14_9
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE351'0000        CMP      R1,#+0
   \       0x10   0x0A00'0001        BEQ      ??board_cfg_nor_flash_0
   \       0x14   0x....'....        LDR      R0,??DataTable14_10
   \       0x18   0x....'....        BL       printf
   \                     ??board_cfg_nor_flash_0:
   \       0x1C   0xEAFF'FFFE        B        ??board_cfg_nor_flash_0
    495          #endif
    496          }
    497          

   \                                 In section SOFTPACK, align 4, keep-with-next
    498          void board_cfg_pmic(void)
    499          {
    500          #ifdef CONFIG_HAVE_PMIC_ACT8865
    501          	/* check PMIC chip presence */
    502          	if (act8865_check_twi_status(&pmic)) {
    503          #if defined(CONFIG_BOARD_SAMA5D3_XPLAINED)
    504          		/* Setup PMIC output 5 to 3.3V (VDDANA) */
    505          		act8865_set_reg_voltage(&pmic, REG5_0, ACT8865_3V3);
    506          #endif
    507          	} else {
    508          		trace_error("Error initializing ACT8865 PMIC\n\r");
    509          		return;
    510          	}
    511          #endif
    512          }
   \                     board_cfg_pmic:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    513          

   \                                 In section SOFTPACK, align 4, keep-with-next
    514          bool board_cfg_sdmmc(uint32_t periph_id)
    515          {
   \                     board_cfg_sdmmc:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    516          	switch (periph_id) {
   \        0x4   0xE350'0015        CMP      R0,#+21
   \        0x8   0x0A00'0004        BEQ      ??board_cfg_sdmmc_0
   \        0xC   0x3A00'0011        BCC      ??board_cfg_sdmmc_1
   \       0x10   0xE350'0017        CMP      R0,#+23
   \       0x14   0x0A00'0008        BEQ      ??board_cfg_sdmmc_2
   \       0x18   0x3A00'0003        BCC      ??board_cfg_sdmmc_3
   \       0x1C   0xEA00'000D        B        ??board_cfg_sdmmc_1
    517          	case ID_HSMCI0:
    518          	{
    519          #ifdef BOARD_HSMCI0_PINS
    520          		const struct _pin pins[] = BOARD_HSMCI0_PINS;
    521          
    522          		/* Configure HSMCI0 pins */
    523          		pio_configure(pins, ARRAY_SIZE(pins));
   \                     ??board_cfg_sdmmc_0:
   \       0x20   0xE3A0'1005        MOV      R1,#+5
   \       0x24   0x....'....        LDR      R0,??DataTable14_11
   \       0x28   0xEA00'0001        B        ??board_cfg_sdmmc_4
    524          		return true;
    525          #else
    526          		trace_fatal("Target board misses HSMCI0 pins");
    527          		return false;
    528          #endif
    529          	}
    530          	case ID_HSMCI1:
    531          	{
    532          #ifdef BOARD_HSMCI1_PINS
    533          		const struct _pin pins[] = BOARD_HSMCI1_PINS;
    534          
    535          		/* Configure HSMCI1 pins */
    536          		pio_configure(pins, ARRAY_SIZE(pins));
   \                     ??board_cfg_sdmmc_3:
   \       0x2C   0xE3A0'1005        MOV      R1,#+5
   \       0x30   0x....'....        LDR      R0,??DataTable14_12
   \                     ??board_cfg_sdmmc_4:
   \       0x34   0x....'....        BL       pio_configure
    537          		return true;
   \       0x38   0x....'....        B        ?Subroutine2
    538          #else
    539          		trace_fatal("Target board misses HSMCI1 pins");
    540          		return false;
    541          #endif
    542          	}
    543          	case ID_HSMCI2:
    544          	{
    545          #ifdef BOARD_HSMCI2_PINS
    546          		const struct _pin pins[] = BOARD_HSMCI2_PINS;
    547          
    548          		/* Configure HSMCI2 pins */
    549          		pio_configure(pins, ARRAY_SIZE(pins));
    550          		return true;
    551          #else
    552          		trace_fatal("Target board misses HSMCI2 pins");
   \                     ??board_cfg_sdmmc_2:
   \       0x3C   0x....'....        LDR      R0,??DataTable14_9
   \       0x40   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x44   0xE351'0000        CMP      R1,#+0
   \       0x48   0x0A00'0001        BEQ      ??board_cfg_sdmmc_5
   \       0x4C   0x....'....        LDR      R0,??DataTable14_13
   \       0x50   0x....'....        BL       printf
   \                     ??board_cfg_sdmmc_5:
   \       0x54   0xEAFF'FFFE        B        ??board_cfg_sdmmc_5
    553          		return false;
                 		^
Warning[Pe111]: statement is unreachable
    554          #endif
    555          	}
    556          	default:
    557          		return false;
   \                     ??board_cfg_sdmmc_1:
   \       0x58   0x....'....        B        ?Subroutine1
    558          	}
    559          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE3A0'0001        MOV      R0,#+1
   \        0x4   0xE8BD'8002        POP      {R1,PC}

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE8BD'8002        POP      {R1,PC}          ;; return

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x46          DC8 "-F- Target board misses HSMCI2 pins"

   \              0x2D 0x20    

   \              0x54 0x61    

   \              0x72 0x67    

   \              0x65 0x74    

   \              0x20 0x62    

   \              0x6F 0x61    

   \              0x72 0x64    

   \              0x20 0x6D    

   \              0x69 0x73    

   \              0x73 0x65    

   \              0x73 0x20    

   \              0x48 0x53    

   \              0x4D 0x43    

   \              0x49 0x32    

   \              0x20 0x70    

   \              0x69 0x6E    

   \              0x73 0x00
   \       0x24   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x28   0x0000'0001        DC32 1
   \       0x2C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x30   0x0000'0000        DC32 0
   \       0x34   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x38   0x0000'0200        DC32 512
   \       0x3C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x40   0x0000'0000        DC32 0
   \       0x44   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x48   0x0000'01FE        DC32 510
   \       0x4C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x50   0x0000'0000        DC32 0
   \       0x54   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x58   0x0002'0000        DC32 131'072
   \       0x5C   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x60   0x0000'0001        DC32 1
   \       0x64   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x68   0x0000'0400        DC32 1'024
   \       0x6C   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x70   0x0000'0000        DC32 0
   \       0x74   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x78   0x0008'0000        DC32 524'288
   \       0x7C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x80   0x0000'0000        DC32 0
   \       0x84   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x88   0x0100'0000        DC32 16'777'216
   \       0x8C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x90   0x0000'0000        DC32 0
   \       0x94   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x98   0x00F0'0000        DC32 15'728'640
   \       0x9C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0xA0   0x0000'0000        DC32 0
   \       0xA4   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0xA8   0x0004'0000        DC32 262'144
   \       0xAC   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0xB0   0x0000'0000        DC32 0
   \       0xB4   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0xB8   0x0000'1000        DC32 4'096
   \       0xBC   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0xC0   0x0000'0000        DC32 0
    560          

   \                                 In section SOFTPACK, align 4, keep-with-next
    561          bool board_get_hsmci_card_detect_status(uint32_t periph_id)
    562          {
   \                     board_get_hsmci_card_detect_status:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    563          	const struct _pin *cd_input = NULL;
    564          
    565          #ifdef BOARD_HSMCI0_PIN_CD
    566          	const struct _pin cd0_input = BOARD_HSMCI0_PIN_CD;
    567          	cd_input = periph_id == ID_HSMCI0 ? &cd0_input : cd_input;
   \        0x4   0xE350'0015        CMP      R0,#+21
   \        0x8   0x1A00'0003        BNE      ??board_get_hsmci_card_detect_status_0
   \        0xC   0x....'....        ADR      R0,`board_get_hsmci_card_detect_status::cd0_input`
    568          #endif
    569          
    570          #ifdef BOARD_HSMCI1_PIN_CD
    571          	const struct _pin cd1_input = BOARD_HSMCI1_PIN_CD;
    572          	cd_input = periph_id == ID_HSMCI1 ? &cd1_input : cd_input;
    573          #endif
    574          
    575          #ifdef BOARD_HSMCI2_PIN_CD
    576          	const struct _pin cd2_input = BOARD_HSMCI2_PIN_CD;
    577          	cd_input = periph_id == ID_HSMCI2 ? &cd2_input : cd_input;
    578          #endif
    579          
    580          	if (periph_id != ID_HSMCI0 && periph_id != ID_HSMCI1 &&
    581          	    periph_id != ID_HSMCI2)
    582          		return false;
    583          
    584          	/* no detection, assume card is always present */
    585          	if (!cd_input)
   \                     ??board_get_hsmci_card_detect_status_1:
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0006        BNE      ??board_get_hsmci_card_detect_status_2
    586          		return true;
   \       0x18   0xEA00'0008        B        ??board_get_hsmci_card_detect_status_3
   \                     ??board_get_hsmci_card_detect_status_0:
   \       0x1C   0xE350'0016        CMP      R0,#+22
   \       0x20   0x....'....        ADREQ    R0,`board_get_hsmci_card_detect_status::cd1_input`
   \       0x24   0x0AFF'FFF9        BEQ      ??board_get_hsmci_card_detect_status_1
   \       0x28   0xE350'0017        CMP      R0,#+23
   \       0x2C   0x0A00'0003        BEQ      ??board_get_hsmci_card_detect_status_3
   \       0x30   0xEA00'0003        B        ??board_get_hsmci_card_detect_status_4
    587          
    588          	return pio_get(cd_input) ? false : true;
   \                     ??board_get_hsmci_card_detect_status_2:
   \       0x34   0x....'....        BL       pio_get
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x1A00'0000        BNE      ??board_get_hsmci_card_detect_status_4
   \                     ??board_get_hsmci_card_detect_status_3:
   \       0x40   0x....'....        B        ?Subroutine2
   \                     ??board_get_hsmci_card_detect_status_4:
   \       0x44   0x....'....        B        ?Subroutine1
    589          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_get_hsmci_card_detect_status::cd0_input`:
   \        0x0   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0002'0000        DC32 131'072
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_get_hsmci_card_detect_status::cd1_input`:
   \        0x0   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0004'0000        DC32 262'144
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
    590          

   \                                 In section SOFTPACK, align 4, keep-with-next
    591          bool board_set_hsmci_card_power(uint32_t periph_id, bool on)
    592          {
   \                     board_set_hsmci_card_power:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE24D'D060        SUB      SP,SP,#+96
    593          	const struct _pin *pwr_ctrl = NULL;
    594          
    595          #ifdef BOARD_HSMCI0_PIN_POWER
    596          	const struct _pin pwr0_ctrl = BOARD_HSMCI0_PIN_POWER;
    597          	pwr_ctrl = periph_id == ID_HSMCI0 ? &pwr0_ctrl : pwr_ctrl;
   \        0xC   0xE354'0015        CMP      R4,#+21
   \       0x10   0x....'....        ADREQ    R5,`board_set_hsmci_card_power::pwr0_ctrl`
   \       0x14   0x0A00'0002        BEQ      ??board_set_hsmci_card_power_0
    598          #endif
    599          
    600          #ifdef BOARD_HSMCI1_PIN_POWER
    601          	const struct _pin pwr1_ctrl = BOARD_HSMCI1_PIN_POWER;
    602          	pwr_ctrl = periph_id == ID_HSMCI1 ? &pwr1_ctrl : pwr_ctrl;
   \       0x18   0xE354'0016        CMP      R4,#+22
   \       0x1C   0x1A00'0002        BNE      ??board_set_hsmci_card_power_1
   \       0x20   0x....'....        ADR      R5,`board_set_hsmci_card_power::pwr1_ctrl`
    603          #endif
    604          
    605          #ifdef BOARD_HSMCI2_PIN_POWER
    606          	const struct _pin pwr2_ctrl = BOARD_HSMCI2_PIN_POWER;
    607          	pwr_ctrl = periph_id == ID_HSMCI2 ? &pwr2_ctrl : pwr_ctrl;
    608          #endif
    609          
    610          	if (periph_id != ID_HSMCI0 && periph_id != ID_HSMCI1 &&
    611          	    periph_id != ID_HSMCI2)
    612          		return false;
    613          
    614          	/* This slot doesn't support switching VDD on/off */
    615          	if (!pwr_ctrl)
   \                     ??board_set_hsmci_card_power_0:
   \       0x24   0xE355'0000        CMP      R5,#+0
   \       0x28   0x1A00'0001        BNE      ??board_set_hsmci_card_power_2
    616          		return false;
   \                     ??board_set_hsmci_card_power_1:
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0x....'....        B        ?Subroutine3
    617          
    618          	if (on) {
   \                     ??board_set_hsmci_card_power_2:
   \       0x34   0xE351'0000        CMP      R1,#+0
   \       0x38   0x....'....        LDR      R6,??DataTable14_1
   \       0x3C   0x....'....        LDR      R7,??DataTable14
   \       0x40   0x0A00'0021        BEQ      ??board_set_hsmci_card_power_3
    619          		/*
    620          		 * Workaround HW issue: flipping straight the VDD switch often
    621          		 * causes the VCC_3V3 rail to drop and trigger reset upon
    622          		 * under-voltage.
    623          		 */
    624          		board_cfg_sd_dev_pins(periph_id, false, true);
   \       0x44   0xE3A0'2001        MOV      R2,#+1
   \       0x48   0xE3A0'1000        MOV      R1,#+0
   \       0x4C   0x....'....        BL       board_cfg_sd_dev_pins
    625          		msleep(100);
   \       0x50   0xE3A0'0064        MOV      R0,#+100
   \       0x54   0x....'....        BL       msleep
    626          		pio_clear(pwr_ctrl);
   \       0x58   0xE1A0'0005        MOV      R0,R5
   \       0x5C   0x....'....        BL       pio_clear
    627          		/* Wait for the VDD rail to settle at nominal voltage */
    628          		msleep(1);
   \       0x60   0xE3A0'0001        MOV      R0,#+1
   \       0x64   0x....'....        BL       msleep
    629          		board_cfg_sd_dev_pins(periph_id, false, false);
   \       0x68   0xE28D'0030        ADD      R0,SP,#+48
   \       0x6C   0xE1A0'1007        MOV      R1,R7
   \       0x70   0xE3A0'2030        MOV      R2,#+48
   \       0x74   0x....'....        BL       __aeabi_memcpy4
   \       0x78   0xE354'0015        CMP      R4,#+21
   \       0x7C   0x1A00'0005        BNE      ??board_set_hsmci_card_power_4
   \       0x80   0xE1A0'000D        MOV      R0,SP
   \       0x84   0xE1A0'1006        MOV      R1,R6
   \       0x88   0xE3A0'2030        MOV      R2,#+48
   \       0x8C   0xE28D'4030        ADD      R4,SP,#+48
   \       0x90   0x....'....        BL       __aeabi_memcpy4
   \       0x94   0xEA00'0006        B        ??board_set_hsmci_card_power_5
   \                     ??board_set_hsmci_card_power_4:
   \       0x98   0xE1A0'000D        MOV      R0,SP
   \       0x9C   0xE1A0'1006        MOV      R1,R6
   \       0xA0   0xE3A0'2030        MOV      R2,#+48
   \       0xA4   0x....'....        BL       __aeabi_memcpy4
   \       0xA8   0xE354'0016        CMP      R4,#+22
   \       0xAC   0x1A00'0003        BNE      ??board_set_hsmci_card_power_6
   \       0xB0   0xE1A0'400D        MOV      R4,SP
   \                     ??board_set_hsmci_card_power_5:
   \       0xB4   0xE3A0'1003        MOV      R1,#+3
   \       0xB8   0xE1A0'0004        MOV      R0,R4
   \       0xBC   0x....'....        BL       pio_configure
    630          		msleep(1);
   \                     ??board_set_hsmci_card_power_6:
   \       0xC0   0xE3A0'0001        MOV      R0,#+1
   \       0xC4   0x....'....        BL       msleep
   \       0xC8   0xEA00'001F        B        ??board_set_hsmci_card_power_7
    631          	} else {
    632          		pio_set(pwr_ctrl);
   \                     ??board_set_hsmci_card_power_3:
   \       0xCC   0xE1A0'0005        MOV      R0,R5
   \       0xD0   0x....'....        BL       pio_set
    633          		/*
    634          		 * Drive all device signals low, in an attempt to have VDD
    635          		 * falling quicker.
    636          		 */
    637          		board_cfg_sd_dev_pins(periph_id, true, false);
   \       0xD4   0xE28D'0030        ADD      R0,SP,#+48
   \       0xD8   0xE1A0'1007        MOV      R1,R7
   \       0xDC   0xE3A0'2030        MOV      R2,#+48
   \       0xE0   0x....'....        BL       __aeabi_memcpy4
   \       0xE4   0xE354'0015        CMP      R4,#+21
   \       0xE8   0x1A00'0005        BNE      ??board_set_hsmci_card_power_8
   \       0xEC   0xE1A0'000D        MOV      R0,SP
   \       0xF0   0xE1A0'1006        MOV      R1,R6
   \       0xF4   0xE3A0'2030        MOV      R2,#+48
   \       0xF8   0xE28D'4030        ADD      R4,SP,#+48
   \       0xFC   0x....'....        BL       __aeabi_memcpy4
   \      0x100   0xEA00'0006        B        ??board_set_hsmci_card_power_9
   \                     ??board_set_hsmci_card_power_8:
   \      0x104   0xE1A0'000D        MOV      R0,SP
   \      0x108   0xE1A0'1006        MOV      R1,R6
   \      0x10C   0xE3A0'2030        MOV      R2,#+48
   \      0x110   0x....'....        BL       __aeabi_memcpy4
   \      0x114   0xE354'0016        CMP      R4,#+22
   \      0x118   0x1A00'000B        BNE      ??board_set_hsmci_card_power_7
   \      0x11C   0xE1A0'400D        MOV      R4,SP
   \                     ??board_set_hsmci_card_power_9:
   \      0x120   0xE284'000C        ADD      R0,R4,#+12
   \      0x124   0xE3A0'1003        MOV      R1,#+3
   \      0x128   0xE3A0'2000        MOV      R2,#+0
   \      0x12C   0xE3A0'3008        MOV      R3,#+8
   \                     ??board_set_hsmci_card_power_10:
   \      0x130   0xE251'1001        SUBS     R1,R1,#+1
   \      0x134   0xE540'3004        STRB     R3,[R0, #-4]
   \      0x138   0xE480'2010        STR      R2,[R0], #+16
   \      0x13C   0x1AFF'FFFB        BNE      ??board_set_hsmci_card_power_10
   \      0x140   0xE3A0'1003        MOV      R1,#+3
   \      0x144   0xE1A0'0004        MOV      R0,R4
   \      0x148   0x....'....        BL       pio_configure
    638          	}
    639          
    640          	return true;
   \                     ??board_set_hsmci_card_power_7:
   \      0x14C   0xE3A0'0001        MOV      R0,#+1
   \      0x150                      REQUIRE ?Subroutine3
   \      0x150                      ;; // Fall through to label ?Subroutine3
    641          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine3:
   \        0x0   0xE28D'D064        ADD      SP,SP,#+100
   \        0x4   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_set_hsmci_card_power::pwr0_ctrl`:
   \        0x0   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'0400        DC32 1'024
   \        0x8   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `board_set_hsmci_card_power::pwr1_ctrl`:
   \        0x0   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'1000        DC32 4'096
   \        0x8   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x0020'0DE6        DC32     0x200de6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x0040'0DF6        DC32     0x400df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x0030'0DEE        DC32     0x300dee

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x....'....        DC32     ?_4+0x24

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x....'....        DC32     ?_4+0x74

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'0001        DC32 1
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
   \       0x10   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0000'0200        DC32 512
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0000        DC32 0
   \       0x20   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x0000'01FE        DC32 510
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0000        DC32 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0008'0000        DC32 524'288
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0100'0000        DC32 16'777'216
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0000        DC32 0
   \       0x20   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x00F0'0000        DC32 15'728'640
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0000        DC32 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFF8'3FFF        DC32 4'294'459'391
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x46          DC8 0x2D, 0x46, 0x2D, 0x20, 0x43, 0x61, 0x6E, 0x6E

   \              0x2D 0x20    

   \              0x43 0x61    

   \              0x6E 0x6E
   \        0x8   0x6F 0x74          DC8 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x66, 0x69

   \              0x20 0x63    

   \              0x6F 0x6E    

   \              0x66 0x69
   \       0x10   0x67 0x75          DC8 0x67, 0x75, 0x72, 0x65, 0x20, 0x4E, 0x4F, 0x52

   \              0x72 0x65    

   \              0x20 0x4E    

   \              0x4F 0x52
   \       0x18   0x3A 0x20          DC8 0x3A, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74

   \              0x74 0x61    

   \              0x72 0x67    

   \              0x65 0x74
   \       0x20   0x20 0x62          DC8 0x20, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x20, 0x68

   \              0x6F 0x61    

   \              0x72 0x64    

   \              0x20 0x68
   \       0x28   0x61 0x76          DC8 0x61, 0x76, 0x65, 0x20, 0x6E, 0x6F, 0x20, 0x4E

   \              0x65 0x20    

   \              0x6E 0x6F    

   \              0x20 0x4E
   \       0x30   0x4F 0x52          DC8 0x4F, 0x52, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E

   \              0x20 0x64    

   \              0x65 0x66    

   \              0x69 0x6E
   \       0x38   0x69 0x74          DC8 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x21, 0

   \              0x69 0x6F    

   \              0x6E 0x73    

   \              0x21 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x73 0x61          DC8 "sama5d3-ek"

   \              0x6D 0x61    

   \              0x35 0x64    

   \              0x33 0x2D    

   \              0x65 0x6B    

   \              0x00
   \        0xB   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   board_cfg_clocks
        24   -> pmc_configure_plla
        24   -> pmc_select_external_osc
        24   -> pmc_set_mck_divider
        24   -> pmc_set_mck_plladiv2
        24   -> pmc_set_mck_prescaler
        24   -> pmc_switch_mck_to_main
        24   -> pmc_switch_mck_to_pll
      48   board_cfg_ddram
        48   -> ddram_configure
        48   -> ddram_init_descriptor
       0   board_cfg_l2cc
      64   board_cfg_lowlevel
        64   -> board_cfg_clocks
        64   -> board_cfg_mmu
        64   -> board_cfg_timer
        64   -> ddram_configure
        64   -> ddram_init_descriptor
        64   -> irq_initialize
        64   -> pio_reset_all_it
        64   -> pmc_set_main_oscillator_freq
        64   -> wdt_disable
       0   board_cfg_matrix_for_ddr
       0   board_cfg_matrix_for_nand
      16   board_cfg_mmu
        16   -> __aeabi_memclr4
         0   -> dcache_enable
        16   -> icache_enable
        16   -> mmu_configure
        16   -> mmu_enable
        16   -> mmu_is_enabled
       8   board_cfg_nand_flash
         8   -> pio_configure
         0   -> smc_nand_configure
       8   board_cfg_nor_flash
         8   -> printf
       0   board_cfg_pmic
     112   board_cfg_sd_dev_pins
       112   -> __aeabi_memcpy4
       112   -> pio_configure
       8   board_cfg_sdmmc
         8   -> pio_configure
         8   -> printf
       8   board_get_hsmci_card_detect_status
         8   -> pio_get
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_bias
        16   -> pmc_disable_upll_clock
     120   board_set_hsmci_card_power
       120   -> __aeabi_memcpy4
       120   -> board_cfg_sd_dev_pins
       120   -> msleep
       120   -> pio_clear
       120   -> pio_configure
       120   -> pio_set
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable14
        4  ??DataTable14_1
        4  ??DataTable14_10
        4  ??DataTable14_11
        4  ??DataTable14_12
        4  ??DataTable14_13
        4  ??DataTable14_2
        4  ??DataTable14_3
        4  ??DataTable14_4
        4  ??DataTable14_5
        4  ??DataTable14_6
        4  ??DataTable14_7
        4  ??DataTable14_8
        4  ??DataTable14_9
        8  ?Subroutine0
        8  ?Subroutine1
        8  ?Subroutine2
        8  ?Subroutine3
       48  ?_0
       48  ?_1
       64  ?_2
       64  ?_3
       12  ?_5
       16  ?_6
       80  board_cfg_clocks
       36  board_cfg_ddram
        4  board_cfg_l2cc
      108  board_cfg_lowlevel
        4  board_cfg_matrix_for_ddr
        4  board_cfg_matrix_for_nand
      608  board_cfg_mmu
       28  board_cfg_nand_flash
       32  board_cfg_nor_flash
        4  board_cfg_pmic
      168  board_cfg_sd_dev_pins
       92  board_cfg_sdmmc
       72  board_get_hsmci_card_detect_status
        4  board_name
       76  board_restore_pio_reset_state
      144  board_save_misc_power
      336  board_set_hsmci_card_power
       16  cd0_input
       16  cd1_input
        8  get_board_name
      196  pins
           pins
       16  pins_nandflash
       16  pwr0_ctrl
       16  pwr1_ctrl
   16'384  tlb

 
 16'384 bytes in section .bss
      4 bytes in section .data
    448 bytes in section .rodata
  1'972 bytes in section SOFTPACK
 
  1'972 bytes of CODE  memory
    448 bytes of CONST memory
 16'388 bytes of DATA  memory

Errors: none
Warnings: 1
