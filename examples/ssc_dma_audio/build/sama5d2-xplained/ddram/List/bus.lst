###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         01/Dec/2020  16:42:55
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW70A3.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_AUDIO -D
#        CONFIG_HAVE_AUDIO_WM8731 -D CONFIG_HAVE_SSC -D CONFIG_HAVE_CLASSD -D
#        CONFIG_HAVE_PDMIC -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D
#        CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_I2C_BUS --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d2-xplained\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d2-xplained\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d2-xplained\ddram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d2-xplained\ddram\List\bus.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\ssc_dma_audio\build\sama5d2-xplained\ddram\Obj\bus.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *         Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <string.h>
     35          
     36          #include "callback.h"
     37          #include "dma/dma.h"
     38          #include "errno.h"
     39          #include "peripherals/bus.h"
     40          #ifdef CONFIG_HAVE_BUS_SPI
     41          #include "spi/spid.h"
     42          #endif
     43          #ifdef CONFIG_HAVE_BUS_I2C
     44          #include "i2c/twid.h"
     45          #endif
     46          #include "timer.h"
     47          #include "trace.h"
     48          
     49          /*----------------------------------------------------------------------------
     50           *         Definitions
     51           *----------------------------------------------------------------------------*/
     52          
     53          #define O_BLOCK (0x01)
     54          
     55          struct _bus_desc {
     56          	enum _bus_type type;
     57          	union {
     58          		uint32_t dummy;
     59          #ifdef CONFIG_HAVE_SPI_BUS
     60          		struct _spi_desc spid;
     61          #endif
     62          #ifdef CONFIG_HAVE_I2C_BUS
     63          		struct _twi_desc twid;
     64          #endif
     65          	} iface;
     66          
     67          	enum _bus_transfer_mode transfer_mode;
     68          
     69          	uint32_t options;
     70          
     71          	uint32_t timeout;
     72          
     73          	struct _callback callback;
     74          
     75          	struct {
     76          		mutex_t lock;
     77          		mutex_t transaction;
     78          	} mutex;
     79          };
     80          
     81          /*----------------------------------------------------------------------------
     82           *         Local variables
     83           *----------------------------------------------------------------------------*/
     84          

   \                                 In section .bss, align 4
     85          static struct _bus_desc _bus[BUS_COUNT];
   \                     _bus:
   \        0x0                      DS8 1'612
     86          
     87          /*----------------------------------------------------------------------------
     88           *         Local functions
     89           *----------------------------------------------------------------------------*/
     90          

   \                                 In section SOFTPACK, align 4, keep-with-next
     91          static int _bus_callback(void* arg, void* arg2)
     92          {
   \                     _bus_callback:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
     93          	uint32_t bus_id = (uint32_t)arg;
     94          
     95          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0x3A00'0001        BCC      ??_bus_callback_0
     96          		return -ENODEV;
   \        0xC   0xE3E0'002B        MVN      R0,#+43
   \       0x10   0xE8BD'8010        POP      {R4,PC}
     97          
     98          	mutex_unlock(&_bus[bus_id].mutex.lock);
   \                     ??_bus_callback_0:
   \       0x14   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x18   0x....'....        LDR      R1,??DataTable10
   \       0x1C   0xE081'4102        ADD      R4,R1,R2, LSL #+2
   \       0x20   0xE284'0074        ADD      R0,R4,#+116
   \       0x24   0x....'....        BL       mutex_unlock
     99          
    100          	return callback_call(&_bus[bus_id].callback, NULL);
   \       0x28   0xE284'006C        ADD      R0,R4,#+108
   \       0x2C   0xE3A0'1000        MOV      R1,#+0
   \       0x30   0xE8BD'4010        POP      {R4,LR}
   \       0x34   0x....'....        B        callback_call    ;; tailcall
    101          }
    102          
    103          static int _bus_fifo_enable(uint8_t bus_id)
    104          {
    105          	int err = 0;
    106          
    107          	if (bus_id >= BUS_COUNT)
    108          		return -ENODEV;
    109          
    110          	switch (_bus[bus_id].type) {
    111          #ifdef CONFIG_HAVE_SPI_BUS
    112          	case BUS_TYPE_SPI:
    113          #ifdef CONFIG_HAVE_SPI_FIFO
    114          		_bus[bus_id].iface.spid.use_fifo = true;
    115          #endif
    116          		break;
    117          #endif
    118          #ifdef CONFIG_HAVE_I2C_BUS
    119          	case BUS_TYPE_I2C:
    120          #ifdef CONFIG_HAVE_TWI_FIFO
    121          		_bus[bus_id].iface.twid.use_fifo = true;
    122          #endif
    123          		break;
    124          #endif
    125          	default:
    126          		err = -EINVAL;
    127          		break;
    128          	}
    129          
    130          	return err;
    131          }
    132          
    133          static int _bus_fifo_disable(uint8_t bus_id)
    134          {
    135          	int err = 0;
    136          
    137          	if (bus_id >= BUS_COUNT)
    138          		return -ENODEV;
    139          
    140          	switch (_bus[bus_id].type) {
    141          #ifdef CONFIG_HAVE_SPI_BUS
    142          	case BUS_TYPE_SPI:
    143          #ifdef CONFIG_HAVE_SPI_FIFO
    144          		_bus[bus_id].iface.spid.use_fifo = false;
    145          #endif
    146          		break;
    147          #endif
    148          #ifdef CONFIG_HAVE_I2C_BUS
    149          	case BUS_TYPE_I2C:
    150          #ifdef CONFIG_HAVE_TWI_FIFO
    151          		_bus[bus_id].iface.twid.use_fifo = false;
    152          #endif
    153          		break;
    154          #endif
    155          	default:
    156          		err = -EINVAL;
    157          		break;
    158          	}
    159          
    160          	return err;
    161          }
    162          
    163          static int _bus_fifo_is_enabled(uint8_t bus_id)
    164          {
    165          	int err = 0;
    166          
    167          	if (bus_id >= BUS_COUNT)
    168          		return -ENODEV;
    169          
    170          	switch (_bus[bus_id].type) {
    171          #ifdef CONFIG_HAVE_SPI_BUS
    172          	case BUS_TYPE_SPI:
    173          #ifdef CONFIG_HAVE_SPI_FIFO
    174          		err = _bus[bus_id].iface.spid.use_fifo;
    175          #endif
    176          		break;
    177          #endif
    178          #ifdef CONFIG_HAVE_I2C_BUS
    179          	case BUS_TYPE_I2C:
    180          #ifdef CONFIG_HAVE_TWI_FIFO
    181          		err = _bus[bus_id].iface.twid.use_fifo;
    182          #endif
    183          		break;
    184          #endif
    185          	default:
    186          		err = -EINVAL;
    187          		break;
    188          	}
    189          
    190          	return err;
    191          }
    192          
    193          static int _bus_enable(uint8_t bus_id)
    194          {
    195          	int err = 0;
    196          
    197          	if (bus_id >= BUS_COUNT)
    198          		return -ENODEV;
    199          
    200          	switch (_bus[bus_id].type) {
    201          #ifdef CONFIG_HAVE_SPI_BUS
    202          	case BUS_TYPE_SPI:
    203          		break;
    204          #endif
    205          #ifdef CONFIG_HAVE_I2C_BUS
    206          	case BUS_TYPE_I2C:
    207          		break;
    208          #endif
    209          	default:
    210          		err = -EINVAL;
    211          		break;
    212          	}
    213          
    214          	return err;
    215          }
    216          
    217          static int _bus_disable(uint8_t bus_id)
    218          {
    219          	int err = 0;
    220          
    221          	if (bus_id >= BUS_COUNT)
    222          		return -ENODEV;
    223          
    224          	switch (_bus[bus_id].type) {
    225          #ifdef CONFIG_HAVE_SPI_BUS
    226          	case BUS_TYPE_SPI:
    227          		break;
    228          #endif
    229          #ifdef CONFIG_HAVE_I2C_BUS
    230          	case BUS_TYPE_I2C:
    231          		break;
    232          #endif
    233          	default:
    234          		err = -EINVAL;
    235          		break;
    236          	}
    237          
    238          	return err;
    239          }
    240          
    241          static int _bus_get_transfer_mode(uint8_t bus_id)
    242          {
    243          	int err = 0;
    244          
    245          	if (bus_id >= BUS_COUNT)
    246          		return -ENODEV;
    247          
    248          	switch (_bus[bus_id].type) {
    249          #ifdef CONFIG_HAVE_SPI_BUS
    250          	case BUS_TYPE_SPI:
    251          		return _bus[bus_id].iface.spid.transfer_mode;
    252          #endif
    253          #ifdef CONFIG_HAVE_I2C_BUS
    254          	case BUS_TYPE_I2C:
    255          		return _bus[bus_id].iface.twid.transfer_mode;
    256          #endif
    257          	default:
    258          		err = -EINVAL;
    259          		break;
    260          	}
    261          
    262          	return err;
    263          }
    264          
    265          static int _bus_set_transfer_mode(uint8_t bus_id, enum _bus_transfer_mode mode)
    266          {
    267          	int err = 0;
    268          
    269          	if (bus_id >= BUS_COUNT)
    270          		return -ENODEV;
    271          
    272          	switch (_bus[bus_id].type) {
    273          #ifdef CONFIG_HAVE_SPI_BUS
    274          	case BUS_TYPE_SPI:
    275          		_bus[bus_id].iface.spid.transfer_mode = mode;
    276          		break;
    277          #endif
    278          #ifdef CONFIG_HAVE_I2C_BUS
    279          	case BUS_TYPE_I2C:
    280          		_bus[bus_id].iface.twid.transfer_mode = mode;
    281          		break;
    282          #endif
    283          	default:
    284          		err = -EINVAL;
    285          		break;
    286          	}
    287          
    288          	return err;
    289          }
    290          
    291          /*----------------------------------------------------------------------------
    292           *         Exported functions
    293           *----------------------------------------------------------------------------*/
    294          

   \                                 In section SOFTPACK, align 4, keep-with-next
    295          int bus_configure(uint8_t bus_id, const struct _bus_iface* iface)
    296          {
   \                     bus_configure:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
    297          	int err = 0;
    298          
    299          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'6001        MOV      R6,R1
   \       0x10   0xE3A0'5000        MOV      R5,#+0
   \       0x14   0xDA00'0001        BLE      ??bus_configure_0
    300          		return -ENODEV;
   \       0x18   0xE3E0'002B        MVN      R0,#+43
   \       0x1C   0xE8BD'83F2        POP      {R1,R4-R9,PC}
    301          
    302          	memset(&_bus[bus_id], 0, sizeof(_bus[bus_id]));
   \                     ??bus_configure_0:
   \       0x20   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \       0x24   0x....'....        LDR      R8,??DataTable10
   \       0x28   0xE1A0'7101        LSL      R7,R1,#+2
   \       0x2C   0xE3A0'107C        MOV      R1,#+124
   \       0x30   0xE088'9007        ADD      R9,R8,R7
   \       0x34   0xE1A0'0009        MOV      R0,R9
   \       0x38   0x....'....        BL       __aeabi_memclr
    303          	_bus[bus_id].transfer_mode = iface->transfer_mode;
   \       0x3C   0xE5D6'000C        LDRB     R0,[R6, #+12]
    304          	_bus[bus_id].options = O_BLOCK;
   \       0x40   0xE3A0'1001        MOV      R1,#+1
   \       0x44   0xE589'1064        STR      R1,[R9, #+100]
   \       0x48   0xE5C9'0060        STRB     R0,[R9, #+96]
    305          	_bus[bus_id].type = iface->type;
   \       0x4C   0xE5D6'0000        LDRB     R0,[R6, #+0]
    306          
    307          	switch (_bus[bus_id].type) {
   \       0x50   0xE350'0001        CMP      R0,#+1
   \       0x54   0xE7C8'0007        STRB     R0,[R8, +R7]
   \       0x58   0x0A00'000B        BEQ      ??bus_configure_1
   \       0x5C   0xE350'0002        CMP      R0,#+2
   \       0x60   0x1A00'0012        BNE      ??bus_configure_2
    308          #ifdef CONFIG_HAVE_SPI_BUS
    309          	case BUS_TYPE_SPI:
    310          		_bus[bus_id].iface.spid.addr = iface->spi.hw;
   \       0x64   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x68   0xE589'0004        STR      R0,[R9, #+4]
    311          		_bus[bus_id].iface.spid.transfer_mode = iface->transfer_mode;
   \       0x6C   0xE5D6'100C        LDRB     R1,[R6, #+12]
    312          
    313          		spid_configure(&_bus[bus_id].iface.spid);
   \       0x70   0xE289'0004        ADD      R0,R9,#+4
   \       0x74   0xE589'100C        STR      R1,[R9, #+12]
   \       0x78   0x....'....        BL       spid_configure
    314          		spid_configure_master(&_bus[bus_id].iface.spid, true);
   \       0x7C   0xE3A0'1001        MOV      R1,#+1
   \       0x80   0xE289'0004        ADD      R0,R9,#+4
   \       0x84   0x....'....        BL       spid_configure_master
    315          		break;
   \       0x88   0xEA00'0009        B        ??bus_configure_3
    316          #endif
    317          #ifdef CONFIG_HAVE_I2C_BUS
    318          	case BUS_TYPE_I2C:
    319          		_bus[bus_id].iface.twid.addr = iface->i2c.hw;
   \                     ??bus_configure_1:
   \       0x8C   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x90   0xE589'0004        STR      R0,[R9, #+4]
    320          		_bus[bus_id].iface.twid.transfer_mode = iface->transfer_mode;
   \       0x94   0xE5D6'100C        LDRB     R1,[R6, #+12]
   \       0x98   0xE589'1010        STR      R1,[R9, #+16]
    321          		_bus[bus_id].iface.twid.freq = iface->i2c.freq;
   \       0x9C   0xE596'0008        LDR      R0,[R6, #+8]
   \       0xA0   0xE589'0008        STR      R0,[R9, #+8]
    322          
    323          		twid_configure(&_bus[bus_id].iface.twid);
   \       0xA4   0xE289'0004        ADD      R0,R9,#+4
   \       0xA8   0x....'....        BL       twid_configure
    324          		break;
   \       0xAC   0xEA00'0000        B        ??bus_configure_3
    325          #endif
    326          	default:
    327          		err = -EINVAL;
   \                     ??bus_configure_2:
   \       0xB0   0xE3E0'501B        MVN      R5,#+27
    328          		break;
    329          	}
    330          
    331          	bus_ioctl(bus_id, BUS_IOCTL_ENABLE, NULL);
   \                     ??bus_configure_3:
   \       0xB4   0xE3A0'2000        MOV      R2,#+0
   \       0xB8   0xE3A0'1001        MOV      R1,#+1
   \       0xBC   0xE1A0'0004        MOV      R0,R4
   \       0xC0   0x....'....        BL       bus_ioctl
    332          
    333          	return err;
   \       0xC4   0xE1A0'0005        MOV      R0,R5
   \       0xC8   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    334          }
    335          

   \                                 In section SOFTPACK, align 4, keep-with-next
    336          int bus_configure_slave(uint8_t bus_id, const struct _bus_dev_cfg* cfg)
    337          {
   \                     bus_configure_slave:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
    338          	int err = 0;
    339          
    340          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xDA00'0001        BLE      ??bus_configure_slave_0
    341          		return -ENODEV;
   \       0x10   0xE3E0'002B        MVN      R0,#+43
   \       0x14   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}
    342          
    343          	switch (_bus[bus_id].type) {
   \                     ??bus_configure_slave_0:
   \       0x18   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x1C   0x....'....        LDR      R12,??DataTable10
   \       0x20   0xE1A0'0102        LSL      R0,R2,#+2
   \       0x24   0xE7DC'3000        LDRB     R3,[R12, +R0]
   \       0x28   0xE353'0001        CMP      R3,#+1
   \       0x2C   0x0A00'000D        BEQ      ??bus_configure_slave_1
   \       0x30   0xE353'0002        CMP      R3,#+2
   \       0x34   0x1A00'000A        BNE      ??bus_configure_slave_2
    344          #ifdef CONFIG_HAVE_SPI_BUS
    345          	case BUS_TYPE_SPI:
    346          		spid_configure_cs(&_bus[bus_id].iface.spid,
    347          		                  cfg->spi_dev.chip_select,
    348          		                  cfg->spi_dev.bitrate,
    349          		                  cfg->spi_dev.delay.bs,
    350          		                  cfg->spi_dev.delay.bct,
    351          		                  cfg->spi_dev.spi_mode);
   \       0x38   0xE5D1'5014        LDRB     R5,[R1, #+20]
   \       0x3C   0xE08C'0000        ADD      R0,R12,R0
   \       0x40   0xE280'0004        ADD      R0,R0,#+4
   \       0x44   0xE58D'5004        STR      R5,[SP, #+4]
   \       0x48   0xE591'6010        LDR      R6,[R1, #+16]
   \       0x4C   0xE58D'6000        STR      R6,[SP, #+0]
   \       0x50   0xE591'300C        LDR      R3,[R1, #+12]
   \       0x54   0xE591'2008        LDR      R2,[R1, #+8]
   \       0x58   0xE5D1'1004        LDRB     R1,[R1, #+4]
   \       0x5C   0x....'....        BL       spid_configure_cs
    352          		break;
   \       0x60   0xEA00'0000        B        ??bus_configure_slave_1
    353          #endif
    354          #ifdef CONFIG_HAVE_I2C_BUS
    355          	case BUS_TYPE_I2C:
    356          		break;
    357          #endif
    358          	default:
    359          		err = -EINVAL;
   \                     ??bus_configure_slave_2:
   \       0x64   0xE3E0'401B        MVN      R4,#+27
    360          		break;
    361          	}
    362          
    363          	return err;
   \                     ??bus_configure_slave_1:
   \       0x68   0xE1A0'0004        MOV      R0,R4
   \       0x6C   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    364          }
    365          

   \                                 In section SOFTPACK, align 4, keep-with-next
    366          int bus_ioctl(uint8_t bus_id, int req, void* arg)
    367          {
    368          	int err = 0;
    369          
    370          	if (bus_id >= BUS_COUNT)
   \                     bus_ioctl:
   \        0x0   0xE350'000C        CMP      R0,#+12
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xE92D'4000        PUSH     {LR}
   \        0xC   0xDA00'0001        BLE      ??bus_ioctl_1
    371          		return -EINVAL;
   \       0x10   0xE3E0'001B        MVN      R0,#+27
   \       0x14   0xE8BD'8000        POP      {PC}
    372          
    373          	switch (req) {
   \                     ??bus_ioctl_1:
   \       0x18   0xE241'1001        SUB      R1,R1,#+1
   \       0x1C   0xE351'0007        CMP      R1,#+7
   \       0x20   0x8A00'005B        BHI      ??bus_ioctl_2
   \       0x24   0xE7DF'C001        LDRB     R12,[PC, R1]
   \       0x28   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??bus_ioctl_0:
   \       0x2C   0x01 0x08          DC8      0x1,0x8,0xF,0x1B

   \              0x0F 0x1B
   \       0x30   0x26 0x37          DC8      0x26,0x37,0x47,0x5B

   \              0x47 0x5B
    374          	case BUS_IOCTL_ENABLE:
    375          		err = _bus_enable(bus_id);
   \                     ??bus_ioctl_3:
   \       0x34   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x38   0x....'....        LDR      R1,??DataTable10
   \       0x3C   0xE7D1'0102        LDRB     R0,[R1, +R2, LSL #+2]
   \       0x40   0xE240'0001        SUB      R0,R0,#+1
   \       0x44   0xE350'0001        CMP      R0,#+1
   \       0x48   0x9A00'0058        BLS      ??bus_ioctl_4
   \       0x4C   0xEA00'0050        B        ??bus_ioctl_2
    376          		break;
    377          	case BUS_IOCTL_DISABLE:
    378          		err = _bus_disable(bus_id);
   \                     ??bus_ioctl_5:
   \       0x50   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x54   0x....'....        LDR      R1,??DataTable10
   \       0x58   0xE7D1'0102        LDRB     R0,[R1, +R2, LSL #+2]
   \       0x5C   0xE240'0001        SUB      R0,R0,#+1
   \       0x60   0xE350'0001        CMP      R0,#+1
   \       0x64   0x9A00'0051        BLS      ??bus_ioctl_4
   \       0x68   0xEA00'0049        B        ??bus_ioctl_2
    379          		break;
    380          	case BUS_IOCTL_ENABLE_FIFO:
    381          		err = _bus_fifo_enable(bus_id);
   \                     ??bus_ioctl_6:
   \       0x6C   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \       0x70   0xE1A0'0101        LSL      R0,R1,#+2
   \       0x74   0x....'....        LDR      R1,??DataTable10
   \       0x78   0xE7D1'2000        LDRB     R2,[R1, +R0]
   \       0x7C   0xE352'0001        CMP      R2,#+1
   \       0x80   0x0A00'004A        BEQ      ??bus_ioctl_4
   \       0x84   0xE352'0002        CMP      R2,#+2
   \       0x88   0x1A00'0041        BNE      ??bus_ioctl_2
   \       0x8C   0xE3A0'E001        MOV      LR,#+1
   \       0x90   0xE081'0000        ADD      R0,R1,R0
   \       0x94   0xE5C0'E014        STRB     LR,[R0, #+20]
   \       0x98   0xEA00'0044        B        ??bus_ioctl_4
    382          		break;
    383          	case BUS_IOCTL_DISABLE_FIFO:
    384          		err = _bus_fifo_disable(bus_id);
   \                     ??bus_ioctl_7:
   \       0x9C   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \       0xA0   0xE1A0'0101        LSL      R0,R1,#+2
   \       0xA4   0x....'....        LDR      R1,??DataTable10
   \       0xA8   0xE7D1'2000        LDRB     R2,[R1, +R0]
   \       0xAC   0xE352'0001        CMP      R2,#+1
   \       0xB0   0x0A00'003E        BEQ      ??bus_ioctl_4
   \       0xB4   0xE352'0002        CMP      R2,#+2
   \       0xB8   0x1A00'0035        BNE      ??bus_ioctl_2
   \       0xBC   0xE081'0000        ADD      R0,R1,R0
   \       0xC0   0xE5C0'3014        STRB     R3,[R0, #+20]
   \       0xC4   0xEA00'0039        B        ??bus_ioctl_4
    385          		break;
    386          	case BUS_IOCTL_GET_FIFO_STATUS:
    387          		err = _bus_fifo_is_enabled(bus_id);
   \                     ??bus_ioctl_8:
   \       0xC8   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \       0xCC   0xE1A0'0101        LSL      R0,R1,#+2
   \       0xD0   0x....'....        LDR      R1,??DataTable10
   \       0xD4   0xE7D1'C000        LDRB     R12,[R1, +R0]
   \       0xD8   0xE35C'0001        CMP      R12,#+1
   \       0xDC   0x0A00'0003        BEQ      ??bus_ioctl_9
   \       0xE0   0xE35C'0002        CMP      R12,#+2
   \       0xE4   0x0081'0000        ADDEQ    R0,R1,R0
   \       0xE8   0x13E0'301B        MVNNE    R3,#+27
   \       0xEC   0x05D0'3014        LDRBEQ   R3,[R0, #+20]
    388          		if (err >= 0) {
   \                     ??bus_ioctl_9:
   \       0xF0   0xE353'0000        CMP      R3,#+0
   \       0xF4   0x4A00'002D        BMI      ??bus_ioctl_4
    389          			*(bool*)arg = err;
   \       0xF8   0x13A0'0001        MOVNE    R0,#+1
    390          			err = 0;
   \       0xFC   0xE3A0'3000        MOV      R3,#+0
   \      0x100   0x03A0'0000        MOVEQ    R0,#+0
   \      0x104   0xE5C2'0000        STRB     R0,[R2, #+0]
   \      0x108   0xEA00'0028        B        ??bus_ioctl_4
    391          		}
    392          		break;
    393          	case BUS_IOCTL_SET_TRANSFER_MODE:
    394          		err = _bus_set_transfer_mode(bus_id, *(enum _bus_transfer_mode*)arg);
   \                     ??bus_ioctl_10:
   \      0x10C   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \      0x110   0xE5D2'2000        LDRB     R2,[R2, #+0]
   \      0x114   0xE1A0'0101        LSL      R0,R1,#+2
   \      0x118   0x....'....        LDR      R1,??DataTable10
   \      0x11C   0xE7D1'C000        LDRB     R12,[R1, +R0]
   \      0x120   0xE35C'0001        CMP      R12,#+1
   \      0x124   0x0A00'0002        BEQ      ??bus_ioctl_11
   \      0x128   0xE35C'0002        CMP      R12,#+2
   \      0x12C   0x0A00'0003        BEQ      ??bus_ioctl_12
   \      0x130   0xEA00'0017        B        ??bus_ioctl_2
   \                     ??bus_ioctl_11:
   \      0x134   0xE081'0000        ADD      R0,R1,R0
   \      0x138   0xE580'2010        STR      R2,[R0, #+16]
   \      0x13C   0xEA00'001B        B        ??bus_ioctl_4
   \                     ??bus_ioctl_12:
   \      0x140   0xE081'0000        ADD      R0,R1,R0
   \      0x144   0xE580'200C        STR      R2,[R0, #+12]
   \      0x148   0xEA00'0018        B        ??bus_ioctl_4
    395          		break;
    396          	case BUS_IOCTL_GET_TRANSFER_MODE:
    397          		err = _bus_get_transfer_mode(bus_id);
   \                     ??bus_ioctl_13:
   \      0x14C   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \      0x150   0xE1A0'0101        LSL      R0,R1,#+2
   \      0x154   0x....'....        LDR      R1,??DataTable10
   \      0x158   0xE7D1'3000        LDRB     R3,[R1, +R0]
   \      0x15C   0xE353'0001        CMP      R3,#+1
   \      0x160   0x0A00'0002        BEQ      ??bus_ioctl_14
   \      0x164   0xE353'0002        CMP      R3,#+2
   \      0x168   0x0A00'0006        BEQ      ??bus_ioctl_15
   \      0x16C   0xEA00'0008        B        ??bus_ioctl_2
   \                     ??bus_ioctl_14:
   \      0x170   0xE081'0000        ADD      R0,R1,R0
   \      0x174   0xE590'3010        LDR      R3,[R0, #+16]
    398          		if (err >= 0)
   \                     ??bus_ioctl_16:
   \      0x178   0xE353'0000        CMP      R3,#+0
   \      0x17C   0x4A00'000B        BMI      ??bus_ioctl_4
    399          			*(enum _bus_transfer_mode*)arg = (enum _bus_transfer_mode)err;
   \      0x180   0xE5C2'3000        STRB     R3,[R2, #+0]
   \      0x184   0xEA00'0009        B        ??bus_ioctl_4
   \                     ??bus_ioctl_15:
   \      0x188   0xE081'0000        ADD      R0,R1,R0
   \      0x18C   0xE590'300C        LDR      R3,[R0, #+12]
   \      0x190   0xEAFF'FFF8        B        ??bus_ioctl_16
   \                     ??bus_ioctl_2:
   \      0x194   0xE3E0'301B        MVN      R3,#+27
   \      0x198   0xEA00'0004        B        ??bus_ioctl_4
    400          		break;
    401          	case BUS_IOCTL_SET_TIMEOUT:
    402          		_bus[bus_id].timeout = *(uint32_t*)arg;
   \                     ??bus_ioctl_17:
   \      0x19C   0xE592'1000        LDR      R1,[R2, #+0]
   \      0x1A0   0xE060'C280        RSB      R12,R0,R0, LSL #+5
   \      0x1A4   0x....'....        LDR      R2,??DataTable10
   \      0x1A8   0xE082'010C        ADD      R0,R2,R12, LSL #+2
   \      0x1AC   0xE580'1068        STR      R1,[R0, #+104]
    403          		break;
    404          
    405          	default:
    406          		err = -EINVAL;
    407          		break;
    408          	}
    409          
    410          	return err;
   \                     ??bus_ioctl_4:
   \      0x1B0   0xE1A0'0003        MOV      R0,R3
   \      0x1B4   0xE8BD'8000        POP      {PC}             ;; return
    411          }
    412          

   \                                 In section SOFTPACK, align 4, keep-with-next
    413          int bus_transfer(uint8_t bus_id, uint16_t remote, struct _buffer* buf, uint16_t buffers, struct _callback* cb)
    414          {
   \                     bus_transfer:
   \        0x0   0xE92D'47FC        PUSH     {R2-R10,LR}
    415          	int err = 0;
    416          	struct _callback _cb;
    417          
    418          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'5001        MOV      R5,R1
   \       0x10   0xE1A0'6002        MOV      R6,R2
   \       0x14   0xE1A0'7003        MOV      R7,R3
   \       0x18   0xDA00'0001        BLE      ??bus_transfer_0
    419          		return -ENODEV;
   \       0x1C   0xE3E0'002B        MVN      R0,#+43
   \       0x20   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    420          
    421          	if (buffers == 0)
   \                     ??bus_transfer_0:
   \       0x24   0xE1B0'1007        MOVS     R1,R7
   \       0x28   0x1A00'0001        BNE      ??bus_transfer_1
    422          		return 0;
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    423          
    424          	if (!mutex_is_locked(&_bus[bus_id].mutex.transaction)) {
   \                     ??bus_transfer_1:
   \       0x34   0xE060'1280        RSB      R1,R0,R0, LSL #+5
   \       0x38   0x....'....        LDR      R10,??DataTable10
   \       0x3C   0xE1A0'9101        LSL      R9,R1,#+2
   \       0x40   0xE08A'8009        ADD      R8,R10,R9
   \       0x44   0xE288'0078        ADD      R0,R8,#+120
   \       0x48   0x....'....        BL       mutex_is_locked
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x1A00'0007        BNE      ??bus_transfer_2
    425          		trace_error("bus: no opened transaction on the bus.");
   \       0x54   0x....'....        LDR      R0,??DataTable10_1
   \       0x58   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x5C   0xE351'0001        CMP      R1,#+1
   \       0x60   0x9A00'0001        BLS      ??bus_transfer_3
   \       0x64   0x....'....        LDR      R0,??DataTable10_2
   \       0x68   0x....'....        BL       printf
    426          		return -EBUSY;
   \                     ??bus_transfer_3:
   \       0x6C   0xE3E0'0009        MVN      R0,#+9
   \       0x70   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    427          	}
    428          	if (!mutex_try_lock(&_bus[bus_id].mutex.lock))
   \                     ??bus_transfer_2:
   \       0x74   0xE288'0074        ADD      R0,R8,#+116
   \       0x78   0x....'....        BL       mutex_try_lock
   \       0x7C   0xE350'0000        CMP      R0,#+0
   \       0x80   0x1A00'0001        BNE      ??bus_transfer_4
    429          		return -EAGAIN;
   \       0x84   0xE3E0'0005        MVN      R0,#+5
   \       0x88   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
   \                     ??bus_transfer_4:
   \       0x8C   0xE59D'1028        LDR      R1,[SP, #+40]
    430          
    431          	callback_copy(&_bus[bus_id].callback, cb);
   \       0x90   0xE288'006C        ADD      R0,R8,#+108
   \       0x94   0x....'....        BL       callback_copy
    432          
    433          	callback_set(&_cb, _bus_callback, (void*)(uint32_t)bus_id);
   \       0x98   0xE1A0'2004        MOV      R2,R4
   \       0x9C   0x....'....        LDR      R1,??DataTable10_3
   \       0xA0   0xE1A0'000D        MOV      R0,SP
   \       0xA4   0x....'....        BL       callback_set
    434          	switch (_bus[bus_id].type) {
   \       0xA8   0xE7DA'0009        LDRB     R0,[R10, +R9]
   \       0xAC   0xE350'0001        CMP      R0,#+1
   \       0xB0   0x0A00'000D        BEQ      ??bus_transfer_5
   \       0xB4   0xE350'0002        CMP      R0,#+2
   \       0xB8   0x1A00'0013        BNE      ??bus_transfer_6
    435          #ifdef CONFIG_HAVE_SPI_BUS
    436          	case BUS_TYPE_SPI:
    437          		_bus[bus_id].iface.spid.chip_select = (uint8_t)remote;
   \       0xBC   0xE5C8'5008        STRB     R5,[R8, #+8]
    438          
    439          		err = spid_transfer(&_bus[bus_id].iface.spid, buf, buffers, &_cb);
   \       0xC0   0xE1A0'300D        MOV      R3,SP
   \       0xC4   0xE1A0'2007        MOV      R2,R7
   \       0xC8   0xE1A0'1006        MOV      R1,R6
   \       0xCC   0xE288'0004        ADD      R0,R8,#+4
   \       0xD0   0x....'....        BL       spid_transfer
   \                     ??bus_transfer_7:
   \       0xD4   0xE1A0'4000        MOV      R4,R0
    440          		break;
    441          #endif
    442          #ifdef CONFIG_HAVE_I2C_BUS
    443          	case BUS_TYPE_I2C:
    444          		_bus[bus_id].iface.twid.slave_addr = (uint8_t)remote;
    445          
    446          		err = twid_transfer(&_bus[bus_id].iface.twid, buf, buffers, &_cb);
    447          		break;
    448          #endif
    449          	default:
    450          		err = -EINVAL;
    451          		break;
    452          	}
    453          
    454          	if (err < 0) {
   \       0xD8   0xE354'0000        CMP      R4,#+0
   \       0xDC   0x5A00'000C        BPL      ??bus_transfer_8
    455          		mutex_unlock(&_bus[bus_id].mutex.lock);
   \                     ??bus_transfer_9:
   \       0xE0   0xE288'0074        ADD      R0,R8,#+116
   \       0xE4   0x....'....        BL       mutex_unlock
    456          		return err;
   \       0xE8   0xEA00'0015        B        ??bus_transfer_10
    457          	}
   \                     ??bus_transfer_5:
   \       0xEC   0xE6EF'5075        UXTB     R5,R5
   \       0xF0   0xE1A0'300D        MOV      R3,SP
   \       0xF4   0xE588'500C        STR      R5,[R8, #+12]
   \       0xF8   0xE1A0'2007        MOV      R2,R7
   \       0xFC   0xE1A0'1006        MOV      R1,R6
   \      0x100   0xE288'0004        ADD      R0,R8,#+4
   \      0x104   0x....'....        BL       twid_transfer
   \      0x108   0xEAFF'FFF1        B        ??bus_transfer_7
   \                     ??bus_transfer_6:
   \      0x10C   0xE3E0'401B        MVN      R4,#+27
   \      0x110   0xEAFF'FFF2        B        ??bus_transfer_9
    458          	if (_bus[bus_id].options & O_BLOCK)
   \                     ??bus_transfer_8:
   \      0x114   0xE5D8'0064        LDRB     R0,[R8, #+100]
   \      0x118   0xE310'0001        TST      R0,#0x1
   \      0x11C   0x1A00'0004        BNE      ??bus_transfer_11
   \      0x120   0xEA00'0007        B        ??bus_transfer_10
    459          		while (bus_is_busy(bus_id)) {
    460          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \                     ??bus_transfer_12:
   \      0x124   0xE5D8'1060        LDRB     R1,[R8, #+96]
   \      0x128   0xE351'0002        CMP      R1,#+2
   \      0x12C   0x1A00'0000        BNE      ??bus_transfer_11
    461          				dma_poll();
   \      0x130   0x....'....        BL       dma_poll
    462          		}
   \                     ??bus_transfer_11:
   \      0x134   0xE288'0074        ADD      R0,R8,#+116
   \      0x138   0x....'....        BL       mutex_is_locked
   \      0x13C   0xE350'0000        CMP      R0,#+0
   \      0x140   0x1AFF'FFF7        BNE      ??bus_transfer_12
    463          
    464          	return err;
   \                     ??bus_transfer_10:
   \      0x144   0xE1A0'0004        MOV      R0,R4
   \      0x148   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}  ;; return
    465          }
    466          

   \                                 In section SOFTPACK, align 4, keep-with-next
    467          int bus_start_transaction(uint8_t bus_id)
    468          {
   \                     bus_start_transaction:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    469          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xBA00'0000        BLT      ??bus_start_transaction_0
    470          		return -ENODEV;
   \        0xC   0x....'....        B        ?Subroutine2
    471          
    472          	mutex_lock(&_bus[bus_id].mutex.transaction);
   \                     ??bus_start_transaction_0:
   \       0x10   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE081'0102        ADD      R0,R1,R2, LSL #+2
   \       0x1C   0xE280'0078        ADD      R0,R0,#+120
   \       0x20   0x....'....        BL       mutex_lock
    473          
    474          	return 0;
   \       0x24   0x....'....        B        ?Subroutine1
    475          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE3E0'002B        MVN      R0,#+43
   \        0x4   0xE8BD'8002        POP      {R1,PC}

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE8BD'8002        POP      {R1,PC}          ;; return
    476          

   \                                 In section SOFTPACK, align 4, keep-with-next
    477          int bus_stop_transaction(uint8_t bus_id)
    478          {
   \                     bus_stop_transaction:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    479          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xBA00'0000        BLT      ??bus_stop_transaction_0
    480          		return -ENODEV;
   \        0xC   0x....'....        B        ?Subroutine2
    481          
    482          	mutex_unlock(&_bus[bus_id].mutex.transaction);
   \                     ??bus_stop_transaction_0:
   \       0x10   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE081'0102        ADD      R0,R1,R2, LSL #+2
   \       0x1C   0xE280'0078        ADD      R0,R0,#+120
   \       0x20   0x....'....        BL       mutex_unlock
    483          
    484          	return 0;
   \       0x24   0x....'....        B        ?Subroutine1
    485          }
    486          

   \                                 In section SOFTPACK, align 4, keep-with-next
    487          void bus_wait_transaction(uint8_t bus_id)
    488          {
   \                     bus_wait_transaction:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \        0x8   0x....'....        LDR      R1,??DataTable10
   \        0xC   0xE081'4102        ADD      R4,R1,R2, LSL #+2
    489          	while (mutex_is_locked(&_bus[bus_id].mutex.transaction));
   \                     ??bus_wait_transaction_0:
   \       0x10   0xE284'0078        ADD      R0,R4,#+120
   \       0x14   0x....'....        BL       mutex_is_locked
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1AFF'FFFB        BNE      ??bus_wait_transaction_0
    490          }
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
    491          

   \                                 In section SOFTPACK, align 4, keep-with-next
    492          bool bus_is_busy(uint8_t bus_id)
    493          {
    494          	return mutex_is_locked(&_bus[bus_id].mutex.lock);
   \                     bus_is_busy:
   \        0x0   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \        0x4   0x....'....        LDR      R1,??DataTable10
   \        0x8   0xE081'0102        ADD      R0,R1,R2, LSL #+2
   \        0xC   0xE280'0074        ADD      R0,R0,#+116
   \       0x10   0x....'....        B        mutex_is_locked  ;; tailcall
    495          }
    496          

   \                                 In section SOFTPACK, align 4, keep-with-next
    497          int bus_wait_transfer(uint8_t bus_id)
    498          {
   \                     bus_wait_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    499          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xE24D'D010        SUB      SP,SP,#+16
    500          		return -ENODEV;
   \        0xC   0xA3E0'002B        MVNGE    R0,#+43
   \       0x10   0xAA00'001F        BGE      ??bus_wait_transfer_0
    501          
    502          	if (_bus[bus_id].timeout > 0) {
   \       0x14   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x18   0x....'....        LDR      R1,??DataTable10
   \       0x1C   0xE081'4102        ADD      R4,R1,R2, LSL #+2
   \       0x20   0xE594'2068        LDR      R2,[R4, #+104]
   \       0x24   0xE352'0000        CMP      R2,#+0
   \       0x28   0x0A00'0015        BEQ      ??bus_wait_transfer_1
    503          		struct _timeout _to;
    504          
    505          		timer_start_timeout(&_to, _bus[bus_id].timeout);
   \       0x2C   0xE3A0'3000        MOV      R3,#+0
   \       0x30   0xE1A0'000D        MOV      R0,SP
   \       0x34   0x....'....        BL       timer_start_timeout
   \       0x38   0xEA00'0007        B        ??bus_wait_transfer_2
    506          		while (!timer_timeout_reached(&_to)) {
    507          			if (!bus_is_busy(bus_id))
   \                     ??bus_wait_transfer_3:
   \       0x3C   0xE284'0074        ADD      R0,R4,#+116
   \       0x40   0x....'....        BL       mutex_is_locked
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x0A00'0011        BEQ      ??bus_wait_transfer_0
    508          				return 0;
    509          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \       0x4C   0xE5D4'0060        LDRB     R0,[R4, #+96]
   \       0x50   0xE350'0002        CMP      R0,#+2
   \       0x54   0x1A00'0000        BNE      ??bus_wait_transfer_2
    510          				dma_poll();
   \       0x58   0x....'....        BL       dma_poll
    511          		}
   \                     ??bus_wait_transfer_2:
   \       0x5C   0xE1A0'000D        MOV      R0,SP
   \       0x60   0x....'....        BL       timer_timeout_reached
   \       0x64   0xE350'0000        CMP      R0,#+0
   \       0x68   0x0AFF'FFF3        BEQ      ??bus_wait_transfer_3
    512          
    513          		return -ETIMEDOUT;
   \       0x6C   0xE3E0'004C        MVN      R0,#+76
   \       0x70   0x....'....        B        ?Subroutine0
    514          	} else {
    515          		while (bus_is_busy(bus_id)) {
    516          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \                     ??bus_wait_transfer_4:
   \       0x74   0xE5D4'0060        LDRB     R0,[R4, #+96]
   \       0x78   0xE350'0002        CMP      R0,#+2
   \       0x7C   0x1A00'0000        BNE      ??bus_wait_transfer_1
    517          				dma_poll();
   \       0x80   0x....'....        BL       dma_poll
    518          		}
   \                     ??bus_wait_transfer_1:
   \       0x84   0xE284'0074        ADD      R0,R4,#+116
   \       0x88   0x....'....        BL       mutex_is_locked
   \       0x8C   0xE350'0000        CMP      R0,#+0
   \       0x90   0x1AFF'FFF7        BNE      ??bus_wait_transfer_4
    519          	}
   \                     ??bus_wait_transfer_0:
   \       0x94                      REQUIRE ?Subroutine0
   \       0x94                      ;; // Fall through to label ?Subroutine0
    520          
    521          	return 0;
    522          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE28D'D010        ADD      SP,SP,#+16
   \        0x4   0xE8BD'8010        POP      {R4,PC}          ;; return
    523          

   \                                 In section SOFTPACK, align 4, keep-with-next
    524          int bus_suspend(uint8_t bus_id)
    525          {
    526          	int err = -ENOTSUP;
    527          
    528          	if (bus_id >= BUS_COUNT)
   \                     bus_suspend:
   \        0x0   0xE350'000D        CMP      R0,#+13
   \        0x4   0xBA00'0001        BLT      ??bus_suspend_0
    529          		return -ENODEV;
   \        0x8   0xE3E0'002B        MVN      R0,#+43
   \        0xC   0xE12F'FF1E        BX       LR
    530          
    531          	switch (_bus[bus_id].type) {
   \                     ??bus_suspend_0:
   \       0x10   0xE060'2280        RSB      R2,R0,R0, LSL #+5
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE7D1'0102        LDRB     R0,[R1, +R2, LSL #+2]
   \       0x1C   0xE240'0001        SUB      R0,R0,#+1
   \       0x20   0xE350'0001        CMP      R0,#+1
    532          #ifdef CONFIG_HAVE_SPI_BUS
    533          	case BUS_TYPE_SPI:
    534          		err = 0;
    535          		break;
    536          #endif
    537          #ifdef CONFIG_HAVE_I2C_BUS
    538          	case BUS_TYPE_I2C:
    539          		err = 0;
   \       0x24   0x93A0'0000        MOVLS    R0,#+0
    540          		break;
    541          #endif
    542          	default:
    543          		err = -EINVAL;
   \       0x28   0x83E0'001B        MVNHI    R0,#+27
    544          		break;
    545          	}
    546          
    547          	return err;
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    548          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     _bus

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     _bus_callback

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x45          DC8 "-E- bus: no opened transaction on the bus."

   \              0x2D 0x20    

   \              0x62 0x75    

   \              0x73 0x3A    

   \              0x20 0x6E    

   \              0x6F 0x20    

   \              0x6F 0x70    

   \              0x65 0x6E    

   \              0x65 0x64    

   \              0x20 0x74    

   \              0x72 0x61    

   \              0x6E 0x73    

   \              0x61 0x63    

   \              0x74 0x69    

   \              0x6F 0x6E    

   \              0x20 0x6F    

   \              0x6E 0x20    

   \              0x74 0x68    

   \              0x65 0x20    

   \              0x62 0x75    

   \              0x73 0x2E    

   \              0x00
   \       0x2B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _bus_callback
         0   -> callback_call
         8   -> mutex_unlock
      32   bus_configure
        32   -> __aeabi_memclr
        32   -> bus_ioctl
        32   -> spid_configure
        32   -> spid_configure_master
        32   -> twid_configure
      24   bus_configure_slave
        24   -> spid_configure_cs
       4   bus_ioctl
       0   bus_is_busy
         0   -> mutex_is_locked
       8   bus_start_transaction
         8   -> mutex_lock
       8   bus_stop_transaction
         8   -> mutex_unlock
       0   bus_suspend
      40   bus_transfer
        40   -> callback_copy
        40   -> callback_set
        40   -> dma_poll
        40   -> mutex_is_locked
        40   -> mutex_try_lock
        40   -> mutex_unlock
        40   -> printf
        40   -> spid_transfer
        40   -> twid_transfer
       8   bus_wait_transaction
         8   -> mutex_is_locked
      24   bus_wait_transfer
        24   -> dma_poll
        24   -> mutex_is_locked
        24   -> timer_start_timeout
        24   -> timer_timeout_reached


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      44  ?_0
   1'612  _bus
      56  _bus_callback
     204  bus_configure
     112  bus_configure_slave
     440  bus_ioctl
      20  bus_is_busy
      40  bus_start_transaction
      40  bus_stop_transaction
      48  bus_suspend
     332  bus_transfer
      36  bus_wait_transaction
     148  bus_wait_transfer

 
 1'612 bytes in section .bss
    44 bytes in section .rodata
 1'516 bytes in section SOFTPACK
 
 1'516 bytes of CODE  memory
    44 bytes of CONST memory
 1'612 bytes of DATA  memory

Errors: none
Warnings: none
