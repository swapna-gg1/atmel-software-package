###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         23/Oct/2020  09:46:37
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\qspi.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EWB7B0.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\qspi.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_QSPI -D CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_NFC -D
#        CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D
#        CONFIG_HAVE_GMAC_QUEUES -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_MPDDRC_DDR3 -D CONFIG_HAVE_MPDDRC_LPDDR3 -D
#        CONFIG_HAVE_ADC_SETTLING_TIME -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_FAST_STARTUP -D
#        CONFIG_HAVE_PMC_GENERATED_CLOCKS -D CONFIG_HAVE_PMC_AUDIO_CLOCK -D
#        CONFIG_HAVE_PMC_PLLADIV2 -D CONFIG_HAVE_PMC_H32MXDIV -D
#        CONFIG_HAVE_PMC_UPLL_BIAS -D CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA
#        -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
#        -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_SFRBU
#        -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_AESB -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List\qspi.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\Obj\qspi.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf         
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\spi\qspi.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           */
     28          
     29          /*----------------------------------------------------------------------------
     30           *        HEADERS
     31           *----------------------------------------------------------------------------*/
     32          
     33          #include <errno.h>
     34          
     35          #include "board.h"
     36          #include "nvm/spi-nor/spi-nor.h"
     37          #include "peripherals/pmc.h"
     38          #include "string.h"
     39          #include "spi/qspi.h"
     40          #include "spi/spid.h"
     41          #include "timer.h"
     42          #include "trace.h"
     43          #ifdef CONFIG_HAVE_QSPI_DMA
     44          #include "barriers.h"
     45          #include "dma/dma.h"
     46          #include "mm/cache.h"
     47          #endif
     48          
     49          /*----------------------------------------------------------------------------
     50           *        CONSTANTS
     51           *----------------------------------------------------------------------------*/
     52          
     53          //#define QSPI_VERBOSE_DEBUG
     54          
     55          /*----------------------------------------------------------------------------
     56           *        LOCAL FUNCTIONS
     57           *----------------------------------------------------------------------------*/
     58          

   \                                 In section SOFTPACK, align 4, keep-with-next
     59          static void * qspi_memcpy(union spi_flash_priv* priv, uint8_t *dst, const uint8_t *src, int count, bool use_dma)
     60          {
   \                     qspi_memcpy:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE24D'D00C        SUB      SP,SP,#+12
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE1A0'4001        MOV      R4,R1
   \       0x10   0xE5DD'0018        LDRB     R0,[SP, #+24]
     61          #ifdef CONFIG_HAVE_QSPI_DMA
     62          	if (use_dma) {
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x1A00'0007        BNE      ??qspi_memcpy_0
   \       0x1C   0xE353'0000        CMP      R3,#+0
   \       0x20   0x0A00'0003        BEQ      ??qspi_memcpy_1
     63          		uint32_t rc;
     64          		struct _dma_transfer_cfg cfg = {
     65          			.daddr = (void *)dst,
     66          			.saddr = (void *)src,
     67          			.len = count,
     68          		};
     69          		static struct _dma_cfg dma_cfg = {
     70          			.incr_saddr = true,
     71          			.incr_daddr = true,
     72          			.data_width = DMA_DATA_WIDTH_BYTE,
     73          			.chunk_size = DMA_CHUNK_SIZE_1,
     74          			.loop = false,
     75          		};
     76          		dma_configure_transfer(priv->qspi.dma_ch, &dma_cfg, &cfg, 1);
     77          		rc = dma_start_transfer(priv->qspi.dma_ch);
     78          		if (rc != 0)
     79          			trace_fatal("Couldn't start xDMA transfer\n\r");
     80          		while (!dma_is_transfer_done(priv->qspi.dma_ch))
     81          			dma_poll();
     82          		dma_reset_channel(priv->qspi.dma_ch);
     83          		dsb();
     84          
     85          		return dst;
     86          	}
     87          #endif
     88          	while (count--) {
     89          		*dst++ = *src;
   \                     ??qspi_memcpy_2:
   \       0x24   0xE4D2'0001        LDRB     R0,[R2], #+1
     90          		src++;
   \       0x28   0xE253'3001        SUBS     R3,R3,#+1
   \       0x2C   0xE4C4'0001        STRB     R0,[R4], #+1
     91          	}
   \       0x30   0x1AFF'FFFB        BNE      ??qspi_memcpy_2
     92          	return 0;
   \                     ??qspi_memcpy_1:
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0x....'....        B        ?Subroutine0
   \                     ??qspi_memcpy_0:
   \       0x3C   0xE58D'4004        STR      R4,[SP, #+4]
   \       0x40   0xE58D'2000        STR      R2,[SP, #+0]
   \       0x44   0xE58D'3008        STR      R3,[SP, #+8]
   \       0x48   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x4C   0xE3A0'3001        MOV      R3,#+1
   \       0x50   0xE1A0'200D        MOV      R2,SP
   \       0x54   0x....'....        LDR      R1,??DataTable3
   \       0x58   0x....'....        BL       dma_configure_transfer
   \       0x5C   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x60   0x....'....        BL       dma_start_transfer
   \       0x64   0xE350'0000        CMP      R0,#+0
   \       0x68   0x0A00'0007        BEQ      ??qspi_memcpy_3
   \       0x6C   0x....'....        LDR      R0,??DataTable3_1
   \       0x70   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x74   0xE351'0000        CMP      R1,#+0
   \       0x78   0x0A00'0001        BEQ      ??qspi_memcpy_4
   \       0x7C   0x....'....        LDR      R0,??DataTable3_2
   \       0x80   0x....'....        BL       printf
   \                     ??qspi_memcpy_4:
   \       0x84   0xEAFF'FFFE        B        ??qspi_memcpy_4
   \                     ??qspi_memcpy_5:
   \       0x88   0x....'....        BL       dma_poll
   \                     ??qspi_memcpy_3:
   \       0x8C   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x90   0x....'....        BL       dma_is_transfer_done
   \       0x94   0xE350'0000        CMP      R0,#+0
   \       0x98   0x0AFF'FFFA        BEQ      ??qspi_memcpy_5
   \       0x9C   0xE595'000C        LDR      R0,[R5, #+12]
   \       0xA0   0x....'....        BL       dma_reset_channel
   \       0xA4   0xF57F'F04F        dsb
   \       0xA8   0xE1A0'0004        MOV      R0,R4
   \       0xAC                      REQUIRE ?Subroutine0
   \       0xAC                      ;; // Fall through to label ?Subroutine0
     93          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE28D'D00C        ADD      SP,SP,#+12
   \        0x4   0xE8BD'8030        POP      {R4,R5,PC}

   \                                 In section .data, align 4
   \                     `qspi_memcpy{1}{2}::dma_cfg`:
   \        0x0   0x0000'0000        DC32 0, 0

   \              0x0000'0000
   \        0x8   0x01 0x01          DC8 1, 1, 0, 0

   \              0x00 0x00
     94          

   \                                 In section SOFTPACK, align 4, keep-with-next
     95          static int qspi_set_freq(union spi_flash_priv* priv, uint32_t clock)
     96          {
   \                     qspi_set_freq:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
     97          	Qspi* qspi = priv->qspi.addr;
   \        0x4   0xE590'4000        LDR      R4,[R0, #+0]
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     98          	uint32_t scbr;
     99          	uint32_t reg;
    100          
    101          	if (clock == 0) {
    102          		scbr = 0;
   \        0xC   0x03A0'0000        MOVEQ    R0,#+0
   \       0x10   0x0A00'000A        BEQ      ??qspi_set_freq_0
    103          	} else {
    104          		uint32_t mck = pmc_get_peripheral_clock(get_qspi_id_from_addr(qspi));
    105          		scbr = (mck + clock - 1) / (clock);
   \       0x14   0xE1A0'0004        MOV      R0,R4
   \       0x18   0x....'....        BL       get_qspi_id_from_addr
   \       0x1C   0x....'....        BL       pmc_get_peripheral_clock
   \       0x20   0xE085'0000        ADD      R0,R5,R0
   \       0x24   0xE1A0'1005        MOV      R1,R5
   \       0x28   0xE240'0001        SUB      R0,R0,#+1
   \       0x2C   0x....'....        BL       __aeabi_uidiv
    106          		if (scbr >= 1)
   \       0x30   0xE350'0000        CMP      R0,#+0
    107          			scbr--;
   \       0x34   0xE3A0'1CFF        MOV      R1,#+65280
   \       0x38   0x1240'0001        SUBNE    R0,R0,#+1
   \       0x3C   0xE001'0400        AND      R0,R1,R0, LSL #+8
    108          	}
    109          
    110          	reg = qspi->QSPI_SCR;
    111          	reg = (reg & ~QSPI_SCR_SCBR_Msk) | QSPI_SCR_SCBR(scbr);
    112          	qspi->QSPI_SCR = reg;
   \                     ??qspi_set_freq_0:
   \       0x40   0xE594'2020        LDR      R2,[R4, #+32]
   \       0x44   0xE3C2'3CFF        BIC      R3,R2,#0xFF00
   \       0x48   0xE180'0003        ORR      R0,R0,R3
   \       0x4C   0xE584'0020        STR      R0,[R4, #+32]
    113          
    114          	return 0;
   \       0x50   0x....'....        B        ?Subroutine1
    115          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    116          

   \                                 In section SOFTPACK, align 4, keep-with-next
    117          static int qspi_set_mode(union spi_flash_priv* priv, uint8_t mode)
    118          {
    119          	Qspi* qspi = priv->qspi.addr;
   \                     qspi_set_mode:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
    120          	uint32_t reg, val, msk;
    121          
    122          	reg = qspi->QSPI_SCR;
    123          
    124          	msk = (QSPI_SCR_CPHA | QSPI_SCR_CPOL);
    125          	switch (mode) {
   \        0x4   0xE351'0003        CMP      R1,#+3
   \        0x8   0xE590'2020        LDR      R2,[R0, #+32]
   \        0xC   0x8A00'000F        BHI      ??qspi_set_mode_1
   \       0x10   0xE7DF'3001        LDRB     R3,[PC, R1]
   \       0x14   0xE08F'F103        ADD      PC,PC,R3, LSL #+2
   \                     ??qspi_set_mode_0:
   \       0x18   0x00 0x07          DC8      0x0,0x7,0x9,0xB

   \              0x09 0x0B
    126          	case SPID_MODE_0:
    127          		val = 0;
   \                     ??qspi_set_mode_2:
   \       0x1C   0xE3A0'1000        MOV      R1,#+0
    128          		break;
    129          
    130          	case SPID_MODE_1:
    131          		val = QSPI_SCR_CPHA;
    132          		break;
    133          
    134          	case SPID_MODE_2:
    135          		val = QSPI_SCR_CPOL;
    136          		break;
    137          
    138          	case SPID_MODE_3:
    139          		val = (QSPI_SCR_CPOL | QSPI_SCR_CPHA);
    140          		break;
    141          
    142          	default:
    143          		return -1;
    144          	}
    145          
    146          	if ((reg & msk) != val) {
   \                     ??qspi_set_mode_3:
   \       0x20   0xE202'C003        AND      R12,R2,#0x3
   \       0x24   0xE15C'0001        CMP      R12,R1
    147          		reg = (reg & ~msk) | val;
    148          		qspi->QSPI_SCR = reg;
   \       0x28   0x11A0'2122        LSRNE    R2,R2,#+2
   \       0x2C   0x1181'1102        ORRNE    R1,R1,R2, LSL #+2
   \       0x30   0x1580'1020        STRNE    R1,[R0, #+32]
    149          	}
    150          
    151          	return 0;
   \       0x34   0x....'....        B        ?Subroutine2
   \                     ??qspi_set_mode_4:
   \       0x38   0xE3A0'1002        MOV      R1,#+2
   \       0x3C   0xEAFF'FFF7        B        ??qspi_set_mode_3
   \                     ??qspi_set_mode_5:
   \       0x40   0xE3A0'1001        MOV      R1,#+1
   \       0x44   0xEAFF'FFF5        B        ??qspi_set_mode_3
   \                     ??qspi_set_mode_6:
   \       0x48   0xE3A0'1003        MOV      R1,#+3
   \       0x4C   0xEAFF'FFF3        B        ??qspi_set_mode_3
   \                     ??qspi_set_mode_1:
   \       0x50   0xE3E0'0000        MVN      R0,#+0
   \       0x54   0xE12F'FF1E        BX       LR
    152          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    153          

   \                                 In section SOFTPACK, align 4, keep-with-next
    154          static int qspi_init(union spi_flash_priv* priv)
    155          {
   \                     qspi_init:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    156          	Qspi* qspi = priv->qspi.addr;
    157          
    158          	if (pmc_has_system_clock(PMC_SYSTEM_CLOCK_QSPI))
   \        0x8   0xE3A0'000D        MOV      R0,#+13
   \        0xC   0xE594'5000        LDR      R5,[R4, #+0]
   \       0x10   0x....'....        BL       pmc_has_system_clock
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x0A00'0001        BEQ      ??qspi_init_0
    159          		pmc_enable_system_clock(PMC_SYSTEM_CLOCK_QSPI);
   \       0x1C   0xE3A0'000D        MOV      R0,#+13
   \       0x20   0x....'....        BL       pmc_enable_system_clock
    160          	pmc_configure_peripheral(get_qspi_id_from_addr(qspi), NULL, true);
   \                     ??qspi_init_0:
   \       0x24   0xE1A0'0005        MOV      R0,R5
   \       0x28   0x....'....        BL       get_qspi_id_from_addr
   \       0x2C   0xE3A0'2001        MOV      R2,#+1
   \       0x30   0xE3A0'1000        MOV      R1,#+0
   \       0x34   0x....'....        BL       pmc_configure_peripheral
    161          
    162          	/* Disable write protection */
    163          	qspi->QSPI_WPMR = QSPI_WPMR_WPKEY_PASSWD;
   \       0x38   0x....'....        LDR      R0,??DataTable3_3  ;; 0x51535000
   \       0x3C   0xE585'00E4        STR      R0,[R5, #+228]
    164          
    165          	qspi->QSPI_CR = QSPI_CR_QSPIDIS;
   \       0x40   0xE3A0'1002        MOV      R1,#+2
    166          	qspi->QSPI_CR = QSPI_CR_SWRST;
   \       0x44   0xE3A0'2080        MOV      R2,#+128
   \       0x48   0xE585'1000        STR      R1,[R5, #+0]
   \       0x4C   0xE585'2000        STR      R2,[R5, #+0]
    167          
    168          	qspi->QSPI_MR = QSPI_MR_SMM_MEMORY;
   \       0x50   0xE3A0'0001        MOV      R0,#+1
    169          	qspi->QSPI_SCR = 0;
   \       0x54   0xE3A0'3000        MOV      R3,#+0
   \       0x58   0xE585'0004        STR      R0,[R5, #+4]
   \       0x5C   0xE585'3020        STR      R3,[R5, #+32]
    170          
    171          	qspi->QSPI_CR = QSPI_CR_QSPIEN;
   \       0x60   0xE585'0000        STR      R0,[R5, #+0]
    172          
    173          #ifdef CONFIG_HAVE_QSPI_DMA
    174          	priv->qspi.dma_ch = dma_allocate_channel(DMA_PERIPH_MEMORY, DMA_PERIPH_MEMORY);
   \       0x64   0xE3A0'10FF        MOV      R1,#+255
   \       0x68   0xE3A0'00FF        MOV      R0,#+255
   \       0x6C   0x....'....        BL       dma_allocate_channel
    175          	if (!priv->qspi.dma_ch)
   \       0x70   0xE350'0000        CMP      R0,#+0
   \       0x74   0xE584'000C        STR      R0,[R4, #+12]
   \       0x78   0x1A00'0006        BNE      ??qspi_init_1
    176          		trace_fatal("Couldn't allocate XDMA channel\n\r");
   \       0x7C   0x....'....        LDR      R0,??DataTable3_1
   \       0x80   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x84   0xE351'0000        CMP      R1,#+0
   \       0x88   0x0A00'0001        BEQ      ??qspi_init_2
   \       0x8C   0x....'....        LDR      R0,??DataTable3_4
   \       0x90   0x....'....        BL       printf
   \                     ??qspi_init_2:
   \       0x94   0xEAFF'FFFE        B        ??qspi_init_2
    177          #endif
    178          
    179          	return 0;
   \                     ??qspi_init_1:
   \       0x98                      REQUIRE ?Subroutine1
   \       0x98                      ;; // Fall through to label ?Subroutine1
    180          }
    181          

   \                                 In section SOFTPACK, align 4, keep-with-next
    182          static int qspi_cleanup(union spi_flash_priv* priv)
    183          {
    184          	Qspi* qspi = priv->qspi.addr;
   \                     qspi_cleanup:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
    185          
    186          	qspi->QSPI_CR = QSPI_CR_QSPIDIS;
   \        0x4   0xE3A0'1002        MOV      R1,#+2
    187          	qspi->QSPI_CR = QSPI_CR_SWRST;
   \        0x8   0xE3A0'2080        MOV      R2,#+128
   \        0xC   0xE580'1000        STR      R1,[R0, #+0]
   \       0x10   0xE580'2000        STR      R2,[R0, #+0]
    188          
    189          	return 0;
   \       0x14                      REQUIRE ?Subroutine2
   \       0x14                      ;; // Fall through to label ?Subroutine2
    190          }
    191          
    192          static int qspi_init_ifr(const struct spi_flash_command *cmd, uint32_t *ifr)
    193          {
    194          	*ifr = 0;
    195          
    196          #ifdef QSPI_IFR_TFRTYP_TRSFR_REGISTER
    197          	switch (cmd->flags & SFLASH_TYPE_MASK) {
    198          	case SFLASH_TYPE_READ_REG:
    199          		*ifr |= QSPI_IFR_APBTFRTYP_READ | QSPI_IFR_TFRTYP_TRSFR_REGISTER;
    200          		break;
    201          	case SFLASH_TYPE_READ:
    202          		*ifr |= QSPI_IFR_APBTFRTYP_READ | QSPI_IFR_TFRTYP_TRSFR_MEMORY;
    203          		break;
    204          	case SFLASH_TYPE_WRITE_REG:
    205          	case SFLASH_TYPE_ERASE:
    206          		*ifr |= QSPI_IFR_APBTFRTYP_WRITE | QSPI_IFR_TFRTYP_TRSFR_REGISTER;
    207          		break;
    208          	case SFLASH_TYPE_WRITE:
    209          		*ifr |= QSPI_IFR_APBTFRTYP_WRITE | QSPI_IFR_TFRTYP_TRSFR_MEMORY;
    210          		break;
    211          	default:
    212          		return -1;
    213          	}
    214          #else
    215          	switch (cmd->flags & SFLASH_TYPE_MASK) {
    216          	case SFLASH_TYPE_READ:
    217          		*ifr |= QSPI_IFR_TFRTYP_TRSFR_READ_MEMORY;
    218          		break;
    219          
    220          	case SFLASH_TYPE_WRITE:
    221          		*ifr |= QSPI_IFR_TFRTYP_TRSFR_WRITE_MEMORY;
    222          		break;
    223          
    224          	case SFLASH_TYPE_READ_REG:
    225          		*ifr |= QSPI_IFR_TFRTYP_TRSFR_READ;
    226          		break;
    227          
    228          	case SFLASH_TYPE_WRITE_REG:
    229          	case SFLASH_TYPE_ERASE:
    230          		*ifr |= QSPI_IFR_TFRTYP_TRSFR_WRITE;
    231          		break;
    232          
    233          	default:
    234          		return -1;
    235          	}
    236          #endif
    237          
    238          	switch (cmd->proto) {
    239          	case SFLASH_PROTO_1_1_1:
    240          		*ifr |= QSPI_IFR_WIDTH_SINGLE_BIT_SPI;
    241          #ifdef QSPI_VERBOSE_DEBUG
    242          		printf("SPI 1-1-1 ");
    243          #endif
    244          		break;
    245          
    246          	case SFLASH_PROTO_1_1_2:
    247          		*ifr |= QSPI_IFR_WIDTH_DUAL_OUTPUT;
    248          #ifdef QSPI_VERBOSE_DEBUG
    249          		printf("SPI 1-1-2 ");
    250          #endif
    251          		break;
    252          
    253          	case SFLASH_PROTO_1_2_2:
    254          		*ifr |= QSPI_IFR_WIDTH_DUAL_IO;
    255          #ifdef QSPI_VERBOSE_DEBUG
    256          		printf("SPI 1-2-2 ");
    257          #endif
    258          		break;
    259          
    260          	case SFLASH_PROTO_2_2_2:
    261          		*ifr |= QSPI_IFR_WIDTH_DUAL_CMD;
    262          #ifdef QSPI_VERBOSE_DEBUG
    263          		printf("SPI 2-2-2 ");
    264          #endif
    265          		break;
    266          
    267          	case SFLASH_PROTO_1_1_4:
    268          		*ifr |= QSPI_IFR_WIDTH_QUAD_OUTPUT;
    269          #ifdef QSPI_VERBOSE_DEBUG
    270          		printf("SPI 1-1-4 ");
    271          #endif
    272          		break;
    273          
    274          	case SFLASH_PROTO_1_4_4:
    275          		*ifr |= QSPI_IFR_WIDTH_QUAD_IO;
    276          #ifdef QSPI_VERBOSE_DEBUG
    277          		printf("SPI 1-4-4 ");
    278          #endif
    279          		break;
    280          
    281          	case SFLASH_PROTO_4_4_4:
    282          		*ifr |= QSPI_IFR_WIDTH_QUAD_CMD;
    283          #ifdef QSPI_VERBOSE_DEBUG
    284          		printf("SPI 4-4-4 ");
    285          #endif
    286          		break;
    287          
    288          	default:
    289          		return -1;
    290          	}
    291          
    292          	return 0;
    293          }
    294          

   \                                 In section SOFTPACK, align 4, keep-with-next
    295          static int qspi_exec(union spi_flash_priv* priv, const struct spi_flash_command *cmd)
    296          {
   \                     qspi_exec:
   \        0x0   0xE92D'47F0        PUSH     {R4-R10,LR}
   \        0x4   0xE1A0'7001        MOV      R7,R1
   \        0x8   0xE1A0'6000        MOV      R6,R0
   \        0xC   0xE24D'D010        SUB      SP,SP,#+16
    297          	Qspi* qspi = priv->qspi.addr;
    298          	uint32_t iar, icr, ifr;
    299          	uint32_t offset;
    300          	uint8_t *ptr;
    301          	bool use_dma = false;
   \       0x10   0xE3A0'5000        MOV      R5,#+0
    302          	bool enable_data =
    303          		(((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_READ ) ||
    304          		 ((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_WRITE ) ||
    305          		 ((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_READ_REG ) ||
    306          		 (((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_WRITE_REG ) &&
    307          		  (cmd->data_len != 0))) ? true : false;
   \       0x14   0xE597'2004        LDR      R2,[R7, #+4]
   \       0x18   0xE596'4000        LDR      R4,[R6, #+0]
   \       0x1C   0xE3A0'8000        MOV      R8,#+0
   \       0x20   0xE312'0007        TST      R2,#0x7
   \       0x24   0x0A00'000A        BEQ      ??qspi_exec_3
   \       0x28   0xE202'0007        AND      R0,R2,#0x7
   \       0x2C   0xE350'0001        CMP      R0,#+1
   \       0x30   0x0A00'000A        BEQ      ??qspi_exec_4
   \       0x34   0xE202'1007        AND      R1,R2,#0x7
   \       0x38   0xE351'0003        CMP      R1,#+3
   \       0x3C   0x0A00'0004        BEQ      ??qspi_exec_3
   \       0x40   0xE350'0004        CMP      R0,#+4
   \       0x44   0x1A00'0004        BNE      ??qspi_exec_5
   \       0x48   0xE597'1014        LDR      R1,[R7, #+20]
   \       0x4C   0xE351'0000        CMP      R1,#+0
   \       0x50   0x0A00'0001        BEQ      ??qspi_exec_5
   \                     ??qspi_exec_3:
   \       0x54   0xE3A0'0001        MOV      R0,#+1
   \       0x58   0xEA00'0000        B        ??qspi_exec_4
   \                     ??qspi_exec_5:
   \       0x5C   0xE3A0'0000        MOV      R0,#+0
    308          #ifdef QSPI_RICR_RDINST
    309          	bool icr_write = false;
    310          #endif
    311          
    312          	iar = 0;
    313          	icr = 0;
    314          
    315          	/* Init ifr. */
    316          	if (qspi_init_ifr(cmd, &ifr))
   \                     ??qspi_exec_4:
   \       0x60   0xE202'2007        AND      R2,R2,#0x7
   \       0x64   0xE3A0'1000        MOV      R1,#+0
   \       0x68   0xE352'0004        CMP      R2,#+4
   \       0x6C   0xE3A0'3000        MOV      R3,#+0
   \       0x70   0x8A00'0088        BHI      ??qspi_exec_6
   \       0x74   0xE7DF'C002        LDRB     R12,[PC, R2]
   \       0x78   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??qspi_exec_0:
   \       0x7C   0x05 0x03          DC8      0x5,0x3,0x1,0x6

   \              0x01 0x06
   \       0x80   0x01 0x00          DC8      0x1,0x0,0x0,0x0

   \              0x00 0x00
   \                     ??qspi_exec_7:
   \       0x84   0xE3A0'3D80        MOV      R3,#+8192
   \       0x88   0xEA00'0002        B        ??qspi_exec_8
   \                     ??qspi_exec_9:
   \       0x8C   0xE3A0'3DC0        MOV      R3,#+12288
   \       0x90   0xEA00'0000        B        ??qspi_exec_8
   \                     ??qspi_exec_10:
   \       0x94   0xE3A0'3D40        MOV      R3,#+4096
   \                     ??qspi_exec_8:
   \       0x98   0xE597'2000        LDR      R2,[R7, #+0]
   \       0x9C   0x....'....        LDR      R12,??DataTable3_5  ;; 0x10101
   \       0xA0   0xE152'000C        CMP      R2,R12
   \       0xA4   0x0A00'001D        BEQ      ??qspi_exec_11
   \       0xA8   0xE28C'C001        ADD      R12,R12,#+1
   \       0xAC   0xE152'000C        CMP      R2,R12
   \       0xB0   0x0A00'0019        BEQ      ??qspi_exec_12
   \       0xB4   0xE28C'C002        ADD      R12,R12,#+2
   \       0xB8   0xE152'000C        CMP      R2,R12
   \       0xBC   0x0A00'0010        BEQ      ??qspi_exec_13
   \       0xC0   0xE28C'C0FE        ADD      R12,R12,#+254
   \       0xC4   0xE152'000C        CMP      R2,R12
   \       0xC8   0x0A00'0011        BEQ      ??qspi_exec_14
   \       0xCC   0xE3A0'C004        MOV      R12,#+4
   \       0xD0   0xE38C'CB41        ORR      R12,R12,#0x10400
   \       0xD4   0xE152'000C        CMP      R2,R12
   \       0xD8   0x0A00'0007        BEQ      ??qspi_exec_15
   \       0xDC   0x....'....        LDR      R12,??DataTable3_6  ;; 0x20202
   \       0xE0   0xE152'000C        CMP      R2,R12
   \       0xE4   0x0A00'0008        BEQ      ??qspi_exec_16
   \       0xE8   0xE1A0'C08C        MOV      R12,R12, LSL #+1
   \       0xEC   0xE152'000C        CMP      R2,R12
   \       0xF0   0x1A00'0068        BNE      ??qspi_exec_6
   \       0xF4   0xE383'3006        ORR      R3,R3,#0x6
   \       0xF8   0xEA00'0008        B        ??qspi_exec_11
   \                     ??qspi_exec_15:
   \       0xFC   0xE383'3004        ORR      R3,R3,#0x4
   \      0x100   0xEA00'0006        B        ??qspi_exec_11
   \                     ??qspi_exec_13:
   \      0x104   0xE383'3002        ORR      R3,R3,#0x2
   \      0x108   0xEA00'0004        B        ??qspi_exec_11
   \                     ??qspi_exec_16:
   \      0x10C   0xE383'3005        ORR      R3,R3,#0x5
   \      0x110   0xEA00'0002        B        ??qspi_exec_11
   \                     ??qspi_exec_14:
   \      0x114   0xE383'3003        ORR      R3,R3,#0x3
   \      0x118   0xEA00'0000        B        ??qspi_exec_11
   \                     ??qspi_exec_12:
   \      0x11C   0xE383'3001        ORR      R3,R3,#0x1
    317          		return -1;
    318          
    319          	/* Compute instruction parameters. */
    320          #ifdef QSPI_RICR_RDINST
    321          	if ((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_ERASE
    322          	    || (cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_WRITE_REG
    323          	    || (cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_WRITE) {
    324          		icr_write = true;
    325          		icr |= QSPI_WICR_WRINST(cmd->inst);
    326          	} else {
    327          		icr |= QSPI_RICR_RDINST(cmd->inst);
    328          	}
    329          #else
    330          	icr |= QSPI_ICR_INST(cmd->inst);
    331          #endif
    332          	ifr |= QSPI_IFR_INSTEN;
    333          
    334          	/* Compute address parameters. */
    335          	switch (cmd->addr_len) {
   \                     ??qspi_exec_11:
   \      0x120   0xE5D7'C00C        LDRB     R12,[R7, #+12]
   \      0x124   0xE5D7'2008        LDRB     R2,[R7, #+8]
   \      0x128   0xE383'3010        ORR      R3,R3,#0x10
   \      0x12C   0xE35C'0000        CMP      R12,#+0
   \      0x130   0x0A00'0009        BEQ      ??qspi_exec_17
   \      0x134   0xE35C'0003        CMP      R12,#+3
   \      0x138   0x0A00'0002        BEQ      ??qspi_exec_18
   \      0x13C   0xE35C'0004        CMP      R12,#+4
   \      0x140   0x1A00'0054        BNE      ??qspi_exec_6
    336          	case 4:
    337          		ifr |= QSPI_IFR_ADDRL_32_BIT;
   \      0x144   0xE383'3E40        ORR      R3,R3,#0x400
    338          		/* fall through the 24bit (3 byte) address case */
    339          	case 3:
    340          		iar = cmd->data_len ? 0 : QSPI_IAR_ADDR(cmd->addr);
   \                     ??qspi_exec_18:
   \      0x148   0xE597'5014        LDR      R5,[R7, #+20]
    341          		ifr |= QSPI_IFR_ADDREN;
   \      0x14C   0xE383'3020        ORR      R3,R3,#0x20
   \      0x150   0xE355'0000        CMP      R5,#+0
    342          		offset = cmd->addr;
   \      0x154   0xE597'5010        LDR      R5,[R7, #+16]
   \      0x158   0x0597'1010        LDREQ    R1,[R7, #+16]
    343          		break;
    344          	case 0:
    345          		offset = 0;
    346          		break;
    347          	default:
    348          		return -1;
    349          	}
    350          
    351          	/* Compute option parameters. */
    352          	if (cmd->num_mode_cycles) {
   \                     ??qspi_exec_17:
   \      0x15C   0xE5D7'C00A        LDRB     R12,[R7, #+10]
   \      0x160   0xE35C'0000        CMP      R12,#+0
   \      0x164   0x0A00'0017        BEQ      ??qspi_exec_19
    353          		uint32_t mode_cycle_bits, mode_bits;
    354          
    355          #ifdef QSPI_RICR_RDINST
    356          		if (icr_write)
    357          			icr |= QSPI_WICR_WROPT(cmd->mode);
    358          		else
    359          			icr |= QSPI_RICR_RDOPT(cmd->mode);
    360          #else
    361          		icr |= QSPI_ICR_OPT(cmd->mode);
   \      0x168   0xE5D7'E009        LDRB     LR,[R7, #+9]
    362          #endif
    363          		ifr |= QSPI_IFR_OPTEN;
   \      0x16C   0xE383'3040        ORR      R3,R3,#0x40
    364          
    365          		switch (ifr & QSPI_IFR_WIDTH_Msk) {
   \      0x170   0xE203'9007        AND      R9,R3,#0x7
   \      0x174   0xE359'0006        CMP      R9,#+6
   \      0x178   0xE182'280E        ORR      R2,R2,LR, LSL #+16
   \      0x17C   0x8A00'0045        BHI      ??qspi_exec_6
   \      0x180   0xE7DF'A009        LDRB     R10,[PC, R9]
   \      0x184   0xE08F'F10A        ADD      PC,PC,R10, LSL #+2
   \                     ??qspi_exec_1:
   \      0x188   0x01 0x01          DC8      0x1,0x1,0x1,0x3

   \              0x01 0x03
   \      0x18C   0x05 0x03          DC8      0x5,0x3,0x5,0x0

   \              0x05 0x00
    366          		case QSPI_IFR_WIDTH_SINGLE_BIT_SPI:
    367          		case QSPI_IFR_WIDTH_DUAL_OUTPUT:
    368          		case QSPI_IFR_WIDTH_QUAD_OUTPUT:
    369          			mode_cycle_bits = 1;
   \                     ??qspi_exec_20:
   \      0x190   0xE3A0'E001        MOV      LR,#+1
    370          			break;
   \      0x194   0xEA00'0002        B        ??qspi_exec_21
    371          		case QSPI_IFR_WIDTH_DUAL_IO:
    372          		case QSPI_IFR_WIDTH_DUAL_CMD:
    373          			mode_cycle_bits = 2;
   \                     ??qspi_exec_22:
   \      0x198   0xE3A0'E002        MOV      LR,#+2
    374          			break;
   \      0x19C   0xEA00'0000        B        ??qspi_exec_21
    375          		case QSPI_IFR_WIDTH_QUAD_IO:
    376          		case QSPI_IFR_WIDTH_QUAD_CMD:
    377          			mode_cycle_bits = 4;
   \                     ??qspi_exec_23:
   \      0x1A0   0xE3A0'E004        MOV      LR,#+4
    378          			break;
    379          		default:
    380          			return -1;
    381          		}
    382          
    383          		mode_bits = cmd->num_mode_cycles * mode_cycle_bits;
    384          		switch (mode_bits) {
   \                     ??qspi_exec_21:
   \      0x1A4   0xE16C'0C8E        SMULBB   R12,LR,R12
   \      0x1A8   0xE24C'C001        SUB      R12,R12,#+1
   \      0x1AC   0xE35C'0007        CMP      R12,#+7
   \      0x1B0   0x8A00'0038        BHI      ??qspi_exec_6
   \      0x1B4   0xE7DF'E00C        LDRB     LR,[PC, R12]
   \      0x1B8   0xE08F'F10E        ADD      PC,PC,LR, LSL #+2
   \                     ??qspi_exec_2:
   \      0x1BC   0x02 0x01          DC8      0x2,0x1,0x36,0x32

   \              0x36 0x32
   \      0x1C0   0x36 0x36          DC8      0x36,0x36,0x36,0x34

   \              0x36 0x34
    385          		case 1:
    386          			ifr |= QSPI_IFR_OPTL_OPTION_1BIT;
    387          			break;
    388          
    389          		case 2:
    390          			ifr |= QSPI_IFR_OPTL_OPTION_2BIT;
   \                     ??qspi_exec_24:
   \      0x1C4   0xE383'3F40        ORR      R3,R3,#0x100
    391          			break;
    392          
    393          		case 4:
    394          			ifr |= QSPI_IFR_OPTL_OPTION_4BIT;
    395          			break;
    396          
    397          		case 8:
    398          			ifr |= QSPI_IFR_OPTL_OPTION_8BIT;
    399          			break;
    400          
    401          		default:
    402          			return -1;
    403          		}
    404          	}
    405          
    406          	/* Set the number of dummy cycles. */
    407          	if (cmd->num_wait_states)
   \                     ??qspi_exec_19:
   \      0x1C8   0xE5D7'C00B        LDRB     R12,[R7, #+11]
   \      0x1CC   0xE35C'0000        CMP      R12,#+0
    408          		ifr |= QSPI_IFR_NBDUM(cmd->num_wait_states);
   \      0x1D0   0x13A0'E97C        MOVNE    LR,#+2031616
   \      0x1D4   0x100E'C80C        ANDNE    R12,LR,R12, LSL #+16
   \      0x1D8   0x118C'3003        ORRNE    R3,R12,R3
    409          
    410          	/* Set data enable. */
    411          	if (enable_data) {
   \      0x1DC   0xE1B0'C000        MOVS     R12,R0
   \      0x1E0   0x0A00'0006        BEQ      ??qspi_exec_25
    412          		ifr |= QSPI_IFR_DATAEN;
    413          
    414          		/* Special case for Continuous Read Mode. */
    415          		if (!cmd->tx_data && !cmd->rx_data)
   \      0x1E4   0xE597'C018        LDR      R12,[R7, #+24]
   \      0x1E8   0xE383'3080        ORR      R3,R3,#0x80
   \      0x1EC   0xE35C'0000        CMP      R12,#+0
   \      0x1F0   0x1A00'0002        BNE      ??qspi_exec_25
   \      0x1F4   0xE597'E01C        LDR      LR,[R7, #+28]
   \      0x1F8   0xE35E'0000        CMP      LR,#+0
    416          			ifr |= QSPI_IFR_CRM;
   \      0x1FC   0x0383'3C40        ORREQ    R3,R3,#0x4000
    417          	}
    418          
    419          	/* Clear pending interrupts. */
    420          	(void)qspi->QSPI_SR;
   \                     ??qspi_exec_25:
   \      0x200   0xE594'C010        LDR      R12,[R4, #+16]
    421          
    422          #ifdef QSPI_VERBOSE_DEBUG
    423          	{
    424          		int len;
    425          
    426          		if (cmd->inst)
    427          			printf("opcode=%02Xh ", cmd->inst);
    428          
    429          		if (cmd->addr_len)
    430          			printf("address=0x%08X (%d-bytes) ", (unsigned int)cmd->addr, cmd->addr_len);
    431          
    432          		if (cmd->num_mode_cycles)
    433          			printf("mode=%u (%02Xh) ", cmd->num_mode_cycles, cmd->mode);
    434          
    435          		if (cmd->num_wait_states)
    436          			printf("dummy=%u ", cmd->num_wait_states);
    437          
    438          		len = cmd->data_len;
    439          		if (len > 4)
    440          			len = 4;
    441          		if (len) {
    442          			if (cmd->rx_data)
    443          				goto next;
    444          
    445          			if (cmd->tx_data) {
    446          				int i;
    447          				printf("TX (%u bytes): ", (unsigned int)cmd->data_len);
    448          				for (i = 0; i < len; i++)
    449          					printf("0x%02X ", ((uint8_t *)cmd->tx_data)[i]);
    450          			}
    451          
    452          			if (len != cmd->data_len)
    453          				printf("... ");
    454          		}
    455          
    456          		printf("\r\n");
    457          	}
    458          next:
    459          #endif /* QSPI_VERBOSE_DEBUG */
    460          
    461          
    462          	/* Set QSPI Instruction Frame registers. */
    463          	qspi->QSPI_IAR = iar;
   \      0x204   0xE584'1030        STR      R1,[R4, #+48]
    464          #ifdef QSPI_RICR_RDINST
    465          	if (icr_write)
    466          		qspi->QSPI_WICR = icr;
    467          	else
    468          		qspi->QSPI_RICR = icr;
    469          #else
    470          	qspi->QSPI_ICR = icr;
    471          #endif
    472          	qspi->QSPI_IFR = ifr;
    473          
    474          	/* Skip to the final steps if there is no data. */
    475          	if (!enable_data)
   \      0x208   0xE350'0000        CMP      R0,#+0
   \      0x20C   0xE584'2034        STR      R2,[R4, #+52]
   \      0x210   0xE584'3038        STR      R3,[R4, #+56]
   \      0x214   0x0A00'003F        BEQ      ??qspi_exec_26
    476          		goto no_data;
    477          
    478          	/* Dummy read of QSPI_IFR to synchronize APB and AHB accesses. */
    479          	(void)qspi->QSPI_IFR;
   \      0x218   0xE594'0038        LDR      R0,[R4, #+56]
    480          
    481          #ifdef CONFIG_HAVE_QSPI_DMA
    482          	if ((((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_WRITE) &&
    483                  //if(((cmd->flags == QSPI_IFR_TFRTYP_TRSFR_WRITE_MEMORY ) &&
    484          	     IS_CACHE_ALIGNED(cmd->tx_data) &&
    485          	     IS_CACHE_ALIGNED(cmd->data_len)) ||
    486          	    (((cmd->flags & SFLASH_TYPE_MASK) == SFLASH_TYPE_READ) &&
    487                     //((cmd->flags == QSPI_IFR_TFRTYP_TRSFR_READ_MEMORY ) &&
    488          	     IS_CACHE_ALIGNED(cmd->rx_data) &&
    489          	     IS_CACHE_ALIGNED(cmd->data_len)))
   \      0x21C   0xE597'0004        LDR      R0,[R7, #+4]
   \      0x220   0xE200'1007        AND      R1,R0,#0x7
   \      0x224   0xE351'0001        CMP      R1,#+1
   \      0x228   0x1A00'0005        BNE      ??qspi_exec_27
   \      0x22C   0xE5D7'2018        LDRB     R2,[R7, #+24]
   \      0x230   0xE312'001F        TST      R2,#0x1F
   \      0x234   0x1A00'0002        BNE      ??qspi_exec_27
   \      0x238   0xE5D7'1014        LDRB     R1,[R7, #+20]
   \      0x23C   0xE311'001F        TST      R1,#0x1F
   \      0x240   0x0A00'0007        BEQ      ??qspi_exec_28
   \                     ??qspi_exec_27:
   \      0x244   0xE310'0007        TST      R0,#0x7
   \      0x248   0x1A00'0006        BNE      ??qspi_exec_29
   \      0x24C   0xE5D7'001C        LDRB     R0,[R7, #+28]
   \      0x250   0xE310'001F        TST      R0,#0x1F
   \      0x254   0x1A00'0003        BNE      ??qspi_exec_29
   \      0x258   0xE5D7'1014        LDRB     R1,[R7, #+20]
   \      0x25C   0xE311'001F        TST      R1,#0x1F
   \      0x260   0x1A00'0000        BNE      ??qspi_exec_29
    490          		use_dma = true;
   \                     ??qspi_exec_28:
   \      0x264   0xE3A0'8001        MOV      R8,#+1
    491          #endif
    492          
    493          	/* Stop here for Continuous Read. */
    494          	if (cmd->tx_data) {
   \                     ??qspi_exec_29:
   \      0x268   0xE597'0018        LDR      R0,[R7, #+24]
   \      0x26C   0xE350'0000        CMP      R0,#+0
   \      0x270   0x0A00'0015        BEQ      ??qspi_exec_30
    495          		/* Write data */
    496          #ifdef CONFIG_HAVE_AESB
    497          		if (cmd->use_aesb)
   \      0x274   0xE5D7'1024        LDRB     R1,[R7, #+36]
   \      0x278   0xE351'0000        CMP      R1,#+0
    498          			ptr = priv->qspi.mem_aesb;
   \      0x27C   0x1596'9008        LDRNE    R9,[R6, #+8]
    499          		else
    500          #endif
    501          			ptr = priv->qspi.mem;
   \      0x280   0x0596'9004        LDREQ    R9,[R6, #+4]
   \      0x284   0xEA00'0005        B        ??qspi_exec_31
   \                     ??qspi_exec_32:
   \      0x288   0xE383'3F80        ORR      R3,R3,#0x200
   \      0x28C   0xEAFF'FFCD        B        ??qspi_exec_19
   \                     ??qspi_exec_33:
   \      0x290   0xE383'3FC0        ORR      R3,R3,#0x300
   \      0x294   0xEAFF'FFCB        B        ??qspi_exec_19
   \                     ??qspi_exec_6:
   \      0x298   0xE1E0'0008        MVN      R0,R8
   \      0x29C   0x....'....        B        ?Subroutine3
    502          
    503          #ifdef CONFIG_HAVE_QSPI_DMA
    504          		if (use_dma)
   \                     ??qspi_exec_31:
   \      0x2A0   0xE1B0'1008        MOVS     R1,R8
   \      0x2A4   0x0A00'0001        BEQ      ??qspi_exec_34
    505          			cache_clean_region(cmd->tx_data, cmd->data_len);
   \      0x2A8   0xE597'1014        LDR      R1,[R7, #+20]
   \      0x2AC   0x....'....        BL       cache_clean_region
    506          #endif
    507          		qspi_memcpy(priv, ptr + offset, cmd->tx_data, cmd->data_len, use_dma);
   \                     ??qspi_exec_34:
   \      0x2B0   0xE58D'8000        STR      R8,[SP, #+0]
   \      0x2B4   0xE597'3014        LDR      R3,[R7, #+20]
   \      0x2B8   0xE597'2018        LDR      R2,[R7, #+24]
   \      0x2BC   0xE089'1005        ADD      R1,R9,R5
   \      0x2C0   0xE1A0'0006        MOV      R0,R6
   \      0x2C4   0x....'....        BL       qspi_memcpy
   \      0x2C8   0xEA00'0010        B        ??qspi_exec_35
    508          	} else if (cmd->rx_data) {
   \                     ??qspi_exec_30:
   \      0x2CC   0xE597'101C        LDR      R1,[R7, #+28]
   \      0x2D0   0xE351'0000        CMP      R1,#+0
   \      0x2D4   0x0A00'0022        BEQ      ??qspi_exec_36
    509          		/* Read data */
    510          #ifdef CONFIG_HAVE_AESB
    511          		if (cmd->use_aesb)
   \      0x2D8   0xE5D7'0024        LDRB     R0,[R7, #+36]
   \      0x2DC   0xE350'0000        CMP      R0,#+0
    512          			ptr = priv->qspi.mem_aesb;
   \      0x2E0   0x1596'0008        LDRNE    R0,[R6, #+8]
    513          		else
    514          #endif
    515          			ptr = priv->qspi.mem;
   \      0x2E4   0x0596'0004        LDREQ    R0,[R6, #+4]
    516          
    517          		qspi_memcpy(priv, cmd->rx_data, ptr + offset, cmd->data_len, use_dma);
   \      0x2E8   0xE58D'8000        STR      R8,[SP, #+0]
   \      0x2EC   0xE597'3014        LDR      R3,[R7, #+20]
   \      0x2F0   0xE080'2005        ADD      R2,R0,R5
   \      0x2F4   0xE1A0'0006        MOV      R0,R6
   \      0x2F8   0x....'....        BL       qspi_memcpy
    518          #ifdef CONFIG_HAVE_QSPI_DMA
    519          		if (use_dma)
   \      0x2FC   0xE358'0000        CMP      R8,#+0
   \      0x300   0x0A00'0002        BEQ      ??qspi_exec_35
    520          			cache_invalidate_region(cmd->rx_data, cmd->data_len);
   \      0x304   0xE597'1014        LDR      R1,[R7, #+20]
   \      0x308   0xE597'001C        LDR      R0,[R7, #+28]
   \      0x30C   0x....'....        BL       cache_invalidate_region
    521          #endif
    522          	} else {
    523          		/* Stop here for continuous read */
    524          		return 0;
    525          	}
    526          
    527          	/* Release the chip-select. */
    528          	qspi->QSPI_CR = QSPI_CR_LASTXFER;
   \                     ??qspi_exec_35:
   \      0x310   0xE3A0'0740        MOV      R0,#+16777216
   \      0x314   0xE584'0000        STR      R0,[R4, #+0]
    529          
    530          no_data:
    531          	{
    532          		/* Wait for INSTRuction End */
    533          		struct _timeout timeout;
    534          		timer_start_timeout(&timeout, cmd->timeout);
   \                     ??qspi_exec_26:
   \      0x318   0xE597'2020        LDR      R2,[R7, #+32]
   \      0x31C   0xE3A0'3000        MOV      R3,#+0
   \      0x320   0xE1A0'000D        MOV      R0,SP
   \      0x324   0x....'....        BL       timer_start_timeout
    535          		while (!(qspi->QSPI_SR & QSPI_SR_INSTRE)) {
   \                     ??qspi_exec_37:
   \      0x328   0xE594'0010        LDR      R0,[R4, #+16]
   \      0x32C   0xE310'0E40        TST      R0,#0x400
   \      0x330   0x1A00'000B        BNE      ??qspi_exec_36
    536          			if (timer_timeout_reached(&timeout)) {
   \      0x334   0xE1A0'000D        MOV      R0,SP
   \      0x338   0x....'....        BL       timer_timeout_reached
   \      0x33C   0xE350'0000        CMP      R0,#+0
   \      0x340   0x0AFF'FFF8        BEQ      ??qspi_exec_37
    537          				trace_debug("qspi_exec timeout reached\r\n");
   \      0x344   0x....'....        LDR      R0,??DataTable3_1
   \      0x348   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x34C   0xE351'0005        CMP      R1,#+5
   \      0x350   0x3A00'0001        BCC      ??qspi_exec_38
   \      0x354   0x....'....        LDR      R0,??DataTable3_7
   \      0x358   0x....'....        BL       printf
    538          				return -ETIMEDOUT;
   \                     ??qspi_exec_38:
   \      0x35C   0xE3E0'004C        MVN      R0,#+76
   \      0x360   0x....'....        B        ?Subroutine3
    539          			}
    540          		}
    541          	}
    542          
    543          #ifdef QSPI_VERBOSE_DEBUG
    544          	{
    545          		uint32_t i, len;
    546          
    547          		len = cmd->data_len;
    548          		if (len > 4)
    549          			len = 4;
    550          		if (len && cmd->rx_data) {
    551          			printf("RX (%u bytes): ", (unsigned int)cmd->data_len);
    552          			for (i = 0; i < len; i++)
    553          				printf("0x%02X ", ((uint8_t *)cmd->rx_data)[i]);
    554          
    555          			if (len != cmd->data_len)
    556          				printf("... ");
    557          
    558          			printf("\r\n");
    559          		}
    560          	}
    561          #endif /* QSPI_VERBOSE_DEBUG */
    562          
    563          	return 0;
   \                     ??qspi_exec_36:
   \      0x364   0xE3A0'0000        MOV      R0,#+0
   \      0x368                      REQUIRE ?Subroutine3
   \      0x368                      ;; // Fall through to label ?Subroutine3
    564          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine3:
   \        0x0   0xE28D'D010        ADD      SP,SP,#+16
   \        0x4   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    565          

   \                                 In section SOFTPACK, align 4, keep-with-next
    566          static const struct spi_ops qspi_ops = {
   \                     qspi_ops:
   \        0x0   0x....'....        DC32 qspi_init, qspi_cleanup, qspi_set_freq, qspi_set_mode, qspi_exec

   \              0x....'....  

   \              0x....'....  

   \              0x....'....  

   \              0x....'....
    567          	.init		= qspi_init,
    568          	.cleanup	= qspi_cleanup,
    569          	.set_freq	= qspi_set_freq,
    570          	.set_mode	= qspi_set_mode,
    571          	.exec		= qspi_exec,
    572          };
    573          
    574          /*----------------------------------------------------------------------------
    575           *        EXPORTED FUNCTIONS
    576           *----------------------------------------------------------------------------*/
    577          

   \                                 In section SOFTPACK, align 4, keep-with-next
    578          void qspi_configure(struct spi_flash *flash, const struct spi_flash_cfg *cfg)
    579          {
   \                     qspi_configure:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'5001        MOV      R5,R1
   \        0x8   0xE1A0'4000        MOV      R4,R0
    580          	flash->priv.qspi.addr = cfg->qspi.addr;
   \        0xC   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x10   0xE584'0000        STR      R0,[R4, #+0]
    581          	flash->priv.qspi.mem = get_qspi_mem_from_addr(cfg->qspi.addr);
   \       0x14   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x18   0x....'....        BL       get_qspi_mem_from_addr
   \       0x1C   0xE584'0004        STR      R0,[R4, #+4]
    582          #ifdef CONFIG_HAVE_AESB
    583          	flash->priv.qspi.mem_aesb = get_qspi_aesb_mem_from_addr(cfg->qspi.addr);
   \       0x20   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x24   0x....'....        BL       get_qspi_aesb_mem_from_addr
   \       0x28   0xE584'0008        STR      R0,[R4, #+8]
    584          #endif
    585          
    586          	flash->hwcaps.mask = (SFLASH_HWCAPS_READ_MASK | SFLASH_HWCAPS_PP_MASK);
   \       0x2C   0xE3A0'00FF        MOV      R0,#+255
    587          
    588          	flash->ops = &qspi_ops;
   \       0x30   0x....'....        ADR      R1,qspi_ops
   \       0x34   0xE380'0AF0        ORR      R0,R0,#0xF0000
   \       0x38   0xE584'10A0        STR      R1,[R4, #+160]
   \       0x3C   0xE584'0018        STR      R0,[R4, #+24]
    589          }
   \       0x40   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    590          

   \                                 In section SOFTPACK, align 4, keep-with-next
    591          int qspi_xip(struct spi_flash *flash, void **mem)
    592          {
   \                     qspi_xip:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    593          	int ret;
    594          
    595          	if (flash->enable_0_4_4) {
   \        0xC   0xE594'20B4        LDR      R2,[R4, #+180]
   \       0x10   0xE352'0000        CMP      R2,#+0
   \       0x14   0x0A00'0003        BEQ      ??qspi_xip_0
    596          		ret = flash->enable_0_4_4(flash, true);
   \       0x18   0xE3A0'1001        MOV      R1,#+1
   \       0x1C   0xE12F'FF32        BLX      R2
    597          		if (ret)
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0008        BNE      ??qspi_xip_1
    598          			return ret;
    599          	}
    600          
    601          	*mem = flash->priv.qspi.mem;
   \                     ??qspi_xip_0:
   \       0x28   0xE594'0004        LDR      R0,[R4, #+4]
    602          	return spi_flash_read(flash, 0, NULL, 0);
   \       0x2C   0xE3A0'3000        MOV      R3,#+0
   \       0x30   0xE3A0'2000        MOV      R2,#+0
   \       0x34   0xE3A0'1000        MOV      R1,#+0
   \       0x38   0xE585'0000        STR      R0,[R5, #+0]
   \       0x3C   0xE1A0'0004        MOV      R0,R4
   \       0x40   0xE28D'D004        ADD      SP,SP,#+4
   \       0x44   0xE8BD'4030        POP      {R4,R5,LR}
   \       0x48   0x....'....        B        spi_flash_read   ;; tailcall
   \                     ??qspi_xip_1:
   \       0x4C   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    603          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     `qspi_memcpy{1}{2}::dma_cfg`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x5153'5000        DC32     0x51535000

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x0001'0101        DC32     0x10101

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x0002'0202        DC32     0x20202

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x46          DC8 "-F- Couldn't start xDMA transfer\012\015"

   \              0x2D 0x20    

   \              0x43 0x6F    

   \              0x75 0x6C    

   \              0x64 0x6E    

   \              0x27 0x74    

   \              0x20 0x73    

   \              0x74 0x61    

   \              0x72 0x74    

   \              0x20 0x78    

   \              0x44 0x4D    

   \              0x41 0x20    

   \              0x74 0x72    

   \              0x61 0x6E    

   \              0x73 0x66    

   \              0x65 0x72    

   \              0x0A 0x0D    

   \              0x00
   \       0x23   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x46          DC8 "-F- Couldn't allocate XDMA channel\012\015"

   \              0x2D 0x20    

   \              0x43 0x6F    

   \              0x75 0x6C    

   \              0x64 0x6E    

   \              0x27 0x74    

   \              0x20 0x61    

   \              0x6C 0x6C    

   \              0x6F 0x63    

   \              0x61 0x74    

   \              0x65 0x20    

   \              0x58 0x44    

   \              0x4D 0x41    

   \              0x20 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x0A 0x0D    

   \              0x00
   \       0x25   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x73, 0x70

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x73 0x70
   \       0x40   0x69 0x5C          DC8 0x69, 0x5C, 0x71, 0x73, 0x70, 0x69, 0x2E, 0x63

   \              0x71 0x73    

   \              0x70 0x69    

   \              0x2E 0x63
   \       0x48   0x3A 0x35          DC8 0x3A, 0x35, 0x33, 0x37, 0x20, 0x71, 0x73, 0x70

   \              0x33 0x37    

   \              0x20 0x71    

   \              0x73 0x70
   \       0x50   0x69 0x5F          DC8 0x69, 0x5F, 0x65, 0x78, 0x65, 0x63, 0x20, 0x74

   \              0x65 0x78    

   \              0x65 0x63    

   \              0x20 0x74
   \       0x58   0x69 0x6D          DC8 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x72

   \              0x65 0x6F    

   \              0x75 0x74    

   \              0x20 0x72
   \       0x60   0x65 0x61          DC8 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x0D, 0x0A

   \              0x63 0x68    

   \              0x65 0x64    

   \              0x0D 0x0A
   \       0x68   0x00               DC8 0
   \       0x69   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   qspi_cleanup
      16   qspi_configure
        16   -> get_qspi_aesb_mem_from_addr
        16   -> get_qspi_mem_from_addr
      48   qspi_exec
        48   -> cache_clean_region
        48   -> cache_invalidate_region
        48   -> printf
        48   -> qspi_memcpy
        48   -> timer_start_timeout
        48   -> timer_timeout_reached
      16   qspi_init
        16   -> dma_allocate_channel
        16   -> get_qspi_id_from_addr
        16   -> pmc_configure_peripheral
        16   -> pmc_enable_system_clock
        16   -> pmc_has_system_clock
        16   -> printf
      24   qspi_memcpy
        24   -> dma_configure_transfer
        24   -> dma_is_transfer_done
        24   -> dma_poll
        24   -> dma_reset_channel
        24   -> dma_start_transfer
        24   -> printf
      16   qspi_set_freq
        16   -> get_qspi_id_from_addr
        16   -> pmc_get_peripheral_clock
        16 __aeabi_uidiv
       0   qspi_set_mode
      16   qspi_xip
        16   -- Indirect call
         0   -> spi_flash_read


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
      36  ?_0
      40  ?_1
     108  ?_2
      12  dma_cfg
      20  qspi_cleanup
      68  qspi_configure
     872  qspi_exec
     152  qspi_init
     172  qspi_memcpy
      20  qspi_ops
      84  qspi_set_freq
      88  qspi_set_mode
      80  qspi_xip

 
    12 bytes in section .data
   184 bytes in section .rodata
 1'620 bytes in section SOFTPACK
 
 1'620 bytes of CODE  memory
   184 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
