###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         22/Oct/2020  19:15:18
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWFDC6.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_QSPI -D CONFIG_HAVE_QSPI_DMA -D CONFIG_HAVE_NFC -D
#        CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D
#        CONFIG_HAVE_GMAC_QUEUES -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_MPDDRC_DDR3 -D CONFIG_HAVE_MPDDRC_LPDDR3 -D
#        CONFIG_HAVE_ADC_SETTLING_TIME -D CONFIG_HAVE_ADC_DIFF_INPUT -D
#        CONFIG_HAVE_ADC_SEQ_R2 -D CONFIG_HAVE_PMC_FAST_STARTUP -D
#        CONFIG_HAVE_PMC_GENERATED_CLOCKS -D CONFIG_HAVE_PMC_AUDIO_CLOCK -D
#        CONFIG_HAVE_PMC_PLLADIV2 -D CONFIG_HAVE_PMC_H32MXDIV -D
#        CONFIG_HAVE_PMC_UPLL_BIAS -D CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA
#        -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
#        -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D CONFIG_HAVE_PWMC_CMP_UNIT -D
#        CONFIG_HAVE_PWMC_SYNC_MODE -D CONFIG_HAVE_PWMC_OOV -D
#        CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP -D
#        CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D CONFIG_HAVE_SFRBU
#        -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_AESB -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\List\bus.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_qspi_aesb\build\sama5d2-xplained\sram\Obj\bus.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\bus.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *         Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <string.h>
     35          
     36          #include "callback.h"
     37          #include "dma/dma.h"
     38          #include "errno.h"
     39          #include "peripherals/bus.h"
     40          #ifdef CONFIG_HAVE_BUS_SPI
     41          #include "spi/spid.h"
     42          #endif
     43          #ifdef CONFIG_HAVE_BUS_I2C
     44          #include "i2c/twid.h"
     45          #endif
     46          #include "timer.h"
     47          #include "trace.h"
     48          
     49          /*----------------------------------------------------------------------------
     50           *         Definitions
     51           *----------------------------------------------------------------------------*/
     52          
     53          #define O_BLOCK (0x01)
     54          
     55          struct _bus_desc {
     56          	enum _bus_type type;
     57          	union {
     58          		uint32_t dummy;
     59          #ifdef CONFIG_HAVE_SPI_BUS
     60          		struct _spi_desc spid;
     61          #endif
     62          #ifdef CONFIG_HAVE_I2C_BUS
     63          		struct _twi_desc twid;
     64          #endif
     65          	} iface;
     66          
     67          	enum _bus_transfer_mode transfer_mode;
     68          
     69          	uint32_t options;
     70          
     71          	uint32_t timeout;
     72          
     73          	struct _callback callback;
     74          
     75          	struct {
     76          		mutex_t lock;
     77          		mutex_t transaction;
     78          	} mutex;
     79          };
     80          
     81          /*----------------------------------------------------------------------------
     82           *         Local variables
     83           *----------------------------------------------------------------------------*/
     84          

   \                                 In section .bss, align 4
     85          static struct _bus_desc _bus[BUS_COUNT];
   \                     _bus:
   \        0x0                      DS8 1'196
     86          
     87          /*----------------------------------------------------------------------------
     88           *         Local functions
     89           *----------------------------------------------------------------------------*/
     90          

   \                                 In section SOFTPACK, align 4, keep-with-next
     91          static int _bus_callback(void* arg, void* arg2)
     92          {
   \                     _bus_callback:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
     93          	uint32_t bus_id = (uint32_t)arg;
     94          
     95          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0x3A00'0001        BCC      ??_bus_callback_0
     96          		return -ENODEV;
   \        0xC   0xE3E0'002B        MVN      R0,#+43
   \       0x10   0xE8BD'8010        POP      {R4,PC}
     97          
     98          	mutex_unlock(&_bus[bus_id].mutex.lock);
   \                     ??_bus_callback_0:
   \       0x14   0xE3A0'205C        MOV      R2,#+92
   \       0x18   0x....'....        LDR      R1,??DataTable10
   \       0x1C   0xE000'0092        MUL      R0,R2,R0
   \       0x20   0xE081'4000        ADD      R4,R1,R0
   \       0x24   0xE284'0054        ADD      R0,R4,#+84
   \       0x28   0x....'....        BL       mutex_unlock
     99          
    100          	return callback_call(&_bus[bus_id].callback, NULL);
   \       0x2C   0xE284'004C        ADD      R0,R4,#+76
   \       0x30   0xE3A0'1000        MOV      R1,#+0
   \       0x34   0xE8BD'4010        POP      {R4,LR}
   \       0x38   0x....'....        B        callback_call    ;; tailcall
    101          }
    102          
    103          static int _bus_fifo_enable(uint8_t bus_id)
    104          {
    105          	int err = 0;
    106          
    107          	if (bus_id >= BUS_COUNT)
    108          		return -ENODEV;
    109          
    110          	switch (_bus[bus_id].type) {
    111          #ifdef CONFIG_HAVE_SPI_BUS
    112          	case BUS_TYPE_SPI:
    113          #ifdef CONFIG_HAVE_SPI_FIFO
    114          		_bus[bus_id].iface.spid.use_fifo = true;
    115          #endif
    116          		break;
    117          #endif
    118          #ifdef CONFIG_HAVE_I2C_BUS
    119          	case BUS_TYPE_I2C:
    120          #ifdef CONFIG_HAVE_TWI_FIFO
    121          		_bus[bus_id].iface.twid.use_fifo = true;
    122          #endif
    123          		break;
    124          #endif
    125          	default:
    126          		err = -EINVAL;
    127          		break;
    128          	}
    129          
    130          	return err;
    131          }
    132          
    133          static int _bus_fifo_disable(uint8_t bus_id)
    134          {
    135          	int err = 0;
    136          
    137          	if (bus_id >= BUS_COUNT)
    138          		return -ENODEV;
    139          
    140          	switch (_bus[bus_id].type) {
    141          #ifdef CONFIG_HAVE_SPI_BUS
    142          	case BUS_TYPE_SPI:
    143          #ifdef CONFIG_HAVE_SPI_FIFO
    144          		_bus[bus_id].iface.spid.use_fifo = false;
    145          #endif
    146          		break;
    147          #endif
    148          #ifdef CONFIG_HAVE_I2C_BUS
    149          	case BUS_TYPE_I2C:
    150          #ifdef CONFIG_HAVE_TWI_FIFO
    151          		_bus[bus_id].iface.twid.use_fifo = false;
    152          #endif
    153          		break;
    154          #endif
    155          	default:
    156          		err = -EINVAL;
    157          		break;
    158          	}
    159          
    160          	return err;
    161          }
    162          
    163          static int _bus_fifo_is_enabled(uint8_t bus_id)
    164          {
    165          	int err = 0;
    166          
    167          	if (bus_id >= BUS_COUNT)
    168          		return -ENODEV;
    169          
    170          	switch (_bus[bus_id].type) {
    171          #ifdef CONFIG_HAVE_SPI_BUS
    172          	case BUS_TYPE_SPI:
    173          #ifdef CONFIG_HAVE_SPI_FIFO
    174          		err = _bus[bus_id].iface.spid.use_fifo;
    175          #endif
    176          		break;
    177          #endif
    178          #ifdef CONFIG_HAVE_I2C_BUS
    179          	case BUS_TYPE_I2C:
    180          #ifdef CONFIG_HAVE_TWI_FIFO
    181          		err = _bus[bus_id].iface.twid.use_fifo;
    182          #endif
    183          		break;
    184          #endif
    185          	default:
    186          		err = -EINVAL;
    187          		break;
    188          	}
    189          
    190          	return err;
    191          }
    192          
    193          static int _bus_enable(uint8_t bus_id)
    194          {
    195          	int err = 0;
    196          
    197          	if (bus_id >= BUS_COUNT)
    198          		return -ENODEV;
    199          
    200          	switch (_bus[bus_id].type) {
    201          #ifdef CONFIG_HAVE_SPI_BUS
    202          	case BUS_TYPE_SPI:
    203          		break;
    204          #endif
    205          #ifdef CONFIG_HAVE_I2C_BUS
    206          	case BUS_TYPE_I2C:
    207          		break;
    208          #endif
    209          	default:
    210          		err = -EINVAL;
    211          		break;
    212          	}
    213          
    214          	return err;
    215          }
    216          
    217          static int _bus_disable(uint8_t bus_id)
    218          {
    219          	int err = 0;
    220          
    221          	if (bus_id >= BUS_COUNT)
    222          		return -ENODEV;
    223          
    224          	switch (_bus[bus_id].type) {
    225          #ifdef CONFIG_HAVE_SPI_BUS
    226          	case BUS_TYPE_SPI:
    227          		break;
    228          #endif
    229          #ifdef CONFIG_HAVE_I2C_BUS
    230          	case BUS_TYPE_I2C:
    231          		break;
    232          #endif
    233          	default:
    234          		err = -EINVAL;
    235          		break;
    236          	}
    237          
    238          	return err;
    239          }
    240          
    241          static int _bus_get_transfer_mode(uint8_t bus_id)
    242          {
    243          	int err = 0;
    244          
    245          	if (bus_id >= BUS_COUNT)
    246          		return -ENODEV;
    247          
    248          	switch (_bus[bus_id].type) {
    249          #ifdef CONFIG_HAVE_SPI_BUS
    250          	case BUS_TYPE_SPI:
    251          		return _bus[bus_id].iface.spid.transfer_mode;
    252          #endif
    253          #ifdef CONFIG_HAVE_I2C_BUS
    254          	case BUS_TYPE_I2C:
    255          		return _bus[bus_id].iface.twid.transfer_mode;
    256          #endif
    257          	default:
    258          		err = -EINVAL;
    259          		break;
    260          	}
    261          
    262          	return err;
    263          }
    264          
    265          static int _bus_set_transfer_mode(uint8_t bus_id, enum _bus_transfer_mode mode)
    266          {
    267          	int err = 0;
    268          
    269          	if (bus_id >= BUS_COUNT)
    270          		return -ENODEV;
    271          
    272          	switch (_bus[bus_id].type) {
    273          #ifdef CONFIG_HAVE_SPI_BUS
    274          	case BUS_TYPE_SPI:
    275          		_bus[bus_id].iface.spid.transfer_mode = mode;
    276          		break;
    277          #endif
    278          #ifdef CONFIG_HAVE_I2C_BUS
    279          	case BUS_TYPE_I2C:
    280          		_bus[bus_id].iface.twid.transfer_mode = mode;
    281          		break;
    282          #endif
    283          	default:
    284          		err = -EINVAL;
    285          		break;
    286          	}
    287          
    288          	return err;
    289          }
    290          
    291          /*----------------------------------------------------------------------------
    292           *         Exported functions
    293           *----------------------------------------------------------------------------*/
    294          

   \                                 In section SOFTPACK, align 4, keep-with-next
    295          int bus_configure(uint8_t bus_id, const struct _bus_iface* iface)
    296          {
   \                     bus_configure:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
    297          	int err = 0;
    298          
    299          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'6001        MOV      R6,R1
   \       0x10   0xE3A0'5000        MOV      R5,#+0
   \       0x14   0xDA00'0001        BLE      ??bus_configure_0
    300          		return -ENODEV;
   \       0x18   0xE3E0'002B        MVN      R0,#+43
   \       0x1C   0xE8BD'83F2        POP      {R1,R4-R9,PC}
    301          
    302          	memset(&_bus[bus_id], 0, sizeof(_bus[bus_id]));
   \                     ??bus_configure_0:
   \       0x20   0xE3A0'105C        MOV      R1,#+92
   \       0x24   0x....'....        LDR      R8,??DataTable10
   \       0x28   0xE167'0081        SMULBB   R7,R1,R0
   \       0x2C   0xE088'9007        ADD      R9,R8,R7
   \       0x30   0xE1A0'0009        MOV      R0,R9
   \       0x34   0x....'....        BL       __aeabi_memclr
    303          	_bus[bus_id].transfer_mode = iface->transfer_mode;
   \       0x38   0xE5D6'0008        LDRB     R0,[R6, #+8]
    304          	_bus[bus_id].options = O_BLOCK;
   \       0x3C   0xE3A0'1001        MOV      R1,#+1
   \       0x40   0xE589'1044        STR      R1,[R9, #+68]
   \       0x44   0xE5C9'0040        STRB     R0,[R9, #+64]
    305          	_bus[bus_id].type = iface->type;
   \       0x48   0xE5D6'0000        LDRB     R0,[R6, #+0]
    306          
    307          	switch (_bus[bus_id].type) {
   \       0x4C   0xE350'0002        CMP      R0,#+2
   \       0x50   0xE7C8'0007        STRB     R0,[R8, +R7]
   \       0x54   0x1A00'0009        BNE      ??bus_configure_1
    308          #ifdef CONFIG_HAVE_SPI_BUS
    309          	case BUS_TYPE_SPI:
    310          		_bus[bus_id].iface.spid.addr = iface->spi.hw;
   \       0x58   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x5C   0xE589'0004        STR      R0,[R9, #+4]
    311          		_bus[bus_id].iface.spid.transfer_mode = iface->transfer_mode;
   \       0x60   0xE5D6'1008        LDRB     R1,[R6, #+8]
    312          
    313          		spid_configure(&_bus[bus_id].iface.spid);
   \       0x64   0xE289'0004        ADD      R0,R9,#+4
   \       0x68   0xE589'100C        STR      R1,[R9, #+12]
   \       0x6C   0x....'....        BL       spid_configure
    314          		spid_configure_master(&_bus[bus_id].iface.spid, true);
   \       0x70   0xE3A0'1001        MOV      R1,#+1
   \       0x74   0xE289'0004        ADD      R0,R9,#+4
   \       0x78   0x....'....        BL       spid_configure_master
    315          		break;
   \       0x7C   0xEA00'0000        B        ??bus_configure_2
    316          #endif
    317          #ifdef CONFIG_HAVE_I2C_BUS
    318          	case BUS_TYPE_I2C:
    319          		_bus[bus_id].iface.twid.addr = iface->i2c.hw;
    320          		_bus[bus_id].iface.twid.transfer_mode = iface->transfer_mode;
    321          		_bus[bus_id].iface.twid.freq = iface->i2c.freq;
    322          
    323          		twid_configure(&_bus[bus_id].iface.twid);
    324          		break;
    325          #endif
    326          	default:
    327          		err = -EINVAL;
   \                     ??bus_configure_1:
   \       0x80   0xE3E0'501B        MVN      R5,#+27
    328          		break;
    329          	}
    330          
    331          	bus_ioctl(bus_id, BUS_IOCTL_ENABLE, NULL);
   \                     ??bus_configure_2:
   \       0x84   0xE3A0'2000        MOV      R2,#+0
   \       0x88   0xE3A0'1001        MOV      R1,#+1
   \       0x8C   0xE1A0'0004        MOV      R0,R4
   \       0x90   0x....'....        BL       bus_ioctl
    332          
    333          	return err;
   \       0x94   0xE1A0'0005        MOV      R0,R5
   \       0x98   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    334          }
    335          

   \                                 In section SOFTPACK, align 4, keep-with-next
    336          int bus_configure_slave(uint8_t bus_id, const struct _bus_dev_cfg* cfg)
    337          {
   \                     bus_configure_slave:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    338          	int err = 0;
    339          
    340          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000C        CMP      R0,#+12
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xDA00'0001        BLE      ??bus_configure_slave_0
    341          		return -ENODEV;
   \       0x10   0xE3E0'002B        MVN      R0,#+43
   \       0x14   0xE8BD'8016        POP      {R1,R2,R4,PC}
    342          
    343          	switch (_bus[bus_id].type) {
   \                     ??bus_configure_slave_0:
   \       0x18   0xE3A0'205C        MOV      R2,#+92
   \       0x1C   0x....'....        LDR      R12,??DataTable10
   \       0x20   0xE160'0082        SMULBB   R0,R2,R0
   \       0x24   0xE7DC'3000        LDRB     R3,[R12, +R0]
   \       0x28   0xE353'0002        CMP      R3,#+2
   \       0x2C   0x1A00'000A        BNE      ??bus_configure_slave_1
    344          #ifdef CONFIG_HAVE_SPI_BUS
    345          	case BUS_TYPE_SPI:
    346          		spid_configure_cs(&_bus[bus_id].iface.spid,
    347          		                  cfg->spi_dev.chip_select,
    348          		                  cfg->spi_dev.bitrate,
    349          		                  cfg->spi_dev.delay.bs,
    350          		                  cfg->spi_dev.delay.bct,
    351          		                  cfg->spi_dev.spi_mode);
   \       0x30   0xE5D1'2014        LDRB     R2,[R1, #+20]
   \       0x34   0xE08C'0000        ADD      R0,R12,R0
   \       0x38   0xE280'0004        ADD      R0,R0,#+4
   \       0x3C   0xE58D'2004        STR      R2,[SP, #+4]
   \       0x40   0xE591'E010        LDR      LR,[R1, #+16]
   \       0x44   0xE58D'E000        STR      LR,[SP, #+0]
   \       0x48   0xE591'300C        LDR      R3,[R1, #+12]
   \       0x4C   0xE591'2008        LDR      R2,[R1, #+8]
   \       0x50   0xE5D1'1004        LDRB     R1,[R1, #+4]
   \       0x54   0x....'....        BL       spid_configure_cs
    352          		break;
   \       0x58   0xEA00'0000        B        ??bus_configure_slave_2
    353          #endif
    354          #ifdef CONFIG_HAVE_I2C_BUS
    355          	case BUS_TYPE_I2C:
    356          		break;
    357          #endif
    358          	default:
    359          		err = -EINVAL;
   \                     ??bus_configure_slave_1:
   \       0x5C   0xE3E0'401B        MVN      R4,#+27
    360          		break;
    361          	}
    362          
    363          	return err;
   \                     ??bus_configure_slave_2:
   \       0x60   0xE1A0'0004        MOV      R0,R4
   \       0x64   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
    364          }
    365          

   \                                 In section SOFTPACK, align 4, keep-with-next
    366          int bus_ioctl(uint8_t bus_id, int req, void* arg)
    367          {
    368          	int err = 0;
    369          
    370          	if (bus_id >= BUS_COUNT)
   \                     bus_ioctl:
   \        0x0   0xE350'000C        CMP      R0,#+12
   \        0x4   0xE3A0'3000        MOV      R3,#+0
   \        0x8   0xDA00'0001        BLE      ??bus_ioctl_1
    371          		return -EINVAL;
   \        0xC   0xE3E0'001B        MVN      R0,#+27
   \       0x10   0xE12F'FF1E        BX       LR
    372          
    373          	switch (req) {
   \                     ??bus_ioctl_1:
   \       0x14   0xE241'1001        SUB      R1,R1,#+1
   \       0x18   0xE351'0007        CMP      R1,#+7
   \       0x1C   0x8A00'0049        BHI      ??bus_ioctl_2
   \       0x20   0xE7DF'C001        LDRB     R12,[PC, R1]
   \       0x24   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??bus_ioctl_0:
   \       0x28   0x01 0x08          DC8      0x1,0x8,0xF,0x19

   \              0x0F 0x19
   \       0x2C   0x22 0x31          DC8      0x22,0x31,0x3B,0x49

   \              0x3B 0x49
    374          	case BUS_IOCTL_ENABLE:
    375          		err = _bus_enable(bus_id);
   \                     ??bus_ioctl_3:
   \       0x30   0xE3A0'205C        MOV      R2,#+92
   \       0x34   0x....'....        LDR      R1,??DataTable10
   \       0x38   0xE160'0082        SMULBB   R0,R2,R0
   \       0x3C   0xE7D1'C000        LDRB     R12,[R1, +R0]
   \       0x40   0xE35C'0002        CMP      R12,#+2
   \       0x44   0x0A00'0047        BEQ      ??bus_ioctl_4
   \       0x48   0xEA00'003E        B        ??bus_ioctl_2
    376          		break;
    377          	case BUS_IOCTL_DISABLE:
    378          		err = _bus_disable(bus_id);
   \                     ??bus_ioctl_5:
   \       0x4C   0xE3A0'205C        MOV      R2,#+92
   \       0x50   0x....'....        LDR      R1,??DataTable10
   \       0x54   0xE160'0082        SMULBB   R0,R2,R0
   \       0x58   0xE7D1'C000        LDRB     R12,[R1, +R0]
   \       0x5C   0xE35C'0002        CMP      R12,#+2
   \       0x60   0x0A00'0040        BEQ      ??bus_ioctl_4
   \       0x64   0xEA00'0037        B        ??bus_ioctl_2
    379          		break;
    380          	case BUS_IOCTL_ENABLE_FIFO:
    381          		err = _bus_fifo_enable(bus_id);
   \                     ??bus_ioctl_6:
   \       0x68   0xE3A0'105C        MOV      R1,#+92
   \       0x6C   0xE160'0081        SMULBB   R0,R1,R0
   \       0x70   0x....'....        LDR      R1,??DataTable10
   \       0x74   0xE7D1'2000        LDRB     R2,[R1, +R0]
   \       0x78   0xE352'0002        CMP      R2,#+2
   \       0x7C   0x1A00'0031        BNE      ??bus_ioctl_2
   \       0x80   0xE3A0'C001        MOV      R12,#+1
   \       0x84   0xE081'0000        ADD      R0,R1,R0
   \       0x88   0xE5C0'C014        STRB     R12,[R0, #+20]
   \       0x8C   0xEA00'0035        B        ??bus_ioctl_4
    382          		break;
    383          	case BUS_IOCTL_DISABLE_FIFO:
    384          		err = _bus_fifo_disable(bus_id);
   \                     ??bus_ioctl_7:
   \       0x90   0xE3A0'105C        MOV      R1,#+92
   \       0x94   0xE160'0081        SMULBB   R0,R1,R0
   \       0x98   0x....'....        LDR      R1,??DataTable10
   \       0x9C   0xE7D1'2000        LDRB     R2,[R1, +R0]
   \       0xA0   0xE352'0002        CMP      R2,#+2
   \       0xA4   0x1A00'0027        BNE      ??bus_ioctl_2
   \       0xA8   0xE081'0000        ADD      R0,R1,R0
   \       0xAC   0xE5C0'3014        STRB     R3,[R0, #+20]
   \       0xB0   0xEA00'002C        B        ??bus_ioctl_4
    385          		break;
    386          	case BUS_IOCTL_GET_FIFO_STATUS:
    387          		err = _bus_fifo_is_enabled(bus_id);
   \                     ??bus_ioctl_8:
   \       0xB4   0xE3A0'105C        MOV      R1,#+92
   \       0xB8   0xE160'0081        SMULBB   R0,R1,R0
   \       0xBC   0x....'....        LDR      R1,??DataTable10
   \       0xC0   0xE7D1'3000        LDRB     R3,[R1, +R0]
   \       0xC4   0xE353'0002        CMP      R3,#+2
   \       0xC8   0x1A00'001E        BNE      ??bus_ioctl_2
   \       0xCC   0xE081'0000        ADD      R0,R1,R0
   \       0xD0   0xE5D0'3014        LDRB     R3,[R0, #+20]
    388          		if (err >= 0) {
   \       0xD4   0xE353'0000        CMP      R3,#+0
   \       0xD8   0x4A00'0022        BMI      ??bus_ioctl_4
    389          			*(bool*)arg = err;
   \       0xDC   0x13A0'0001        MOVNE    R0,#+1
    390          			err = 0;
   \       0xE0   0xE3A0'3000        MOV      R3,#+0
   \       0xE4   0x03A0'0000        MOVEQ    R0,#+0
   \       0xE8   0xE5C2'0000        STRB     R0,[R2, #+0]
   \       0xEC   0xEA00'001D        B        ??bus_ioctl_4
    391          		}
    392          		break;
    393          	case BUS_IOCTL_SET_TRANSFER_MODE:
    394          		err = _bus_set_transfer_mode(bus_id, *(enum _bus_transfer_mode*)arg);
   \                     ??bus_ioctl_9:
   \       0xF0   0xE3A0'105C        MOV      R1,#+92
   \       0xF4   0xE160'0081        SMULBB   R0,R1,R0
   \       0xF8   0x....'....        LDR      R1,??DataTable10
   \       0xFC   0xE7D1'C000        LDRB     R12,[R1, +R0]
   \      0x100   0xE35C'0002        CMP      R12,#+2
   \      0x104   0x1A00'000F        BNE      ??bus_ioctl_2
   \      0x108   0xE5D2'2000        LDRB     R2,[R2, #+0]
   \      0x10C   0xE081'0000        ADD      R0,R1,R0
   \      0x110   0xE580'200C        STR      R2,[R0, #+12]
   \      0x114   0xEA00'0013        B        ??bus_ioctl_4
    395          		break;
    396          	case BUS_IOCTL_GET_TRANSFER_MODE:
    397          		err = _bus_get_transfer_mode(bus_id);
   \                     ??bus_ioctl_10:
   \      0x118   0xE3A0'105C        MOV      R1,#+92
   \      0x11C   0xE160'0081        SMULBB   R0,R1,R0
   \      0x120   0x....'....        LDR      R1,??DataTable10
   \      0x124   0xE7D1'3000        LDRB     R3,[R1, +R0]
   \      0x128   0xE353'0002        CMP      R3,#+2
   \      0x12C   0x1A00'0005        BNE      ??bus_ioctl_2
   \      0x130   0xE081'0000        ADD      R0,R1,R0
   \      0x134   0xE590'300C        LDR      R3,[R0, #+12]
    398          		if (err >= 0)
   \      0x138   0xE353'0000        CMP      R3,#+0
   \      0x13C   0x4A00'0009        BMI      ??bus_ioctl_4
    399          			*(enum _bus_transfer_mode*)arg = (enum _bus_transfer_mode)err;
   \      0x140   0xE5C2'3000        STRB     R3,[R2, #+0]
   \      0x144   0xEA00'0007        B        ??bus_ioctl_4
   \                     ??bus_ioctl_2:
   \      0x148   0xE3E0'301B        MVN      R3,#+27
   \      0x14C   0xEA00'0005        B        ??bus_ioctl_4
    400          		break;
    401          	case BUS_IOCTL_SET_TIMEOUT:
    402          		_bus[bus_id].timeout = *(uint32_t*)arg;
   \                     ??bus_ioctl_11:
   \      0x150   0xE592'1000        LDR      R1,[R2, #+0]
   \      0x154   0xE3A0'C05C        MOV      R12,#+92
   \      0x158   0x....'....        LDR      R2,??DataTable10
   \      0x15C   0xE160'008C        SMULBB   R0,R12,R0
   \      0x160   0xE082'0000        ADD      R0,R2,R0
   \      0x164   0xE580'1048        STR      R1,[R0, #+72]
    403          		break;
    404          
    405          	default:
    406          		err = -EINVAL;
    407          		break;
    408          	}
    409          
    410          	return err;
   \                     ??bus_ioctl_4:
   \      0x168   0xE1A0'0003        MOV      R0,R3
   \      0x16C   0xE12F'FF1E        BX       LR               ;; return
    411          }
    412          

   \                                 In section SOFTPACK, align 4, keep-with-next
    413          int bus_transfer(uint8_t bus_id, uint16_t remote, struct _buffer* buf, uint16_t buffers, struct _callback* cb)
    414          {
   \                     bus_transfer:
   \        0x0   0xE92D'47FC        PUSH     {R2-R10,LR}
    415          	int err = 0;
    416          	struct _callback _cb;
    417          
    418          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'5001        MOV      R5,R1
   \       0x10   0xE1A0'6002        MOV      R6,R2
   \       0x14   0xE1A0'7003        MOV      R7,R3
   \       0x18   0xBA00'0001        BLT      ??bus_transfer_0
    419          		return -ENODEV;
   \       0x1C   0xE3E0'002B        MVN      R0,#+43
   \       0x20   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    420          
    421          	if (buffers == 0)
   \                     ??bus_transfer_0:
   \       0x24   0xE1B0'1007        MOVS     R1,R7
   \       0x28   0x1A00'0001        BNE      ??bus_transfer_1
    422          		return 0;
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    423          
    424          	if (!mutex_is_locked(&_bus[bus_id].mutex.transaction)) {
   \                     ??bus_transfer_1:
   \       0x34   0xE3A0'105C        MOV      R1,#+92
   \       0x38   0x....'....        LDR      R10,??DataTable10
   \       0x3C   0xE169'0081        SMULBB   R9,R1,R0
   \       0x40   0xE08A'8009        ADD      R8,R10,R9
   \       0x44   0xE288'0058        ADD      R0,R8,#+88
   \       0x48   0x....'....        BL       mutex_is_locked
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x1A00'0007        BNE      ??bus_transfer_2
    425          		trace_error("bus: no opened transaction on the bus.");
   \       0x54   0x....'....        LDR      R0,??DataTable10_1
   \       0x58   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x5C   0xE351'0001        CMP      R1,#+1
   \       0x60   0x9A00'0001        BLS      ??bus_transfer_3
   \       0x64   0x....'....        LDR      R0,??DataTable10_2
   \       0x68   0x....'....        BL       printf
    426          		return -EBUSY;
   \                     ??bus_transfer_3:
   \       0x6C   0xE3E0'0009        MVN      R0,#+9
   \       0x70   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
    427          	}
    428          	if (!mutex_try_lock(&_bus[bus_id].mutex.lock))
   \                     ??bus_transfer_2:
   \       0x74   0xE288'0054        ADD      R0,R8,#+84
   \       0x78   0x....'....        BL       mutex_try_lock
   \       0x7C   0xE350'0000        CMP      R0,#+0
   \       0x80   0x1A00'0001        BNE      ??bus_transfer_4
    429          		return -EAGAIN;
   \       0x84   0xE3E0'0005        MVN      R0,#+5
   \       0x88   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}
   \                     ??bus_transfer_4:
   \       0x8C   0xE59D'1028        LDR      R1,[SP, #+40]
    430          
    431          	callback_copy(&_bus[bus_id].callback, cb);
   \       0x90   0xE288'004C        ADD      R0,R8,#+76
   \       0x94   0x....'....        BL       callback_copy
    432          
    433          	callback_set(&_cb, _bus_callback, (void*)(uint32_t)bus_id);
   \       0x98   0xE1A0'2004        MOV      R2,R4
   \       0x9C   0x....'....        ADR      R1,_bus_callback
   \       0xA0   0xE1A0'000D        MOV      R0,SP
   \       0xA4   0x....'....        BL       callback_set
    434          	switch (_bus[bus_id].type) {
   \       0xA8   0xE7DA'0009        LDRB     R0,[R10, +R9]
   \       0xAC   0xE350'0002        CMP      R0,#+2
   \       0xB0   0x1A00'000B        BNE      ??bus_transfer_5
    435          #ifdef CONFIG_HAVE_SPI_BUS
    436          	case BUS_TYPE_SPI:
    437          		_bus[bus_id].iface.spid.chip_select = (uint8_t)remote;
   \       0xB4   0xE5C8'5008        STRB     R5,[R8, #+8]
    438          
    439          		err = spid_transfer(&_bus[bus_id].iface.spid, buf, buffers, &_cb);
   \       0xB8   0xE1A0'300D        MOV      R3,SP
   \       0xBC   0xE1A0'2007        MOV      R2,R7
   \       0xC0   0xE1A0'1006        MOV      R1,R6
   \       0xC4   0xE288'0004        ADD      R0,R8,#+4
   \       0xC8   0x....'....        BL       spid_transfer
   \       0xCC   0xE1B0'4000        MOVS     R4,R0
    440          		break;
    441          #endif
    442          #ifdef CONFIG_HAVE_I2C_BUS
    443          	case BUS_TYPE_I2C:
    444          		_bus[bus_id].iface.twid.slave_addr = (uint8_t)remote;
    445          
    446          		err = twid_transfer(&_bus[bus_id].iface.twid, buf, buffers, &_cb);
    447          		break;
    448          #endif
    449          	default:
    450          		err = -EINVAL;
    451          		break;
    452          	}
    453          
    454          	if (err < 0) {
   \       0xD0   0x4A00'0004        BMI      ??bus_transfer_6
    455          		mutex_unlock(&_bus[bus_id].mutex.lock);
    456          		return err;
    457          	}
    458          	if (_bus[bus_id].options & O_BLOCK)
   \       0xD4   0xE5D8'0044        LDRB     R0,[R8, #+68]
   \       0xD8   0xE310'0001        TST      R0,#0x1
   \       0xDC   0x1A00'0008        BNE      ??bus_transfer_7
   \       0xE0   0xEA00'000B        B        ??bus_transfer_8
   \                     ??bus_transfer_5:
   \       0xE4   0xE3E0'401B        MVN      R4,#+27
   \                     ??bus_transfer_6:
   \       0xE8   0xE288'0054        ADD      R0,R8,#+84
   \       0xEC   0x....'....        BL       mutex_unlock
   \       0xF0   0xEA00'0007        B        ??bus_transfer_8
    459          		while (bus_is_busy(bus_id)) {
    460          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \                     ??bus_transfer_9:
   \       0xF4   0xE5D8'0040        LDRB     R0,[R8, #+64]
   \       0xF8   0xE350'0002        CMP      R0,#+2
   \       0xFC   0x1A00'0000        BNE      ??bus_transfer_7
    461          				dma_poll();
   \      0x100   0x....'....        BL       dma_poll
    462          		}
   \                     ??bus_transfer_7:
   \      0x104   0xE288'0054        ADD      R0,R8,#+84
   \      0x108   0x....'....        BL       mutex_is_locked
   \      0x10C   0xE350'0000        CMP      R0,#+0
   \      0x110   0x1AFF'FFF7        BNE      ??bus_transfer_9
    463          
    464          	return err;
   \                     ??bus_transfer_8:
   \      0x114   0xE1A0'0004        MOV      R0,R4
   \      0x118   0xE8BD'87F6        POP      {R1,R2,R4-R10,PC}  ;; return
    465          }
    466          

   \                                 In section SOFTPACK, align 4, keep-with-next
    467          int bus_start_transaction(uint8_t bus_id)
    468          {
   \                     bus_start_transaction:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    469          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xBA00'0000        BLT      ??bus_start_transaction_0
    470          		return -ENODEV;
   \        0xC   0x....'....        B        ?Subroutine2
    471          
    472          	mutex_lock(&_bus[bus_id].mutex.transaction);
   \                     ??bus_start_transaction_0:
   \       0x10   0xE3A0'205C        MOV      R2,#+92
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE160'0082        SMULBB   R0,R2,R0
   \       0x1C   0xE081'0000        ADD      R0,R1,R0
   \       0x20   0xE280'0058        ADD      R0,R0,#+88
   \       0x24   0x....'....        BL       mutex_lock
    473          
    474          	return 0;
   \       0x28   0x....'....        B        ?Subroutine1
    475          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE3E0'002B        MVN      R0,#+43
   \        0x4   0xE8BD'8002        POP      {R1,PC}

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE8BD'8002        POP      {R1,PC}          ;; return
    476          

   \                                 In section SOFTPACK, align 4, keep-with-next
    477          int bus_stop_transaction(uint8_t bus_id)
    478          {
   \                     bus_stop_transaction:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    479          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xBA00'0000        BLT      ??bus_stop_transaction_0
    480          		return -ENODEV;
   \        0xC   0x....'....        B        ?Subroutine2
    481          
    482          	mutex_unlock(&_bus[bus_id].mutex.transaction);
   \                     ??bus_stop_transaction_0:
   \       0x10   0xE3A0'205C        MOV      R2,#+92
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE160'0082        SMULBB   R0,R2,R0
   \       0x1C   0xE081'0000        ADD      R0,R1,R0
   \       0x20   0xE280'0058        ADD      R0,R0,#+88
   \       0x24   0x....'....        BL       mutex_unlock
    483          
    484          	return 0;
   \       0x28   0x....'....        B        ?Subroutine1
    485          }
    486          

   \                                 In section SOFTPACK, align 4, keep-with-next
    487          void bus_wait_transaction(uint8_t bus_id)
    488          {
   \                     bus_wait_transaction:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE3A0'205C        MOV      R2,#+92
   \        0x8   0x....'....        LDR      R1,??DataTable10
   \        0xC   0xE160'0082        SMULBB   R0,R2,R0
   \       0x10   0xE081'4000        ADD      R4,R1,R0
    489          	while (mutex_is_locked(&_bus[bus_id].mutex.transaction));
   \                     ??bus_wait_transaction_0:
   \       0x14   0xE284'0058        ADD      R0,R4,#+88
   \       0x18   0x....'....        BL       mutex_is_locked
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x1AFF'FFFB        BNE      ??bus_wait_transaction_0
    490          }
   \       0x24   0xE8BD'8010        POP      {R4,PC}          ;; return
    491          

   \                                 In section SOFTPACK, align 4, keep-with-next
    492          bool bus_is_busy(uint8_t bus_id)
    493          {
    494          	return mutex_is_locked(&_bus[bus_id].mutex.lock);
   \                     bus_is_busy:
   \        0x0   0xE3A0'205C        MOV      R2,#+92
   \        0x4   0x....'....        LDR      R1,??DataTable10
   \        0x8   0xE160'0082        SMULBB   R0,R2,R0
   \        0xC   0xE081'0000        ADD      R0,R1,R0
   \       0x10   0xE280'0054        ADD      R0,R0,#+84
   \       0x14   0x....'....        B        mutex_is_locked  ;; tailcall
    495          }
    496          

   \                                 In section SOFTPACK, align 4, keep-with-next
    497          int bus_wait_transfer(uint8_t bus_id)
    498          {
   \                     bus_wait_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    499          	if (bus_id >= BUS_COUNT)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0xE24D'D010        SUB      SP,SP,#+16
    500          		return -ENODEV;
   \        0xC   0xA3E0'002B        MVNGE    R0,#+43
   \       0x10   0xAA00'0020        BGE      ??bus_wait_transfer_0
    501          
    502          	if (_bus[bus_id].timeout > 0) {
   \       0x14   0xE3A0'205C        MOV      R2,#+92
   \       0x18   0x....'....        LDR      R1,??DataTable10
   \       0x1C   0xE160'0082        SMULBB   R0,R2,R0
   \       0x20   0xE081'4000        ADD      R4,R1,R0
   \       0x24   0xE594'2048        LDR      R2,[R4, #+72]
   \       0x28   0xE352'0000        CMP      R2,#+0
   \       0x2C   0x0A00'0015        BEQ      ??bus_wait_transfer_1
    503          		struct _timeout _to;
    504          
    505          		timer_start_timeout(&_to, _bus[bus_id].timeout);
   \       0x30   0xE3A0'3000        MOV      R3,#+0
   \       0x34   0xE1A0'000D        MOV      R0,SP
   \       0x38   0x....'....        BL       timer_start_timeout
   \       0x3C   0xEA00'0007        B        ??bus_wait_transfer_2
    506          		while (!timer_timeout_reached(&_to)) {
    507          			if (!bus_is_busy(bus_id))
   \                     ??bus_wait_transfer_3:
   \       0x40   0xE284'0054        ADD      R0,R4,#+84
   \       0x44   0x....'....        BL       mutex_is_locked
   \       0x48   0xE350'0000        CMP      R0,#+0
   \       0x4C   0x0A00'0011        BEQ      ??bus_wait_transfer_0
    508          				return 0;
    509          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \       0x50   0xE5D4'0040        LDRB     R0,[R4, #+64]
   \       0x54   0xE350'0002        CMP      R0,#+2
   \       0x58   0x1A00'0000        BNE      ??bus_wait_transfer_2
    510          				dma_poll();
   \       0x5C   0x....'....        BL       dma_poll
    511          		}
   \                     ??bus_wait_transfer_2:
   \       0x60   0xE1A0'000D        MOV      R0,SP
   \       0x64   0x....'....        BL       timer_timeout_reached
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x0AFF'FFF3        BEQ      ??bus_wait_transfer_3
    512          
    513          		return -ETIMEDOUT;
   \       0x70   0xE3E0'004C        MVN      R0,#+76
   \       0x74   0x....'....        B        ?Subroutine0
    514          	} else {
    515          		while (bus_is_busy(bus_id)) {
    516          			if (_bus[bus_id].transfer_mode == BUS_TRANSFER_MODE_DMA)
   \                     ??bus_wait_transfer_4:
   \       0x78   0xE5D4'0040        LDRB     R0,[R4, #+64]
   \       0x7C   0xE350'0002        CMP      R0,#+2
   \       0x80   0x1A00'0000        BNE      ??bus_wait_transfer_1
    517          				dma_poll();
   \       0x84   0x....'....        BL       dma_poll
    518          		}
   \                     ??bus_wait_transfer_1:
   \       0x88   0xE284'0054        ADD      R0,R4,#+84
   \       0x8C   0x....'....        BL       mutex_is_locked
   \       0x90   0xE350'0000        CMP      R0,#+0
   \       0x94   0x1AFF'FFF7        BNE      ??bus_wait_transfer_4
    519          	}
   \                     ??bus_wait_transfer_0:
   \       0x98                      REQUIRE ?Subroutine0
   \       0x98                      ;; // Fall through to label ?Subroutine0
    520          
    521          	return 0;
    522          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE28D'D010        ADD      SP,SP,#+16
   \        0x4   0xE8BD'8010        POP      {R4,PC}          ;; return
    523          

   \                                 In section SOFTPACK, align 4, keep-with-next
    524          int bus_suspend(uint8_t bus_id)
    525          {
    526          	int err = -ENOTSUP;
    527          
    528          	if (bus_id >= BUS_COUNT)
   \                     bus_suspend:
   \        0x0   0xE350'000D        CMP      R0,#+13
   \        0x4   0xBA00'0001        BLT      ??bus_suspend_0
    529          		return -ENODEV;
   \        0x8   0xE3E0'002B        MVN      R0,#+43
   \        0xC   0xE12F'FF1E        BX       LR
    530          
    531          	switch (_bus[bus_id].type) {
   \                     ??bus_suspend_0:
   \       0x10   0xE3A0'205C        MOV      R2,#+92
   \       0x14   0x....'....        LDR      R1,??DataTable10
   \       0x18   0xE160'0082        SMULBB   R0,R2,R0
   \       0x1C   0xE7D1'3000        LDRB     R3,[R1, +R0]
   \       0x20   0xE353'0002        CMP      R3,#+2
    532          #ifdef CONFIG_HAVE_SPI_BUS
    533          	case BUS_TYPE_SPI:
    534          		err = 0;
   \       0x24   0x03A0'0000        MOVEQ    R0,#+0
    535          		break;
    536          #endif
    537          #ifdef CONFIG_HAVE_I2C_BUS
    538          	case BUS_TYPE_I2C:
    539          		err = 0;
    540          		break;
    541          #endif
    542          	default:
    543          		err = -EINVAL;
   \       0x28   0x13E0'001B        MVNNE    R0,#+27
    544          		break;
    545          	}
    546          
    547          	return err;
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    548          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     _bus

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x45          DC8 "-E- bus: no opened transaction on the bus."

   \              0x2D 0x20    

   \              0x62 0x75    

   \              0x73 0x3A    

   \              0x20 0x6E    

   \              0x6F 0x20    

   \              0x6F 0x70    

   \              0x65 0x6E    

   \              0x65 0x64    

   \              0x20 0x74    

   \              0x72 0x61    

   \              0x6E 0x73    

   \              0x61 0x63    

   \              0x74 0x69    

   \              0x6F 0x6E    

   \              0x20 0x6F    

   \              0x6E 0x20    

   \              0x74 0x68    

   \              0x65 0x20    

   \              0x62 0x75    

   \              0x73 0x2E    

   \              0x00
   \       0x2B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _bus_callback
         0   -> callback_call
         8   -> mutex_unlock
      32   bus_configure
        32   -> __aeabi_memclr
        32   -> bus_ioctl
        32   -> spid_configure
        32   -> spid_configure_master
      16   bus_configure_slave
        16   -> spid_configure_cs
       0   bus_ioctl
       0   bus_is_busy
         0   -> mutex_is_locked
       8   bus_start_transaction
         8   -> mutex_lock
       8   bus_stop_transaction
         8   -> mutex_unlock
       0   bus_suspend
      40   bus_transfer
        40   -> callback_copy
        40   -> callback_set
        40   -> dma_poll
        40   -> mutex_is_locked
        40   -> mutex_try_lock
        40   -> mutex_unlock
        40   -> printf
        40   -> spid_transfer
       8   bus_wait_transaction
         8   -> mutex_is_locked
      24   bus_wait_transfer
        24   -> dma_poll
        24   -> mutex_is_locked
        24   -> timer_start_timeout
        24   -> timer_timeout_reached


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      44  ?_0
   1'196  _bus
      60  _bus_callback
     156  bus_configure
     104  bus_configure_slave
     368  bus_ioctl
      24  bus_is_busy
      44  bus_start_transaction
      44  bus_stop_transaction
      48  bus_suspend
     284  bus_transfer
      40  bus_wait_transaction
     152  bus_wait_transfer

 
 1'196 bytes in section .bss
    44 bytes in section .rodata
 1'360 bytes in section SOFTPACK
 
 1'360 bytes of CODE  memory
    44 bytes of CONST memory
 1'196 bytes of DATA  memory

Errors: none
Warnings: none
