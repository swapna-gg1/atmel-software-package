###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         30/Apr/2020  11:05:19
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW330F.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\ddram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\lib\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\ddram\List\pmc.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\ddram\Obj\pmc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup pmc_module Working with PMC
     31           * \section Purpose
     32           * The PMC driver provides the Interface for configuration the Power Management
     33           *  Controller (PMC).
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li>  Enable & disable peripherals using pmc_enable_peripheral() and
     38           * pmc_enable_all_peripherals() or pmc_disable_peripheral() and
     39           * pmc_disable_all_peripherals().
     40           * <li>  Get & set maximum frequency clock for giving peripheral using
     41           * pmc_get_peri_max_freq() and pmc_set_peri_max_clock().
     42           * <li>  Get Peripheral Status for the given peripheral using pmc_is_periph_enabled()
     43           * <li>  Select clocks's source using pmc_select_external_crystal(),
     44           * pmc_select_internal_crystal(), pmc_select_external_osc() and pmc_select_internal_osc().
     45           * <li>  Switch MCK using pmc_switch_mck_to_pll(), pmc_switch_mck_to_main() and
     46           * pmc_switch_mck_to_slck().
     47           * <li>  Config PLL using pmc_set_pll_a() and pmc_disable_pll_a().
     48           * </li>
     49           * </ul>
     50           * For more accurate information, please look at the PMC section of the
     51           * Datasheet.
     52           *
     53           * Related files :\n
     54           * \ref pmc.c\n
     55           * \ref pmc.h\n
     56          */
     57          /*@{*/
     58          /*@}*/
     59          
     60          /**
     61           * \file
     62           *
     63           * Implementation of PIO (Parallel Input/Output) controller.
     64           *
     65           */
     66          /*----------------------------------------------------------------------------
     67           *        Headers
     68           *----------------------------------------------------------------------------*/
     69          
     70          #include <assert.h>
     71          #include <errno.h>
     72          #include <string.h>
     73          
     74          #include "chip.h"
     75          #include "timer.h"
     76          #include "peripherals/pmc.h"
     77          #include "peripherals/slowclock.h"
     78          #include "trace.h"
     79          #include "barriers.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void dsb(void)
   \                     `dsb`:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xEE07'0F9A        mcr p15, 0, R0, c7, c10, 4
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     80          /*----------------------------------------------------------------------------
     81           *        Types
     82           *----------------------------------------------------------------------------*/
     83          
     84          struct _pmc_main_osc {
     85          	uint32_t rc_freq;
     86          	uint32_t crystal_freq;
     87          };
     88          
     89          #define OSC_STARTUP_TIME	0xFFu
     90          #define MAINFRDY_TIMEOUT	32000u
     91          #define MOSCXTS_TIMEOUT		((OSC_STARTUP_TIME * 8) + 8)
     92          #define MOSCSELS_TIMEOUT	32u
     93          
     94          /*----------------------------------------------------------------------------
     95           *        Variables
     96           *----------------------------------------------------------------------------*/
     97          

   \                                 In section .bss, align 4
     98          RAMDATA static uint32_t _pmc_mck = 0;
   \                     _pmc_mck:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
     99          static struct _pmc_main_osc _pmc_main_oscillators = {
   \                     _pmc_main_oscillators:
   \        0x0   0x00B7'1B00        DC32 12'000'000
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
    100          	.rc_freq = MAIN_CLOCK_INT_OSC,
    101          };
    102          
    103          #ifdef CONFIG_RAMCODE
    104          	#define TRACE_FATAL(...) ((void)0)
    105          	#define _ASSERT(x) ((void)0)
    106          	#define _SLEEP(x) do { for(volatile uint32_t count = 0; count < 100; count++);} while(0)
    107          #else
    108          	#define TRACE_FATAL trace_fatal
    109          	#define _ASSERT assert
    110          	#define _SLEEP(x) do { usleep(x); } while(0)
    111          #endif
    112          
    113          /*----------------------------------------------------------------------------
    114           *        Private functions
    115           *----------------------------------------------------------------------------*/
    116          

   \                                 In section SOFTPACK, align 4, keep-with-next
    117          static void _pmc_compute_mck(void)
    118          {
   \                     _pmc_compute_mck:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
    119          	uint32_t clk = 0;
   \        0x4   0xE3A0'4000        MOV      R4,#+0
    120          	uint32_t mckr = PMC->PMC_MCKR;
   \        0x8   0xE3E0'00D7        MVN      R0,#+215
   \        0xC   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x10   0xE590'5000        LDR      R5,[R0, #+0]
    121          
    122          	uint32_t css = mckr & PMC_MCKR_CSS_Msk;
   \       0x14   0xE215'6003        ANDS     R6,R5,#0x3
    123          	switch (css) {
   \       0x18   0xE1B0'0006        MOVS     R0,R6
   \       0x1C   0xE350'0003        CMP      R0,#+3
   \       0x20   0x8A00'000E        BHI      ??_pmc_compute_mck_1
   \       0x24   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x28   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??_pmc_compute_mck_0:
   \       0x2C   0x00 0x03          DC8      0x0,0x3,0x6,0x9

   \              0x06 0x09
    124          	case PMC_MCKR_CSS_SLOW_CLK:
    125          		clk = pmc_get_slow_clock();
   \                     ??_pmc_compute_mck_2:
   \       0x30   0x....'....        BL       pmc_get_slow_clock
   \       0x34   0xE1B0'4000        MOVS     R4,R0
    126          		break;
   \       0x38   0xEA00'0008        B        ??_pmc_compute_mck_3
    127          	case PMC_MCKR_CSS_MAIN_CLK:
    128          		clk = pmc_get_main_clock();
   \                     ??_pmc_compute_mck_4:
   \       0x3C   0x....'....        BL       pmc_get_main_clock
   \       0x40   0xE1B0'4000        MOVS     R4,R0
    129          		break;
   \       0x44   0xEA00'0005        B        ??_pmc_compute_mck_3
    130          	case PMC_MCKR_CSS_PLLA_CLK:
    131          		clk = pmc_get_plla_clock();
   \                     ??_pmc_compute_mck_5:
   \       0x48   0x....'....        BL       pmc_get_plla_clock
   \       0x4C   0xE1B0'4000        MOVS     R4,R0
    132          		break;
   \       0x50   0xEA00'0002        B        ??_pmc_compute_mck_3
    133          	case PMC_MCKR_CSS_UPLL_CLK:
    134          		clk = pmc_get_upll_clock();
   \                     ??_pmc_compute_mck_6:
   \       0x54   0x....'....        BL       pmc_get_upll_clock
   \       0x58   0xE1B0'4000        MOVS     R4,R0
    135          		break;
   \       0x5C   0xEAFF'FFFF        B        ??_pmc_compute_mck_3
    136          	default:
    137          		/* should never get here... */
    138          		break;
    139          	}
    140          
    141          	uint32_t pres = mckr & PMC_MCKR_PRES_Msk;
   \                     ??_pmc_compute_mck_1:
   \                     ??_pmc_compute_mck_3:
   \       0x60   0xE215'7070        ANDS     R7,R5,#0x70
    142          	switch (pres) {
   \       0x64   0xE1B0'0007        MOVS     R0,R7
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x0A00'000E        BEQ      ??_pmc_compute_mck_7
   \       0x70   0xE350'0010        CMP      R0,#+16
   \       0x74   0x0A00'000D        BEQ      ??_pmc_compute_mck_8
   \       0x78   0xE350'0020        CMP      R0,#+32
   \       0x7C   0x0A00'000D        BEQ      ??_pmc_compute_mck_9
   \       0x80   0xE350'0030        CMP      R0,#+48
   \       0x84   0x0A00'000D        BEQ      ??_pmc_compute_mck_10
   \       0x88   0xE350'0040        CMP      R0,#+64
   \       0x8C   0x0A00'000D        BEQ      ??_pmc_compute_mck_11
   \       0x90   0xE350'0050        CMP      R0,#+80
   \       0x94   0x0A00'000D        BEQ      ??_pmc_compute_mck_12
   \       0x98   0xE350'0060        CMP      R0,#+96
   \       0x9C   0x0A00'000D        BEQ      ??_pmc_compute_mck_13
   \       0xA0   0xE350'0070        CMP      R0,#+112
   \       0xA4   0x0A00'000D        BEQ      ??_pmc_compute_mck_14
   \       0xA8   0xEA00'0011        B        ??_pmc_compute_mck_15
    143          	case PMC_MCKR_PRES_CLOCK:
    144          		break;
   \                     ??_pmc_compute_mck_7:
   \       0xAC   0xEA00'0010        B        ??_pmc_compute_mck_16
    145          	case PMC_MCKR_PRES_CLOCK_DIV2:
    146          		clk >>= 1;
   \                     ??_pmc_compute_mck_8:
   \       0xB0   0xE1B0'40A4        LSRS     R4,R4,#+1
    147          		break;
   \       0xB4   0xEA00'000E        B        ??_pmc_compute_mck_16
    148          	case PMC_MCKR_PRES_CLOCK_DIV4:
    149          		clk >>= 2;
   \                     ??_pmc_compute_mck_9:
   \       0xB8   0xE1B0'4124        LSRS     R4,R4,#+2
    150          		break;
   \       0xBC   0xEA00'000C        B        ??_pmc_compute_mck_16
    151          	case PMC_MCKR_PRES_CLOCK_DIV8:
    152          		clk >>= 3;
   \                     ??_pmc_compute_mck_10:
   \       0xC0   0xE1B0'41A4        LSRS     R4,R4,#+3
    153          		break;
   \       0xC4   0xEA00'000A        B        ??_pmc_compute_mck_16
    154          	case PMC_MCKR_PRES_CLOCK_DIV16:
    155          		clk >>= 4;
   \                     ??_pmc_compute_mck_11:
   \       0xC8   0xE1B0'4224        LSRS     R4,R4,#+4
    156          		break;
   \       0xCC   0xEA00'0008        B        ??_pmc_compute_mck_16
    157          	case PMC_MCKR_PRES_CLOCK_DIV32:
    158          		clk >>= 5;
   \                     ??_pmc_compute_mck_12:
   \       0xD0   0xE1B0'42A4        LSRS     R4,R4,#+5
    159          		break;
   \       0xD4   0xEA00'0006        B        ??_pmc_compute_mck_16
    160          	case PMC_MCKR_PRES_CLOCK_DIV64:
    161          		clk >>= 6;
   \                     ??_pmc_compute_mck_13:
   \       0xD8   0xE1B0'4324        LSRS     R4,R4,#+6
    162          		break;
   \       0xDC   0xEA00'0004        B        ??_pmc_compute_mck_16
    163          #ifdef PMC_MCKR_PRES_CLOCK_DIV3
    164          	case PMC_MCKR_PRES_CLOCK_DIV3:
    165          		clk /= 3;
   \                     ??_pmc_compute_mck_14:
   \       0xE0   0xE1B0'0004        MOVS     R0,R4
   \       0xE4   0xE3A0'1003        MOV      R1,#+3
   \       0xE8   0x....'....        BL       __aeabi_uidiv
   \       0xEC   0xE1B0'4000        MOVS     R4,R0
    166          		break;
   \       0xF0   0xEAFF'FFFF        B        ??_pmc_compute_mck_16
    167          #endif
    168          	default:
    169          		/* should never get here... */
    170          		break;
    171          	}
    172          
    173          	uint32_t mdiv = mckr & PMC_MCKR_MDIV_Msk;
   \                     ??_pmc_compute_mck_15:
   \                     ??_pmc_compute_mck_16:
   \       0xF4   0xE215'8E70        ANDS     R8,R5,#0x700
    174          	switch (mdiv) {
   \       0xF8   0xE1B0'0008        MOVS     R0,R8
   \       0xFC   0xE350'0000        CMP      R0,#+0
   \      0x100   0x0A00'0006        BEQ      ??_pmc_compute_mck_17
   \      0x104   0xE350'0F40        CMP      R0,#+256
   \      0x108   0x0A00'0005        BEQ      ??_pmc_compute_mck_18
   \      0x10C   0xE350'0F80        CMP      R0,#+512
   \      0x110   0x0A00'0005        BEQ      ??_pmc_compute_mck_19
   \      0x114   0xE350'0FC0        CMP      R0,#+768
   \      0x118   0x0A00'0005        BEQ      ??_pmc_compute_mck_20
   \      0x11C   0xEA00'0009        B        ??_pmc_compute_mck_21
    175          	case PMC_MCKR_MDIV_EQ_PCK:
    176          		break;
   \                     ??_pmc_compute_mck_17:
   \      0x120   0xEA00'0008        B        ??_pmc_compute_mck_22
    177          	case PMC_MCKR_MDIV_PCK_DIV2:
    178          		clk >>= 1; // divide by 2
   \                     ??_pmc_compute_mck_18:
   \      0x124   0xE1B0'40A4        LSRS     R4,R4,#+1
    179          		break;
   \      0x128   0xEA00'0006        B        ??_pmc_compute_mck_22
    180          	case PMC_MCKR_MDIV_PCK_DIV4:
    181          		clk >>= 2; // divide by 4
   \                     ??_pmc_compute_mck_19:
   \      0x12C   0xE1B0'4124        LSRS     R4,R4,#+2
    182          		break;
   \      0x130   0xEA00'0004        B        ??_pmc_compute_mck_22
    183          	case PMC_MCKR_MDIV_PCK_DIV3:
    184          		clk /= 3;  // divide by 3
   \                     ??_pmc_compute_mck_20:
   \      0x134   0xE1B0'0004        MOVS     R0,R4
   \      0x138   0xE3A0'1003        MOV      R1,#+3
   \      0x13C   0x....'....        BL       __aeabi_uidiv
   \      0x140   0xE1B0'4000        MOVS     R4,R0
    185          		break;
   \      0x144   0xEAFF'FFFF        B        ??_pmc_compute_mck_22
    186          	default:
    187          		/* should never get here... */
    188          		break;
    189          	}
    190          
    191          	_pmc_mck = clk;
   \                     ??_pmc_compute_mck_21:
   \                     ??_pmc_compute_mck_22:
   \      0x148   0x....'....        LDR      R0,??DataTable16
   \      0x14C   0xE580'4000        STR      R4,[R0, #+0]
    192          }
   \      0x150   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    193          

   \                                 In section SOFTPACK, align 4, keep-with-next
    194          static uint32_t _pmc_get_pck_clock(uint32_t index)
    195          {
   \                     _pmc_get_pck_clock:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    196          	uint32_t clk = 0;
   \        0x8   0xE3A0'5000        MOV      R5,#+0
    197          	uint32_t pck = PMC->PMC_PCK[index];
   \        0xC   0xE3E0'00BF        MVN      R0,#+191
   \       0x10   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x14   0xE1B0'1104        LSLS     R1,R4,#+2
   \       0x18   0xE790'6001        LDR      R6,[R0, +R1]
    198          
    199          	switch (pck & PMC_PCK_CSS_Msk) {
   \       0x1C   0xE216'001F        ANDS     R0,R6,#0x1F
   \       0x20   0xE350'0005        CMP      R0,#+5
   \       0x24   0x8A00'0011        BHI      ??_pmc_get_pck_clock_1
   \       0x28   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x2C   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??_pmc_get_pck_clock_0:
   \       0x30   0x01 0x0F          DC8      0x1,0xF,0x4,0xD

   \              0x04 0x0D
   \       0x34   0x07 0x0A          DC8      0x7,0xA,0x0,0x0

   \              0x00 0x00
    200          	case PMC_PCK_CSS_SLOW_CLK:
    201          		clk = pmc_get_slow_clock();
   \                     ??_pmc_get_pck_clock_2:
   \       0x38   0x....'....        BL       pmc_get_slow_clock
   \       0x3C   0xE1B0'5000        MOVS     R5,R0
    202          		break;
   \       0x40   0xEA00'000A        B        ??_pmc_get_pck_clock_1
    203          	case PMC_PCK_CSS_MAIN_CLK:
    204          		clk = pmc_get_main_clock();
   \                     ??_pmc_get_pck_clock_3:
   \       0x44   0x....'....        BL       pmc_get_main_clock
   \       0x48   0xE1B0'5000        MOVS     R5,R0
    205          		break;
   \       0x4C   0xEA00'0007        B        ??_pmc_get_pck_clock_1
    206          	case PMC_PCK_CSS_PLLA_CLK:
    207          		clk = pmc_get_plla_clock();
   \                     ??_pmc_get_pck_clock_4:
   \       0x50   0x....'....        BL       pmc_get_plla_clock
   \       0x54   0xE1B0'5000        MOVS     R5,R0
    208          		break;
   \       0x58   0xEA00'0004        B        ??_pmc_get_pck_clock_1
    209          	case PMC_PCK_CSS_UPLL_CLK:
    210          		clk = pmc_get_upll_clock();
   \                     ??_pmc_get_pck_clock_5:
   \       0x5C   0x....'....        BL       pmc_get_upll_clock
   \       0x60   0xE1B0'5000        MOVS     R5,R0
    211          		break;
   \       0x64   0xEA00'0001        B        ??_pmc_get_pck_clock_1
    212          	case PMC_PCK_CSS_MCK:
    213          		clk = pmc_get_master_clock();
   \                     ??_pmc_get_pck_clock_6:
   \       0x68   0x....'....        BL       pmc_get_master_clock
   \       0x6C   0xE1B0'5000        MOVS     R5,R0
    214          		break;
    215          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    216          	case PMC_PCK_CSS_AUDIO_CLK:
    217          		clk = pmc_get_audio_pmc_clock();
    218          		break;
    219          #endif
    220          	}
    221          
    222          	uint32_t prescaler = (pck & PMC_PCK_PRES_Msk) >> PMC_PCK_PRES_Pos;
   \                     ??_pmc_get_pck_clock_1:
   \       0x70   0xE3A0'00FF        MOV      R0,#+255
   \       0x74   0xE010'1426        ANDS     R1,R0,R6, LSR #+8
    223          	return clk / (prescaler + 1);
   \       0x78   0xE1B0'0005        MOVS     R0,R5
   \       0x7C   0xE291'1001        ADDS     R1,R1,#+1
   \       0x80   0x....'....        BL       __aeabi_uidiv
   \       0x84   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    224          }
    225          

   \                                 In section SOFTPACK, align 4, keep-with-next
    226          RAMCODE static bool _pmc_get_system_clock_bits(enum _pmc_system_clock clock,
    227          	uint32_t *scer, uint32_t* scdr, uint32_t *scsr)
    228          {
   \                     _pmc_get_system_clock_bits:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE1B0'C000        MOVS     R12,R0
    229          	uint32_t e, d, s;
    230          
    231          	switch (clock)
   \        0x8   0xE1B0'000C        MOVS     R0,R12
   \        0xC   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x10   0xE350'000D        CMP      R0,#+13
   \       0x14   0x8A00'0019        BHI      ??_pmc_get_system_clock_bits_1
   \       0x18   0xE7DF'E000        LDRB     LR,[PC, R0]
   \       0x1C   0xE08F'F10E        ADD      PC,PC,LR, LSL #+2
   \                     ??_pmc_get_system_clock_bits_0:
   \       0x20   0x03 0x17          DC8      0x3,0x17,0x17,0x7

   \              0x17 0x07
   \       0x24   0x17 0x0B          DC8      0x17,0xB,0xF,0x17

   \              0x0F 0x17
   \       0x28   0x17 0x17          DC8      0x17,0x17,0x17,0x17

   \              0x17 0x17
   \       0x2C   0x17 0x13          DC8      0x17,0x13,0x0,0x0

   \              0x00 0x00
    232          	{
    233          #ifdef PMC_SCER_DDRCK
    234          	case PMC_SYSTEM_CLOCK_DDR:
    235          		e = PMC_SCER_DDRCK;
   \                     ??_pmc_get_system_clock_bits_2:
   \       0x30   0xE3A0'E004        MOV      LR,#+4
    236          		d = PMC_SCDR_DDRCK;
   \       0x34   0xE3A0'4004        MOV      R4,#+4
    237          		s = PMC_SCSR_DDRCK;
   \       0x38   0xE3A0'5004        MOV      R5,#+4
    238          		break;
   \       0x3C   0xEA00'0011        B        ??_pmc_get_system_clock_bits_3
    239          #endif
    240          #ifdef PMC_SCER_LCDCK
    241          	case PMC_SYSTEM_CLOCK_LCD:
    242          		e = PMC_SCER_LCDCK;
    243          		d = PMC_SCDR_LCDCK;
    244          		s = PMC_SCSR_LCDCK;
    245          		break;
    246          #endif
    247          #ifdef PMC_SCER_SMDCK
    248          	case PMC_SYSTEM_CLOCK_SMD:
    249          		e = PMC_SCER_SMDCK;
    250          		d = PMC_SCDR_SMDCK;
    251          		s = PMC_SCSR_SMDCK;
    252          		break;
    253          #endif
    254          #ifdef PMC_SCER_UHP
    255          	case PMC_SYSTEM_CLOCK_UHP:
    256          		e = PMC_SCER_UHP;
   \                     ??_pmc_get_system_clock_bits_4:
   \       0x40   0xE3A0'E040        MOV      LR,#+64
    257          		d = PMC_SCDR_UHP;
   \       0x44   0xE3A0'4040        MOV      R4,#+64
    258          		s = PMC_SCSR_UHP;
   \       0x48   0xE3A0'5040        MOV      R5,#+64
    259          		break;
   \       0x4C   0xEA00'000D        B        ??_pmc_get_system_clock_bits_3
    260          #endif
    261          #ifdef PMC_SCER_UDP
    262          	case PMC_SYSTEM_CLOCK_UDP:
    263          		e = PMC_SCER_UDP;
    264          		d = PMC_SCDR_UDP;
    265          		s = PMC_SCSR_UDP;
    266          		break;
    267          #endif
    268          #ifdef PMC_SCER_PCK0
    269          	case PMC_SYSTEM_CLOCK_PCK0:
    270          		e = PMC_SCER_PCK0;
   \                     ??_pmc_get_system_clock_bits_5:
   \       0x50   0xE3A0'EF40        MOV      LR,#+256
    271          		d = PMC_SCDR_PCK0;
   \       0x54   0xE3A0'4F40        MOV      R4,#+256
    272          		s = PMC_SCSR_PCK0;
   \       0x58   0xE3A0'5F40        MOV      R5,#+256
    273          		break;
   \       0x5C   0xEA00'0009        B        ??_pmc_get_system_clock_bits_3
    274          #endif
    275          #ifdef PMC_SCER_PCK1
    276          	case PMC_SYSTEM_CLOCK_PCK1:
    277          		e = PMC_SCER_PCK1;
   \                     ??_pmc_get_system_clock_bits_6:
   \       0x60   0xE3A0'EF80        MOV      LR,#+512
    278          		d = PMC_SCDR_PCK1;
   \       0x64   0xE3A0'4F80        MOV      R4,#+512
    279          		s = PMC_SCSR_PCK1;
   \       0x68   0xE3A0'5F80        MOV      R5,#+512
    280          		break;
   \       0x6C   0xEA00'0005        B        ??_pmc_get_system_clock_bits_3
    281          #endif
    282          #ifdef PMC_SCER_PCK2
    283          	case PMC_SYSTEM_CLOCK_PCK2:
    284          		e = PMC_SCER_PCK2;
    285          		d = PMC_SCDR_PCK2;
    286          		s = PMC_SCSR_PCK2;
    287          		break;
    288          #endif
    289          #ifdef PMC_SCER_PCK3
    290          	case PMC_SYSTEM_CLOCK_PCK3:
    291          		e = PMC_SCER_PCK3;
    292          		d = PMC_SCDR_PCK3;
    293          		s = PMC_SCSR_PCK3;
    294          		break;
    295          #endif
    296          #ifdef PMC_SCER_PCK4
    297          	case PMC_SYSTEM_CLOCK_PCK4:
    298          		e = PMC_SCER_PCK4;
    299          		d = PMC_SCDR_PCK4;
    300          		s = PMC_SCSR_PCK4;
    301          		break;
    302          #endif
    303          #ifdef PMC_SCER_PCK5
    304          	case PMC_SYSTEM_CLOCK_PCK5:
    305          		e = PMC_SCER_PCK5;
    306          		d = PMC_SCDR_PCK5;
    307          		s = PMC_SCSR_PCK5;
    308          		break;
    309          #endif
    310          #ifdef PMC_SCER_PCK6
    311          	case PMC_SYSTEM_CLOCK_PCK6:
    312          		e = PMC_SCER_PCK6;
    313          		d = PMC_SCDR_PCK6;
    314          		s = PMC_SCSR_PCK6;
    315          		break;
    316          #endif
    317          #ifdef PMC_SCER_ISCCK
    318          	case PMC_SYSTEM_CLOCK_ISC:
    319          		e = PMC_SCER_ISCCK;
    320          		d = PMC_SCDR_ISCCK;
    321          		s = PMC_SCSR_ISCCK;
    322          		break;
    323          #endif
    324          #ifdef PMC_SCER_QSPICLK
    325          	case PMC_SYSTEM_CLOCK_QSPI:
    326          		e = PMC_SCER_QSPICLK;
   \                     ??_pmc_get_system_clock_bits_7:
   \       0x70   0xE3A0'EA80        MOV      LR,#+524288
    327          		d = PMC_SCDR_QSPICLK;
   \       0x74   0xE3A0'4A80        MOV      R4,#+524288
    328          		s = PMC_SCSR_QSPICLK;
   \       0x78   0xE3A0'5A80        MOV      R5,#+524288
    329          		break;
   \       0x7C   0xEA00'0001        B        ??_pmc_get_system_clock_bits_3
    330          #endif
    331          	default:
    332          		return false;
   \                     ??_pmc_get_system_clock_bits_1:
   \       0x80   0xE3A0'0000        MOV      R0,#+0
   \       0x84   0xEA00'0018        B        ??_pmc_get_system_clock_bits_8
    333          	}
    334          
    335          	if (scer) {
   \                     ??_pmc_get_system_clock_bits_3:
   \       0x88   0xE351'0000        CMP      R1,#+0
   \       0x8C   0x0A00'0005        BEQ      ??_pmc_get_system_clock_bits_9
    336          		if (e)
   \       0x90   0xE35E'0000        CMP      LR,#+0
   \       0x94   0x0A00'0001        BEQ      ??_pmc_get_system_clock_bits_10
    337          			*scer = e;
   \       0x98   0xE581'E000        STR      LR,[R1, #+0]
   \       0x9C   0xEA00'0001        B        ??_pmc_get_system_clock_bits_9
    338          		else
    339          			return false;
   \                     ??_pmc_get_system_clock_bits_10:
   \       0xA0   0xE3A0'0000        MOV      R0,#+0
   \       0xA4   0xEA00'0010        B        ??_pmc_get_system_clock_bits_8
    340          	}
    341          
    342          	if (scdr) {
   \                     ??_pmc_get_system_clock_bits_9:
   \       0xA8   0xE352'0000        CMP      R2,#+0
   \       0xAC   0x0A00'0005        BEQ      ??_pmc_get_system_clock_bits_11
    343          		if (d)
   \       0xB0   0xE354'0000        CMP      R4,#+0
   \       0xB4   0x0A00'0001        BEQ      ??_pmc_get_system_clock_bits_12
    344          			*scdr = d;
   \       0xB8   0xE582'4000        STR      R4,[R2, #+0]
   \       0xBC   0xEA00'0001        B        ??_pmc_get_system_clock_bits_11
    345          		else
    346          			return false;
   \                     ??_pmc_get_system_clock_bits_12:
   \       0xC0   0xE3A0'0000        MOV      R0,#+0
   \       0xC4   0xEA00'0008        B        ??_pmc_get_system_clock_bits_8
    347          	}
    348          
    349          	if (scsr) {
   \                     ??_pmc_get_system_clock_bits_11:
   \       0xC8   0xE353'0000        CMP      R3,#+0
   \       0xCC   0x0A00'0005        BEQ      ??_pmc_get_system_clock_bits_13
    350          		if (s)
   \       0xD0   0xE355'0000        CMP      R5,#+0
   \       0xD4   0x0A00'0001        BEQ      ??_pmc_get_system_clock_bits_14
    351          			*scsr = s;
   \       0xD8   0xE583'5000        STR      R5,[R3, #+0]
   \       0xDC   0xEA00'0001        B        ??_pmc_get_system_clock_bits_13
    352          		else
    353          			return false;
   \                     ??_pmc_get_system_clock_bits_14:
   \       0xE0   0xE3A0'0000        MOV      R0,#+0
   \       0xE4   0xEA00'0000        B        ??_pmc_get_system_clock_bits_8
    354          	}
    355          
    356          	return true;
   \                     ??_pmc_get_system_clock_bits_13:
   \       0xE8   0xE3A0'0001        MOV      R0,#+1
   \                     ??_pmc_get_system_clock_bits_8:
   \       0xEC   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    357          }
    358          
    359          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
    360          static void _pmc_configure_peripheral_div(uint32_t id, uint32_t div)
    361          {
    362          	uint32_t clk_max;
    363          	bool can_divide;
    364          
    365          	can_divide = peripheral_has_clock_div(id);
    366          	clk_max = get_peripheral_clock_max_freq(id);
    367          
    368          	if (div == 0) {
    369          		if (can_divide) {
    370          			for (div = 0; div < ((PMC_PCR_DIV_Msk >> PMC_PCR_DIV_Pos)); div++)
    371          				if ((pmc_get_master_clock() >> div) <= clk_max)
    372          					break;
    373          		}
    374          	} else {
    375          		if (div > 1 && !can_divide)
    376          			TRACE_FATAL("Peripheral does not support divided clock\r\n");
    377          		div--;
    378          	}
    379          
    380          	if ((pmc_get_master_clock() >> div) <= clk_max) {
    381          		PMC->PMC_PCR = PMC_PCR_PID(id);
    382          		volatile uint32_t pcr = PMC->PMC_PCR;
    383          		PMC->PMC_PCR = (pcr & ~PMC_PCR_DIV_Msk) | PMC_PCR_DIV(div) | PMC_PCR_CMD;
    384          	} else {
    385          		TRACE_FATAL("Peripheral clock for periph#%d is too high\r\n", (int)id);
    386          	}
    387          }
    388          #endif
    389          

   \                                 In section SOFTPACK, align 4, keep-with-next
    390          static uint16_t _pmc_measure_main_osc_freq(bool external_xt)
    391          {
   \                     _pmc_measure_main_osc_freq:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    392          	volatile uint32_t timeout = MAINFRDY_TIMEOUT;
   \        0x8   0xE3A0'0C7D        MOV      R0,#+32000
   \        0xC   0xE58D'0000        STR      R0,[SP, #+0]
    393          
    394          #ifdef CKGR_MCFR_CCSS
    395          	PMC->CKGR_MCFR = external_xt ? CKGR_MCFR_CCSS : 0;
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0001        BEQ      ??_pmc_measure_main_osc_freq_0
   \       0x20   0xE3A0'0740        MOV      R0,#+16777216
   \       0x24   0xEA00'0000        B        ??_pmc_measure_main_osc_freq_1
   \                     ??_pmc_measure_main_osc_freq_0:
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \                     ??_pmc_measure_main_osc_freq_1:
   \       0x2C   0xE3E0'50DB        MVN      R5,#+219
   \       0x30   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x34   0xE585'0000        STR      R0,[R5, #+0]
    396          #endif
    397          
    398          #ifdef CKGR_MCFR_RCMEAS
    399          	PMC->CKGR_MCFR |= CKGR_MCFR_RCMEAS;
   \       0x38   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x3C   0xE390'0940        ORRS     R0,R0,#0x100000
   \       0x40   0xE585'0000        STR      R0,[R5, #+0]
    400          #endif
    401          	dsb();
   \       0x44   0x....'....        BL       `dsb`
    402          	while (!(PMC->CKGR_MCFR & CKGR_MCFR_MAINFRDY) && (--timeout > 0));
   \                     ??_pmc_measure_main_osc_freq_2:
   \       0x48   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x4C   0xE310'0B40        TST      R0,#0x10000
   \       0x50   0x1A00'0004        BNE      ??_pmc_measure_main_osc_freq_3
   \       0x54   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x58   0xE250'0001        SUBS     R0,R0,#+1
   \       0x5C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x1AFF'FFF7        BNE      ??_pmc_measure_main_osc_freq_2
    403          	return (timeout ?
    404          		((PMC->CKGR_MCFR & CKGR_MCFR_MAINF_Msk) >> CKGR_MCFR_MAINF_Pos) :
    405          		0u);
   \                     ??_pmc_measure_main_osc_freq_3:
   \       0x68   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x6C   0xE350'0000        CMP      R0,#+0
   \       0x70   0x0A00'0001        BEQ      ??_pmc_measure_main_osc_freq_4
   \       0x74   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x78   0xEA00'0000        B        ??_pmc_measure_main_osc_freq_5
   \                     ??_pmc_measure_main_osc_freq_4:
   \       0x7C   0xE3A0'0000        MOV      R0,#+0
   \                     ??_pmc_measure_main_osc_freq_5:
   \       0x80   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x84   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x88   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    406          }
    407          
    408          #if defined(PMC_PLL_UPDT_ID)

   \                                 In section SOFTPACK, align 4, keep-with-next
    409          RAMCODE static void _pmc_configure_pll(const struct _pmc_plla_cfg* plla)
    410          {
   \                     _pmc_configure_pll:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    411          	uint32_t reg;
    412          
    413          	if (plla->pll_id == PLL_ID_PLLA) {
   \        0x8   0xE594'000C        LDR      R0,[R4, #+12]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x0A00'0014        BEQ      ??_pmc_configure_pll_0
    414          	} else if (plla->pll_id == PLL_ID_UPLL){
   \       0x14   0xE594'000C        LDR      R0,[R4, #+12]
   \       0x18   0xE350'0001        CMP      R0,#+1
   \       0x1C   0x1A00'0009        BNE      ??_pmc_configure_pll_1
    415          		_ASSERT(plla->div == 1);
   \       0x20   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x24   0xE350'0001        CMP      R0,#+1
   \       0x28   0x0A00'000E        BEQ      ??_pmc_configure_pll_0
   \       0x2C   0xE3A0'209F        MOV      R2,#+159
   \       0x30   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x34   0x....'....        LDR      R1,??DataTable18
   \       0x38   0x....'....        LDR      R0,??DataTable18_1
   \       0x3C   0x....'....        BL       __aeabi_assert
   \       0x40   0x....'....        BL       __iar_EmptyStepPoint
   \       0x44   0xEA00'0007        B        ??_pmc_configure_pll_0
    416          	} else {
    417          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)plla->pll_id);
   \                     ??_pmc_configure_pll_1:
   \       0x48   0x....'....        LDR      R0,??DataTable18_2
   \       0x4C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'0002        BEQ      ??_pmc_configure_pll_2
   \       0x58   0xE594'100C        LDR      R1,[R4, #+12]
   \       0x5C   0x....'....        LDR      R0,??DataTable18_3
   \       0x60   0x....'....        BL       printf
   \                     ??_pmc_configure_pll_2:
   \       0x64   0xEAFF'FFFE        B        ??_pmc_configure_pll_2
    418          	}
    419          
    420          	/* Follow the steps below to power-on a PLL: */
    421          	/* 1. Define the ID (ID=n) and startup time by configuring the fields PMC_PLL_UPDT.ID and
    422          	PMC_PLL_UPDT.STUPTIM. Set PMC_PLL_UPDT.UPDATE to '0'. */
    423          	reg = PMC->PMC_PLL_UPDT;
   \                     ??_pmc_configure_pll_0:
   \       0x68   0xE3E0'50E3        MVN      R5,#+227
   \       0x6C   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x70   0xE595'0000        LDR      R0,[R5, #+0]
    424          	reg &= ~(PMC_PLL_UPDT_STUPTIM_Msk | PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
   \       0x74   0x....'....        LDR      R1,??DataTable19  ;; 0xff00fefe
   \       0x78   0xE011'0000        ANDS     R0,R1,R0
    425          	reg |= PMC_PLL_UPDT_STUPTIM(plla->count);
   \       0x7C   0xE594'1008        LDR      R1,[R4, #+8]
   \       0x80   0xE3A0'28FF        MOV      R2,#+16711680
   \       0x84   0xE012'1801        ANDS     R1,R2,R1, LSL #+16
   \       0x88   0xE191'8000        ORRS     R8,R1,R0
    426          	if (plla->pll_id)
   \       0x8C   0xE594'000C        LDR      R0,[R4, #+12]
   \       0x90   0xE350'0000        CMP      R0,#+0
   \       0x94   0x0A00'0000        BEQ      ??_pmc_configure_pll_3
    427          		reg |= PMC_PLL_UPDT_ID;
   \       0x98   0xE398'8001        ORRS     R8,R8,#0x1
    428          	PMC->PMC_PLL_UPDT = reg;
   \                     ??_pmc_configure_pll_3:
   \       0x9C   0xE585'8000        STR      R8,[R5, #+0]
    429          	
    430          	if ((PMC -> PMC_PLL_ACR & PMC_PLL_ACR_UTMIBG) != PMC_PLL_ACR_UTMIBG) {
   \       0xA0   0xE3E0'60E7        MVN      R6,#+231
   \       0xA4   0xE3C6'6FC0        BIC      R6,R6,#0x300
   \       0xA8   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xAC   0xE310'0D80        TST      R0,#0x2000
   \       0xB0   0x1A00'0005        BNE      ??_pmc_configure_pll_4
    431          		/* 2. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    432          		reg = PMC->PMC_PLL_ACR;
   \       0xB4   0xE596'0000        LDR      R0,[R6, #+0]
    433          		reg |= PMC_PLL_ACR_UTMIBG;
   \       0xB8   0xE390'0D80        ORRS     R0,R0,#0x2000
   \       0xBC   0xE1B0'8000        MOVS     R8,R0
    434          		PMC->PMC_PLL_ACR = reg;
   \       0xC0   0xE586'8000        STR      R8,[R6, #+0]
    435          		/* 3. Wait 10 us. */
    436          		_SLEEP(10);
   \       0xC4   0xE3A0'000A        MOV      R0,#+10
   \       0xC8   0x....'....        BL       usleep
    437          	}
    438          
    439          	/* 2. Configure PMC_PLL_ACR.LOOP_FILTER. */
    440          	reg = PMC->PMC_PLL_ACR;
   \                     ??_pmc_configure_pll_4:
   \       0xCC   0xE596'0000        LDR      R0,[R6, #+0]
    441          	reg &= ~PMC_PLL_ACR_LOOP_FILTER_Msk;
   \       0xD0   0xE3D0'05FC        BICS     R0,R0,#0x3F000000
    442          	reg |= PMC_PLL_ACR_LOOP_FILTER(plla->loop_filter);
   \       0xD4   0xE594'1014        LDR      R1,[R4, #+20]
   \       0xD8   0xE3A0'25FC        MOV      R2,#+1056964608
   \       0xDC   0xE012'1C01        ANDS     R1,R2,R1, LSL #+24
   \       0xE0   0xE191'7000        ORRS     R7,R1,R0
    443          	PMC->PMC_PLL_ACR = reg;
   \       0xE4   0xE586'7000        STR      R7,[R6, #+0]
    444          
    445          	/* 3. Define the MUL and FRACR to be applied to PLL(n) in PMC_PLL_CTRL1. */
    446          	PMC->PMC_PLL_CTRL1 = PMC_PLL_CTRL1_MUL(plla->mul) | PMC_PLL_CTRL1_FRACR(plla->fracr);
   \       0xE8   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xEC   0xE594'1010        LDR      R1,[R4, #+16]
   \       0xF0   0xE1B0'1501        LSLS     R1,R1,#+10
   \       0xF4   0xE1B0'1521        LSRS     R1,R1,#+10
   \       0xF8   0xE191'0C00        ORRS     R0,R1,R0, LSL #+24
   \       0xFC   0xE3E0'10EF        MVN      R1,#+239
   \      0x100   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \      0x104   0xE581'0000        STR      R0,[R1, #+0]
    447          
    448          	/* In case UPLL is being configured, follow Step 4. to Step 7., else jump to Step 8. */
    449          	if (plla->pll_id == PLL_ID_UPLL) {
   \      0x108   0xE594'000C        LDR      R0,[R4, #+12]
   \      0x10C   0xE350'0001        CMP      R0,#+1
   \      0x110   0x1A00'000A        BNE      ??_pmc_configure_pll_5
    450          		/* 4. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    451          		reg = PMC->PMC_PLL_ACR;
   \      0x114   0xE596'0000        LDR      R0,[R6, #+0]
    452          		reg |= PMC_PLL_ACR_UTMIBG;
   \      0x118   0xE390'8D80        ORRS     R8,R0,#0x2000
    453          		PMC->PMC_PLL_ACR = reg;
   \      0x11C   0xE586'8000        STR      R8,[R6, #+0]
    454          		/* 5. Wait 10 us. */
    455          		_SLEEP(10);
   \      0x120   0xE3A0'000A        MOV      R0,#+10
   \      0x124   0x....'....        BL       usleep
    456          
    457          		/* 6. Write PMC_PLL_ACR.UTMIVR to '1' to enable the UTMI internal regulator. */
    458          		reg = PMC->PMC_PLL_ACR;
   \      0x128   0xE596'0000        LDR      R0,[R6, #+0]
    459          		reg |= PMC_PLL_ACR_UTMIVR;
   \      0x12C   0xE390'0D40        ORRS     R0,R0,#0x1000
   \      0x130   0xE1B0'7000        MOVS     R7,R0
    460          		PMC->PMC_PLL_ACR = reg;
   \      0x134   0xE586'7000        STR      R7,[R6, #+0]
    461          
    462          		/* 7. Wait 10 us. */
    463          		_SLEEP(10);
   \      0x138   0xE3A0'000A        MOV      R0,#+10
   \      0x13C   0x....'....        BL       usleep
    464          	}
    465          
    466          	/* 8. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    467          	1, else the update is cancelled. */
    468          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
   \                     ??_pmc_configure_pll_5:
   \      0x140   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x144   0xE390'0F40        ORRS     R0,R0,#0x100
   \      0x148   0xE585'0000        STR      R0,[R5, #+0]
    469          
    470          	/* 9. In PMC_PLL_CTRL0, write a '1' to ENLOCK and to ENPLL and configure DIVPMC (for PLLA only,
    471          	as UPLL has a fixed divider value) and ENPLLCK. */
    472          	reg = PMC->PMC_PLL_CTRL0 & ~PMC_PLL_CTRL0_DIVPMC_Msk;
   \      0x14C   0xE3E0'10F3        MVN      R1,#+243
   \      0x150   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \      0x154   0xE591'0000        LDR      R0,[R1, #+0]
   \      0x158   0xE3D0'00FF        BICS     R0,R0,#0xFF
    473          	reg |= PMC_PLL_CTRL0_ENLOCK | PMC_PLL_CTRL0_ENPLL;
   \      0x15C   0xE390'0490        ORRS     R0,R0,#0x90000000
    474          	reg |= PMC_PLL_CTRL0_DIVPMC(plla->div) | PMC_PLL_CTRL0_ENPLLCK;
   \      0x160   0xE5D4'2004        LDRB     R2,[R4, #+4]
   \      0x164   0xE212'20FF        ANDS     R2,R2,#0xFF
   \      0x168   0xE392'2580        ORRS     R2,R2,#0x20000000
   \      0x16C   0xE192'0000        ORRS     R0,R2,R0
    475          	PMC->PMC_PLL_CTRL0 = reg;
   \      0x170   0xE581'0000        STR      R0,[R1, #+0]
    476          
    477          	/* 10. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    478          	1, else the update is cancelled. */
    479          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
   \      0x174   0xE595'1000        LDR      R1,[R5, #+0]
   \      0x178   0xE391'1F40        ORRS     R1,R1,#0x100
   \      0x17C   0xE585'1000        STR      R1,[R5, #+0]
    480          
    481          	/* 11. Wait for the lock bit to rise by polling the PMC_PLL_ISR0 or by enabling the corresponding interrupt
    482          	in PMC_PLL_IER. */
    483          	while ((PMC->PMC_PLL_ISR0 & (PMC_PLL_ISR0_LOCKA << plla->pll_id)) != (PMC_PLL_ISR0_LOCKA << plla->pll_id));
   \                     ??_pmc_configure_pll_6:
   \      0x180   0xE3A0'1001        MOV      R1,#+1
   \      0x184   0xE3E0'2013        MVN      R2,#+19
   \      0x188   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \      0x18C   0xE592'2000        LDR      R2,[R2, #+0]
   \      0x190   0xE594'300C        LDR      R3,[R4, #+12]
   \      0x194   0xE012'2311        ANDS     R2,R2,R1, LSL R3
   \      0x198   0xE594'300C        LDR      R3,[R4, #+12]
   \      0x19C   0xE152'0311        CMP      R2,R1, LSL R3
   \      0x1A0   0x1AFF'FFF6        BNE      ??_pmc_configure_pll_6
    484          
    485          	/* 12. Disable the interrupt (if enabled) */
    486          
    487          	/* 13. Enable the unlock interrupt to quickly detect a failure on the generation of the clock of the PLL. */
    488          	PMC->PMC_PLL_IER |= (PMC_PLL_IER_UNLOCKA << plla->pll_id);
   \      0x1A4   0xE3E0'101F        MVN      R1,#+31
   \      0x1A8   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \      0x1AC   0xE591'2000        LDR      R2,[R1, #+0]
   \      0x1B0   0xE3A0'3B40        MOV      R3,#+65536
   \      0x1B4   0xE594'C00C        LDR      R12,[R4, #+12]
   \      0x1B8   0xE192'2C13        ORRS     R2,R2,R3, LSL R12
   \      0x1BC   0xE581'2000        STR      R2,[R1, #+0]
    489          }
   \      0x1C0   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    490          

   \                                 In section SOFTPACK, align 4, keep-with-next
    491          RAMCODE static void _pmc_disable_pll(uint32_t pll_id)
    492          {
   \                     _pmc_disable_pll:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    493          	uint32_t reg;
    494          
    495          	if (pll_id == PLL_ID_PLLA) {
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x0A00'0009        BEQ      ??_pmc_disable_pll_0
    496          	} else if (pll_id == PLL_ID_UPLL){
   \       0x10   0xE354'0001        CMP      R4,#+1
   \       0x14   0x0A00'0007        BEQ      ??_pmc_disable_pll_0
    497          	} else {
    498          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
   \       0x18   0x....'....        LDR      R0,??DataTable18_2
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x0A00'0002        BEQ      ??_pmc_disable_pll_1
   \       0x28   0xE1B0'1004        MOVS     R1,R4
   \       0x2C   0x....'....        LDR      R0,??DataTable18_3
   \       0x30   0x....'....        BL       printf
   \                     ??_pmc_disable_pll_1:
   \       0x34   0xEAFF'FFFE        B        ??_pmc_disable_pll_1
    499          	}
    500          
    501          	/* To power-down a PLL, the following sequence must be applied: */
    502          	/* 1. If the PLL drives a section of the system that is active, modify the source clock of the system. */
    503          
    504          	/* 2. Define the ID (ID=n) of the PLL to be switched off in PMC_UPDT. The bit UPDATE in this register
    505          	must be set at 0 in this step. */
    506          	reg = PMC->PMC_PLL_UPDT;
   \                     ??_pmc_disable_pll_0:
   \       0x38   0xE3E0'20E3        MVN      R2,#+227
   \       0x3C   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \       0x40   0xE592'0000        LDR      R0,[R2, #+0]
    507          	reg &= ~(PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
   \       0x44   0xE3E0'1001        MVN      R1,#+1
   \       0x48   0xE3C1'1F40        BIC      R1,R1,#0x100
   \       0x4C   0xE011'0000        ANDS     R0,R1,R0
    508          	if (pll_id)
   \       0x50   0xE354'0000        CMP      R4,#+0
   \       0x54   0x0A00'0000        BEQ      ??_pmc_disable_pll_2
    509          		reg |= PMC_PLL_UPDT_ID;
   \       0x58   0xE390'0001        ORRS     R0,R0,#0x1
    510          	PMC->PMC_PLL_UPDT = reg;
   \                     ??_pmc_disable_pll_2:
   \       0x5C   0xE582'0000        STR      R0,[R2, #+0]
    511          
    512          	/* 3. In PMC_PLL_CTRL0, set ENPLLCK to 0 and leave ENPLL at '1'. */
    513          	reg = PMC->PMC_PLL_CTRL0 & (~PMC_PLL_CTRL0_ENPLLCK);
   \       0x60   0xE3E0'30F3        MVN      R3,#+243
   \       0x64   0xE3C3'3FC0        BIC      R3,R3,#0x300
   \       0x68   0xE593'1000        LDR      R1,[R3, #+0]
   \       0x6C   0xE3D1'1580        BICS     R1,R1,#0x20000000
    514          	PMC->PMC_PLL_CTRL0 = reg | PMC_PLL_CTRL0_ENPLL;
   \       0x70   0xE391'C540        ORRS     R12,R1,#0x10000000
   \       0x74   0xE583'C000        STR      R12,[R3, #+0]
    515          
    516          	/* 4. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    517          	2, else the update is cancelled. */
    518          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
   \       0x78   0xE592'C000        LDR      R12,[R2, #+0]
   \       0x7C   0xE39C'CF40        ORRS     R12,R12,#0x100
   \       0x80   0xE582'C000        STR      R12,[R2, #+0]
    519          
    520          	/* 5. Write a '0' to PMC_PLL_CTRL0.ENPLL. */
    521          	PMC->PMC_PLL_CTRL0 &= ~PMC_PLL_CTRL0_ENPLL;
   \       0x84   0xE593'2000        LDR      R2,[R3, #+0]
   \       0x88   0xE3D2'2540        BICS     R2,R2,#0x10000000
   \       0x8C   0xE583'2000        STR      R2,[R3, #+0]
    522          
    523          	/* 6. In case a UPLL is being powered down, write a '0' to PMC_PLL_ACR.UTMIBG and
    524          	PMC_PLL_ACR.UTMIVR. */
    525          	if (pll_id == PLL_ID_UPLL) {
   \       0x90   0xE354'0001        CMP      R4,#+1
   \       0x94   0x1A00'0005        BNE      ??_pmc_disable_pll_3
    526          		reg = PMC->PMC_PLL_ACR;
   \       0x98   0xE3E0'20E7        MVN      R2,#+231
   \       0x9C   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \       0xA0   0xE592'0000        LDR      R0,[R2, #+0]
    527          		reg &= ~(PMC_PLL_ACR_UTMIBG | PMC_PLL_ACR_UTMIVR);
   \       0xA4   0xE3D0'0DC0        BICS     R0,R0,#0x3000
   \       0xA8   0xE1B0'1000        MOVS     R1,R0
    528          		PMC->PMC_PLL_ACR = reg;
   \       0xAC   0xE582'1000        STR      R1,[R2, #+0]
    529          	}
    530          }
   \                     ??_pmc_disable_pll_3:
   \       0xB0   0xE8BD'8010        POP      {R4,PC}          ;; return
    531          

   \                                 In section SOFTPACK, align 4, keep-with-next
    532          static bool _pmc_pll_enabled(uint32_t pll_id)
    533          {
    534          	return (PMC->PMC_PLL_ISR0 & (1 << (pll_id & 0xf))) != 0;
   \                     _pmc_pll_enabled:
   \        0x0   0xE3E0'1013        MVN      R1,#+19
   \        0x4   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0x8   0xE591'1000        LDR      R1,[R1, #+0]
   \        0xC   0xE210'000F        ANDS     R0,R0,#0xF
   \       0x10   0xE1B0'0031        LSRS     R0,R1,R0
   \       0x14   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    535          }
    536          

   \                                 In section SOFTPACK, align 4, keep-with-next
    537          static void _pmc_get_pll_config(uint32_t pll_id, struct _pmc_plla_cfg *plla)
    538          {
   \                     _pmc_get_pll_config:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    539          #ifdef PMC_PLL_UPDT_ID_Msk
    540          	uint32_t pll_updt;
    541          
    542          	pll_updt = PMC->PMC_PLL_UPDT;
    543          	pll_updt = (pll_updt & ~PMC_PLL_UPDT_ID_Msk) | PMC_PLL_UPDT_ID(pll_id);
    544          	PMC->PMC_PLL_UPDT = pll_updt;
    545          #else
    546          	if (pll_id)
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x0A00'0005        BEQ      ??_pmc_get_pll_config_0
    547          		PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_ID;
   \       0x14   0xE3E0'00E3        MVN      R0,#+227
   \       0x18   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x1C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x20   0xE391'1001        ORRS     R1,R1,#0x1
   \       0x24   0xE580'1000        STR      R1,[R0, #+0]
   \       0x28   0xEA00'0004        B        ??_pmc_get_pll_config_1
    548          	else 
    549          		PMC->PMC_PLL_UPDT &= ~PMC_PLL_UPDT_ID;
   \                     ??_pmc_get_pll_config_0:
   \       0x2C   0xE3E0'00E3        MVN      R0,#+227
   \       0x30   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x34   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x38   0xE3D1'1001        BICS     R1,R1,#0x1
   \       0x3C   0xE580'1000        STR      R1,[R0, #+0]
    550          #endif
    551          
    552          	memset(plla, 0, sizeof(*plla));
   \                     ??_pmc_get_pll_config_1:
   \       0x40   0xE3A0'6018        MOV      R6,#+24
   \       0x44   0xE3A0'7000        MOV      R7,#+0
   \       0x48   0xE1B0'8005        MOVS     R8,R5
   \       0x4C   0xE1B0'2007        MOVS     R2,R7
   \       0x50   0xE1B0'1006        MOVS     R1,R6
   \       0x54   0xE1B0'0008        MOVS     R0,R8
   \       0x58   0x....'....        BL       __aeabi_memset
   \       0x5C   0xE1B0'0008        MOVS     R0,R8
    553          	plla->pll_id = pll_id;
   \       0x60   0xE585'400C        STR      R4,[R5, #+12]
    554          	plla->mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
   \       0x64   0xE3E0'00EF        MVN      R0,#+239
   \       0x68   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x6C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x70   0xE1B0'1C21        LSRS     R1,R1,#+24
   \       0x74   0xE585'1000        STR      R1,[R5, #+0]
    555          	plla->fracr = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_FRACR_Msk) >> PMC_PLL_CTRL1_FRACR_Pos;
   \       0x78   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x7C   0xE1B0'0500        LSLS     R0,R0,#+10
   \       0x80   0xE1B0'0520        LSRS     R0,R0,#+10
   \       0x84   0xE585'0010        STR      R0,[R5, #+16]
    556          	plla->div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
   \       0x88   0xE3E0'00F3        MVN      R0,#+243
   \       0x8C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x90   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x94   0xE210'00FF        ANDS     R0,R0,#0xFF
   \       0x98   0xE585'0004        STR      R0,[R5, #+4]
    557          
    558          #if defined(CONFIG_SOC_SAM9X60)
    559          	/*
    560          	 * On SAM9X60, the value of DIVPMC in PMC_PLL_CTRL0 is ignored for the
    561          	 * USB PLL as there is a fixed hardware divider of 2. Hence, we should
    562          	 * always consider that DIVPMC is actually read as 1, whatever its real
    563          	 * value.
    564          	 */
    565          	if (pll_id)
   \       0x9C   0xE354'0000        CMP      R4,#+0
   \       0xA0   0x0A00'0001        BEQ      ??_pmc_get_pll_config_2
    566          		plla->div = 1;
   \       0xA4   0xE3A0'0001        MOV      R0,#+1
   \       0xA8   0xE585'0004        STR      R0,[R5, #+4]
    567          #endif
    568          }
   \                     ??_pmc_get_pll_config_2:
   \       0xAC   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    569          

   \                                 In section SOFTPACK, align 4, keep-with-next
    570          static uint32_t _pmc_get_pll_clock(uint32_t pll_id)
    571          {
   \                     _pmc_get_pll_clock:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'4000        MOVS     R4,R0
    572          	struct _pmc_plla_cfg plla;
    573          	uint32_t f_core, f_ref;
    574          
    575          	if (pll_id == PLL_ID_PLLA) {
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0002        BNE      ??_pmc_get_pll_clock_0
    576          		f_ref = pmc_get_main_clock();
   \       0x14   0x....'....        BL       pmc_get_main_clock
   \       0x18   0xE1B0'5000        MOVS     R5,R0
   \       0x1C   0xEA00'000C        B        ??_pmc_get_pll_clock_1
    577          	} else if (pll_id == PLL_ID_UPLL){
   \                     ??_pmc_get_pll_clock_0:
   \       0x20   0xE354'0001        CMP      R4,#+1
   \       0x24   0x1A00'0002        BNE      ??_pmc_get_pll_clock_2
    578          		f_ref = pmc_get_main_oscillator_freq();
   \       0x28   0x....'....        BL       pmc_get_main_oscillator_freq
   \       0x2C   0xE1B0'5000        MOVS     R5,R0
   \       0x30   0xEA00'0007        B        ??_pmc_get_pll_clock_1
    579          	} else {
    580          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
   \                     ??_pmc_get_pll_clock_2:
   \       0x34   0x....'....        LDR      R0,??DataTable18_2
   \       0x38   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x3C   0xE350'0000        CMP      R0,#+0
   \       0x40   0x0A00'0002        BEQ      ??_pmc_get_pll_clock_3
   \       0x44   0xE1B0'1004        MOVS     R1,R4
   \       0x48   0x....'....        LDR      R0,??DataTable18_3
   \       0x4C   0x....'....        BL       printf
   \                     ??_pmc_get_pll_clock_3:
   \       0x50   0xEAFF'FFFE        B        ??_pmc_get_pll_clock_3
    581          	}
    582          
    583          	_pmc_get_pll_config(pll_id, &plla);
   \                     ??_pmc_get_pll_clock_1:
   \       0x54   0xE1B0'100D        MOVS     R1,SP
   \       0x58   0xE1B0'0004        MOVS     R0,R4
   \       0x5C   0x....'....        BL       _pmc_get_pll_config
    584          
    585          	f_core = f_ref * (plla.mul + 1) + (uint32_t)((((uint64_t)f_ref) * plla.fracr) >> 22);
   \       0x60   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x64   0xE290'2001        ADDS     R2,R0,#+1
   \       0x68   0xE59D'3010        LDR      R3,[SP, #+16]
   \       0x6C   0xE081'0395        UMULL    R0,R1,R5,R3
   \       0x70   0xE1B0'0B20        LSRS     R0,R0,#+22
   \       0x74   0xE180'0501        ORR      R0,R0,R1, LSL #+10
   \       0x78   0xE1B0'1B21        LSRS     R1,R1,#+22
   \       0x7C   0xE020'0592        MLA      R0,R2,R5,R0
    586          	return f_core / (plla.div + 1);
   \       0x80   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x84   0xE291'1001        ADDS     R1,R1,#+1
   \       0x88   0x....'....        BL       __aeabi_uidiv
   \       0x8C   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x90   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    587          }
    588          #endif /* PMC_PLL_UPDT_ID */
    589          
    590          /*----------------------------------------------------------------------------
    591           *        Exported functions (General)
    592           *----------------------------------------------------------------------------*/
    593          

   \                                 In section SOFTPACK, align 4, keep-with-next
    594          uint32_t pmc_set_main_oscillator_freq(uint32_t freq)
    595          {
   \                     pmc_set_main_oscillator_freq:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'5000        MOVS     R5,R0
    596          	uint32_t mor, mckr, mckr_mask;
    597          #ifdef CKGR_PLLAR_MULA_Msk
    598          	uint32_t pllar;
    599          #endif
    600          	uint16_t mainf_rc, mainf_xt = 0;
   \        0x8   0xE3A0'4000        MOV      R4,#+0
    601          
    602          	_pmc_main_oscillators.crystal_freq = freq;
   \        0xC   0x....'....        LDR      R6,??DataTable25
   \       0x10   0xE586'5004        STR      R5,[R6, #+4]
    603          	if (freq > 0)
   \       0x14   0xE355'0000        CMP      R5,#+0
   \       0x18   0x0A00'0001        BEQ      ??pmc_set_main_oscillator_freq_0
    604          		return freq;
   \       0x1C   0xE1B0'0005        MOVS     R0,R5
   \       0x20   0xEA00'006D        B        ??pmc_set_main_oscillator_freq_1
    605          
    606          	/*
    607          	 * Save the current value of the CKGR_MCKR register then swith to
    608          	 * the slow clock.
    609          	 */
    610          	mckr = PMC->PMC_MCKR;
   \                     ??pmc_set_main_oscillator_freq_0:
   \       0x24   0xE3E0'B0D7        MVN      R11,#+215
   \       0x28   0xE3CB'BFC0        BIC      R11,R11,#0x300
   \       0x2C   0xE59B'7000        LDR      R7,[R11, #+0]
    611          	pmc_switch_mck_to_slck();
   \       0x30   0x....'....        BL       pmc_switch_mck_to_slck
    612          	mckr_mask = PMC_MCKR_MDIV_Msk | PMC_MCKR_PRES_Msk;
   \       0x34   0xE3A0'8E77        MOV      R8,#+1904
    613          	PMC->PMC_MCKR &= ~mckr_mask;
   \       0x38   0xE59B'0000        LDR      R0,[R11, #+0]
   \       0x3C   0xE1D0'0008        BICS     R0,R0,R8
   \       0x40   0xE58B'0000        STR      R0,[R11, #+0]
    614          
    615          	/* Save the current value of the CKGR_MOR register. */
    616          	mor = PMC->CKGR_MOR;
   \       0x44   0xE3E0'00DF        MVN      R0,#+223
   \       0x48   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x4C   0xE590'9000        LDR      R9,[R0, #+0]
    617          
    618          #ifdef CKGR_PLLAR_MULA_Msk
    619          	/*
    620          	 * Save the current value of the CKGR_PLLAR register then stop this
    621          	 * PLL, if needed.
    622          	 */
    623          	pllar = PMC->CKGR_PLLAR;
    624          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk))
    625          		PMC->CKGR_PLLAR &= ~(CKGR_PLLAR_MULA_Msk | CKGR_PLLAR_DIVA_Msk);
    626          #endif
    627          
    628          	/* Switch to internal 12MHz RC, if needed. */
    629          	pmc_select_internal_osc();
   \       0x50   0x....'....        BL       pmc_select_internal_osc
    630          
    631          	/* Measure the 12MHz RC frequency. */
    632          	mainf_rc = _pmc_measure_main_osc_freq(false);
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0x....'....        BL       _pmc_measure_main_osc_freq
   \       0x5C   0xE1B0'A000        MOVS     R10,R0
    633          
    634          	/* Measure the crystal or by-pass frequency. */
    635          
    636          #ifdef CKGR_MOR_MOSCXTBY
    637          	/* Try by-pass first. */
    638          	if (pmc_select_external_osc(true) == 0)
    639          		mainf_xt = _pmc_measure_main_osc_freq(true);
    640          #endif /* CKGR_MOR_MOSCXTBY */
    641          
    642          	/* Then try external crytal if no by-pass. */
    643          	if (!mainf_xt) {
   \       0x60   0xE1B0'0004        MOVS     R0,R4
   \       0x64   0xE1A0'0800        LSL      R0,R0,#+16
   \       0x68   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x6C   0xE350'0000        CMP      R0,#+0
   \       0x70   0x1A00'0006        BNE      ??pmc_set_main_oscillator_freq_2
    644          		if (pmc_select_external_osc(false) == 0)
   \       0x74   0xE3A0'0000        MOV      R0,#+0
   \       0x78   0x....'....        BL       pmc_select_external_osc
   \       0x7C   0xE350'0000        CMP      R0,#+0
   \       0x80   0x1A00'0002        BNE      ??pmc_set_main_oscillator_freq_2
    645          			mainf_xt = _pmc_measure_main_osc_freq(true);
   \       0x84   0xE3A0'0001        MOV      R0,#+1
   \       0x88   0x....'....        BL       _pmc_measure_main_osc_freq
   \       0x8C   0xE1B0'4000        MOVS     R4,R0
    646          	}
    647          
    648          	/* Switch back to internal 12MHz RC if it was selected initially */
    649          	if (!(mor & CKGR_MOR_MOSCSEL))
   \                     ??pmc_set_main_oscillator_freq_2:
   \       0x90   0xE319'0740        TST      R9,#0x1000000
   \       0x94   0x1A00'0000        BNE      ??pmc_set_main_oscillator_freq_3
    650          		pmc_select_internal_osc();
   \       0x98   0x....'....        BL       pmc_select_internal_osc
    651          
    652          #ifdef CKGR_MOR_MOSCRCEN
    653          	/* Disable internal oscillator if it wasn't enabled initially */
    654          	if (!(mor & CKGR_MOR_MOSCRCEN))
   \                     ??pmc_set_main_oscillator_freq_3:
   \       0x9C   0xE319'0008        TST      R9,#0x8
   \       0xA0   0x1A00'0000        BNE      ??pmc_set_main_oscillator_freq_4
    655          		pmc_disable_internal_osc();
   \       0xA4   0x....'....        BL       pmc_disable_internal_osc
    656          #endif
    657          
    658          #ifdef CKGR_PLLAR_MULA_Msk
    659          	/* Restart the PLLA, if needed. */
    660          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk)) {
    661          		PMC->CKGR_PLLAR = pllar;
    662          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
    663          	}
    664          #endif
    665          
    666          	/* Switch back to the former MCK source. */
    667          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~mckr_mask) | (mckr & mckr_mask);
   \                     ??pmc_set_main_oscillator_freq_4:
   \       0xA8   0xE59B'0000        LDR      R0,[R11, #+0]
   \       0xAC   0xE1D0'0008        BICS     R0,R0,R8
   \       0xB0   0xE018'1007        ANDS     R1,R8,R7
   \       0xB4   0xE191'0000        ORRS     R0,R1,R0
   \       0xB8   0xE58B'0000        STR      R0,[R11, #+0]
    668          	pmc_switch_mck_to_new_source(mckr & PMC_MCKR_CSS_Msk);
   \       0xBC   0xE217'0003        ANDS     R0,R7,#0x3
   \       0xC0   0x....'....        BL       pmc_switch_mck_to_new_source
    669          
    670          	/* Guess the external crystal frequency, if available. */
    671          	if (mainf_rc && mainf_xt) {
   \       0xC4   0xE1B0'000A        MOVS     R0,R10
   \       0xC8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xCC   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xD0   0xE350'0000        CMP      R0,#+0
   \       0xD4   0x0A00'003F        BEQ      ??pmc_set_main_oscillator_freq_5
   \       0xD8   0xE1B0'0004        MOVS     R0,R4
   \       0xDC   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xE0   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xE4   0xE350'0000        CMP      R0,#+0
   \       0xE8   0x0A00'003A        BEQ      ??pmc_set_main_oscillator_freq_5
    672          		uint32_t ratio = (mainf_xt * 1000) / mainf_rc;
   \       0xEC   0xE1B0'0004        MOVS     R0,R4
   \       0xF0   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xF4   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xF8   0xE3A0'1FFA        MOV      R1,#+1000
   \       0xFC   0xE010'0091        MULS     R0,R1,R0
   \      0x100   0xE1B0'100A        MOVS     R1,R10
   \      0x104   0xE1A0'1801        LSL      R1,R1,#+16
   \      0x108   0xE1B0'1821        LSRS     R1,R1,#+16
   \      0x10C   0x....'....        BL       __aeabi_idiv
    673          
    674          		// Use 10% low and high margins
    675          		if (3600 <= ratio && ratio <= 4400) {
   \      0x110   0xE350'0EE1        CMP      R0,#+3600
   \      0x114   0x3A00'0007        BCC      ??pmc_set_main_oscillator_freq_6
   \      0x118   0xE3A0'1031        MOV      R1,#+49
   \      0x11C   0xE381'1D44        ORR      R1,R1,#0x1100
   \      0x120   0xE150'0001        CMP      R0,R1
   \      0x124   0x2A00'0003        BCS      ??pmc_set_main_oscillator_freq_6
    676          			// 48/12 => ratio = 4000
    677          			_pmc_main_oscillators.crystal_freq = 48000000u;
   \      0x128   0xE3A0'17B7        MOV      R1,#+47972352
   \      0x12C   0xE381'1C6C        ORR      R1,R1,#0x6C00
   \      0x130   0xE586'1004        STR      R1,[R6, #+4]
   \      0x134   0xEA00'0027        B        ??pmc_set_main_oscillator_freq_5
    678          		} else if (1800 <= ratio && ratio <= 2200) {
   \                     ??pmc_set_main_oscillator_freq_6:
   \      0x138   0xE3A0'1008        MOV      R1,#+8
   \      0x13C   0xE381'1E70        ORR      R1,R1,#0x700
   \      0x140   0xE150'0001        CMP      R0,R1
   \      0x144   0x3A00'0006        BCC      ??pmc_set_main_oscillator_freq_7
   \      0x148   0xE3A0'1099        MOV      R1,#+153
   \      0x14C   0xE381'1E80        ORR      R1,R1,#0x800
   \      0x150   0xE150'0001        CMP      R0,R1
   \      0x154   0x2A00'0002        BCS      ??pmc_set_main_oscillator_freq_7
    679          			// 24/12 => ratio = 2000
    680          			_pmc_main_oscillators.crystal_freq = 24000000u;
   \      0x158   0x....'....        LDR      R1,??DataTable29  ;; 0x16e3600
   \      0x15C   0xE586'1004        STR      R1,[R6, #+4]
   \      0x160   0xEA00'001C        B        ??pmc_set_main_oscillator_freq_5
    681          		} else if (1200 <= ratio && ratio <= 1467) {
   \                     ??pmc_set_main_oscillator_freq_7:
   \      0x164   0xE350'0E4B        CMP      R0,#+1200
   \      0x168   0x3A00'0007        BCC      ??pmc_set_main_oscillator_freq_8
   \      0x16C   0xE3A0'10BC        MOV      R1,#+188
   \      0x170   0xE381'1E50        ORR      R1,R1,#0x500
   \      0x174   0xE150'0001        CMP      R0,R1
   \      0x178   0x2A00'0003        BCS      ??pmc_set_main_oscillator_freq_8
    682          			// 16/12 => ratio = 1333
    683          			_pmc_main_oscillators.crystal_freq = 16000000u;
   \      0x17C   0xE3A0'18F4        MOV      R1,#+15990784
   \      0x180   0xE381'1D90        ORR      R1,R1,#0x2400
   \      0x184   0xE586'1004        STR      R1,[R6, #+4]
   \      0x188   0xEA00'0012        B        ??pmc_set_main_oscillator_freq_5
    684          		} else if (900 <= ratio && ratio <= 1100) {
   \                     ??pmc_set_main_oscillator_freq_8:
   \      0x18C   0xE350'0FE1        CMP      R0,#+900
   \      0x190   0x3A00'0007        BCC      ??pmc_set_main_oscillator_freq_9
   \      0x194   0xE3A0'104D        MOV      R1,#+77
   \      0x198   0xE381'1E40        ORR      R1,R1,#0x400
   \      0x19C   0xE150'0001        CMP      R0,R1
   \      0x1A0   0x2A00'0003        BCS      ??pmc_set_main_oscillator_freq_9
    685          			// 12/12 => ratio = 1000
    686          			_pmc_main_oscillators.crystal_freq = 12000000u;
   \      0x1A4   0xE3A0'18B7        MOV      R1,#+11993088
   \      0x1A8   0xE381'1D6C        ORR      R1,R1,#0x1B00
   \      0x1AC   0xE586'1004        STR      R1,[R6, #+4]
   \      0x1B0   0xEA00'0008        B        ??pmc_set_main_oscillator_freq_5
    687          		} else if (600 <= ratio && ratio <= 733) {
   \                     ??pmc_set_main_oscillator_freq_9:
   \      0x1B4   0xE350'0F96        CMP      R0,#+600
   \      0x1B8   0x3A00'0006        BCC      ??pmc_set_main_oscillator_freq_5
   \      0x1BC   0xE3A0'10DE        MOV      R1,#+222
   \      0x1C0   0xE381'1F80        ORR      R1,R1,#0x200
   \      0x1C4   0xE150'0001        CMP      R0,R1
   \      0x1C8   0x2A00'0002        BCS      ??pmc_set_main_oscillator_freq_5
    688          			// 8/12 => ratio = 667
    689          			_pmc_main_oscillators.crystal_freq = 8000000u;
   \      0x1CC   0xE3A0'187A        MOV      R1,#+7995392
   \      0x1D0   0xE381'1D48        ORR      R1,R1,#0x1200
   \      0x1D4   0xE586'1004        STR      R1,[R6, #+4]
    690          		}
    691          	}
    692          
    693          	return _pmc_main_oscillators.crystal_freq;
   \                     ??pmc_set_main_oscillator_freq_5:
   \      0x1D8   0xE596'0004        LDR      R0,[R6, #+4]
   \                     ??pmc_set_main_oscillator_freq_1:
   \      0x1DC   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    694          }
    695          

   \                                 In section SOFTPACK, align 4, keep-with-next
    696          uint32_t pmc_get_main_oscillator_freq(void)
    697          {
   \                     pmc_get_main_oscillator_freq:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    698          	if (_pmc_main_oscillators.crystal_freq > 0)
   \        0x4   0x....'....        LDR      R0,??DataTable25
   \        0x8   0xE590'1004        LDR      R1,[R0, #+4]
   \        0xC   0xE351'0000        CMP      R1,#+0
   \       0x10   0x0A00'0001        BEQ      ??pmc_get_main_oscillator_freq_0
    699          		return _pmc_main_oscillators.crystal_freq;
   \       0x14   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x18   0xEA00'0001        B        ??pmc_get_main_oscillator_freq_1
    700          	else
    701          		return pmc_set_main_oscillator_freq(0);
   \                     ??pmc_get_main_oscillator_freq_0:
   \       0x1C   0xE3A0'0000        MOV      R0,#+0
   \       0x20   0x....'....        BL       pmc_set_main_oscillator_freq
   \                     ??pmc_get_main_oscillator_freq_1:
   \       0x24   0xE8BD'8002        POP      {R1,PC}          ;; return
    702          }
    703          

   \                                 In section SOFTPACK, align 4, keep-with-next
    704          uint32_t pmc_get_master_clock(void)
    705          {
   \                     pmc_get_master_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    706          	if (!_pmc_mck)
   \        0x4   0x....'....        LDR      R4,??DataTable16
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'0000        BNE      ??pmc_get_master_clock_0
    707          		_pmc_compute_mck();
   \       0x14   0x....'....        BL       _pmc_compute_mck
    708          	return _pmc_mck;
   \                     ??pmc_get_master_clock_0:
   \       0x18   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x1C   0xE8BD'8010        POP      {R4,PC}          ;; return
    709          }
    710          

   \                                 In section SOFTPACK, align 4, keep-with-next
    711          uint32_t pmc_get_slow_clock(void)
    712          {
   \                     pmc_get_slow_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    713          	return slowclock_get_clock(SLOWCLOCK_DOMAIN_DEFAULT);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        BL       slowclock_get_clock
   \        0xC   0xE8BD'8002        POP      {R1,PC}          ;; return
    714          }
    715          

   \                                 In section SOFTPACK, align 4, keep-with-next
    716          uint32_t pmc_get_main_clock(void)
    717          {
    718          	if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)
   \                     pmc_get_main_clock:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'0000        LDR      R0,[R0, #+0]
   \        0xC   0xE310'0740        TST      R0,#0x1000000
   \       0x10   0x0A00'0002        BEQ      ??pmc_get_main_clock_0
    719          		return _pmc_main_oscillators.crystal_freq; /* external crystal */
   \       0x14   0x....'....        LDR      R0,??DataTable25
   \       0x18   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x1C   0xEA00'0001        B        ??pmc_get_main_clock_1
    720          	else
    721          		return _pmc_main_oscillators.rc_freq; /* on-chip main clock RC */
   \                     ??pmc_get_main_clock_0:
   \       0x20   0x....'....        LDR      R0,??DataTable25
   \       0x24   0xE590'0000        LDR      R0,[R0, #+0]
   \                     ??pmc_get_main_clock_1:
   \       0x28   0xE12F'FF1E        BX       LR               ;; return
    722          }
    723          

   \                                 In section SOFTPACK, align 4, keep-with-next
    724          uint32_t pmc_get_plla_clock(void)
    725          {
   \                     pmc_get_plla_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    726          #if defined(PMC_PLL_UPDT_ID)
    727          	return _pmc_get_pll_clock(PLL_ID_PLLA);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        BL       _pmc_get_pll_clock
   \        0xC   0xE8BD'8002        POP      {R1,PC}          ;; return
    728          #elif defined(CKGR_PLLAR_DIVA_Pos)
    729          	uint32_t pllaclk, pllar, pllmula, plldiva;
    730          
    731          	pllar = PMC->CKGR_PLLAR;
    732          	pllmula = (pllar & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
    733          	plldiva = (pllar & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
    734          	if (plldiva == 0 || pllmula == 0)
    735          		return 0;
    736          
    737          	pllaclk = pmc_get_main_clock();
    738          	pllaclk = pllaclk * (pllmula + 1) / plldiva;
    739          #ifdef CONFIG_HAVE_PMC_PLLADIV2
    740          	if (PMC->PMC_MCKR & PMC_MCKR_PLLADIV2)
    741          		pllaclk >>= 1;
    742          #endif
    743          	return pllaclk;
    744          #endif
    745          }
    746          

   \                                 In section SOFTPACK, align 4, keep-with-next
    747          uint32_t pmc_get_processor_clock(void)
    748          {
   \                     pmc_get_processor_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    749          	uint32_t procclk, mdiv;
    750          
    751          	procclk = pmc_get_master_clock();
   \        0x4   0x....'....        BL       pmc_get_master_clock
    752          
    753          	mdiv = PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk;
   \        0x8   0xE3E0'10D7        MVN      R1,#+215
   \        0xC   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x10   0xE591'1000        LDR      R1,[R1, #+0]
   \       0x14   0xE211'1E70        ANDS     R1,R1,#0x700
    754          	switch (mdiv) {
   \       0x18   0xE1B0'2001        MOVS     R2,R1
   \       0x1C   0xE352'0000        CMP      R2,#+0
   \       0x20   0x0A00'0006        BEQ      ??pmc_get_processor_clock_0
   \       0x24   0xE352'0F40        CMP      R2,#+256
   \       0x28   0x0A00'0005        BEQ      ??pmc_get_processor_clock_1
   \       0x2C   0xE352'0F80        CMP      R2,#+512
   \       0x30   0x0A00'0007        BEQ      ??pmc_get_processor_clock_2
   \       0x34   0xE352'0FC0        CMP      R2,#+768
   \       0x38   0x0A00'0003        BEQ      ??pmc_get_processor_clock_3
   \       0x3C   0xEA00'0006        B        ??pmc_get_processor_clock_4
    755          	case PMC_MCKR_MDIV_EQ_PCK:
    756          		break;
   \                     ??pmc_get_processor_clock_0:
   \       0x40   0xEA00'0005        B        ??pmc_get_processor_clock_5
    757          	case PMC_MCKR_MDIV_PCK_DIV2:
    758          		procclk <<= 1; // multiply by 2
   \                     ??pmc_get_processor_clock_1:
   \       0x44   0xE1B0'0080        LSLS     R0,R0,#+1
    759          		break;
   \       0x48   0xEA00'0003        B        ??pmc_get_processor_clock_5
    760          	case PMC_MCKR_MDIV_PCK_DIV3:
    761          		procclk *= 3;  // multiply by 3
   \                     ??pmc_get_processor_clock_3:
   \       0x4C   0xE080'0080        ADD      R0,R0,R0, LSL #+1
    762          		break;
   \       0x50   0xEA00'0001        B        ??pmc_get_processor_clock_5
    763          	case PMC_MCKR_MDIV_PCK_DIV4:
    764          		procclk <<= 2; // multiply by 4
   \                     ??pmc_get_processor_clock_2:
   \       0x54   0xE1B0'0100        LSLS     R0,R0,#+2
    765          		break;
   \       0x58   0xEAFF'FFFF        B        ??pmc_get_processor_clock_5
    766          	default:
    767          		/* should never get here... */
    768          		break;
    769          	}
    770          
    771          	return procclk;
   \                     ??pmc_get_processor_clock_4:
   \                     ??pmc_get_processor_clock_5:
   \       0x5C   0xE8BD'8002        POP      {R1,PC}          ;; return
    772          }
    773          

   \                                 In section SOFTPACK, align 4, keep-with-next
    774          RAMCODE void pmc_select_external_crystal(void)
    775          {
   \                     pmc_select_external_crystal:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    776          	bool return_to_slck = false;
   \        0x4   0xE3A0'4000        MOV      R4,#+0
    777          
    778          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \        0x8   0xE3E0'00D7        MVN      R0,#+215
   \        0xC   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x10   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x1A00'0002        BNE      ??pmc_select_external_crystal_0
    779          		pmc_switch_mck_to_main();
   \       0x1C   0x....'....        BL       pmc_switch_mck_to_main
    780          		return_to_slck = true;
   \       0x20   0xE3A0'0001        MOV      R0,#+1
   \       0x24   0xE1B0'4000        MOVS     R4,R0
    781          	}
    782          
    783          	slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_external_crystal_0:
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x....'....        BL       slowclock_select_external
    784          
    785          	/* Switch to slow clock again if needed */
    786          	if (return_to_slck)
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x0A00'0000        BEQ      ??pmc_select_external_crystal_1
    787          		pmc_switch_mck_to_slck();
   \       0x40   0x....'....        BL       pmc_switch_mck_to_slck
    788          }
   \                     ??pmc_select_external_crystal_1:
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
    789          

   \                                 In section SOFTPACK, align 4, keep-with-next
    790          RAMCODE void pmc_select_internal_crystal(void)
    791          {
   \                     pmc_select_internal_crystal:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    792          	bool return_to_slck = false;
   \        0x4   0xE3A0'4000        MOV      R4,#+0
    793          
    794          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \        0x8   0xE3E0'00D7        MVN      R0,#+215
   \        0xC   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x10   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x1A00'0002        BNE      ??pmc_select_internal_crystal_0
    795          		pmc_switch_mck_to_main();
   \       0x1C   0x....'....        BL       pmc_switch_mck_to_main
    796          		return_to_slck = true;
   \       0x20   0xE3A0'0001        MOV      R0,#+1
   \       0x24   0xE1B0'4000        MOVS     R4,R0
    797          	}
    798          
    799          	slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_internal_crystal_0:
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x....'....        BL       slowclock_select_internal
    800          
    801          	/* Switch to slow clock again if needed */
    802          	if (return_to_slck)
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x0A00'0000        BEQ      ??pmc_select_internal_crystal_1
    803          		pmc_switch_mck_to_slck();
   \       0x40   0x....'....        BL       pmc_switch_mck_to_slck
    804          }
   \                     ??pmc_select_internal_crystal_1:
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
    805          

   \                                 In section SOFTPACK, align 4, keep-with-next
    806          RAMCODE int pmc_select_external_osc(bool bypass)
    807          {
   \                     pmc_select_external_osc:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    808          	int err;
    809          	volatile uint32_t timeout;
    810          
    811          	/* Return if external oscillator had been selected */
    812          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \        0x8   0xE3E0'50DF        MVN      R5,#+223
   \        0xC   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x10   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x14   0xE310'0740        TST      R0,#0x1000000
   \       0x18   0x0A00'0006        BEQ      ??pmc_select_external_osc_0
    813          #ifdef CKGR_MOR_MOSCXTBY
    814          		uint32_t mask = bypass ? CKGR_MOR_MOSCXTBY : CKGR_MOR_MOSCXTEN;
    815          #else
    816          		uint32_t mask = CKGR_MOR_MOSCXTEN;
   \       0x1C   0xE3A0'1001        MOV      R1,#+1
    817          #endif  /* CKGR_MOR_MOSCXTBY */
    818          		if ((PMC->CKGR_MOR & mask) == mask)
   \       0x20   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x24   0xE011'0000        ANDS     R0,R1,R0
   \       0x28   0xE150'0001        CMP      R0,R1
   \       0x2C   0x1A00'0001        BNE      ??pmc_select_external_osc_0
    819          			return 0;
   \       0x30   0xE3A0'0000        MOV      R0,#+0
   \       0x34   0xEA00'0034        B        ??pmc_select_external_osc_1
    820          	}
    821          
    822          	/*
    823          	 * When switching the source of the main clock between the RC oscillator and the crystal
    824          	 * oscillator, both oscillators must be enabled. After completion of the switch, the
    825          	 * unused oscillator can be disabled.
    826          	 */
    827          	pmc_enable_internal_osc();
   \                     ??pmc_select_external_osc_0:
   \       0x38   0x....'....        BL       pmc_enable_internal_osc
    828          	err = pmc_enable_external_osc(bypass);
   \       0x3C   0xE1B0'0004        MOVS     R0,R4
   \       0x40   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x44   0x....'....        BL       pmc_enable_external_osc
   \       0x48   0xE1B0'6000        MOVS     R6,R0
    829          	if (err < 0)
   \       0x4C   0xE356'0000        CMP      R6,#+0
   \       0x50   0x5A00'0001        BPL      ??pmc_select_external_osc_2
    830          		return err;
   \       0x54   0xE1B0'0006        MOVS     R0,R6
   \       0x58   0xEA00'002B        B        ??pmc_select_external_osc_1
    831          
    832          	/* switch MAIN clock to external oscillator */
    833          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCSEL
    834          	    | CKGR_MOR_KEY_PASSWD;
   \                     ??pmc_select_external_osc_2:
   \       0x5C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x60   0xE3D0'08FF        BICS     R0,R0,#0xFF0000
   \       0x64   0xE390'09DC        ORRS     R0,R0,#0x370000
   \       0x68   0xE390'0740        ORRS     R0,R0,#0x1000000
   \       0x6C   0xE585'0000        STR      R0,[R5, #+0]
    835          
    836          	/* wait for the command to be taken into account */
    837          	while ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) != CKGR_MOR_MOSCSEL);
   \                     ??pmc_select_external_osc_3:
   \       0x70   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x74   0xE310'0740        TST      R0,#0x1000000
   \       0x78   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_3
    838          
    839          	/* wait MAIN clock status change for external oscillator selection */
    840          	timeout = MOSCSELS_TIMEOUT;
   \       0x7C   0xE3A0'0020        MOV      R0,#+32
   \       0x80   0xE58D'0000        STR      R0,[SP, #+0]
    841          	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS) && --timeout > 0);
   \                     ??pmc_select_external_osc_4:
   \       0x84   0xE3E0'0097        MVN      R0,#+151
   \       0x88   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x8C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x90   0xE311'0B40        TST      R1,#0x10000
   \       0x94   0x1A00'0004        BNE      ??pmc_select_external_osc_5
   \       0x98   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x9C   0xE251'1001        SUBS     R1,R1,#+1
   \       0xA0   0xE58D'1000        STR      R1,[SP, #+0]
   \       0xA4   0xE351'0000        CMP      R1,#+0
   \       0xA8   0x1AFF'FFF5        BNE      ??pmc_select_external_osc_4
    842          	if (!timeout) {
   \                     ??pmc_select_external_osc_5:
   \       0xAC   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xB0   0xE351'0000        CMP      R1,#+0
   \       0xB4   0x1A00'0007        BNE      ??pmc_select_external_osc_6
    843          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk))
    844          			| CKGR_MOR_KEY_PASSWD;
   \       0xB8   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xBC   0xE3E0'1740        MVN      R1,#+16777216
   \       0xC0   0xE3C1'18FF        BIC      R1,R1,#0xFF0000
   \       0xC4   0xE011'0000        ANDS     R0,R1,R0
   \       0xC8   0xE390'09DC        ORRS     R0,R0,#0x370000
   \       0xCC   0xE585'0000        STR      R0,[R5, #+0]
    845          		return -ETIMEDOUT;
   \       0xD0   0xE3E0'004C        MVN      R0,#+76
   \       0xD4   0xEA00'000C        B        ??pmc_select_external_osc_1
    846          	}
    847          
    848          	/* in case where MCK is running on MAIN CLK */
    849          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \                     ??pmc_select_external_osc_6:
   \       0xD8   0xE3E0'10D7        MVN      R1,#+215
   \       0xDC   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0xE0   0xE591'2000        LDR      R2,[R1, #+0]
   \       0xE4   0xE312'0002        TST      R2,#0x2
   \       0xE8   0x1A00'0002        BNE      ??pmc_select_external_osc_7
   \       0xEC   0xE591'1000        LDR      R1,[R1, #+0]
   \       0xF0   0xE311'0001        TST      R1,#0x1
   \       0xF4   0x0A00'0002        BEQ      ??pmc_select_external_osc_8
    850          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_external_osc_7:
   \       0xF8   0xE590'1000        LDR      R1,[R0, #+0]
   \       0xFC   0xE311'0008        TST      R1,#0x8
   \      0x100   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_7
    851          
    852          	/* disable internal 12MHz RC to save power */
    853          	pmc_disable_internal_osc();
   \                     ??pmc_select_external_osc_8:
   \      0x104   0x....'....        BL       pmc_disable_internal_osc
    854          
    855          	return 0;
   \      0x108   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_select_external_osc_1:
   \      0x10C   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
    856          }
    857          

   \                                 In section SOFTPACK, align 4, keep-with-next
    858          RAMCODE int pmc_enable_external_osc(bool bypass)
    859          {
   \                     pmc_enable_external_osc:
   \        0x0   0xE24D'D004        SUB      SP,SP,#+4
   \        0x4   0xE1B0'1000        MOVS     R1,R0
    860          	uint32_t cgmor = PMC->CKGR_MOR;
   \        0x8   0xE3E0'C0DF        MVN      R12,#+223
   \        0xC   0xE3CC'CFC0        BIC      R12,R12,#0x300
   \       0x10   0xE59C'3000        LDR      R3,[R12, #+0]
    861          	uint32_t mask = CKGR_MOR_MOSCXTEN;
   \       0x14   0xE3A0'2001        MOV      R2,#+1
    862          	volatile uint32_t timeout;
    863          
    864          #ifdef CKGR_MOR_MOSCXTBY
    865          	if (bypass)
    866          		mask = CKGR_MOR_MOSCXTBY;
    867          #else
    868          	(void)bypass;
    869          #endif /* CKGR_MOR_MOSCXTBY */
    870          
    871          	/* Enable Crystal Oscillator if needed */
    872          	if ((cgmor & mask) != mask) {
   \       0x18   0xE012'0003        ANDS     R0,R2,R3
   \       0x1C   0xE150'0002        CMP      R0,R2
   \       0x20   0x0A00'0019        BEQ      ??pmc_enable_external_osc_0
    873          		cgmor &= ~CKGR_MOR_KEY_Msk;
   \       0x24   0xE3D3'08FF        BICS     R0,R3,#0xFF0000
    874          		cgmor |= CKGR_MOR_KEY_PASSWD;
   \       0x28   0xE390'09DC        ORRS     R0,R0,#0x370000
    875          
    876          #ifdef CKGR_MOR_MOSCXTBY
    877          		if (bypass) {
    878          			/* Disable Crystal Oscillator */
    879          			cgmor &= ~CKGR_MOR_MOSCXTEN;
    880          			PMC->CKGR_MOR = cgmor;
    881          
    882          			/* Wait Main Oscillator not ready */
    883          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
    884          
    885          			/* Enable Crystal Oscillator Bypass */
    886          			cgmor |= CKGR_MOR_MOSCXTBY;
    887          			PMC->CKGR_MOR = cgmor;
    888          		} else {
    889          			/* Disable Crystal Oscillator Bypass */
    890          			cgmor &= ~CKGR_MOR_MOSCXTBY;
    891          			PMC->CKGR_MOR = cgmor;
    892          
    893          			/* Wait Main Oscillator not ready */
    894          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
    895          
    896          			/* Set Oscillator Startup Time */
    897          			cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
    898          			cgmor |= CKGR_MOR_MOSCXTST(18);
    899          			PMC->CKGR_MOR = cgmor;
    900          
    901          			/* Enable Crystal Oscillator */
    902          			cgmor |= CKGR_MOR_MOSCXTEN;
    903          			PMC->CKGR_MOR = cgmor;
    904          		}
    905          #else
    906          		/* Set Oscillator Startup Time */
    907          		cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
   \       0x2C   0xE3D0'0CFF        BICS     R0,R0,#0xFF00
    908          		cgmor |= CKGR_MOR_MOSCXTST(18);
   \       0x30   0xE390'0D48        ORRS     R0,R0,#0x1200
    909          		PMC->CKGR_MOR = cgmor;
   \       0x34   0xE58C'0000        STR      R0,[R12, #+0]
    910          
    911          		/* Enable Crystal Oscillator */
    912          		cgmor |= CKGR_MOR_MOSCXTEN;
   \       0x38   0xE390'0001        ORRS     R0,R0,#0x1
    913          		PMC->CKGR_MOR = cgmor;
   \       0x3C   0xE58C'0000        STR      R0,[R12, #+0]
    914          #endif /* CKGR_MOR_MOSCXTBY */
    915          
    916          		/* Wait Main Oscillator ready */
    917          		timeout = MOSCXTS_TIMEOUT;
   \       0x40   0xE3A0'3E80        MOV      R3,#+2048
   \       0x44   0xE58D'3000        STR      R3,[SP, #+0]
    918          		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS) && --timeout > 0);
   \                     ??pmc_enable_external_osc_1:
   \       0x48   0xE3E0'3097        MVN      R3,#+151
   \       0x4C   0xE3C3'3FC0        BIC      R3,R3,#0x300
   \       0x50   0xE593'3000        LDR      R3,[R3, #+0]
   \       0x54   0xE313'0001        TST      R3,#0x1
   \       0x58   0x1A00'0004        BNE      ??pmc_enable_external_osc_2
   \       0x5C   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x60   0xE253'3001        SUBS     R3,R3,#+1
   \       0x64   0xE58D'3000        STR      R3,[SP, #+0]
   \       0x68   0xE353'0000        CMP      R3,#+0
   \       0x6C   0x1AFF'FFF5        BNE      ??pmc_enable_external_osc_1
    919          
    920          		/* Return true if oscillator ready before timeout */
    921          		return timeout == 0 ? -ETIMEDOUT : 0;
   \                     ??pmc_enable_external_osc_2:
   \       0x70   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x74   0xE353'0000        CMP      R3,#+0
   \       0x78   0x1A00'0001        BNE      ??pmc_enable_external_osc_3
   \       0x7C   0xE3E0'004C        MVN      R0,#+76
   \       0x80   0xEA00'0000        B        ??pmc_enable_external_osc_4
   \                     ??pmc_enable_external_osc_3:
   \       0x84   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_enable_external_osc_4:
   \       0x88   0xEA00'0007        B        ??pmc_enable_external_osc_5
    922          	} else {
    923          		/* Crystal Oscillator already selected, just check if ready */
    924          		if (PMC->PMC_SR & PMC_SR_MOSCXTS)
   \                     ??pmc_enable_external_osc_0:
   \       0x8C   0xE3E0'0097        MVN      R0,#+151
   \       0x90   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x94   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x98   0xE310'0001        TST      R0,#0x1
   \       0x9C   0x0A00'0001        BEQ      ??pmc_enable_external_osc_6
    925          			return 0;
   \       0xA0   0xE3A0'0000        MOV      R0,#+0
   \       0xA4   0xEA00'0000        B        ??pmc_enable_external_osc_5
    926          		else
    927          			return -ENOTSUP;
   \                     ??pmc_enable_external_osc_6:
   \       0xA8   0xE3E0'003C        MVN      R0,#+60
   \                     ??pmc_enable_external_osc_5:
   \       0xAC   0xE28D'D004        ADD      SP,SP,#+4
   \       0xB0   0xE12F'FF1E        BX       LR               ;; return
    928          	}
    929          }
    930          

   \                                 In section SOFTPACK, align 4, keep-with-next
    931          RAMCODE void pmc_disable_external_osc(void)
    932          {
    933          #ifdef CKGR_MOR_MOSCXTBY
    934          	uint32_t mask = CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTBY;
    935          #else
    936          	uint32_t mask = CKGR_MOR_MOSCXTEN;
   \                     pmc_disable_external_osc:
   \        0x0   0xE3A0'0001        MOV      R0,#+1
    937          #endif /* CKGR_MOR_MOSCXTBY */
    938          
    939          	/* disable external OSC */
    940          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \        0x4   0xE3E0'10DF        MVN      R1,#+223
   \        0x8   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0xC   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x10   0xE3E0'3740        MVN      R3,#+16777216
   \       0x14   0xE3C3'38FF        BIC      R3,R3,#0xFF0000
   \       0x18   0xE013'2002        ANDS     R2,R3,R2
   \       0x1C   0xE392'29DC        ORRS     R2,R2,#0x370000
   \       0x20   0xE581'2000        STR      R2,[R1, #+0]
    941          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(mask | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \       0x24   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x28   0xE390'38FF        ORRS     R3,R0,#0xFF0000
   \       0x2C   0xE1D2'2003        BICS     R2,R2,R3
   \       0x30   0xE392'29DC        ORRS     R2,R2,#0x370000
   \       0x34   0xE581'2000        STR      R2,[R1, #+0]
    942          }
   \       0x38   0xE12F'FF1E        BX       LR               ;; return
    943          

   \                                 In section SOFTPACK, align 4, keep-with-next
    944          RAMCODE void pmc_select_internal_osc(void)
    945          {
   \                     pmc_select_internal_osc:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    946          	pmc_enable_internal_osc();
   \        0x4   0x....'....        BL       pmc_enable_internal_osc
    947          
    948          	/* switch MAIN clock to internal 12MHz RC */
    949          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \        0x8   0xE3E0'00DF        MVN      R0,#+223
   \        0xC   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x10   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x14   0xE3E0'2740        MVN      R2,#+16777216
   \       0x18   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \       0x1C   0xE012'1001        ANDS     R1,R2,R1
   \       0x20   0xE391'19DC        ORRS     R1,R1,#0x370000
   \       0x24   0xE580'1000        STR      R1,[R0, #+0]
    950          
    951          	/* in case where MCK is running on MAIN CLK */
    952          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \       0x28   0xE3E0'00D7        MVN      R0,#+215
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x34   0xE311'0002        TST      R1,#0x2
   \       0x38   0x1A00'0002        BNE      ??pmc_select_internal_osc_0
   \       0x3C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x40   0xE310'0001        TST      R0,#0x1
   \       0x44   0x0A00'0004        BEQ      ??pmc_select_internal_osc_1
    953          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_internal_osc_0:
   \       0x48   0xE3E0'0097        MVN      R0,#+151
   \       0x4C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x50   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x54   0xE310'0008        TST      R0,#0x8
   \       0x58   0x0AFF'FFFA        BEQ      ??pmc_select_internal_osc_0
    954          
    955          	/* disable external OSC 12 MHz to save power*/
    956          	pmc_disable_external_osc();
   \                     ??pmc_select_internal_osc_1:
   \       0x5C   0x....'....        BL       pmc_disable_external_osc
    957          }
   \       0x60   0xE8BD'8001        POP      {R0,PC}          ;; return
    958          

   \                                 In section SOFTPACK, align 4, keep-with-next
    959          RAMCODE void pmc_enable_internal_osc(void)
    960          {
    961          #ifdef CKGR_MOR_MOSCRCEN
    962          	/* Enable internal 12MHz RC when needed */
    963          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCRCEN) != CKGR_MOR_MOSCRCEN) {
   \                     pmc_enable_internal_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE311'0008        TST      R1,#0x8
   \       0x10   0x1A00'0009        BNE      ??pmc_enable_internal_osc_0
    964          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCRCEN | CKGR_MOR_KEY_PASSWD;
   \       0x14   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x18   0xE3D1'18FF        BICS     R1,R1,#0xFF0000
   \       0x1C   0xE391'1008        ORRS     R1,R1,#0x8
   \       0x20   0xE391'19DC        ORRS     R1,R1,#0x370000
   \       0x24   0xE580'1000        STR      R1,[R0, #+0]
    965          		/* Wait internal 12MHz RC Startup Time for clock stabilization */
    966          		while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
   \                     ??pmc_enable_internal_osc_1:
   \       0x28   0xE3E0'0097        MVN      R0,#+151
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x34   0xE310'0B80        TST      R0,#0x20000
   \       0x38   0x0AFF'FFFA        BEQ      ??pmc_enable_internal_osc_1
    967          	}
    968          #endif
    969          }
   \                     ??pmc_enable_internal_osc_0:
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
    970          

   \                                 In section SOFTPACK, align 4, keep-with-next
    971          RAMCODE void pmc_disable_internal_osc(void)
    972          {
    973          #ifdef CKGR_MOR_MOSCRCEN
    974          	/* disable internal 12MHz RC */
    975          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_KEY_PASSWD;
   \                     pmc_disable_internal_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3E0'2008        MVN      R2,#+8
   \       0x10   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \       0x14   0xE012'1001        ANDS     R1,R2,R1
   \       0x18   0xE391'19DC        ORRS     R1,R1,#0x370000
   \       0x1C   0xE580'1000        STR      R1,[R0, #+0]
    976          #endif
    977          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
    978          

   \                                 In section SOFTPACK, align 4, keep-with-next
    979          RAMCODE void pmc_enable_ulp1(void)
    980          {
    981          #ifdef CKGR_MOR_ULP1
    982          	/* enable ulp1 mode */
    983          	PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_ULP1 | CKGR_MOR_KEY_PASSWD;
   \                     pmc_enable_ulp1:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE391'1004        ORRS     R1,R1,#0x4
   \       0x10   0xE391'19DC        ORRS     R1,R1,#0x370000
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
    984          	asm volatile ("nop");
   \       0x18   0xE1A0'0000        nop
    985          	asm volatile ("nop");
   \       0x1C   0xE1A0'0000        nop
    986          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_enable_ulp1_0:
   \       0x20   0xE3E0'0097        MVN      R0,#+151
   \       0x24   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x28   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x2C   0xE310'0008        TST      R0,#0x8
   \       0x30   0x0AFF'FFFA        BEQ      ??pmc_enable_ulp1_0
    987          #endif
    988          }
   \       0x34   0xE12F'FF1E        BX       LR               ;; return
    989          

   \                                 In section SOFTPACK, align 4, keep-with-next
    990          void pmc_switch_mck_to_new_source(uint32_t mckr_css)
    991          {
   \                     pmc_switch_mck_to_new_source:
   \        0x0   0xE92D'4000        PUSH     {LR}
    992          	uint32_t mckr = PMC->PMC_MCKR;
   \        0x4   0xE3E0'20D7        MVN      R2,#+215
   \        0x8   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \        0xC   0xE592'1000        LDR      R1,[R2, #+0]
    993          	uint32_t mask = PMC_MCKR_CSS_Msk;
   \       0x10   0xE3A0'3003        MOV      R3,#+3
    994          
    995          	if ((mckr ^ mckr_css) & mask) {
   \       0x14   0xE030'C001        EORS     R12,R0,R1
   \       0x18   0xE113'000C        TST      R3,R12
   \       0x1C   0x0A00'0008        BEQ      ??pmc_switch_mck_to_new_source_0
    996          		PMC->PMC_MCKR = (mckr & ~mask) | (mckr_css & mask);
   \       0x20   0xE1D1'C003        BICS     R12,R1,R3
   \       0x24   0xE013'E000        ANDS     LR,R3,R0
   \       0x28   0xE19E'C00C        ORRS     R12,LR,R12
   \       0x2C   0xE582'C000        STR      R12,[R2, #+0]
    997          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_new_source_1:
   \       0x30   0xE3E0'2097        MVN      R2,#+151
   \       0x34   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \       0x38   0xE592'2000        LDR      R2,[R2, #+0]
   \       0x3C   0xE312'0008        TST      R2,#0x8
   \       0x40   0x0AFF'FFFA        BEQ      ??pmc_switch_mck_to_new_source_1
    998          	}
    999          
   1000          	_pmc_mck = 0;
   \                     ??pmc_switch_mck_to_new_source_0:
   \       0x44   0xE3A0'2000        MOV      R2,#+0
   \       0x48   0x....'....        LDR      R12,??DataTable16
   \       0x4C   0xE58C'2000        STR      R2,[R12, #+0]
   1001          }
   \       0x50   0xE8BD'8000        POP      {PC}             ;; return
   1002          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1003          RAMCODE void pmc_switch_mck_to_pll(void)
   1004          {
   1005          	/* Select PLL as input clock for PCK and MCK */
   1006          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_PLLA_CLK;
   \                     pmc_switch_mck_to_pll:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3D1'1003        BICS     R1,R1,#0x3
   \       0x10   0xE391'1002        ORRS     R1,R1,#0x2
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
   1007          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_pll_0:
   \       0x18   0xE3E0'0097        MVN      R0,#+151
   \       0x1C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x20   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x24   0xE310'0008        TST      R0,#0x8
   \       0x28   0x0AFF'FFFA        BEQ      ??pmc_switch_mck_to_pll_0
   1008          
   1009          	_pmc_mck = 0;
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0x....'....        LDR      R1,??DataTable16
   \       0x34   0xE581'0000        STR      R0,[R1, #+0]
   1010          }
   \       0x38   0xE12F'FF1E        BX       LR               ;; return
   1011          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1012          RAMCODE void pmc_switch_mck_to_upll(void)
   1013          {
   1014          	/* Select UPLL as input clock for PCK and MCK */
   1015          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_UPLL_CLK;
   \                     pmc_switch_mck_to_upll:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE391'1003        ORRS     R1,R1,#0x3
   \       0x10   0xE580'1000        STR      R1,[R0, #+0]
   1016          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_upll_0:
   \       0x14   0xE3E0'0097        MVN      R0,#+151
   \       0x18   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0xE310'0008        TST      R0,#0x8
   \       0x24   0x0AFF'FFFA        BEQ      ??pmc_switch_mck_to_upll_0
   1017          
   1018          	_pmc_mck = 0;
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x....'....        LDR      R1,??DataTable16
   \       0x30   0xE581'0000        STR      R0,[R1, #+0]
   1019          }
   \       0x34   0xE12F'FF1E        BX       LR               ;; return
   1020          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1021          RAMCODE void pmc_switch_mck_to_main(void)
   1022          {
   1023          	/* Select Main Oscillator as input clock for PCK and MCK */
   1024          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   \                     pmc_switch_mck_to_main:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3D1'1003        BICS     R1,R1,#0x3
   \       0x10   0xE391'1001        ORRS     R1,R1,#0x1
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
   1025          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_main_0:
   \       0x18   0xE3E0'0097        MVN      R0,#+151
   \       0x1C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x20   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x24   0xE310'0008        TST      R0,#0x8
   \       0x28   0x0AFF'FFFA        BEQ      ??pmc_switch_mck_to_main_0
   1026          
   1027          	_pmc_mck = 0;
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0x....'....        LDR      R1,??DataTable16
   \       0x34   0xE581'0000        STR      R0,[R1, #+0]
   1028          }
   \       0x38   0xE12F'FF1E        BX       LR               ;; return
   1029          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1030          RAMCODE void pmc_switch_mck_to_slck(void)
   1031          {
   1032          	/* Select Slow Clock as input clock for PCK and MCK */
   1033          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_SLOW_CLK;
   \                     pmc_switch_mck_to_slck:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3D1'1003        BICS     R1,R1,#0x3
   \       0x10   0xE580'1000        STR      R1,[R0, #+0]
   1034          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_slck_0:
   \       0x14   0xE3E0'0097        MVN      R0,#+151
   \       0x18   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0xE310'0008        TST      R0,#0x8
   \       0x24   0x0AFF'FFFA        BEQ      ??pmc_switch_mck_to_slck_0
   1035          
   1036          	_pmc_mck = 0;
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x....'....        LDR      R1,??DataTable16
   \       0x30   0xE581'0000        STR      R0,[R1, #+0]
   1037          }
   \       0x34   0xE12F'FF1E        BX       LR               ;; return
   1038          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1039          RAMCODE void pmc_set_mck_prescaler(uint32_t prescaler)
   1040          {
   \                     pmc_set_mck_prescaler:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1041          	_ASSERT(!(prescaler & ~PMC_MCKR_PRES_Msk));
   \        0x8   0xE3D4'0070        BICS     R0,R4,#0x70
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x0A00'0005        BEQ      ??pmc_set_mck_prescaler_0
   \       0x14   0xE3A0'2011        MOV      R2,#+17
   \       0x18   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x1C   0x....'....        LDR      R1,??DataTable18
   \       0x20   0x....'....        LDR      R0,??DataTable34
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
   1042          
   1043          	/* Change MCK Prescaler divider in PMC_MCKR register */
   1044          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_PRES_Msk) | prescaler;
   \                     ??pmc_set_mck_prescaler_0:
   \       0x2C   0xE3E0'00D7        MVN      R0,#+215
   \       0x30   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x34   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x38   0xE3D1'1070        BICS     R1,R1,#0x70
   \       0x3C   0xE194'1001        ORRS     R1,R4,R1
   \       0x40   0xE580'1000        STR      R1,[R0, #+0]
   1045          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_set_mck_prescaler_1:
   \       0x44   0xE3E0'0097        MVN      R0,#+151
   \       0x48   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x4C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x50   0xE310'0008        TST      R0,#0x8
   \       0x54   0x0AFF'FFFA        BEQ      ??pmc_set_mck_prescaler_1
   1046          }
   \       0x58   0xE8BD'8010        POP      {R4,PC}          ;; return
   1047          
   1048          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1049          RAMCODE void pmc_set_mck_plladiv2(bool div2)
   1050          {
   1051          	uint32_t mckr = PMC->PMC_MCKR;
   1052          	if (div2) {
   1053          		if ((mckr & PMC_MCKR_PLLADIV2) != PMC_MCKR_PLLADIV2)
   1054          			PMC->PMC_MCKR = mckr | PMC_MCKR_PLLADIV2;
   1055          	} else {
   1056          		if ((mckr & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2)
   1057          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_PLLADIV2;
   1058          	}
   1059          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1060          }
   1061          #endif
   1062          
   1063          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1064          void pmc_set_mck_uplldiv2(bool div2)
   1065          {
   1066          	uint32_t mckr = PMC->PMC_MCKR;
   1067          	if (div2) {
   1068          		if ((mckr & PMC_MCKR_UPLLDIV2) != PMC_MCKR_UPLLDIV2)
   1069          			PMC->PMC_MCKR = mckr | PMC_MCKR_UPLLDIV2;
   1070          	} else {
   1071          		if ((PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2) == PMC_MCKR_UPLLDIV2)
   1072          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_UPLLDIV2;
   1073          	}
   1074          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1075          }
   1076          #endif
   1077          
   1078          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1079          RAMCODE void pmc_set_mck_h32mxdiv(bool div2)
   1080          {
   1081          	uint32_t mckr = PMC->PMC_MCKR;
   1082          	if (div2) {
   1083          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV2)
   1084          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV2;
   1085          	} else {
   1086          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV1)
   1087          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV1;
   1088          	}
   1089          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1090          }
   1091          #endif /* CONFIG_HAVE_PMC_H32MXDIV */
   1092          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1093          RAMCODE void pmc_set_mck_divider(uint32_t divider)
   1094          {
   \                     pmc_set_mck_divider:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1095          	_ASSERT(!(divider & ~PMC_MCKR_MDIV_Msk));
   \        0x8   0xE3D4'0E70        BICS     R0,R4,#0x700
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x0A00'0005        BEQ      ??pmc_set_mck_divider_0
   \       0x14   0xE3A0'2047        MOV      R2,#+71
   \       0x18   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x1C   0x....'....        LDR      R1,??DataTable18
   \       0x20   0x....'....        LDR      R0,??DataTable34_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
   1096          
   1097          	/* change MCK Prescaler divider in PMC_MCKR register */
   1098          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_MDIV_Msk) | divider;
   \                     ??pmc_set_mck_divider_0:
   \       0x2C   0xE3E0'00D7        MVN      R0,#+215
   \       0x30   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x34   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x38   0xE3D1'1E70        BICS     R1,R1,#0x700
   \       0x3C   0xE194'1001        ORRS     R1,R4,R1
   \       0x40   0xE580'1000        STR      R1,[R0, #+0]
   1099          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_set_mck_divider_1:
   \       0x44   0xE3E0'0097        MVN      R0,#+151
   \       0x48   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x4C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x50   0xE310'0008        TST      R0,#0x8
   \       0x54   0x0AFF'FFFA        BEQ      ??pmc_set_mck_divider_1
   1100          }
   \       0x58   0xE8BD'8010        POP      {R4,PC}          ;; return
   1101          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1102          RAMCODE void pmc_configure_plla(const struct _pmc_plla_cfg* plla)
   1103          {
   \                     pmc_configure_plla:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1104          #if defined(PMC_PLL_UPDT_ID)
   1105          	_pmc_configure_pll(plla);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0x....'....        BL       _pmc_configure_pll
   1106          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1107          	uint32_t pllar = 0;
   1108          
   1109          #ifdef CKGR_PLLAR_ONE
   1110          	pllar |= CKGR_PLLAR_ONE;
   1111          #endif
   1112          	pllar |= CKGR_PLLAR_MULA(plla->mul);
   1113          	pllar |= CKGR_PLLAR_DIVA(plla->div);
   1114          	pllar |= CKGR_PLLAR_PLLACOUNT(plla->count);
   1115          	PMC->CKGR_PLLAR = pllar;
   1116          
   1117          #ifdef CONFIG_HAVE_PMC_PLLA_CHARGEPUMP
   1118          	PMC->PMC_PLLICPR = plla->icp & PMC_PLLICPR_ICP_PLLA_Msk;
   1119          #endif /* CONFIG_HAVE_PMC_PLLA_CHARGEPUMP */
   1120          
   1121          	if (plla->mul > 0)
   1122          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
   1123          #endif
   1124          }
   \       0x10   0xE8BD'8010        POP      {R4,PC}          ;; return
   1125          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1126          RAMCODE void pmc_disable_plla(void)
   1127          {
   \                     pmc_disable_plla:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   1128          #if defined(PMC_PLL_UPDT_ID)
   1129          	_pmc_disable_pll(PLL_ID_PLLA);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        BL       _pmc_disable_pll
   1130          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1131          	PMC->CKGR_PLLAR = (PMC->CKGR_PLLAR & ~CKGR_PLLAR_MULA_Msk) | CKGR_PLLAR_MULA(0);
   1132          #endif
   1133          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
   1134          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1135          bool pmc_has_system_clock(enum _pmc_system_clock clock)
   1136          {
   \                     pmc_has_system_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1137          	return _pmc_get_system_clock_bits(clock, NULL, NULL, NULL);
   \        0x8   0xE3A0'3000        MOV      R3,#+0
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
   1138          }
   1139          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1140          RAMCODE void pmc_enable_system_clock(enum _pmc_system_clock clock)
   1141          {
   \                     pmc_enable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1142          	uint32_t scer, scsr;
   1143          
   1144          	if (!_pmc_get_system_clock_bits(clock, &scer, NULL, &scsr)) {
   \        0x8   0xE1B0'300D        MOVS     R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE28D'1004        ADD      R1,SP,#+4
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0008        BNE      ??pmc_enable_system_clock_0
   1145          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x28   0x....'....        LDR      R0,??DataTable18_2
   \       0x2C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x30   0xE350'0005        CMP      R0,#+5
   \       0x34   0x3A00'0003        BCC      ??pmc_enable_system_clock_1
   \       0x38   0xE1B0'1004        MOVS     R1,R4
   \       0x3C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x40   0x....'....        LDR      R0,??DataTable34_2
   \       0x44   0x....'....        BL       printf
   1146          		return;
   \                     ??pmc_enable_system_clock_1:
   \       0x48   0xEA00'000B        B        ??pmc_enable_system_clock_2
   1147          	}
   1148          
   1149          	PMC->PMC_SCER |= scer;
   \                     ??pmc_enable_system_clock_0:
   \       0x4C   0xE3E0'00FF        MVN      R0,#+255
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x58   0xE59D'2004        LDR      R2,[SP, #+4]
   \       0x5C   0xE192'1001        ORRS     R1,R2,R1
   \       0x60   0xE580'1000        STR      R1,[R0, #+0]
   1150          	while (!(PMC->PMC_SCSR & scsr));
   \                     ??pmc_enable_system_clock_3:
   \       0x64   0xE3E0'00F7        MVN      R0,#+247
   \       0x68   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x6C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x70   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x74   0xE111'0000        TST      R1,R0
   \       0x78   0x0AFF'FFF9        BEQ      ??pmc_enable_system_clock_3
   1151          }
   \                     ??pmc_enable_system_clock_2:
   \       0x7C   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1152          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1153          RAMCODE void pmc_disable_system_clock(enum _pmc_system_clock clock)
   1154          {
   \                     pmc_disable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1155          	uint32_t scdr, scsr;
   1156          
   1157          	if (!_pmc_get_system_clock_bits(clock, NULL, &scdr, &scsr)) {
   \        0x8   0xE1B0'300D        MOVS     R3,SP
   \        0xC   0xE28D'2004        ADD      R2,SP,#+4
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0008        BNE      ??pmc_disable_system_clock_0
   1158          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x28   0x....'....        LDR      R0,??DataTable18_2
   \       0x2C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x30   0xE350'0005        CMP      R0,#+5
   \       0x34   0x3A00'0003        BCC      ??pmc_disable_system_clock_1
   \       0x38   0xE1B0'1004        MOVS     R1,R4
   \       0x3C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x40   0x....'....        LDR      R0,??DataTable34_3
   \       0x44   0x....'....        BL       printf
   1159          		return;
   \                     ??pmc_disable_system_clock_1:
   \       0x48   0xEA00'000B        B        ??pmc_disable_system_clock_2
   1160          	}
   1161          
   1162          	PMC->PMC_SCDR |= scdr;
   \                     ??pmc_disable_system_clock_0:
   \       0x4C   0xE3E0'00FB        MVN      R0,#+251
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x58   0xE59D'2004        LDR      R2,[SP, #+4]
   \       0x5C   0xE192'1001        ORRS     R1,R2,R1
   \       0x60   0xE580'1000        STR      R1,[R0, #+0]
   1163          	while (PMC->PMC_SCSR & scsr);
   \                     ??pmc_disable_system_clock_3:
   \       0x64   0xE3E0'00F7        MVN      R0,#+247
   \       0x68   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x6C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x70   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x74   0xE111'0000        TST      R1,R0
   \       0x78   0x1AFF'FFF9        BNE      ??pmc_disable_system_clock_3
   1164          }
   \                     ??pmc_disable_system_clock_2:
   \       0x7C   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1165          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1166          bool pmc_is_system_clock_enabled(enum _pmc_system_clock clock)
   1167          {
   \                     pmc_is_system_clock_enabled:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1168          	uint32_t scsr;
   1169          
   1170          	if (!_pmc_get_system_clock_bits(clock, NULL, NULL, &scsr)) {
   \        0x8   0xE1B0'300D        MOVS     R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0009        BNE      ??pmc_is_system_clock_enabled_0
   1171          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x28   0x....'....        LDR      R0,??DataTable18_2
   \       0x2C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x30   0xE350'0005        CMP      R0,#+5
   \       0x34   0x3A00'0003        BCC      ??pmc_is_system_clock_enabled_1
   \       0x38   0xE1B0'1004        MOVS     R1,R4
   \       0x3C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x40   0x....'....        LDR      R0,??DataTable34_4
   \       0x44   0x....'....        BL       printf
   1172          		return false;
   \                     ??pmc_is_system_clock_enabled_1:
   \       0x48   0xE3A0'0000        MOV      R0,#+0
   \       0x4C   0xEA00'000B        B        ??pmc_is_system_clock_enabled_2
   1173          	}
   1174          
   1175          	return (PMC->PMC_SCSR & scsr) == scsr;
   \                     ??pmc_is_system_clock_enabled_0:
   \       0x50   0xE3E0'00F7        MVN      R0,#+247
   \       0x54   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x58   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x5C   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x60   0xE011'0000        ANDS     R0,R1,R0
   \       0x64   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x68   0xE150'0001        CMP      R0,R1
   \       0x6C   0x1A00'0001        BNE      ??pmc_is_system_clock_enabled_3
   \       0x70   0xE3A0'0001        MOV      R0,#+1
   \       0x74   0xEA00'0000        B        ??pmc_is_system_clock_enabled_4
   \                     ??pmc_is_system_clock_enabled_3:
   \       0x78   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_is_system_clock_enabled_4:
   \       0x7C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \                     ??pmc_is_system_clock_enabled_2:
   \       0x80   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
   1176          }
   1177          
   1178          #ifdef CONFIG_HAVE_PMC_FAST_STARTUP

   \                                 In section SOFTPACK, align 4, keep-with-next
   1179          void pmc_set_fast_startup_mode(uint32_t startup_mode)
   1180          {
   1181          	PMC->PMC_FSMR = startup_mode;
   \                     pmc_set_fast_startup_mode:
   \        0x0   0xE3E0'108F        MVN      R1,#+143
   \        0x4   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0x8   0xE581'0000        STR      R0,[R1, #+0]
   1182          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
   1183          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1184          void pmc_set_fast_startup_polarity(uint32_t high_level, uint32_t low_level)
   1185          {
   1186          #ifdef PMC_FSPR_FSTP0
   1187          	PMC->PMC_FSPR &= ~low_level;
   1188          	PMC->PMC_FSPR |= high_level;
   1189          #endif /* PMC_FSPR_FSTP0 */
   1190          }
   \                     pmc_set_fast_startup_polarity:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
   1191          #endif /* CONFIG_HAVE_PMC_FAST_STARTUP */
   1192          
   1193          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1194           * it doesn't support samv71 targets. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1195          RAMCODE void pmc_set_custom_pck_mck(const struct pck_mck_cfg *cfg)
   1196          {
   \                     pmc_set_custom_pck_mck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1197          	pmc_switch_mck_to_slck();
   \        0x8   0x....'....        BL       pmc_switch_mck_to_slck
   1198          
   1199          	if (cfg->extosc)
   \        0xC   0xE5D4'0004        LDRB     R0,[R4, #+4]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_0
   1200          		pmc_select_external_osc(cfg->ext_bypass);
   \       0x18   0xE5D4'0005        LDRB     R0,[R4, #+5]
   \       0x1C   0x....'....        BL       pmc_select_external_osc
   \       0x20   0xEA00'0000        B        ??pmc_set_custom_pck_mck_1
   1201          	else
   1202          		pmc_select_internal_osc();
   \                     ??pmc_set_custom_pck_mck_0:
   \       0x24   0x....'....        BL       pmc_select_internal_osc
   1203          
   1204          	pmc_switch_mck_to_main();
   \                     ??pmc_set_custom_pck_mck_1:
   \       0x28   0x....'....        BL       pmc_switch_mck_to_main
   1205          
   1206          	if (cfg->ext32k) {
   \       0x2C   0xE5D4'0006        LDRB     R0,[R4, #+6]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0A00'0003        BEQ      ??pmc_set_custom_pck_mck_2
   1207          		pmc_select_external_crystal();
   \       0x38   0x....'....        BL       pmc_select_external_crystal
   1208          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1209          		slowclock_set_bypass(cfg->ext32k_bypass);
   \       0x3C   0xE5D4'0007        LDRB     R0,[R4, #+7]
   \       0x40   0x....'....        BL       slowclock_set_bypass
   \       0x44   0xEA00'0000        B        ??pmc_set_custom_pck_mck_3
   1210          #endif
   1211          	}
   1212          	else
   1213          		pmc_select_internal_crystal();
   \                     ??pmc_set_custom_pck_mck_2:
   \       0x48   0x....'....        BL       pmc_select_internal_crystal
   1214          
   1215          	pmc_disable_plla();
   \                     ??pmc_set_custom_pck_mck_3:
   \       0x4C   0x....'....        BL       pmc_disable_plla
   1216          	if (cfg->plla.mul > 0 && cfg->plla.div > 0) {
   \       0x50   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x54   0xE350'0000        CMP      R0,#+0
   \       0x58   0x0A00'0004        BEQ      ??pmc_set_custom_pck_mck_4
   \       0x5C   0xE594'000C        LDR      R0,[R4, #+12]
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x0A00'0001        BEQ      ??pmc_set_custom_pck_mck_4
   1217          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1218          		pmc_set_mck_plladiv2(cfg->plla_div2);
   1219          #endif
   1220          		pmc_configure_plla(&cfg->plla);
   \       0x68   0xE294'0008        ADDS     R0,R4,#+8
   \       0x6C   0x....'....        BL       pmc_configure_plla
   1221          	}
   1222          
   1223          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1224          	pmc_set_mck_uplldiv2(cfg->upll_div2);
   1225          #endif
   1226          	pmc_set_mck_prescaler(cfg->pck_pres);
   \                     ??pmc_set_custom_pck_mck_4:
   \       0x70   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x74   0x....'....        BL       pmc_set_mck_prescaler
   1227          	pmc_set_mck_divider(cfg->mck_div);
   \       0x78   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x7C   0x....'....        BL       pmc_set_mck_divider
   1228          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1229          	pmc_set_mck_h32mxdiv(cfg->h32mx_div2);
   1230          #endif
   1231          
   1232          	switch (cfg->pck_input) {
   \       0x80   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x84   0xE350'0000        CMP      R0,#+0
   \       0x88   0x0A00'0008        BEQ      ??pmc_set_custom_pck_mck_5
   \       0x8C   0xE350'0002        CMP      R0,#+2
   \       0x90   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_6
   \       0x94   0xE350'0003        CMP      R0,#+3
   \       0x98   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_7
   \       0x9C   0xEA00'0006        B        ??pmc_set_custom_pck_mck_8
   1233          	case PMC_MCKR_CSS_PLLA_CLK:
   1234          		pmc_switch_mck_to_pll();
   \                     ??pmc_set_custom_pck_mck_6:
   \       0xA0   0x....'....        BL       pmc_switch_mck_to_pll
   1235          		break;
   \       0xA4   0xEA00'0004        B        ??pmc_set_custom_pck_mck_8
   1236          
   1237          	case PMC_MCKR_CSS_UPLL_CLK:
   1238          		pmc_switch_mck_to_upll();
   \                     ??pmc_set_custom_pck_mck_7:
   \       0xA8   0x....'....        BL       pmc_switch_mck_to_upll
   1239          		break;
   \       0xAC   0xEA00'0002        B        ??pmc_set_custom_pck_mck_8
   1240          
   1241          	case PMC_MCKR_CSS_SLOW_CLK:
   1242          		pmc_switch_mck_to_slck();
   \                     ??pmc_set_custom_pck_mck_5:
   \       0xB0   0x....'....        BL       pmc_switch_mck_to_slck
   1243          		pmc_disable_internal_osc();
   \       0xB4   0x....'....        BL       pmc_disable_internal_osc
   1244          		pmc_disable_external_osc();
   \       0xB8   0x....'....        BL       pmc_disable_external_osc
   1245          		break;
   1246          	}
   1247          }
   \                     ??pmc_set_custom_pck_mck_8:
   \       0xBC   0xE8BD'8010        POP      {R4,PC}          ;; return
   1248          
   1249          /*----------------------------------------------------------------------------
   1250           *        Exported functions (Peripherals)
   1251           *----------------------------------------------------------------------------*/
   1252          
   1253          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1254           * it only supports a NULL (struct _pmc_periph_cfg*) parameter. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1255          RAMCODE void pmc_configure_peripheral(uint32_t id, const struct _pmc_periph_cfg* cfg, bool enable)
   1256          {
   \                     pmc_configure_peripheral:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   1257          	_ASSERT(id < ID_PERIPH_COUNT);
   \       0x10   0xE354'0033        CMP      R4,#+51
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_peripheral_0
   \       0x18   0xE3A0'20E9        MOV      R2,#+233
   \       0x1C   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x20   0x....'....        LDR      R1,??DataTable34_5
   \       0x24   0x....'....        LDR      R0,??DataTable34_6
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1258          
   1259          	pmc_disable_peripheral(id);
   \                     ??pmc_configure_peripheral_0:
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0x....'....        BL       pmc_disable_peripheral
   1260          
   1261          	if (cfg != NULL) {
   \       0x38   0xE355'0000        CMP      R5,#+0
   \       0x3C   0x0A00'0007        BEQ      ??pmc_configure_peripheral_1
   1262          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1263          		if (cfg->gck.div > 0)
   \       0x40   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x0A00'0006        BEQ      ??pmc_configure_peripheral_2
   1264          			pmc_configure_gck(id, cfg->gck.css, cfg->gck.div);
   \       0x4C   0xE595'2004        LDR      R2,[R5, #+4]
   \       0x50   0xE595'1000        LDR      R1,[R5, #+0]
   \       0x54   0xE1B0'0004        MOVS     R0,R4
   \       0x58   0x....'....        BL       pmc_configure_gck
   \       0x5C   0xEA00'0001        B        ??pmc_configure_peripheral_2
   1265          #endif
   1266          
   1267          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1268          		_pmc_configure_peripheral_div(id, cfg->div);
   1269          #endif
   1270          	} else {
   1271          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1272          		pmc_disable_gck(id);
   \                     ??pmc_configure_peripheral_1:
   \       0x60   0xE1B0'0004        MOVS     R0,R4
   \       0x64   0x....'....        BL       pmc_disable_gck
   1273          #endif
   1274          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1275          		_pmc_configure_peripheral_div(id, 0);
   1276          #endif
   1277          	}
   1278          
   1279          	/* Enable peripheral, gck or only configure it */
   1280          	if (enable) {
   \                     ??pmc_configure_peripheral_2:
   \       0x68   0xE1B0'0006        MOVS     R0,R6
   \       0x6C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x70   0xE350'0000        CMP      R0,#+0
   \       0x74   0x0A00'0008        BEQ      ??pmc_configure_peripheral_3
   1281          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1282          		if (cfg && cfg->gck.div > 0)
   \       0x78   0xE355'0000        CMP      R5,#+0
   \       0x7C   0x0A00'0004        BEQ      ??pmc_configure_peripheral_4
   \       0x80   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x84   0xE350'0000        CMP      R0,#+0
   \       0x88   0x0A00'0001        BEQ      ??pmc_configure_peripheral_4
   1283          			pmc_enable_gck(id);
   \       0x8C   0xE1B0'0004        MOVS     R0,R4
   \       0x90   0x....'....        BL       pmc_enable_gck
   1284          #endif
   1285          		pmc_enable_peripheral(id);
   \                     ??pmc_configure_peripheral_4:
   \       0x94   0xE1B0'0004        MOVS     R0,R4
   \       0x98   0x....'....        BL       pmc_enable_peripheral
   1286          	}
   1287          }
   \                     ??pmc_configure_peripheral_3:
   \       0x9C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1288          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1289          RAMCODE void pmc_enable_peripheral(uint32_t id)
   1290          {
   \                     pmc_enable_peripheral:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1291          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_peripheral_0
   \       0x10   0xE3A0'200B        MOV      R2,#+11
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1292          
   1293          	// select peripheral
   1294          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_enable_peripheral_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1295          
   1296          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x3C   0xE58D'1000        STR      R1,[SP, #+0]
   1297          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_EN;
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE391'1490        ORRS     R1,R1,#0x90000000
   \       0x48   0xE580'1000        STR      R1,[R0, #+0]
   1298          }
   \       0x4C   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1299          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1300          RAMCODE void pmc_disable_peripheral(uint32_t id)
   1301          {
   \                     pmc_disable_peripheral:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1302          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_peripheral_0
   \       0x10   0xE3A0'2016        MOV      R2,#+22
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1303          
   1304          	// select peripheral
   1305          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_disable_peripheral_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1306          
   1307          	// disable it but keep previous configuration
   1308          	PMC->PMC_PCR = (PMC->PMC_PCR & ~PMC_PCR_EN) | PMC_PCR_CMD;
   \       0x38   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x3C   0xE3D1'1540        BICS     R1,R1,#0x10000000
   \       0x40   0xE391'1480        ORRS     R1,R1,#0x80000000
   \       0x44   0xE580'1000        STR      R1,[R0, #+0]
   1309          }
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
   1310          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1311          bool pmc_is_peripheral_enabled(uint32_t id)
   1312          {
   \                     pmc_is_peripheral_enabled:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1313          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_is_peripheral_enabled_0
   \       0x10   0xE3A0'2021        MOV      R2,#+33
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1314          
   1315          #if defined(PMC_CSR_PID0) || defined(PMC_CSR0_PID5)
   1316          	return (PMC->PMC_CSR[(id >> 5) & 3] & (1 << (id & 31))) != 0;
   \                     ??pmc_is_peripheral_enabled_0:
   \       0x28   0xE3E0'005F        MVN      R0,#+95
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE3A0'1003        MOV      R1,#+3
   \       0x34   0xE011'12A4        ANDS     R1,R1,R4, LSR #+5
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE214'101F        ANDS     R1,R4,#0x1F
   \       0x44   0xE1B0'0130        LSRS     R0,R0,R1
   \       0x48   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x4C   0xE8BD'8010        POP      {R4,PC}          ;; return
   1317          #elif defined(PMC_PCR_PID)
   1318          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1319          	volatile uint32_t pcr = PMC->PMC_PCR;
   1320          
   1321          	return (pcr & PMC_PCR_EN) != 0;
   1322          #else
   1323          	#error pmc_is_peripheral_enabled() needs to be updated.
   1324          #endif
   1325          }
   1326          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1327          uint32_t pmc_get_peripheral_clock(uint32_t id)
   1328          {
   \                     pmc_get_peripheral_clock:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1329          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_get_peripheral_clock_0
   \       0x10   0xE3A0'2031        MOV      R2,#+49
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1330          
   1331          	uint32_t div = get_peripheral_clock_matrix_div(id);
   \                     ??pmc_get_peripheral_clock_0:
   \       0x28   0xE1B0'0004        MOVS     R0,R4
   \       0x2C   0x....'....        BL       get_peripheral_clock_matrix_div
   \       0x30   0xE1B0'5000        MOVS     R5,R0
   1332          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1333          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1334          	volatile uint32_t pcr = PMC->PMC_PCR;
   1335          	div *= 1 << ((pcr & PMC_PCR_DIV_Msk) >> PMC_PCR_DIV_Pos);
   1336          #endif
   1337          
   1338          	return pmc_get_master_clock() / div;
   \       0x34   0x....'....        BL       pmc_get_master_clock
   \       0x38   0xE1B0'1005        MOVS     R1,R5
   \       0x3C   0x....'....        BL       __aeabi_uidiv
   \       0x40   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
   1339          }
   1340          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1341          void pmc_disable_all_peripherals(void)
   1342          {
   \                     pmc_disable_all_peripherals:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1343          	int i;
   1344          	for (i = 2; i < ID_PERIPH_COUNT; i++)
   \        0x4   0xE3A0'4002        MOV      R4,#+2
   \                     ??pmc_disable_all_peripherals_0:
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0xAA00'0003        BGE      ??pmc_disable_all_peripherals_1
   1345          		pmc_disable_peripheral(i);
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       pmc_disable_peripheral
   \       0x18   0xE294'4001        ADDS     R4,R4,#+1
   \       0x1C   0xEAFF'FFF9        B        ??pmc_disable_all_peripherals_0
   1346          }
   \                     ??pmc_disable_all_peripherals_1:
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
   1347          
   1348          /*----------------------------------------------------------------------------
   1349           *        Exported functions (PCK)
   1350           *----------------------------------------------------------------------------*/
   1351          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1352          void pmc_configure_pck(uint32_t index, uint32_t clock_source, uint32_t prescaler)
   1353          {
   \                     pmc_configure_pck:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   1354          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \       0x10   0xE354'0002        CMP      R4,#+2
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_pck_0
   \       0x18   0xE3A0'204A        MOV      R2,#+74
   \       0x1C   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x20   0x....'....        LDR      R1,??DataTable34_5
   \       0x24   0x....'....        LDR      R0,??DataTable34_7
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1355          	assert(!(clock_source & ~PMC_PCK_CSS_Msk));
   \                     ??pmc_configure_pck_0:
   \       0x30   0xE3D5'001F        BICS     R0,R5,#0x1F
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x0A00'0005        BEQ      ??pmc_configure_pck_1
   \       0x3C   0xE3A0'204B        MOV      R2,#+75
   \       0x40   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x44   0x....'....        LDR      R1,??DataTable34_5
   \       0x48   0x....'....        LDR      R0,??DataTable34_8
   \       0x4C   0x....'....        BL       __aeabi_assert
   \       0x50   0x....'....        BL       __iar_EmptyStepPoint
   1356          	assert(!(prescaler << PMC_PCK_PRES_Pos & ~PMC_PCK_PRES_Msk));
   \                     ??pmc_configure_pck_1:
   \       0x54   0xE3E0'0CFF        MVN      R0,#+65280
   \       0x58   0xE110'0406        TST      R0,R6, LSL #+8
   \       0x5C   0x0A00'0005        BEQ      ??pmc_configure_pck_2
   \       0x60   0xE3A0'204C        MOV      R2,#+76
   \       0x64   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x68   0x....'....        LDR      R1,??DataTable34_5
   \       0x6C   0x....'....        LDR      R0,??DataTable34_9
   \       0x70   0x....'....        BL       __aeabi_assert
   \       0x74   0x....'....        BL       __iar_EmptyStepPoint
   1357          
   1358          	pmc_disable_pck(index);
   \                     ??pmc_configure_pck_2:
   \       0x78   0xE1B0'0004        MOVS     R0,R4
   \       0x7C   0x....'....        BL       pmc_disable_pck
   1359          	PMC->PMC_PCK[index] = clock_source | PMC_PCK_PRES(prescaler);
   \       0x80   0xE3A0'0CFF        MOV      R0,#+65280
   \       0x84   0xE010'0406        ANDS     R0,R0,R6, LSL #+8
   \       0x88   0xE190'0005        ORRS     R0,R0,R5
   \       0x8C   0xE3E0'10BF        MVN      R1,#+191
   \       0x90   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x94   0xE1B0'2104        LSLS     R2,R4,#+2
   \       0x98   0xE781'0002        STR      R0,[R1, +R2]
   1360          }
   \       0x9C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1361          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1362          void pmc_enable_pck(uint32_t index)
   1363          {
   \                     pmc_enable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1364          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0002        CMP      R4,#+2
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_pck_0
   \       0x10   0xE3A0'2054        MOV      R2,#+84
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_7
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1365          
   1366          	switch (index) {
   \                     ??pmc_enable_pck_0:
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0002        BEQ      ??pmc_enable_pck_1
   \       0x30   0xE354'0001        CMP      R4,#+1
   \       0x34   0x0A00'000A        BEQ      ??pmc_enable_pck_2
   \       0x38   0xEA00'0013        B        ??pmc_enable_pck_3
   1367          #ifdef PMC_SCER_PCK0
   1368          	case 0:
   1369          		PMC->PMC_SCER = PMC_SCER_PCK0;
   \                     ??pmc_enable_pck_1:
   \       0x3C   0xE3A0'0F40        MOV      R0,#+256
   \       0x40   0xE3E0'10FF        MVN      R1,#+255
   \       0x44   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x48   0xE581'0000        STR      R0,[R1, #+0]
   1370          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY0));
   \                     ??pmc_enable_pck_4:
   \       0x4C   0xE3E0'0097        MVN      R0,#+151
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x58   0xE310'0F40        TST      R0,#0x100
   \       0x5C   0x0AFF'FFFA        BEQ      ??pmc_enable_pck_4
   1371          		break;
   \       0x60   0xEA00'000F        B        ??pmc_enable_pck_5
   1372          #endif
   1373          #ifdef PMC_SCER_PCK1
   1374          	case 1:
   1375          		PMC->PMC_SCER = PMC_SCER_PCK1;
   \                     ??pmc_enable_pck_2:
   \       0x64   0xE3A0'0F80        MOV      R0,#+512
   \       0x68   0xE3E0'10FF        MVN      R1,#+255
   \       0x6C   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x70   0xE581'0000        STR      R0,[R1, #+0]
   1376          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY1));
   \                     ??pmc_enable_pck_6:
   \       0x74   0xE3E0'0097        MVN      R0,#+151
   \       0x78   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x7C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x80   0xE310'0F80        TST      R0,#0x200
   \       0x84   0x0AFF'FFFA        BEQ      ??pmc_enable_pck_6
   1377          		break;
   \       0x88   0xEA00'0005        B        ??pmc_enable_pck_5
   1378          #endif
   1379          #ifdef PMC_SCER_PCK2
   1380          	case 2:
   1381          		PMC->PMC_SCER = PMC_SCER_PCK2;
   1382          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY2));
   1383          		break;
   1384          #endif
   1385          #ifdef PMC_SCER_PCK3
   1386          	case 3:
   1387          		PMC->PMC_SCER = PMC_SCER_PCK3;
   1388          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY3));
   1389          		break;
   1390          #endif
   1391          #ifdef PMC_SCER_PCK4
   1392          	case 4:
   1393          		PMC->PMC_SCER = PMC_SCER_PCK4;
   1394          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY4));
   1395          		break;
   1396          #endif
   1397          #ifdef PMC_SCER_PCK5
   1398          	case 5:
   1399          		PMC->PMC_SCER = PMC_SCER_PCK5;
   1400          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY5));
   1401          		break;
   1402          #endif
   1403          #ifdef PMC_SCER_PCK6
   1404          	case 6:
   1405          		PMC->PMC_SCER = PMC_SCER_PCK6;
   1406          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY6));
   1407          		break;
   1408          #endif
   1409          	default:
   1410          		assert(0);
   \                     ??pmc_enable_pck_3:
   \       0x8C   0xE3A0'2082        MOV      R2,#+130
   \       0x90   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x94   0x....'....        LDR      R1,??DataTable34_5
   \       0x98   0x....'....        ADR      R0,??DataTable29_1  ;; "0"
   \       0x9C   0x....'....        BL       __aeabi_assert
   \       0xA0   0x....'....        BL       __iar_EmptyStepPoint
   1411          	}
   1412          }
   \                     ??pmc_enable_pck_5:
   \       0xA4   0xE8BD'8010        POP      {R4,PC}          ;; return
   1413          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1414          void pmc_disable_pck(uint32_t index)
   1415          {
   \                     pmc_disable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1416          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0002        CMP      R4,#+2
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_pck_0
   \       0x10   0xE3A0'2088        MOV      R2,#+136
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_7
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1417          
   1418          	switch (index) {
   \                     ??pmc_disable_pck_0:
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0002        BEQ      ??pmc_disable_pck_1
   \       0x30   0xE354'0001        CMP      R4,#+1
   \       0x34   0x0A00'000A        BEQ      ??pmc_disable_pck_2
   \       0x38   0xEA00'0013        B        ??pmc_disable_pck_3
   1419          #ifdef PMC_SCDR_PCK0
   1420          	case 0:
   1421          		PMC->PMC_SCDR = PMC_SCDR_PCK0;
   \                     ??pmc_disable_pck_1:
   \       0x3C   0xE3A0'0F40        MOV      R0,#+256
   \       0x40   0xE3E0'10FB        MVN      R1,#+251
   \       0x44   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x48   0xE581'0000        STR      R0,[R1, #+0]
   1422          		while (PMC->PMC_SCSR & PMC_SCSR_PCK0);
   \                     ??pmc_disable_pck_4:
   \       0x4C   0xE3E0'00F7        MVN      R0,#+247
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x58   0xE310'0F40        TST      R0,#0x100
   \       0x5C   0x1AFF'FFFA        BNE      ??pmc_disable_pck_4
   1423          		break;
   \       0x60   0xEA00'000F        B        ??pmc_disable_pck_5
   1424          #endif
   1425          #ifdef PMC_SCDR_PCK1
   1426          	case 1:
   1427          		PMC->PMC_SCDR = PMC_SCDR_PCK1;
   \                     ??pmc_disable_pck_2:
   \       0x64   0xE3A0'0F80        MOV      R0,#+512
   \       0x68   0xE3E0'10FB        MVN      R1,#+251
   \       0x6C   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x70   0xE581'0000        STR      R0,[R1, #+0]
   1428          		while (PMC->PMC_SCSR & PMC_SCSR_PCK1);
   \                     ??pmc_disable_pck_6:
   \       0x74   0xE3E0'00F7        MVN      R0,#+247
   \       0x78   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x7C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x80   0xE310'0F80        TST      R0,#0x200
   \       0x84   0x1AFF'FFFA        BNE      ??pmc_disable_pck_6
   1429          		break;
   \       0x88   0xEA00'0005        B        ??pmc_disable_pck_5
   1430          #endif
   1431          #ifdef PMC_SCDR_PCK2
   1432          	case 2:
   1433          		PMC->PMC_SCDR = PMC_SCDR_PCK2;
   1434          		while (PMC->PMC_SCSR & PMC_SCSR_PCK2);
   1435          		break;
   1436          #endif
   1437          #ifdef PMC_SCDR_PCK3
   1438          	case 3:
   1439          		PMC->PMC_SCDR = PMC_SCDR_PCK3;
   1440          		while (PMC->PMC_SCSR & PMC_SCSR_PCK3);
   1441          		break;
   1442          #endif
   1443          #ifdef PMC_SCDR_PCK4
   1444          	case 4:
   1445          		PMC->PMC_SCDR = PMC_SCDR_PCK4;
   1446          		while (PMC->PMC_SCSR & PMC_SCSR_PCK4);
   1447          		break;
   1448          #endif
   1449          #ifdef PMC_SCDR_PCK5
   1450          	case 5:
   1451          		PMC->PMC_SCDR = PMC_SCDR_PCK5;
   1452          		while (PMC->PMC_SCSR & PMC_SCSR_PCK5);
   1453          		break;
   1454          #endif
   1455          #ifdef PMC_SCDR_PCK6
   1456          	case 6:
   1457          		PMC->PMC_SCDR = PMC_SCDR_PCK6;
   1458          		while (PMC->PMC_SCSR & PMC_SCSR_PCK6);
   1459          		break;
   1460          #endif
   1461          	default:
   1462          		assert(0);
   \                     ??pmc_disable_pck_3:
   \       0x8C   0xE3A0'20B6        MOV      R2,#+182
   \       0x90   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x94   0x....'....        LDR      R1,??DataTable34_5
   \       0x98   0x....'....        ADR      R0,??DataTable29_1  ;; "0"
   \       0x9C   0x....'....        BL       __aeabi_assert
   \       0xA0   0x....'....        BL       __iar_EmptyStepPoint
   1463          	}
   1464          }
   \                     ??pmc_disable_pck_5:
   \       0xA4   0xE8BD'8010        POP      {R4,PC}          ;; return
   1465          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1466          uint32_t pmc_get_pck_clock(uint32_t index)
   1467          {
   \                     pmc_get_pck_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1468          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0002        CMP      R4,#+2
   \        0xC   0x3A00'0005        BCC      ??pmc_get_pck_clock_0
   \       0x10   0xE3A0'20BC        MOV      R2,#+188
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_7
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1469          	return _pmc_get_pck_clock(index);
   \                     ??pmc_get_pck_clock_0:
   \       0x28   0xE1B0'0004        MOVS     R0,R4
   \       0x2C   0x....'....        BL       _pmc_get_pck_clock
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
   1470          }
   1471          
   1472          /*----------------------------------------------------------------------------
   1473           *        Exported functions (UPLL)
   1474           *----------------------------------------------------------------------------*/
   1475          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1476          void pmc_enable_upll_clock(void)
   1477          {
   \                     pmc_enable_upll_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   1478          #if defined(PMC_PLL_UPDT_ID)
   1479          	struct _pmc_plla_cfg plla = {
   1480          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
   1481          		.mul = BOARD_PMC_UPLL_MUL,
   1482          		.div = BOARD_PMC_UPLL_DIV,
   1483          #else
   1484          		.mul = 49,
   1485          		.div = 1,
   1486          #endif
   1487          		.count = 0x3f,
   1488          		.fracr = 0,
   1489          		.pll_id = PLL_ID_UPLL,
   1490          };
   \        0x8   0xE1B0'000D        MOVS     R0,SP
   \        0xC   0x....'....        LDR      R1,??DataTable34_10
   \       0x10   0xE3A0'2018        MOV      R2,#+24
   \       0x14   0x....'....        BL       __aeabi_memcpy4
   1491          	_pmc_configure_pll(&plla);
   \       0x18   0xE1B0'000D        MOVS     R0,SP
   \       0x1C   0x....'....        BL       _pmc_configure_pll
   1492          #else
   1493          	uint32_t uckr = CKGR_UCKR_UPLLEN | CKGR_UCKR_UPLLCOUNT(0x3);
   1494          
   1495          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS
   1496          	uckr |= CKGR_UCKR_BIASCOUNT(0x1);
   1497          #endif
   1498          
   1499          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1500          	switch (_pmc_main_oscillators.crystal_freq) {
   1501          #ifdef SFR_UTMICKTRIM_FREQ_48
   1502          	case 48000000:
   1503          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_48;
   1504          		break;
   1505          #endif
   1506          	case 24000000:
   1507          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_24;
   1508          		break;
   1509          	case 16000000:
   1510          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_16;
   1511          		break;
   1512          	default:
   1513          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_12;
   1514          	}
   1515          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1516          	switch (_pmc_main_oscillators.crystal_freq) {
   1517          	case 16000000:
   1518          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL16;
   1519          		break;
   1520          	default:
   1521          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL12;
   1522          	}
   1523          #endif
   1524          
   1525          	/* enable the 480MHz UTMI PLL  */
   1526          	PMC->CKGR_UCKR = uckr;
   1527          
   1528          	/* wait until UPLL is locked */
   1529          	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   1530          #endif
   1531          }
   \       0x20   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x24   0xE8BD'8000        POP      {PC}             ;; return

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x0000'0027        DC32 39, 1, 63, 1, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0001  

   \              0x0000'0000
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   1532          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1533          void pmc_disable_upll_clock(void)
   1534          {
   \                     pmc_disable_upll_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   1535          #if defined(PMC_PLL_UPDT_ID)
   1536          	_pmc_disable_pll(PLL_ID_UPLL);
   \        0x4   0xE3A0'0001        MOV      R0,#+1
   \        0x8   0x....'....        BL       _pmc_disable_pll
   1537          #else
   1538          	PMC->CKGR_UCKR &= ~CKGR_UCKR_UPLLEN;
   1539          #endif
   1540          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
   1541          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1542          bool pmc_is_upll_clock_enabled(void)
   1543          {
   \                     pmc_is_upll_clock_enabled:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   1544          #if defined(PMC_PLL_UPDT_ID)
   1545          	return _pmc_pll_enabled(PLL_ID_UPLL);
   \        0x4   0xE3A0'0001        MOV      R0,#+1
   \        0x8   0x....'....        BL       _pmc_pll_enabled
   \        0xC   0xE8BD'8002        POP      {R1,PC}          ;; return
   1546          #else
   1547          	return (PMC->PMC_SR & PMC_SR_LOCKU) != 0;
   1548          #endif
   1549          }
   1550          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1551          uint32_t pmc_get_upll_clock(void)
   1552          {
   \                     pmc_get_upll_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   1553          #if defined(PMC_PLL_UPDT_ID)
   1554          	return _pmc_get_pll_clock(PLL_ID_UPLL);
   \        0x4   0xE3A0'0001        MOV      R0,#+1
   \        0x8   0x....'....        BL       _pmc_get_pll_clock
   \        0xC   0xE8BD'8002        POP      {R1,PC}          ;; return
   1555          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1556          	uint32_t upllclk;
   1557          
   1558          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1559          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1560          	switch (clktrim) {
   1561          #ifdef SFR_UTMICKTRIM_FREQ_48
   1562          		case SFR_UTMICKTRIM_FREQ_48:
   1563          			upllclk = 10 * _pmc_main_oscillators.crystal_freq;
   1564          			break;
   1565          #endif
   1566          		case SFR_UTMICKTRIM_FREQ_24:
   1567          			upllclk = 20 * _pmc_main_oscillators.crystal_freq;
   1568          			break;
   1569          		case SFR_UTMICKTRIM_FREQ_16:
   1570          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1571          			break;
   1572          		default:
   1573          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1574          			break;
   1575          	}
   1576          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1577          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1578          	switch (clktrim) {
   1579          		case UTMI_CKTRIM_FREQ_XTAL16:
   1580          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1581          			break;
   1582          		default:
   1583          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1584          			break;
   1585          	}
   1586          #else
   1587          	upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1588          #endif
   1589          
   1590          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1591          	if (PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2)
   1592          		upllclk >>= 1;
   1593          #endif
   1594          
   1595          	return upllclk;
   1596          #endif
   1597          }
   1598          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1599          RAMCODE bool pmc_ext32k_monitor(void)
   1600          {
   \                     pmc_ext32k_monitor:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   1601          	bool bypass = false;
   \        0x4   0xE3A0'4000        MOV      R4,#+0
   1602          	volatile int count;
   1603          	/* 32.768kHz crystal oscillator frequency monitor  */
   1604          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1605          	if(!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \        0x8   0xE3A0'0000        MOV      R0,#+0
   \        0xC   0x....'....        BL       slowclock_is_internal
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0028        BNE      ??pmc_ext32k_monitor_0
   1606          		slowclock_set_bypass(false);
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0x....'....        BL       slowclock_set_bypass
   1607          
   1608          		/* Wait 5 slow clock cycles for internal resynchronization. */
   1609          		for (count = 0; count < 0x100000; count++);
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE58D'0000        STR      R0,[SP, #+0]
   \                     ??pmc_ext32k_monitor_1:
   \       0x28   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x2C   0xE350'0940        CMP      R0,#+1048576
   \       0x30   0xAA00'0003        BGE      ??pmc_ext32k_monitor_2
   \       0x34   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x38   0xE290'0001        ADDS     R0,R0,#+1
   \       0x3C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x40   0xEAFF'FFF8        B        ??pmc_ext32k_monitor_1
   1610          
   1611          		/* 32.768 kHz Crystal Oscillator Frequency Monitoring Enabled */
   1612          		PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD | CKGR_MOR_XT32KFME;
   \                     ??pmc_ext32k_monitor_2:
   \       0x44   0xE3E0'50DF        MVN      R5,#+223
   \       0x48   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x4C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x50   0xE390'09DC        ORRS     R0,R0,#0x370000
   \       0x54   0xE390'0640        ORRS     R0,R0,#0x4000000
   \       0x58   0xE585'0000        STR      R0,[R5, #+0]
   1613          
   1614          		/* Wait 4 slow clock cycles for internal resynchronization */
   1615          		for (count = 0; count < 0x1000; count++);
   \       0x5C   0xE3A0'0000        MOV      R0,#+0
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
   \                     ??pmc_ext32k_monitor_3:
   \       0x64   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x68   0xE350'0D40        CMP      R0,#+4096
   \       0x6C   0xAA00'0003        BGE      ??pmc_ext32k_monitor_4
   \       0x70   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x74   0xE290'0001        ADDS     R0,R0,#+1
   \       0x78   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x7C   0xEAFF'FFF8        B        ??pmc_ext32k_monitor_3
   1616          
   1617          		/* check if the 32.768 kHz crystal oscillator was correct */
   1618          		if((PMC->PMC_SR & PMC_SR_XT32KERR) == PMC_SR_XT32KERR) {
   \                     ??pmc_ext32k_monitor_4:
   \       0x80   0xE3E0'0097        MVN      R0,#+151
   \       0x84   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x88   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x8C   0xE310'0980        TST      R0,#0x200000
   \       0x90   0x0A00'0005        BEQ      ??pmc_ext32k_monitor_5
   1619          			slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x94   0xE3A0'0000        MOV      R0,#+0
   \       0x98   0x....'....        BL       slowclock_select_external
   1620          			slowclock_set_bypass(true);
   \       0x9C   0xE3A0'0001        MOV      R0,#+1
   \       0xA0   0x....'....        BL       slowclock_set_bypass
   1621          			bypass = true;
   \       0xA4   0xE3A0'0001        MOV      R0,#+1
   \       0xA8   0xE1B0'4000        MOVS     R4,R0
   1622          		}
   1623          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_XT32KFME) | CKGR_MOR_KEY_PASSWD;
   \                     ??pmc_ext32k_monitor_5:
   \       0xAC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xB0   0xE3D0'0640        BICS     R0,R0,#0x4000000
   \       0xB4   0xE390'09DC        ORRS     R0,R0,#0x370000
   \       0xB8   0xE585'0000        STR      R0,[R5, #+0]
   1624          	}
   1625          #endif
   1626          	return bypass;
   \                     ??pmc_ext32k_monitor_0:
   \       0xBC   0xE1B0'0004        MOVS     R0,R4
   \       0xC0   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0xC4   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
   1627          }
   1628          
   1629          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS
   1630          void pmc_enable_upll_bias(void)
   1631          {
   1632          	PMC->CKGR_UCKR |= CKGR_UCKR_BIASEN;
   1633          }
   1634          
   1635          void pmc_disable_upll_bias(void)
   1636          {
   1637          	PMC->CKGR_UCKR &= ~CKGR_UCKR_BIASEN;
   1638          }
   1639          #endif /* CONFIG_HAVE_PMC_UPLL_BIAS */
   1640          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1641          uint32_t pmc_get_utmi_clock_trim(void)
   1642          {
   \                     pmc_get_utmi_clock_trim:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   1643          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1644          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1645          	switch (clktrim) {
   1646          #ifdef SFR_UTMICKTRIM_FREQ_48
   1647          		case SFR_UTMICKTRIM_FREQ_48:
   1648          			return 48000000;
   1649          #endif
   1650          		case SFR_UTMICKTRIM_FREQ_24:
   1651          			return 24000000;
   1652          		case SFR_UTMICKTRIM_FREQ_16:
   1653          			return 16000000;
   1654          		default:
   1655          			return 12000000;
   1656          	}
   1657          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1658          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1659          	switch (clktrim) {
   1660          		case UTMI_CKTRIM_FREQ_XTAL16:
   1661          			return 16000000;
   1662          		default:
   1663          			return 12000000;
   1664          	}
   1665          #elif defined(CONFIG_SOC_SAM9X60)
   1666          	struct _pmc_plla_cfg plla;
   1667          
   1668          	_pmc_get_pll_config(PLL_ID_UPLL, &plla);
   \        0x8   0xE1B0'100D        MOVS     R1,SP
   \        0xC   0xE3A0'0001        MOV      R0,#+1
   \       0x10   0x....'....        BL       _pmc_get_pll_config
   1669          	return 480000000U * (plla.div + 1) / (plla.mul + 1);
   \       0x14   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x18   0xE290'0001        ADDS     R0,R0,#+1
   \       0x1C   0x....'....        LDR      R1,??DataTable34_11  ;; 0x1c9c3800
   \       0x20   0xE010'0091        MULS     R0,R1,R0
   \       0x24   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x28   0xE291'1001        ADDS     R1,R1,#+1
   \       0x2C   0x....'....        BL       __aeabi_uidiv
   \       0x30   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x34   0xE8BD'8000        POP      {PC}             ;; return
   1670          #else
   1671          	return 12000000;
   1672          #endif
   1673          }
   1674          
   1675          /*----------------------------------------------------------------------------
   1676           *        Exported functions (Generated clocks)
   1677           *----------------------------------------------------------------------------*/
   1678          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1679          struct pck_mck_cfg pmc_get_pck_mck_cfg(void)
   1680          {
   \                     pmc_get_pck_mck_cfg:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE24D'D028        SUB      SP,SP,#+40
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE3A0'1028        MOV      R1,#+40
   \       0x10   0xE3A0'2000        MOV      R2,#+0
   \       0x14   0xE1B0'500D        MOVS     R5,SP
   \       0x18   0xE1B0'0005        MOVS     R0,R5
   \       0x1C   0x....'....        BL       __aeabi_memset
   \       0x20   0xE1B0'0005        MOVS     R0,R5
   1681          	struct pck_mck_cfg cfg = { 0 };
   1682          	cfg.pck_input = PMC->PMC_MCKR & PMC_MCKR_CSS_Msk;
   \       0x24   0xE3E0'50D7        MVN      R5,#+215
   \       0x28   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x2C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x30   0xE210'0003        ANDS     R0,R0,#0x3
   \       0x34   0xE58D'0000        STR      R0,[SP, #+0]
   1683          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \       0x38   0xE3E0'00DF        MVN      R0,#+223
   \       0x3C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x40   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x44   0xE310'0740        TST      R0,#0x1000000
   \       0x48   0x0A00'0002        BEQ      ??pmc_get_pck_mck_cfg_0
   1684          		cfg.extosc = true;
   \       0x4C   0xE3A0'0001        MOV      R0,#+1
   \       0x50   0xE5CD'0004        STRB     R0,[SP, #+4]
   \       0x54   0xEA00'0001        B        ??pmc_get_pck_mck_cfg_1
   1685          	} else {
   1686          		cfg.extosc = false;
   \                     ??pmc_get_pck_mck_cfg_0:
   \       0x58   0xE3A0'0000        MOV      R0,#+0
   \       0x5C   0xE5CD'0004        STRB     R0,[SP, #+4]
   1687          	}
   1688          	if (!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \                     ??pmc_get_pck_mck_cfg_1:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \       0x64   0x....'....        BL       slowclock_is_internal
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x1A00'0002        BNE      ??pmc_get_pck_mck_cfg_2
   1689          		cfg.ext32k = true;
   \       0x70   0xE3A0'0001        MOV      R0,#+1
   \       0x74   0xE5CD'0006        STRB     R0,[SP, #+6]
   \       0x78   0xEA00'0001        B        ??pmc_get_pck_mck_cfg_3
   1690          	} else {
   1691          		cfg.ext32k = false;
   \                     ??pmc_get_pck_mck_cfg_2:
   \       0x7C   0xE3A0'0000        MOV      R0,#+0
   \       0x80   0xE5CD'0006        STRB     R0,[SP, #+6]
   1692          	}
   1693          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1694          	/* Get ext32k bypass state*/
   1695          	if(slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \                     ??pmc_get_pck_mck_cfg_3:
   \       0x84   0xE3A0'0000        MOV      R0,#+0
   \       0x88   0x....'....        BL       slowclock_is_internal
   \       0x8C   0xE350'0000        CMP      R0,#+0
   \       0x90   0x0A00'0006        BEQ      ??pmc_get_pck_mck_cfg_4
   1696          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x94   0xE3A0'0000        MOV      R0,#+0
   \       0x98   0x....'....        BL       slowclock_select_external
   1697          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   \       0x9C   0x....'....        BL       pmc_ext32k_monitor
   \       0xA0   0xE5CD'0007        STRB     R0,[SP, #+7]
   1698          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0xA4   0xE3A0'0000        MOV      R0,#+0
   \       0xA8   0x....'....        BL       slowclock_select_internal
   \       0xAC   0xEA00'0005        B        ??pmc_get_pck_mck_cfg_5
   1699          	} else {
   1700          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_get_pck_mck_cfg_4:
   \       0xB0   0xE3A0'0000        MOV      R0,#+0
   \       0xB4   0x....'....        BL       slowclock_select_internal
   1701          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0xB8   0xE3A0'0000        MOV      R0,#+0
   \       0xBC   0x....'....        BL       slowclock_select_external
   1702          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   \       0xC0   0x....'....        BL       pmc_ext32k_monitor
   \       0xC4   0xE5CD'0007        STRB     R0,[SP, #+7]
   1703          	}
   1704          #endif
   1705          	cfg.pck_pres = (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk);
   \                     ??pmc_get_pck_mck_cfg_5:
   \       0xC8   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xCC   0xE210'0070        ANDS     R0,R0,#0x70
   \       0xD0   0xE58D'0020        STR      R0,[SP, #+32]
   1706          	cfg.mck_div = (PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk);
   \       0xD4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xD8   0xE210'0E70        ANDS     R0,R0,#0x700
   \       0xDC   0xE58D'0024        STR      R0,[SP, #+36]
   1707          
   1708          #ifdef PMC_PLL_UPDT_ID
   1709          	if ((cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) | (cfg.pck_input == PMC_MCKR_CSS_UPLL_CLK)) {
   \       0xE0   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xE4   0xE350'0002        CMP      R0,#+2
   \       0xE8   0x1A00'0001        BNE      ??pmc_get_pck_mck_cfg_6
   \       0xEC   0xE3A0'0001        MOV      R0,#+1
   \       0xF0   0xEA00'0000        B        ??pmc_get_pck_mck_cfg_7
   \                     ??pmc_get_pck_mck_cfg_6:
   \       0xF4   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_get_pck_mck_cfg_7:
   \       0xF8   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xFC   0xE351'0003        CMP      R1,#+3
   \      0x100   0x1A00'0001        BNE      ??pmc_get_pck_mck_cfg_8
   \      0x104   0xE3A0'1001        MOV      R1,#+1
   \      0x108   0xEA00'0000        B        ??pmc_get_pck_mck_cfg_9
   \                     ??pmc_get_pck_mck_cfg_8:
   \      0x10C   0xE3A0'1000        MOV      R1,#+0
   \                     ??pmc_get_pck_mck_cfg_9:
   \      0x110   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \      0x114   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \      0x118   0xE191'0000        ORRS     R0,R1,R0
   \      0x11C   0xE350'0000        CMP      R0,#+0
   \      0x120   0x0A00'0018        BEQ      ??pmc_get_pck_mck_cfg_10
   1710          		if (cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   \      0x124   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x128   0xE350'0002        CMP      R0,#+2
   \      0x12C   0x1A00'0002        BNE      ??pmc_get_pck_mck_cfg_11
   1711          			cfg.plla.pll_id = PLL_ID_PLLA;
   \      0x130   0xE3A0'0000        MOV      R0,#+0
   \      0x134   0xE58D'0014        STR      R0,[SP, #+20]
   \      0x138   0xEA00'0001        B        ??pmc_get_pck_mck_cfg_12
   1712          		} else {
   1713          			cfg.plla.pll_id = PLL_ID_UPLL;
   \                     ??pmc_get_pck_mck_cfg_11:
   \      0x13C   0xE3A0'0001        MOV      R0,#+1
   \      0x140   0xE58D'0014        STR      R0,[SP, #+20]
   1714          		}
   1715          		PMC->PMC_PLL_UPDT = (PMC->PMC_PLL_UPDT & ~PMC_PLL_UPDT_ID) | cfg.plla.pll_id;
   \                     ??pmc_get_pck_mck_cfg_12:
   \      0x144   0xE3E0'00E3        MVN      R0,#+227
   \      0x148   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x14C   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x150   0xE1B0'10A1        LSRS     R1,R1,#+1
   \      0x154   0xE59D'2014        LDR      R2,[SP, #+20]
   \      0x158   0xE192'1081        ORRS     R1,R2,R1, LSL #+1
   \      0x15C   0xE580'1000        STR      R1,[R0, #+0]
   1716          		cfg.plla.mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
   \      0x160   0xE3E0'00EF        MVN      R0,#+239
   \      0x164   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x168   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x16C   0xE1B0'0C20        LSRS     R0,R0,#+24
   \      0x170   0xE58D'0008        STR      R0,[SP, #+8]
   1717          		cfg.plla.div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
   \      0x174   0xE3E0'00F3        MVN      R0,#+243
   \      0x178   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x17C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x180   0xE210'00FF        ANDS     R0,R0,#0xFF
   \      0x184   0xE58D'000C        STR      R0,[SP, #+12]
   1718          	}
   1719          #else
   1720          	if(cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   1721          		cfg.plla.mul = (PMC->CKGR_PLLAR & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
   1722          		cfg.plla.div = (PMC->CKGR_PLLAR & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
   1723          		cfg.plla.count = (PMC->CKGR_PLLAR & CKGR_PLLAR_PLLACOUNT_Msk) >> CKGR_PLLAR_PLLACOUNT_Pos;
   1724          	}
   1725          #endif
   1726          #ifdef CKGR_MOR_MOSCXTBY	
   1727          	if((PMC->CKGR_MOR & CKGR_MOR_MOSCXTBY) == CKGR_MOR_MOSCXTBY) {
   1728          		cfg.ext_bypass = true;
   1729          	} else {
   1730          		cfg.ext_bypass = false;
   1731          	}
   1732          #endif
   1733          
   1734          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1735          	if((PMC->PMC_MCKR & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2) {
   1736          		cfg.plla_div2 = true;
   1737          	} else {
   1738          		cfg.plla_div2 = false;
   1739          	}
   1740          #endif
   1741          
   1742          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1743          	if ((PMC->PMC_MCKR & PMC_MCKR_H32MXDIV_H32MXDIV2) == PMC_MCKR_H32MXDIV_H32MXDIV2) {
   1744          		cfg.h32mx_div2 = true;
   1745          	} else {
   1746          		cfg.h32mx_div2 = false;
   1747          	}
   1748          #endif
   1749          	return cfg;
   \                     ??pmc_get_pck_mck_cfg_10:
   \      0x188   0xE1B0'0004        MOVS     R0,R4
   \      0x18C   0xE1B0'100D        MOVS     R1,SP
   \      0x190   0xE3A0'2028        MOV      R2,#+40
   \      0x194   0x....'....        BL       __aeabi_memcpy4
   \      0x198   0xE28D'D02C        ADD      SP,SP,#+44
   \      0x19C   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
   1750          }
   1751          
   1752          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1753          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1754          void pmc_configure_gck(uint32_t id, uint32_t clock_source, uint32_t div)
   1755          {
   \                     pmc_configure_gck:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   1756          	assert(id < ID_PERIPH_COUNT);
   \       0x10   0xE354'0033        CMP      R4,#+51
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_gck_0
   \       0x18   0xE3A0'20DC        MOV      R2,#+220
   \       0x1C   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x20   0x....'....        LDR      R1,??DataTable34_5
   \       0x24   0x....'....        LDR      R0,??DataTable34_6
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1757          	assert(!(clock_source & ~PMC_PCR_GCKCSS_Msk));
   \                     ??pmc_configure_gck_0:
   \       0x30   0xE3D5'0D7C        BICS     R0,R5,#0x1F00
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x0A00'0005        BEQ      ??pmc_configure_gck_1
   \       0x3C   0xE3A0'20DD        MOV      R2,#+221
   \       0x40   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x44   0x....'....        LDR      R1,??DataTable34_5
   \       0x48   0x....'....        LDR      R0,??DataTable34_12
   \       0x4C   0x....'....        BL       __aeabi_assert
   \       0x50   0x....'....        BL       __iar_EmptyStepPoint
   1758          	assert(div > 0);
   \                     ??pmc_configure_gck_1:
   \       0x54   0xE356'0000        CMP      R6,#+0
   \       0x58   0x1A00'0005        BNE      ??pmc_configure_gck_2
   \       0x5C   0xE3A0'20DE        MOV      R2,#+222
   \       0x60   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x64   0x....'....        LDR      R1,??DataTable34_5
   \       0x68   0x....'....        LDR      R0,??DataTable34_13
   \       0x6C   0x....'....        BL       __aeabi_assert
   \       0x70   0x....'....        BL       __iar_EmptyStepPoint
   1759          	assert(!((div << PMC_PCR_GCKDIV_Pos) & ~PMC_PCR_GCKDIV_Msk));
   \                     ??pmc_configure_gck_2:
   \       0x74   0xE3E0'06FF        MVN      R0,#+267386880
   \       0x78   0xE110'0A06        TST      R0,R6, LSL #+20
   \       0x7C   0x0A00'0005        BEQ      ??pmc_configure_gck_3
   \       0x80   0xE3A0'20DF        MOV      R2,#+223
   \       0x84   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x88   0x....'....        LDR      R1,??DataTable34_5
   \       0x8C   0x....'....        LDR      R0,??DataTable34_14
   \       0x90   0x....'....        BL       __aeabi_assert
   \       0x94   0x....'....        BL       __iar_EmptyStepPoint
   1760          
   1761          	pmc_disable_gck(id);
   \                     ??pmc_configure_gck_3:
   \       0x98   0xE1B0'0004        MOVS     R0,R4
   \       0x9C   0x....'....        BL       pmc_disable_gck
   1762          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \       0xA0   0xE3E0'0077        MVN      R0,#+119
   \       0xA4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0xA8   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0xAC   0xE580'1000        STR      R1,[R0, #+0]
   1763          	volatile uint32_t pcr = PMC->PMC_PCR & ~(PMC_PCR_GCKCSS_Msk | PMC_PCR_GCKDIV_Msk);
   \       0xB0   0xE590'1000        LDR      R1,[R0, #+0]
   \       0xB4   0xE3E0'26FF        MVN      R2,#+267386880
   \       0xB8   0xE3C2'2D7C        BIC      R2,R2,#0x1F00
   \       0xBC   0xE012'1001        ANDS     R1,R2,R1
   \       0xC0   0xE58D'1000        STR      R1,[SP, #+0]
   1764          	PMC->PMC_PCR = pcr | clock_source | PMC_PCR_CMD | PMC_PCR_GCKDIV(div - 1);
   \       0xC4   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xC8   0xE195'1001        ORRS     R1,R5,R1
   \       0xCC   0xE256'2001        SUBS     R2,R6,#+1
   \       0xD0   0xE3A0'36FF        MOV      R3,#+267386880
   \       0xD4   0xE013'2A02        ANDS     R2,R3,R2, LSL #+20
   \       0xD8   0xE192'1001        ORRS     R1,R2,R1
   \       0xDC   0xE391'1480        ORRS     R1,R1,#0x80000000
   \       0xE0   0xE580'1000        STR      R1,[R0, #+0]
   1765          }
   \       0xE4   0xE8BD'8073        POP      {R0,R1,R4-R6,PC}  ;; return
   1766          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1767          void pmc_enable_gck(uint32_t id)
   1768          {
   \                     pmc_enable_gck:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1769          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_gck_1
   \       0x10   0xE3A0'20E9        MOV      R2,#+233
   \       0x14   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1770          
   1771          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_enable_gck_1:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1772          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x3C   0xE58D'1000        STR      R1,[SP, #+0]
   1773          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_GCKEN;
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE391'14A0        ORRS     R1,R1,#0xA0000000
   \       0x48   0xE580'1000        STR      R1,[R0, #+0]
   1774          
   1775          #if defined(PMC_GCSR_PID0) || defined(PMC_GCSR0_GPID5)
   1776          	/* check whether or not fGCLK(Max) is out of range */
   1777          	switch(id) {
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0xE240'0005        SUB      R0,R0,#+5
   \       0x54   0xE350'002A        CMP      R0,#+42
   \       0x58   0x8A00'004A        BHI      ??pmc_enable_gck_2
   \       0x5C   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x60   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??pmc_enable_gck_0:
   \       0x64   0x3A 0x3A          DC8      0x3A,0x3A,0x3A,0x3A

   \              0x3A 0x3A
   \       0x68   0x3A 0x3A          DC8      0x3A,0x3A,0x3A,0x22

   \              0x3A 0x22
   \       0x6C   0x3A 0x3A          DC8      0x3A,0x3A,0x3A,0x3A

   \              0x3A 0x3A
   \       0x70   0x3A 0x48          DC8      0x3A,0x48,0x3A,0x48

   \              0x3A 0x48
   \       0x74   0x48 0x48          DC8      0x48,0x48,0x48,0x48

   \              0x48 0x48
   \       0x78   0x0A 0x22          DC8      0xA,0x22,0x48,0x48

   \              0x48 0x48
   \       0x7C   0x48 0x48          DC8      0x48,0x48,0x48,0x3A

   \              0x48 0x3A
   \       0x80   0x3A 0x2E          DC8      0x3A,0x2E,0x48,0x48

   \              0x48 0x48
   \       0x84   0x3A 0x48          DC8      0x3A,0x48,0x48,0x48

   \              0x48 0x48
   \       0x88   0x48 0x16          DC8      0x48,0x16,0x48,0x48

   \              0x48 0x48
   \       0x8C   0x3A 0x48          DC8      0x3A,0x48,0x3A,0x0

   \              0x3A 0x00
   1778          	case ID_LCDC:
   1779          		if (pmc_get_gck_clock(id) > 140000000) {
   \                     ??pmc_enable_gck_3:
   \       0x90   0xE1B0'0004        MOVS     R0,R4
   \       0x94   0x....'....        BL       pmc_get_gck_clock
   \       0x98   0x....'....        LDR      R1,??DataTable34_15  ;; 0x8583b01
   \       0x9C   0xE150'0001        CMP      R0,R1
   \       0xA0   0x3A00'0005        BCC      ??pmc_enable_gck_4
   1780          			trace_warning("fGCK(Max) for LCDC should not exceed 140MHz!\r\n");
   \       0xA4   0x....'....        LDR      R0,??DataTable34_16
   \       0xA8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xAC   0xE350'0003        CMP      R0,#+3
   \       0xB0   0x3A00'0001        BCC      ??pmc_enable_gck_5
   \       0xB4   0x....'....        LDR      R0,??DataTable34_17
   \       0xB8   0x....'....        BL       printf
   1781          		}
   1782          		break;
   \                     ??pmc_enable_gck_5:
   \                     ??pmc_enable_gck_4:
   \       0xBC   0xEA00'0031        B        ??pmc_enable_gck_2
   1783          	case ID_CLASSD0:
   1784          		if (pmc_get_gck_clock(id) > 100000000) {
   \                     ??pmc_enable_gck_6:
   \       0xC0   0xE1B0'0004        MOVS     R0,R4
   \       0xC4   0x....'....        BL       pmc_get_gck_clock
   \       0xC8   0x....'....        LDR      R1,??DataTable34_18  ;; 0x5f5e101
   \       0xCC   0xE150'0001        CMP      R0,R1
   \       0xD0   0x3A00'0005        BCC      ??pmc_enable_gck_7
   1785          			trace_warning("fGCK(Max) for CLASSD should not exceed 100MHz!\r\n");
   \       0xD4   0x....'....        LDR      R0,??DataTable34_16
   \       0xD8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xDC   0xE350'0003        CMP      R0,#+3
   \       0xE0   0x3A00'0001        BCC      ??pmc_enable_gck_8
   \       0xE4   0x....'....        LDR      R0,??DataTable34_19
   \       0xE8   0x....'....        BL       printf
   1786          		}
   1787          		break;
   \                     ??pmc_enable_gck_8:
   \                     ??pmc_enable_gck_7:
   \       0xEC   0xEA00'0025        B        ??pmc_enable_gck_2
   1788          	case ID_SDMMC0:
   1789          	case ID_SDMMC1:
   1790          		if (pmc_get_gck_clock(id) > 105000000) {
   \                     ??pmc_enable_gck_9:
   \       0xF0   0xE1B0'0004        MOVS     R0,R4
   \       0xF4   0x....'....        BL       pmc_get_gck_clock
   \       0xF8   0x....'....        LDR      R1,??DataTable34_20  ;; 0x6422c41
   \       0xFC   0xE150'0001        CMP      R0,R1
   \      0x100   0x3A00'0005        BCC      ??pmc_enable_gck_10
   1791          			trace_warning("fGCK(Max) for SDMMC should not exceed 105MHz!\r\n");
   \      0x104   0x....'....        LDR      R0,??DataTable34_16
   \      0x108   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x10C   0xE350'0003        CMP      R0,#+3
   \      0x110   0x3A00'0001        BCC      ??pmc_enable_gck_11
   \      0x114   0x....'....        LDR      R0,??DataTable34_21
   \      0x118   0x....'....        BL       printf
   1792          		}
   1793          		break;
   \                     ??pmc_enable_gck_11:
   \                     ??pmc_enable_gck_10:
   \      0x11C   0xEA00'0019        B        ??pmc_enable_gck_2
   1794          	case ID_I2SMCC:
   1795          		if (pmc_get_gck_clock(id) > 105000000) {
   \                     ??pmc_enable_gck_12:
   \      0x120   0xE1B0'0004        MOVS     R0,R4
   \      0x124   0x....'....        BL       pmc_get_gck_clock
   \      0x128   0x....'....        LDR      R1,??DataTable34_20  ;; 0x6422c41
   \      0x12C   0xE150'0001        CMP      R0,R1
   \      0x130   0x3A00'0005        BCC      ??pmc_enable_gck_13
   1796          			trace_warning("fGCK(Max) for I2SMCC should not exceed 105MHz!\r\n");
   \      0x134   0x....'....        LDR      R0,??DataTable34_16
   \      0x138   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x13C   0xE350'0003        CMP      R0,#+3
   \      0x140   0x3A00'0001        BCC      ??pmc_enable_gck_14
   \      0x144   0x....'....        LDR      R0,??DataTable34_22
   \      0x148   0x....'....        BL       printf
   1797          		}
   1798          		break;
   \                     ??pmc_enable_gck_14:
   \                     ??pmc_enable_gck_13:
   \      0x14C   0xEA00'000D        B        ??pmc_enable_gck_2
   1799          	case ID_ADC:
   1800          	case ID_TC0: case ID_TC1:
   1801          	case ID_PIT64B:
   1802          	case ID_DBGU:
   1803          	case ID_FLEXCOM0: case ID_FLEXCOM1: case ID_FLEXCOM2: case ID_FLEXCOM3:
   1804          	case ID_FLEXCOM4: case ID_FLEXCOM5: case ID_FLEXCOM6: case ID_FLEXCOM7:
   1805          	case ID_FLEXCOM8: case ID_FLEXCOM9:	case ID_FLEXCOM10: case ID_FLEXCOM11:
   1806          	case ID_FLEXCOM12:
   1807          		if (3 * pmc_get_gck_clock(id) > pmc_get_master_clock()) {
   \                     ??pmc_enable_gck_15:
   \      0x150   0x....'....        BL       pmc_get_master_clock
   \      0x154   0xE1B0'5000        MOVS     R5,R0
   \      0x158   0xE1B0'0004        MOVS     R0,R4
   \      0x15C   0x....'....        BL       pmc_get_gck_clock
   \      0x160   0xE080'0080        ADD      R0,R0,R0, LSL #+1
   \      0x164   0xE155'0000        CMP      R5,R0
   \      0x168   0x2A00'0006        BCS      ??pmc_enable_gck_16
   1808          			trace_warning("fGCK(Max) for perpheral %d should not exceed fMCK/3!\r\n", id);
   \      0x16C   0x....'....        LDR      R0,??DataTable34_16
   \      0x170   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x174   0xE350'0003        CMP      R0,#+3
   \      0x178   0x3A00'0002        BCC      ??pmc_enable_gck_17
   \      0x17C   0xE1B0'1004        MOVS     R1,R4
   \      0x180   0x....'....        LDR      R0,??DataTable34_23
   \      0x184   0x....'....        BL       printf
   1809          		}
   1810          		break;
   1811          	}
   1812          
   1813          	while ((PMC->PMC_GCSR[(id >> 5) & 3] & (1 << (id & 31))) == 0);
   \                     ??pmc_enable_gck_17:
   \                     ??pmc_enable_gck_16:
   \                     ??pmc_enable_gck_2:
   \      0x188   0xE3E0'003F        MVN      R0,#+63
   \      0x18C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x190   0xE3A0'1003        MOV      R1,#+3
   \      0x194   0xE011'12A4        ANDS     R1,R1,R4, LSR #+5
   \      0x198   0xE1B0'1101        LSLS     R1,R1,#+2
   \      0x19C   0xE790'0001        LDR      R0,[R0, +R1]
   \      0x1A0   0xE1B0'1004        MOVS     R1,R4
   \      0x1A4   0xE211'101F        ANDS     R1,R1,#0x1F
   \      0x1A8   0xE3A0'2001        MOV      R2,#+1
   \      0x1AC   0xE112'0130        TST      R2,R0, LSR R1
   \      0x1B0   0x0AFF'FFF4        BEQ      ??pmc_enable_gck_2
   1814          #elif defined (PMC_SR_GCKRDY)
   1815          	while (!(PMC->PMC_SR & PMC_SR_GCKRDY));
   1816          #else
   1817          	#error pmc_enable_gck() needs to be updated.
   1818          #endif
   1819          }
   \      0x1B4   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
   1820          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1821          RAMCODE void pmc_disable_gck(uint32_t id)
   1822          {
   \                     pmc_disable_gck:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1823          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_gck_0
   \       0x10   0xE3A0'201F        MOV      R2,#+31
   \       0x14   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1824          
   1825          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_disable_gck_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1826          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x3C   0xE58D'1000        STR      R1,[SP, #+0]
   1827          	PMC->PMC_PCR = PMC_PCR_CMD | (pcr & ~PMC_PCR_GCKEN);
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE3D1'1580        BICS     R1,R1,#0x20000000
   \       0x48   0xE391'1480        ORRS     R1,R1,#0x80000000
   \       0x4C   0xE580'1000        STR      R1,[R0, #+0]
   1828          }
   \       0x50   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1829          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1830          uint32_t pmc_get_gck_clock(uint32_t id)
   1831          {
   \                     pmc_get_gck_clock:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'6000        MOVS     R6,R0
   1832          	uint32_t clk = 0;
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xE1B0'5004        MOVS     R5,R4
   1833          	assert(id < ID_PERIPH_COUNT);
   \       0x10   0xE356'0033        CMP      R6,#+51
   \       0x14   0x3A00'0005        BCC      ??pmc_get_gck_clock_0
   \       0x18   0xE3A0'2029        MOV      R2,#+41
   \       0x1C   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x20   0x....'....        LDR      R1,??DataTable34_5
   \       0x24   0x....'....        LDR      R0,??DataTable34_6
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1834          
   1835          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_get_gck_clock_0:
   \       0x30   0xE3E0'0077        MVN      R0,#+119
   \       0x34   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x38   0xE216'107F        ANDS     R1,R6,#0x7F
   \       0x3C   0xE580'1000        STR      R1,[R0, #+0]
   1836          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x40   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x44   0xE58D'0000        STR      R0,[SP, #+0]
   1837          
   1838          	switch (pcr & PMC_PCR_GCKCSS_Msk) {
   \       0x48   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x4C   0xE210'0D7C        ANDS     R0,R0,#0x1F00
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'0008        BEQ      ??pmc_get_gck_clock_1
   \       0x58   0xE350'0F80        CMP      R0,#+512
   \       0x5C   0x0A00'0009        BEQ      ??pmc_get_gck_clock_2
   \       0x60   0xE350'0FC0        CMP      R0,#+768
   \       0x64   0x0A00'0010        BEQ      ??pmc_get_gck_clock_3
   \       0x68   0xE350'0E40        CMP      R0,#+1024
   \       0x6C   0x0A00'0008        BEQ      ??pmc_get_gck_clock_4
   \       0x70   0xE350'0E50        CMP      R0,#+1280
   \       0x74   0x0A00'0009        BEQ      ??pmc_get_gck_clock_5
   \       0x78   0xEA00'000D        B        ??pmc_get_gck_clock_6
   1839          	case PMC_PCR_GCKCSS_SLOW_CLK:
   1840          		clk = pmc_get_slow_clock();
   \                     ??pmc_get_gck_clock_1:
   \       0x7C   0x....'....        BL       pmc_get_slow_clock
   \       0x80   0xE1B0'5000        MOVS     R5,R0
   1841          		break;
   \       0x84   0xEA00'000A        B        ??pmc_get_gck_clock_6
   1842          	case PMC_PCR_GCKCSS_MAIN_CLK:
   1843          		clk = pmc_get_main_clock();
   \                     ??pmc_get_gck_clock_2:
   \       0x88   0x....'....        BL       pmc_get_main_clock
   \       0x8C   0xE1B0'5000        MOVS     R5,R0
   1844          		break;
   \       0x90   0xEA00'0007        B        ??pmc_get_gck_clock_6
   1845          	case PMC_PCR_GCKCSS_PLLA_CLK:
   1846          		clk = pmc_get_plla_clock();
   \                     ??pmc_get_gck_clock_4:
   \       0x94   0x....'....        BL       pmc_get_plla_clock
   \       0x98   0xE1B0'5000        MOVS     R5,R0
   1847          		break;
   \       0x9C   0xEA00'0004        B        ??pmc_get_gck_clock_6
   1848          	case PMC_PCR_GCKCSS_UPLL_CLK:
   1849          		clk = pmc_get_upll_clock();
   \                     ??pmc_get_gck_clock_5:
   \       0xA0   0x....'....        BL       pmc_get_upll_clock
   \       0xA4   0xE1B0'5000        MOVS     R5,R0
   1850          		break;
   \       0xA8   0xEA00'0001        B        ??pmc_get_gck_clock_6
   1851          	case PMC_PCR_GCKCSS_MCK_CLK:
   1852          		clk = pmc_get_master_clock();
   \                     ??pmc_get_gck_clock_3:
   \       0xAC   0x....'....        BL       pmc_get_master_clock
   \       0xB0   0xE1B0'5000        MOVS     R5,R0
   1853          		break;
   1854          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1855          	case PMC_PCR_GCKCSS_AUDIO_CLK:
   1856          		clk = pmc_get_audio_pmc_clock();
   1857          		break;
   1858          #endif
   1859          	}
   1860          
   1861          	uint32_t div = (pcr & PMC_PCR_GCKDIV_Msk) >> PMC_PCR_GCKDIV_Pos;
   \                     ??pmc_get_gck_clock_6:
   \       0xB4   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xB8   0xE3A0'10FF        MOV      R1,#+255
   \       0xBC   0xE011'1A20        ANDS     R1,R1,R0, LSR #+20
   1862          	return ROUND_INT_DIV(clk, div + 1);
   \       0xC0   0xE355'0000        CMP      R5,#+0
   \       0xC4   0x0A00'0019        BEQ      ??pmc_get_gck_clock_7
   \                     ??pmc_get_gck_clock_8:
   \       0xC8   0xE355'0000        CMP      R5,#+0
   \       0xCC   0x1A00'0001        BNE      ??pmc_get_gck_clock_9
   \       0xD0   0xE3A0'0001        MOV      R0,#+1
   \       0xD4   0xEA00'0000        B        ??pmc_get_gck_clock_10
   \                     ??pmc_get_gck_clock_9:
   \       0xD8   0xE1B0'0004        MOVS     R0,R4
   \                     ??pmc_get_gck_clock_10:
   \       0xDC   0xE291'2001        ADDS     R2,R1,#+1
   \       0xE0   0xE352'0000        CMP      R2,#+0
   \       0xE4   0x1A00'0001        BNE      ??pmc_get_gck_clock_11
   \       0xE8   0xE3A0'4001        MOV      R4,#+1
   \       0xEC   0xEAFF'FFFF        B        ??pmc_get_gck_clock_12
   \                     ??pmc_get_gck_clock_11:
   \                     ??pmc_get_gck_clock_12:
   \       0xF0   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0xF4   0xE214'40FF        ANDS     R4,R4,#0xFF      ;; Zero extend
   \       0xF8   0xE034'0000        EORS     R0,R4,R0
   \       0xFC   0xE350'0000        CMP      R0,#+0
   \      0x100   0x0A00'0005        BEQ      ??pmc_get_gck_clock_13
   \      0x104   0xE291'0001        ADDS     R0,R1,#+1
   \      0x108   0xE055'00A0        SUBS     R0,R5,R0, LSR #+1
   \      0x10C   0xE291'1001        ADDS     R1,R1,#+1
   \      0x110   0x....'....        BL       __aeabi_uidiv
   \      0x114   0xE1B0'4000        MOVS     R4,R0
   \      0x118   0xEA00'0004        B        ??pmc_get_gck_clock_7
   \                     ??pmc_get_gck_clock_13:
   \      0x11C   0xE291'0001        ADDS     R0,R1,#+1
   \      0x120   0xE095'00A0        ADDS     R0,R5,R0, LSR #+1
   \      0x124   0xE291'1001        ADDS     R1,R1,#+1
   \      0x128   0x....'....        BL       __aeabi_uidiv
   \      0x12C   0xE1B0'4000        MOVS     R4,R0
   \                     ??pmc_get_gck_clock_7:
   \      0x130   0xE1B0'0004        MOVS     R0,R4
   \      0x134   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
   1863          }
   1864          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1865          bool pmc_is_gck_enabled(uint32_t id)
   1866          {
   \                     pmc_is_gck_enabled:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1867          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_is_gck_enabled_0
   \       0x10   0xE3A0'204B        MOV      R2,#+75
   \       0x14   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x18   0x....'....        LDR      R1,??DataTable34_5
   \       0x1C   0x....'....        LDR      R0,??DataTable34_6
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1868          
   1869          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_is_gck_enabled_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1870          
   1871          	return (PMC->PMC_PCR & PMC_PCR_GCKEN) != 0;
   \       0x38   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x3C   0xE1B0'0EA0        LSRS     R0,R0,#+29
   \       0x40   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
   1872          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     _pmc_mck

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0xFF00'FEFE        DC32     0xff00fefe

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable29_1:
   \        0x0   0x30 0x00          DC8      "0",0x0,0x0

   \              0x00 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_1:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_2:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_3:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_4:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_5:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_6:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_7:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_8:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_9:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_10:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_11:
   \        0x0   0x1C9C'3800        DC32     0x1c9c3800

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_12:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_13:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_14:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_15:
   \        0x0   0x0858'3B01        DC32     0x8583b01

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_16:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_17:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_18:
   \        0x0   0x05F5'E101        DC32     0x5f5e101

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_19:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_20:
   \        0x0   0x0642'2C41        DC32     0x6422c41

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_21:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_22:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable34_23:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x70 0x6C          DC8 "plla->div == 1"

   \              0x6C 0x61    

   \              0x2D 0x3E    

   \              0x64 0x69    

   \              0x76 0x20    

   \              0x3D 0x3D    

   \              0x20 0x31    

   \              0x00
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68

   \              0x70 0x65    

   \              0x72 0x69    

   \              0x70 0x68
   \       0x40   0x65 0x72          DC8 0x65, 0x72, 0x61, 0x6C, 0x73, 0x5C, 0x70, 0x6D

   \              0x61 0x6C    

   \              0x73 0x5C    

   \              0x70 0x6D
   \       0x48   0x63 0x2E          DC8 0x63, 0x2E, 0x63, 0

   \              0x63 0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x46          DC8 "-F- Unknown PLL which index is %d\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x6B 0x6E    

   \              0x6F 0x77    

   \              0x6E 0x20    

   \              0x50 0x4C    

   \              0x4C 0x20    

   \              0x77 0x68    

   \              0x69 0x63    

   \              0x68 0x20    

   \              0x69 0x6E    

   \              0x64 0x65    

   \              0x78 0x20    

   \              0x69 0x73    

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x21 0x28          DC8 "!(prescaler & ~(0x7u << 4))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x37 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x34 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x21 0x28          DC8 "!(divider & ~(0x7u << 8))"

   \              0x64 0x69    

   \              0x76 0x69    

   \              0x64 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x37 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x34, 0x35, 0x20, 0x55, 0x6E, 0x6B

   \              0x34 0x35    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x35, 0x38, 0x20, 0x55, 0x6E, 0x6B

   \              0x35 0x38    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x37, 0x31, 0x20, 0x55, 0x6E, 0x6B

   \              0x37 0x31    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x69 0x64          DC8 "id < (51)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x35 0x31    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x69 0x6E          DC8 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x3C, 0x20

   \              0x64 0x65    

   \              0x78 0x20    

   \              0x3C 0x20
   \        0x8   0x28 0x73          DC8 0x28, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x20

   \              0x69 0x7A    

   \              0x65 0x6F    

   \              0x66 0x20
   \       0x10   0x28 0x28          DC8 0x28, 0x28, 0x28, 0x28, 0x50, 0x6D, 0x63, 0x20

   \              0x28 0x28    

   \              0x50 0x6D    

   \              0x63 0x20
   \       0x18   0x2A 0x29          DC8 0x2A, 0x29, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46

   \              0x30 0x78    

   \              0x46 0x46    

   \              0x46 0x46
   \       0x20   0x46 0x43          DC8 0x46, 0x43, 0x30, 0x30, 0x55, 0x29, 0x2D, 0x3E

   \              0x30 0x30    

   \              0x55 0x29    

   \              0x2D 0x3E
   \       0x28   0x50 0x4D          DC8 0x50, 0x4D, 0x43, 0x5F, 0x50, 0x43, 0x4B, 0x29

   \              0x43 0x5F    

   \              0x50 0x43    

   \              0x4B 0x29
   \       0x30   0x29 0x20          DC8 0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65

   \              0x2F 0x20    

   \              0x73 0x69    

   \              0x7A 0x65
   \       0x38   0x6F 0x66          DC8 0x6F, 0x66, 0x28, 0x2A, 0x28, 0x28, 0x28, 0x50

   \              0x28 0x2A    

   \              0x28 0x28    

   \              0x28 0x50
   \       0x40   0x6D 0x63          DC8 0x6D, 0x63, 0x20, 0x2A, 0x29, 0x30, 0x78, 0x46

   \              0x20 0x2A    

   \              0x29 0x30    

   \              0x78 0x46
   \       0x48   0x46 0x46          DC8 0x46, 0x46, 0x46, 0x46, 0x43, 0x30, 0x30, 0x55

   \              0x46 0x46    

   \              0x43 0x30    

   \              0x30 0x55
   \       0x50   0x29 0x2D          DC8 0x29, 0x2D, 0x3E, 0x50, 0x4D, 0x43, 0x5F, 0x50

   \              0x3E 0x50    

   \              0x4D 0x43    

   \              0x5F 0x50
   \       0x58   0x43 0x4B          DC8 0x43, 0x4B, 0x29, 0x29, 0x29, 0

   \              0x29 0x29    

   \              0x29 0x00
   \       0x5E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x21 0x28          DC8 "!(clock_source & ~(0x1fu << 0))"

   \              0x63 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x5F    

   \              0x73 0x6F    

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x31    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x30 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x21 0x28          DC8 "!(prescaler << 8 & ~(0xffu << 8))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x3C 0x3C    

   \              0x20 0x38    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x66    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00
   \       0x22   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \        0x0   0x30 0x00          DC8 "0"

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x21 0x28          DC8 "!(clock_source & ~(0x1fu << 8))"

   \              0x63 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x5F    

   \              0x73 0x6F    

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x31    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x64 0x69          DC8 "div > 0"

   \              0x76 0x20    

   \              0x3E 0x20    

   \              0x30 0x00

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x21 0x28          DC8 "!((div << 20) & ~(0xffu << 20))"

   \              0x28 0x64    

   \              0x69 0x76    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x32 0x30    

   \              0x29 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x66 0x66    

   \              0x75 0x20    

   \              0x3C 0x3C    

   \              0x20 0x32    

   \              0x30 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \        0x8   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \       0x10   0x72 0x20          DC8 0x72, 0x20, 0x4C, 0x43, 0x44, 0x43, 0x20, 0x73

   \              0x4C 0x43    

   \              0x44 0x43    

   \              0x20 0x73
   \       0x18   0x68 0x6F          DC8 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F

   \              0x75 0x6C    

   \              0x64 0x20    

   \              0x6E 0x6F
   \       0x20   0x74 0x20          DC8 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64

   \              0x65 0x78    

   \              0x63 0x65    

   \              0x65 0x64
   \       0x28   0x20 0x31          DC8 0x20, 0x31, 0x34, 0x30, 0x4D, 0x48, 0x7A, 0x21

   \              0x34 0x30    

   \              0x4D 0x48    

   \              0x7A 0x21
   \       0x30   0x0D 0x0A          DC8 0x0D, 0x0A, 0

   \              0x00
   \       0x33   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \        0x8   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \       0x10   0x72 0x20          DC8 0x72, 0x20, 0x43, 0x4C, 0x41, 0x53, 0x53, 0x44

   \              0x43 0x4C    

   \              0x41 0x53    

   \              0x53 0x44
   \       0x18   0x20 0x73          DC8 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20

   \              0x68 0x6F    

   \              0x75 0x6C    

   \              0x64 0x20
   \       0x20   0x6E 0x6F          DC8 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65

   \              0x74 0x20    

   \              0x65 0x78    

   \              0x63 0x65
   \       0x28   0x65 0x64          DC8 0x65, 0x64, 0x20, 0x31, 0x30, 0x30, 0x4D, 0x48

   \              0x20 0x31    

   \              0x30 0x30    

   \              0x4D 0x48
   \       0x30   0x7A 0x21          DC8 0x7A, 0x21, 0x0D, 0x0A, 0

   \              0x0D 0x0A    

   \              0x00
   \       0x35   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \        0x8   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \       0x10   0x72 0x20          DC8 0x72, 0x20, 0x53, 0x44, 0x4D, 0x4D, 0x43, 0x20

   \              0x53 0x44    

   \              0x4D 0x4D    

   \              0x43 0x20
   \       0x18   0x73 0x68          DC8 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E

   \              0x6F 0x75    

   \              0x6C 0x64    

   \              0x20 0x6E
   \       0x20   0x6F 0x74          DC8 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65

   \              0x20 0x65    

   \              0x78 0x63    

   \              0x65 0x65
   \       0x28   0x64 0x20          DC8 0x64, 0x20, 0x31, 0x30, 0x35, 0x4D, 0x48, 0x7A

   \              0x31 0x30    

   \              0x35 0x4D    

   \              0x48 0x7A
   \       0x30   0x21 0x0D          DC8 0x21, 0x0D, 0x0A, 0

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \        0x8   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \       0x10   0x72 0x20          DC8 0x72, 0x20, 0x49, 0x32, 0x53, 0x4D, 0x43, 0x43

   \              0x49 0x32    

   \              0x53 0x4D    

   \              0x43 0x43
   \       0x18   0x20 0x73          DC8 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20

   \              0x68 0x6F    

   \              0x75 0x6C    

   \              0x64 0x20
   \       0x20   0x6E 0x6F          DC8 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65

   \              0x74 0x20    

   \              0x65 0x78    

   \              0x63 0x65
   \       0x28   0x65 0x64          DC8 0x65, 0x64, 0x20, 0x31, 0x30, 0x35, 0x4D, 0x48

   \              0x20 0x31    

   \              0x30 0x35    

   \              0x4D 0x48
   \       0x30   0x7A 0x21          DC8 0x7A, 0x21, 0x0D, 0x0A, 0

   \              0x0D 0x0A    

   \              0x00
   \       0x35   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \        0x8   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \       0x10   0x72 0x20          DC8 0x72, 0x20, 0x70, 0x65, 0x72, 0x70, 0x68, 0x65

   \              0x70 0x65    

   \              0x72 0x70    

   \              0x68 0x65
   \       0x18   0x72 0x61          DC8 0x72, 0x61, 0x6C, 0x20, 0x25, 0x64, 0x20, 0x73

   \              0x6C 0x20    

   \              0x25 0x64    

   \              0x20 0x73
   \       0x20   0x68 0x6F          DC8 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F

   \              0x75 0x6C    

   \              0x64 0x20    

   \              0x6E 0x6F
   \       0x28   0x74 0x20          DC8 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64

   \              0x65 0x78    

   \              0x63 0x65    

   \              0x65 0x64
   \       0x30   0x20 0x66          DC8 0x20, 0x66, 0x4D, 0x43, 0x4B, 0x2F, 0x33, 0x21

   \              0x4D 0x43    

   \              0x4B 0x2F    

   \              0x33 0x21
   \       0x38   0x0D 0x0A          DC8 0x0D, 0x0A, 0

   \              0x00
   \       0x3B   0x00               DC8 0
   1873          
   1874          #endif /* CONFIG_HAVE_PMC_GENERATED_CLOCKS */
   1875          
   1876          /*----------------------------------------------------------------------------
   1877           *        Exported functions (Audio PLL)
   1878           *----------------------------------------------------------------------------*/
   1879          
   1880          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1881          void pmc_configure_audio(const struct _pmc_audio_cfg *cfg)
   1882          {
   1883          #ifdef PMC_AUDIO_PLL0_PLLEN
   1884          	/* reset audio clock */
   1885          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_RESETN |
   1886          	                         PMC_AUDIO_PLL0_PLLEN);
   1887          	PMC->PMC_AUDIO_PLL0 |= PMC_AUDIO_PLL0_RESETN;
   1888          
   1889          	/* configure values */
   1890          	PMC->PMC_AUDIO_PLL0 = PMC_AUDIO_PLL0_ND(cfg->nd)
   1891          	                    | PMC_AUDIO_PLL0_QDPMC(cfg->qdpmc)
   1892          	                    | PMC_AUDIO_PLL0_PLLFLT_STD
   1893          	                    | PMC_AUDIO_PLL0_RESETN;
   1894          	PMC->PMC_AUDIO_PLL1 = PMC_AUDIO_PLL1_FRACR(cfg->fracr)
   1895          	                    | PMC_AUDIO_PLL1_DIV(cfg->div)
   1896          	                    | PMC_AUDIO_PLL1_QDAUDIO(cfg->qdaudio);
   1897          #else
   1898          	/* reset audio clock */
   1899          	PMC->PMC_APLLCCR &= ~(PMC_APLLCCR_RESETN |
   1900          	                      PMC_APLLCCR_PLLEN);
   1901          	PMC->PMC_APLLCCR |= PMC_APLLCCR_RESETN;
   1902          
   1903          	/* configure values */
   1904          	PMC->PMC_APLLCCR = PMC_APLLCCR_ND(cfg->nd)
   1905          	                 | PMC_APLLCCR_FRACR(cfg->fracr)
   1906          	                 | PMC_APLLCCR_RESETN;
   1907          	PMC->PMC_APLLPCR = PMC_APLLPCR_QDAUDIO(cfg->div * cfg->qdaudio);
   1908          	PMC->PMC_APLLICR = PMC_APLLICR_QDPMC(cfg->qdpmc);
   1909          #endif
   1910          }
   1911          
   1912          void pmc_enable_audio(bool pmc_clock, bool pad_clock)
   1913          {
   1914          #ifdef PMC_AUDIO_PLL0_PLLEN
   1915          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1916          	pll0 &= ~(PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1917          	pll0 |= PMC_AUDIO_PLL0_PLLEN;
   1918          	if (pad_clock)
   1919          		pll0 |= PMC_AUDIO_PLL0_PADEN;
   1920          	if (pmc_clock)
   1921          		pll0 |= PMC_AUDIO_PLL0_PMCEN;
   1922          	PMC->PMC_AUDIO_PLL0 = pll0;
   1923          #else
   1924          	PMC->PMC_APLLCCR |= PMC_APLLCCR_PLLEN;
   1925          
   1926          	if (pad_clock)
   1927          		PMC->PMC_APLLPCR |= PMC_APLLPCR_PADEN;
   1928          	else
   1929          		PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1930          
   1931          	if (pmc_clock)
   1932          		PMC->PMC_APLLICR |= PMC_APLLICR_PMCEN;
   1933          	else
   1934          		PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1935          #endif
   1936          
   1937          	/* Wait for the Audio PLL Startup Time (tSTART = 100 usec) */
   1938          	usleep(100);
   1939          }
   1940          
   1941          void pmc_disable_audio()
   1942          {
   1943          #ifdef PMC_AUDIO_PLL0_PLLEN
   1944          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_PLLEN | PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1945          #else
   1946          	PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1947          	PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1948          	PMC->PMC_APLLCCR &= ~PMC_APLLCCR_PLLEN;
   1949          #endif
   1950          }
   1951          
   1952          uint32_t pmc_get_audio_pmc_clock(void)
   1953          {
   1954          	uint32_t nd, fracr, qdpmc;
   1955          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1956          
   1957          #ifdef PMC_AUDIO_PLL0_PLLEN
   1958          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1959          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1960          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1961          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1962          	qdpmc = (pll0 & PMC_AUDIO_PLL0_QDPMC_Msk) >> PMC_AUDIO_PLL0_QDPMC_Pos;
   1963          #else
   1964          	uint32_t ccr = PMC->PMC_APLLCCR;
   1965          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1966          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1967          	qdpmc = (PMC->PMC_APLLICR & PMC_APLLICR_QDPMC_Msk) >> PMC_APLLICR_QDPMC_Pos;
   1968          #endif
   1969          
   1970          	clk *= ((nd + 1) << 22) + fracr;
   1971          	clk /= 1 << 22;
   1972          	clk /= qdpmc + 1;
   1973          	return (uint32_t)clk;
   1974          }
   1975          
   1976          uint32_t pmc_get_audio_pad_clock(void)
   1977          {
   1978          	uint32_t nd, fracr, qdaudio, div;
   1979          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1980          
   1981          #ifdef PMC_AUDIO_PLL0_PLLEN
   1982          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1983          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1984          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1985          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1986          	qdaudio = (pll1 & PMC_AUDIO_PLL1_QDAUDIO_Msk) >> PMC_AUDIO_PLL1_QDAUDIO_Pos;
   1987          	if (qdaudio == 0)
   1988          		return 0;
   1989          	div = (pll1 & PMC_AUDIO_PLL1_DIV_Msk) >> PMC_AUDIO_PLL1_DIV_Pos;
   1990          	if (div != 2 && div != 3)
   1991          		return 0;
   1992          #else
   1993          	uint32_t ccr = PMC->PMC_APLLCCR;
   1994          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1995          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1996          	qdaudio = (PMC->PMC_APLLPCR & PMC_APLLPCR_QDAUDIO_Msk) >> PMC_APLLPCR_QDAUDIO_Pos;
   1997          	if (qdaudio == 0)
   1998          		return 0;
   1999          	div = 1;
   2000          #endif
   2001          
   2002          	clk *= ((nd + 1) << 22) + fracr;
   2003          	clk /= 1 << 22;
   2004          	clk /= div * qdaudio;
   2005          	return (uint32_t)clk;
   2006          }
   2007          #endif /* CONFIG_HAVE_PMC_AUDIO_CLOCK */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   _pmc_compute_mck
        24   -> pmc_get_main_clock
        24   -> pmc_get_plla_clock
        24   -> pmc_get_slow_clock
        24   -> pmc_get_upll_clock
        24 __aeabi_uidiv
      24   _pmc_configure_pll
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> printf
        24   -> usleep
       8   _pmc_disable_pll
         8   -> printf
      16   _pmc_get_pck_clock
        16   -> pmc_get_main_clock
        16   -> pmc_get_master_clock
        16   -> pmc_get_plla_clock
        16   -> pmc_get_slow_clock
        16   -> pmc_get_upll_clock
        16 __aeabi_uidiv
      40   _pmc_get_pll_clock
        40   -> _pmc_get_pll_config
        40   -> pmc_get_main_clock
        40   -> pmc_get_main_oscillator_freq
        40   -> printf
        40 __aeabi_uidiv
      24   _pmc_get_pll_config
        24   -> __aeabi_memset
      12   _pmc_get_system_clock_bits
      16   _pmc_measure_main_osc_freq
        16   -> dsb
       0   _pmc_pll_enabled
       0   dsb
      24   pmc_configure_gck
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> pmc_disable_gck
      16   pmc_configure_pck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_disable_pck
      16   pmc_configure_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_configure_gck
        16   -> pmc_disable_gck
        16   -> pmc_disable_peripheral
        16   -> pmc_enable_gck
        16   -> pmc_enable_peripheral
       8   pmc_configure_plla
         8   -> _pmc_configure_pll
       8   pmc_disable_all_peripherals
         8   -> pmc_disable_peripheral
       0   pmc_disable_external_osc
      16   pmc_disable_gck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   pmc_disable_internal_osc
       8   pmc_disable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_disable_peripheral
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_disable_plla
         8   -> _pmc_disable_pll
      16   pmc_disable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       8   pmc_disable_upll_clock
         8   -> _pmc_disable_pll
       4   pmc_enable_external_osc
      16   pmc_enable_gck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_get_gck_clock
        16   -> pmc_get_master_clock
        16   -> printf
       0   pmc_enable_internal_osc
       8   pmc_enable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pmc_enable_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   pmc_enable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_enable_ulp1
      32   pmc_enable_upll_clock
        32   -> __aeabi_memcpy4
        32   -> _pmc_configure_pll
      16   pmc_ext32k_monitor
        16   -> slowclock_is_internal
        16   -> slowclock_select_external
        16   -> slowclock_set_bypass
      24   pmc_get_gck_clock
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> pmc_get_main_clock
        24   -> pmc_get_master_clock
        24   -> pmc_get_plla_clock
        24   -> pmc_get_slow_clock
        24   -> pmc_get_upll_clock
        24 __aeabi_uidiv
       0   pmc_get_main_clock
       8   pmc_get_main_oscillator_freq
         8   -> pmc_set_main_oscillator_freq
       8   pmc_get_master_clock
         8   -> _pmc_compute_mck
       8   pmc_get_pck_clock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> _pmc_get_pck_clock
      56   pmc_get_pck_mck_cfg
        56   -> __aeabi_memcpy4
        56   -> __aeabi_memset
        56   -> pmc_ext32k_monitor
        56   -> slowclock_is_internal
        56   -> slowclock_select_external
        56   -> slowclock_select_internal
      16   pmc_get_peripheral_clock
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> get_peripheral_clock_matrix_div
        16   -> pmc_get_master_clock
        16 __aeabi_uidiv
       8   pmc_get_plla_clock
         8   -> _pmc_get_pll_clock
       8   pmc_get_processor_clock
         8   -> pmc_get_master_clock
       8   pmc_get_slow_clock
         8   -> slowclock_get_clock
       8   pmc_get_upll_clock
         8   -> _pmc_get_pll_clock
      32   pmc_get_utmi_clock_trim
        32   -> _pmc_get_pll_config
        32 __aeabi_uidiv
       8   pmc_has_system_clock
         8   -> _pmc_get_system_clock_bits
       8   pmc_is_gck_enabled
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_is_peripheral_enabled
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pmc_is_system_clock_enabled
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       8   pmc_is_upll_clock_enabled
         8   -> _pmc_pll_enabled
       8   pmc_select_external_crystal
         8   -> pmc_switch_mck_to_main
         8   -> pmc_switch_mck_to_slck
         8   -> slowclock_select_external
      24   pmc_select_external_osc
        24   -> pmc_disable_internal_osc
        24   -> pmc_enable_external_osc
        24   -> pmc_enable_internal_osc
       8   pmc_select_internal_crystal
         8   -> pmc_switch_mck_to_main
         8   -> pmc_switch_mck_to_slck
         8   -> slowclock_select_internal
       8   pmc_select_internal_osc
         8   -> pmc_disable_external_osc
         8   -> pmc_enable_internal_osc
       8   pmc_set_custom_pck_mck
         8   -> pmc_configure_plla
         8   -> pmc_disable_external_osc
         8   -> pmc_disable_internal_osc
         8   -> pmc_disable_plla
         8   -> pmc_select_external_crystal
         8   -> pmc_select_external_osc
         8   -> pmc_select_internal_crystal
         8   -> pmc_select_internal_osc
         8   -> pmc_set_mck_divider
         8   -> pmc_set_mck_prescaler
         8   -> pmc_switch_mck_to_main
         8   -> pmc_switch_mck_to_pll
         8   -> pmc_switch_mck_to_slck
         8   -> pmc_switch_mck_to_upll
         8   -> slowclock_set_bypass
       0   pmc_set_fast_startup_mode
       0   pmc_set_fast_startup_polarity
      40   pmc_set_main_oscillator_freq
        40   -> _pmc_measure_main_osc_freq
        40   -> pmc_disable_internal_osc
        40   -> pmc_select_external_osc
        40   -> pmc_select_internal_osc
        40   -> pmc_switch_mck_to_new_source
        40   -> pmc_switch_mck_to_slck
        40 __aeabi_idiv
       8   pmc_set_mck_divider
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_set_mck_prescaler
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_switch_mck_to_main
       4   pmc_switch_mck_to_new_source
       0   pmc_switch_mck_to_pll
       0   pmc_switch_mck_to_slck
       0   pmc_switch_mck_to_upll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable25
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_10
       4  ??DataTable34_11
       4  ??DataTable34_12
       4  ??DataTable34_13
       4  ??DataTable34_14
       4  ??DataTable34_15
       4  ??DataTable34_16
       4  ??DataTable34_17
       4  ??DataTable34_18
       4  ??DataTable34_19
       4  ??DataTable34_2
       4  ??DataTable34_20
       4  ??DataTable34_21
       4  ??DataTable34_22
       4  ??DataTable34_23
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable34_8
       4  ??DataTable34_9
      16  ?_0
      76  ?_1
      32  ?_10
      36  ?_11
       2  ?_12
      32  ?_13
       8  ?_14
      32  ?_15
      52  ?_16
      56  ?_17
      52  ?_18
      56  ?_19
      36  ?_2
      60  ?_20
      24  ?_21
      28  ?_3
      28  ?_4
     112  ?_5
     112  ?_6
     112  ?_7
      12  ?_8
      96  ?_9
     340  _pmc_compute_mck
     452  _pmc_configure_pll
     180  _pmc_disable_pll
     136  _pmc_get_pck_clock
     148  _pmc_get_pll_clock
     176  _pmc_get_pll_config
     240  _pmc_get_system_clock_bits
       8  _pmc_main_oscillators
       4  _pmc_mck
     140  _pmc_measure_main_osc_freq
      28  _pmc_pll_enabled
      12  dsb
     232  pmc_configure_gck
     160  pmc_configure_pck
     160  pmc_configure_peripheral
      20  pmc_configure_plla
      36  pmc_disable_all_peripherals
      60  pmc_disable_external_osc
      84  pmc_disable_gck
      36  pmc_disable_internal_osc
     168  pmc_disable_pck
      76  pmc_disable_peripheral
      16  pmc_disable_plla
     128  pmc_disable_system_clock
      16  pmc_disable_upll_clock
     180  pmc_enable_external_osc
     440  pmc_enable_gck
      64  pmc_enable_internal_osc
     168  pmc_enable_pck
      80  pmc_enable_peripheral
     128  pmc_enable_system_clock
      56  pmc_enable_ulp1
      40  pmc_enable_upll_clock
     200  pmc_ext32k_monitor
     312  pmc_get_gck_clock
      44  pmc_get_main_clock
      40  pmc_get_main_oscillator_freq
      32  pmc_get_master_clock
      52  pmc_get_pck_clock
     416  pmc_get_pck_mck_cfg
      68  pmc_get_peripheral_clock
      16  pmc_get_plla_clock
      96  pmc_get_processor_clock
      16  pmc_get_slow_clock
      16  pmc_get_upll_clock
      56  pmc_get_utmi_clock_trim
      36  pmc_has_system_clock
      72  pmc_is_gck_enabled
      80  pmc_is_peripheral_enabled
     132  pmc_is_system_clock_enabled
      16  pmc_is_upll_clock_enabled
      72  pmc_select_external_crystal
     272  pmc_select_external_osc
      72  pmc_select_internal_crystal
     100  pmc_select_internal_osc
     192  pmc_set_custom_pck_mck
      16  pmc_set_fast_startup_mode
       4  pmc_set_fast_startup_polarity
     480  pmc_set_main_oscillator_freq
      92  pmc_set_mck_divider
      92  pmc_set_mck_prescaler
      60  pmc_switch_mck_to_main
      84  pmc_switch_mck_to_new_source
      60  pmc_switch_mck_to_pll
      56  pmc_switch_mck_to_slck
      56  pmc_switch_mck_to_upll

 
     4 bytes in section .bss
     8 bytes in section .data
 1'070 bytes in section .rodata
 7'740 bytes in section SOFTPACK
 
 7'740 bytes of CODE  memory
 1'070 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
