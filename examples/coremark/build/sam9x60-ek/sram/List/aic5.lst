###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         30/Apr/2020  10:56:58
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\irq\aic5.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW8CAA.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\irq\aic5.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\lib\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\sram\List\aic5.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sam9x60-ek\sram\Obj\aic5.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\irq\aic5.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include "chip.h"
     35          #include "trace.h"
     36          #include "irqflags.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void arch_irq_enable(void)
   \                     arch_irq_enable:
   \        0x0   0xE10F'0000        mrs R0, cpsr
   \        0x4   0xE3D0'1080        BICS     R1,R0,#0x80
   \        0x8   0xE121'F001        msr cpsr_c, R1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void arch_irq_disable(void)
   \                     arch_irq_disable:
   \        0x0   0xE10F'0000        mrs R0, cpsr
   \        0x4   0xE390'1080        ORRS     R1,R0,#0x80
   \        0x8   0xE121'F001        msr cpsr_c, R1
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
     37          
     38          #include "irq/aic.h"
     39          #include "irq/irq.h"
     40          #include "peripherals/matrix.h"
     41          
     42          #include <stdint.h>
     43          #include <assert.h>
     44          #include <errno.h>
     45          
     46          /*------------------------------------------------------------------------------
     47           *         Local functions
     48           *------------------------------------------------------------------------------*/
     49          

   \                                 In section SOFTPACK, align 4, keep-with-next
     50          static void spurious_handler(void)
     51          {
     52          	// nothing here
     53          }
   \                     spurious_handler:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
     54          
     55          /**
     56           * \brief Interrupt Init.
     57           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     58          static void _aic_initialize(Aic* aic, aic_handler_t irq_handler)
     59          {
     60          	int i;
     61          
     62          	/* Disable all interrupts and clear pending flags */
     63          	for (i = 1; i < ID_PERIPH_COUNT; i++)
   \                     _aic_initialize:
   \        0x0   0xE3A0'2001        MOV      R2,#+1
   \                     ??_aic_initialize_0:
   \        0x4   0xE352'0033        CMP      R2,#+51
   \        0x8   0xAA00'0005        BGE      ??_aic_initialize_1
     64          	{
     65          		aic->AIC_SSR = i;
   \        0xC   0xE580'2000        STR      R2,[R0, #+0]
     66          		aic->AIC_IDCR = AIC_IDCR_INTD;
   \       0x10   0xE3A0'3001        MOV      R3,#+1
   \       0x14   0xE580'3044        STR      R3,[R0, #+68]
     67          		aic->AIC_ICCR = AIC_ICCR_INTCLR;
   \       0x18   0xE580'3048        STR      R3,[R0, #+72]
     68          	}
   \       0x1C   0xE292'2001        ADDS     R2,R2,#+1
   \       0x20   0xEAFF'FFF7        B        ??_aic_initialize_0
     69          
     70          	/* Perform 8 IT acknowledge (write any value in EOICR) */
     71          	for (i = 0; i < 8; i++)
   \                     ??_aic_initialize_1:
   \       0x24   0xE3A0'3000        MOV      R3,#+0
   \                     ??_aic_initialize_2:
   \       0x28   0xE353'0008        CMP      R3,#+8
   \       0x2C   0xAA00'0003        BGE      ??_aic_initialize_3
     72          		aic->AIC_EOICR = 0;
   \       0x30   0xE3A0'2000        MOV      R2,#+0
   \       0x34   0xE580'2038        STR      R2,[R0, #+56]
   \       0x38   0xE293'3001        ADDS     R3,R3,#+1
   \       0x3C   0xEAFF'FFF9        B        ??_aic_initialize_2
     73          
     74          	/* Assign default handlers */
     75          	for (i = 0; i < ID_PERIPH_COUNT; i++)
   \                     ??_aic_initialize_3:
   \       0x40   0xE3A0'2000        MOV      R2,#+0
   \                     ??_aic_initialize_4:
   \       0x44   0xE352'0033        CMP      R2,#+51
   \       0x48   0xAA00'0003        BGE      ??_aic_initialize_5
     76          	{
     77          		aic->AIC_SSR = i;
   \       0x4C   0xE580'2000        STR      R2,[R0, #+0]
     78          		aic->AIC_SVR = (uint32_t)irq_handler;
   \       0x50   0xE580'1008        STR      R1,[R0, #+8]
     79          	}
   \       0x54   0xE292'2001        ADDS     R2,R2,#+1
   \       0x58   0xEAFF'FFF9        B        ??_aic_initialize_4
     80          	aic->AIC_SPU = (uint32_t)spurious_handler;
   \                     ??_aic_initialize_5:
   \       0x5C   0x....'....        ADR      R3,spurious_handler
   \       0x60   0xE580'303C        STR      R3,[R0, #+60]
     81          }
   \       0x64   0xE12F'FF1E        BX       LR               ;; return
     82          

   \                                 In section SOFTPACK, align 4, keep-with-next
     83          static Aic* _get_aic_instance(uint32_t source)
     84          {
   \                     _get_aic_instance:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
     85          #ifdef CONFIG_HAVE_SAIC
     86          	if (SFR->SFR_AICREDIR == 0) {
     87          		Matrix* matrix = get_peripheral_matrix(source);
     88          		if (matrix_is_peripheral_secured(matrix, source))
     89          			return SAIC;
     90          	}
     91          #endif /* CONFIG_HAVE_SAIC */
     92          	return AIC;
   \        0x4   0xE3E0'00FF        MVN      R0,#+255
   \        0x8   0xE3C0'0EE0        BIC      R0,R0,#0xE00
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
     93          }
     94          
     95          /*----------------------------------------------------------------------------
     96           *        Exported functions
     97           *----------------------------------------------------------------------------*/
     98          

   \                                 In section SOFTPACK, align 4, keep-with-next
     99          void aic_initialize(aic_handler_t irq_handler)
    100          {
   \                     aic_initialize:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    101          	/* Disable interrupts at core level */
    102          	arch_irq_disable();
   \        0x8   0x....'....        BL       arch_irq_disable
    103          
    104          	/* Set default vectors */
    105          	_aic_initialize(AIC, irq_handler);
   \        0xC   0xE1B0'1004        MOVS     R1,R4
   \       0x10   0xE3E0'00FF        MVN      R0,#+255
   \       0x14   0xE3C0'0EE0        BIC      R0,R0,#0xE00
   \       0x18   0x....'....        BL       _aic_initialize
    106          #ifdef CONFIG_HAVE_SAIC
    107          	_aic_initialize(SAIC, irq_handler);
    108          
    109          	/* Redirect all interrupts to Non-secure AIC */
    110          	uint32_t aicredir = SFR_AICREDIR_AICREDIRKEY((uint32_t)(AICREDIR_KEY));
    111          	SFR->SFR_AICREDIR = (aicredir ^ SFR->SFR_SN1) | SFR_AICREDIR_NSAIC;
    112          #endif /* CONFIG_HAVE_SAIC */
    113          
    114          	/* Enable interrupts at core level */
    115          	arch_irq_enable();
   \       0x1C   0x....'....        BL       arch_irq_enable
    116          }
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
    117          

   \                                 In section SOFTPACK, align 4, keep-with-next
    118          void aic_set_source_vector(uint32_t source, aic_handler_t handler)
    119          {
   \                     aic_set_source_vector:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    120          	Aic *aic = _get_aic_instance(source);
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       _get_aic_instance
    121          	aic->AIC_SSR = AIC_SSR_INTSEL(source);
   \       0x14   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x18   0xE580'1000        STR      R1,[R0, #+0]
    122          	aic->AIC_SVR = (uint32_t)handler;
   \       0x1C   0xE580'5008        STR      R5,[R0, #+8]
    123          }
   \       0x20   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    124          

   \                                 In section SOFTPACK, align 4, keep-with-next
    125          void aic_set_spurious_vector(aic_handler_t handler)
    126          {
    127          	AIC->AIC_SPU = (uint32_t)handler;
   \                     aic_set_spurious_vector:
   \        0x0   0xE3E0'10C3        MVN      R1,#+195
   \        0x4   0xE3C1'1EE0        BIC      R1,R1,#0xE00
   \        0x8   0xE581'0000        STR      R0,[R1, #+0]
    128          #ifdef CONFIG_HAVE_SAIC
    129          	if (SFR->SFR_AICREDIR == 0)
    130          		SAIC->AIC_SPU = (uint32_t)handler;
    131          #endif
    132          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    133          

   \                                 In section SOFTPACK, align 4, keep-with-next
    134          void aic_configure_mode(uint32_t source, enum _irq_mode mode)
    135          {
   \                     aic_configure_mode:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    136          	uint32_t srctype;
    137          
    138          	switch (mode) {
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x14   0xE350'0003        CMP      R0,#+3
   \       0x18   0x8A00'000A        BHI      ??aic_configure_mode_1
   \       0x1C   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x20   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??aic_configure_mode_0:
   \       0x24   0x00 0x02          DC8      0x0,0x2,0x4,0x6

   \              0x04 0x06
    139          	case IRQ_MODE_HIGH_LEVEL:
    140          		srctype = AIC_SMR_SRCTYPE_EXT_HIGH_LEVEL;
   \                     ??aic_configure_mode_2:
   \       0x28   0xE3A0'6040        MOV      R6,#+64
    141          		break;
   \       0x2C   0xEA00'000E        B        ??aic_configure_mode_3
    142          	case IRQ_MODE_LOW_LEVEL:
    143          		srctype = AIC_SMR_SRCTYPE_INT_LEVEL_SENSITIVE;
   \                     ??aic_configure_mode_4:
   \       0x30   0xE3A0'6000        MOV      R6,#+0
    144          		break;
   \       0x34   0xEA00'000C        B        ??aic_configure_mode_3
    145          	case IRQ_MODE_POSITIVE_EDGE:
    146          		srctype = AIC_SMR_SRCTYPE_EXT_POSITIVE_EDGE;
   \                     ??aic_configure_mode_5:
   \       0x38   0xE3A0'6060        MOV      R6,#+96
    147          		break;
   \       0x3C   0xEA00'000A        B        ??aic_configure_mode_3
    148          	case IRQ_MODE_NEGATIVE_EDGE:
    149          		srctype = AIC_SMR_SRCTYPE_INT_EDGE_TRIGGERED;
   \                     ??aic_configure_mode_6:
   \       0x40   0xE3A0'6020        MOV      R6,#+32
    150          		break;
   \       0x44   0xEA00'0008        B        ??aic_configure_mode_3
    151          	default:
    152          		trace_fatal("Invalid interrupt mode: %d\r\n", (int)mode);
   \                     ??aic_configure_mode_1:
   \       0x48   0x....'....        LDR      R0,??DataTable2
   \       0x4C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'0003        BEQ      ??aic_configure_mode_7
   \       0x58   0xE1B0'1005        MOVS     R1,R5
   \       0x5C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x60   0x....'....        LDR      R0,??DataTable2_1
   \       0x64   0x....'....        BL       printf
   \                     ??aic_configure_mode_7:
   \       0x68   0xEAFF'FFFE        B        ??aic_configure_mode_7
    153          	}
    154          
    155          	Aic* aic = _get_aic_instance(source);
   \                     ??aic_configure_mode_3:
   \       0x6C   0xE1B0'0004        MOVS     R0,R4
   \       0x70   0x....'....        BL       _get_aic_instance
    156          	aic->AIC_SSR = source;
   \       0x74   0xE580'4000        STR      R4,[R0, #+0]
    157          	aic->AIC_IDCR = AIC_IDCR_INTD;
   \       0x78   0xE3A0'1001        MOV      R1,#+1
   \       0x7C   0xE580'1044        STR      R1,[R0, #+68]
    158          	aic->AIC_SMR = (aic->AIC_SMR & ~AIC_SMR_SRCTYPE_Msk) | srctype;
   \       0x80   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x84   0xE3D2'2060        BICS     R2,R2,#0x60
   \       0x88   0xE196'2002        ORRS     R2,R6,R2
   \       0x8C   0xE580'2004        STR      R2,[R0, #+4]
    159          	aic->AIC_ICCR = AIC_ICCR_INTCLR;
   \       0x90   0xE580'1048        STR      R1,[R0, #+72]
    160          }
   \       0x94   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    161          

   \                                 In section SOFTPACK, align 4, keep-with-next
    162          void aic_configure_priority(uint32_t source, uint8_t priority)
    163          {
   \                     aic_configure_priority:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    164          	Aic* aic = _get_aic_instance(source);
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       _get_aic_instance
    165          	aic->AIC_SSR = source;
   \       0x14   0xE580'4000        STR      R4,[R0, #+0]
    166          	aic->AIC_IDCR = AIC_IDCR_INTD;
   \       0x18   0xE3A0'1001        MOV      R1,#+1
   \       0x1C   0xE580'1044        STR      R1,[R0, #+68]
    167          	aic->AIC_SMR = (aic->AIC_SMR & ~AIC_SMR_PRIOR_Msk) | AIC_SMR_PRIOR(priority);
   \       0x20   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x24   0xE1B0'21A2        LSRS     R2,R2,#+3
   \       0x28   0xE1B0'3005        MOVS     R3,R5
   \       0x2C   0xE213'30FF        ANDS     R3,R3,#0xFF      ;; Zero extend
   \       0x30   0xE213'3007        ANDS     R3,R3,#0x7
   \       0x34   0xE193'2182        ORRS     R2,R3,R2, LSL #+3
   \       0x38   0xE580'2004        STR      R2,[R0, #+4]
    168          	aic->AIC_ICCR = AIC_ICCR_INTCLR;
   \       0x3C   0xE580'1048        STR      R1,[R0, #+72]
    169          }
   \       0x40   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    170          

   \                                 In section SOFTPACK, align 4, keep-with-next
    171          void aic_enable(uint32_t source)
    172          {
   \                     aic_enable:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    173          	Aic* aic = _get_aic_instance(source);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0x....'....        BL       _get_aic_instance
    174          	aic->AIC_SSR = AIC_SSR_INTSEL(source);
   \       0x10   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
    175          	aic->AIC_IECR = AIC_IECR_INTEN;
   \       0x18   0xE3A0'1001        MOV      R1,#+1
   \       0x1C   0xE580'1040        STR      R1,[R0, #+64]
    176          }
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
    177          

   \                                 In section SOFTPACK, align 4, keep-with-next
    178          void aic_disable(uint32_t source)
    179          {
   \                     aic_disable:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    180          	Aic* aic = _get_aic_instance(source);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0x....'....        BL       _get_aic_instance
    181          	aic->AIC_SSR = AIC_SSR_INTSEL(source);
   \       0x10   0xE214'107F        ANDS     R1,R4,#0x7F
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
    182          	aic->AIC_IDCR = AIC_IDCR_INTD;
   \       0x18   0xE3A0'1001        MOV      R1,#+1
   \       0x1C   0xE580'1044        STR      R1,[R0, #+68]
    183          }
   \       0x20   0xE8BD'8010        POP      {R4,PC}          ;; return
    184          

   \                                 In section SOFTPACK, align 4, keep-with-next
    185          uint32_t aic_get_current_interrupt_source(void)
    186          {
    187          	return AIC->AIC_ISR;
   \                     aic_get_current_interrupt_source:
   \        0x0   0xE3E0'00E7        MVN      R0,#+231
   \        0x4   0xE3C0'0EE0        BIC      R0,R0,#0xE00
   \        0x8   0xE590'0000        LDR      R0,[R0, #+0]
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    188          }
    189          

   \                                 In section SOFTPACK, align 4, keep-with-next
    190          void aic_set_debug_config(Aic* aic, bool protect, bool mask)
    191          {
    192          	uint32_t dcr = 0;
   \                     aic_set_debug_config:
   \        0x0   0xE3A0'3000        MOV      R3,#+0
    193          	if (protect)
   \        0x4   0xE1B0'C001        MOVS     R12,R1
   \        0x8   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \        0xC   0xE35C'0000        CMP      R12,#+0
   \       0x10   0x0A00'0000        BEQ      ??aic_set_debug_config_0
    194          		dcr |= AIC_DCR_PROT;
   \       0x14   0xE393'3001        ORRS     R3,R3,#0x1
    195          	if (mask)
   \                     ??aic_set_debug_config_0:
   \       0x18   0xE1B0'C002        MOVS     R12,R2
   \       0x1C   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \       0x20   0xE35C'0000        CMP      R12,#+0
   \       0x24   0x0A00'0000        BEQ      ??aic_set_debug_config_1
    196          		dcr |= AIC_DCR_GMSK;
   \       0x28   0xE393'3002        ORRS     R3,R3,#0x2
    197          	aic->AIC_DCR = dcr;
   \                     ??aic_set_debug_config_1:
   \       0x2C   0xE580'306C        STR      R3,[R0, #+108]
    198          }
   \       0x30   0xE12F'FF1E        BX       LR               ;; return
    199          

   \                                 In section SOFTPACK, align 4, keep-with-next
    200          void aic_set_write_protection(Aic* aic, bool enable)
    201          {
    202          	if (enable)
   \                     aic_set_write_protection:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0002        BEQ      ??aic_set_write_protection_0
    203          		aic->AIC_WPMR = AIC_WPMR_WPKEY_PASSWD | AIC_WPMR_WPEN;
   \       0x10   0x....'....        LDR      R2,??DataTable2_2  ;; 0x41494301
   \       0x14   0xE580'20E4        STR      R2,[R0, #+228]
   \       0x18   0xEA00'0001        B        ??aic_set_write_protection_1
    204          	else
    205          		aic->AIC_WPMR = AIC_WPMR_WPKEY_PASSWD;
   \                     ??aic_set_write_protection_0:
   \       0x1C   0x....'....        LDR      R2,??DataTable2_3  ;; 0x41494300
   \       0x20   0xE580'20E4        STR      R2,[R0, #+228]
    206          }
   \                     ??aic_set_write_protection_1:
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    207          

   \                                 In section SOFTPACK, align 4, keep-with-next
    208          bool aic_check_write_protection_violation(Aic* aic, uint32_t* wpvsrc)
    209          {
   \                     aic_check_write_protection_violation:
   \        0x0   0xE1B0'2000        MOVS     R2,R0
    210          	if (aic->AIC_WPSR & AIC_WPSR_WPVS) {
   \        0x4   0xE592'00E8        LDR      R0,[R2, #+232]
   \        0x8   0xE310'0001        TST      R0,#0x1
   \        0xC   0x0A00'0005        BEQ      ??aic_check_write_protection_violation_0
    211          		*wpvsrc = (aic->AIC_WPSR & AIC_WPSR_WPVSRC_Msk) >> AIC_WPSR_WPVSRC_Pos;
   \       0x10   0xE592'00E8        LDR      R0,[R2, #+232]
   \       0x14   0xE1B0'0400        LSLS     R0,R0,#+8
   \       0x18   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x1C   0xE581'0000        STR      R0,[R1, #+0]
    212          		return true;
   \       0x20   0xE3A0'0001        MOV      R0,#+1
   \       0x24   0xEA00'0000        B        ??aic_check_write_protection_violation_1
    213          	}
    214          	return false;
   \                     ??aic_check_write_protection_violation_0:
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \                     ??aic_check_write_protection_violation_1:
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    215          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4149'4301        DC32     0x41494301

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4149'4300        DC32     0x41494300

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x46          DC8 "-F- Invalid interrupt mode: %d\015\012"

   \              0x2D 0x20    

   \              0x49 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x69 0x6E    

   \              0x74 0x65    

   \              0x72 0x72    

   \              0x75 0x70    

   \              0x74 0x20    

   \              0x6D 0x6F    

   \              0x64 0x65    

   \              0x3A 0x20    

   \              0x25 0x64    

   \              0x0D 0x0A    

   \              0x00
   \       0x21   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _aic_initialize
       0   _get_aic_instance
       0   aic_check_write_protection_violation
      16   aic_configure_mode
        16   -> _get_aic_instance
        16   -> printf
      16   aic_configure_priority
        16   -> _get_aic_instance
       8   aic_disable
         8   -> _get_aic_instance
       8   aic_enable
         8   -> _get_aic_instance
       0   aic_get_current_interrupt_source
       8   aic_initialize
         8   -> _aic_initialize
         8   -> arch_irq_disable
         8   -> arch_irq_enable
       0   aic_set_debug_config
      16   aic_set_source_vector
        16   -> _get_aic_instance
       0   aic_set_spurious_vector
       0   aic_set_write_protection
       0   arch_irq_disable
       0   arch_irq_enable
       0   spurious_handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
      36  ?_0
     104  _aic_initialize
      16  _get_aic_instance
      48  aic_check_write_protection_violation
     152  aic_configure_mode
      68  aic_configure_priority
      36  aic_disable
      36  aic_enable
      16  aic_get_current_interrupt_source
      36  aic_initialize
      52  aic_set_debug_config
      36  aic_set_source_vector
      16  aic_set_spurious_vector
      40  aic_set_write_protection
      16  arch_irq_disable
      16  arch_irq_enable
       4  spurious_handler

 
  36 bytes in section .rodata
 708 bytes in section SOFTPACK
 
 708 bytes of CODE  memory
  36 bytes of CONST memory

Errors: none
Warnings: none
