###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         06/May/2020  06:12:21
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EW3C84.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\lib\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\sram\List\fft_radix2.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\sram\Obj\fft_radix2.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  flags,floats,int_specials,widths
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
      1          /*
      2          (C) 2014 EEMBC(R).  All rights reserved.                            
      3          
      4          All EEMBC Benchmark Software are products of EEMBC 
      5          and are provided under the terms of the EEMBC Benchmark License Agreements.  
      6          The EEMBC Benchmark Software are proprietary intellectual properties of EEMBC and its Members 
      7          and is protected under all applicable laws, including all applicable copyright laws.  
      8          If you received this EEMBC Benchmark Software without having 
      9          a currently effective EEMBC Benchmark License Agreement, you must discontinue use. 
     10          Please refer to LICENSE.md for the specific license agreement that pertains to this Benchmark Software.
     11          */
     12          
     13          /*************************
     14          ** FFT radix 2 **
     15          ** Perform FFT with radix2.
     16          *************************/
     17          //#include "th_cfg.h"
     18          #include <math.h> /* for sin, cos and pow */
     19          #include <stdlib.h>
     20          #include <string.h>
     21          #include "th_rand.h" /* initialize a random data vector */
     22          #include "fft_radix2.h"
     23          #include <stdio.h>
     24          
     25          
     26          #define EE_MININI (1.0e38)
     27          #define EE_MAXINI (-1.0e38)
     28          #define EE_EPSINI (1.0e-37)
     29          #define EE_EPSILON EE_EPSINI
     30          #define BMDEBUG (0)
     31          
     32          //PT: 4/4/2016: w/g decision (undoes th_lib.h for radix only)
     33          #undef  MIN_ACC_BITS_FP64    
     34          #define MIN_ACC_BITS_FP64 25
     35          
     36          #define EE_PI 3.1415926535897932
     37          #define MIN_ACC_BITS_FP32 14
     38          
     39          #if !defined(ALIGN_BOUNDARY)
     40          #define ALIGN_BOUNDARY 64
     41          #endif

   \                                 In section .bss, align 4
     42          radix2_params presets_radix2[NUM_DATAS];
   \                     presets_radix2:
   \        0x0                      DS8 384
     43          extern void init_preset_0();
     44          /* ======================================================================== */
     45          /*         F U N C T I O N   P R O T O T Y P E S                            */
     46          /* ======================================================================== */
     47          /* file provides :
     48          define - init base input params (segment [within 0..2 boundary], number of coefficients to calculate, number of integration steps)
     49          init -  allocate working memory, assign a[0] and b[0] . 
     50          run - calculate N coefficients in the segment
     51          fini - calculate avg of coeffients then dealloc working memory
     52          verify - SNR average of coefficients vs golden reference, must run at least base iterations for valid output.
     53          clean - deallocate output memory
     54          */
     55          
     56          
     57          
     58          
     59          /* benchmark function declarations */
     60          static void FFT_transform_internal (int N, float * data, int direction, float *twp);
     61          static void FFT_bitreverse(int N, float * data);

   \                                 In section SOFTPACK, align 4, keep-with-next
     62          static int int_log2 (int n)
     63          {
   \                     int_log2:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
     64              int k = 1;
   \        0x8   0xE3A0'5001        MOV      R5,#+1
     65              int log = 0;
   \        0xC   0xE3A0'6000        MOV      R6,#+0
     66              for(/*k=1*/; k < n; k *= 2, log++);
   \                     ??int_log2_0:
   \       0x10   0xE155'0004        CMP      R5,R4
   \       0x14   0xAA00'0002        BGE      ??int_log2_1
   \       0x18   0xE1B0'5085        LSLS     R5,R5,#+1
   \       0x1C   0xE296'6001        ADDS     R6,R6,#+1
   \       0x20   0xEAFF'FFFA        B        ??int_log2_0
     67              if (n != (1 << log))
   \                     ??int_log2_1:
   \       0x24   0xE3A0'0001        MOV      R0,#+1
   \       0x28   0xE154'0610        CMP      R4,R0, LSL R6
   \       0x2C   0x0A00'0002        BEQ      ??int_log2_2
     68                printf("ERROR: FFT radix2, Data length is not a power of 2! [%d]\n",n);
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable5_2
   \       0x38   0x....'....        BL       printf
     69              return log; 
   \                     ??int_log2_2:
   \       0x3C   0xE1B0'0006        MOVS     R0,R6
   \       0x40   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
     70          }
     71          

   \                                 In section SOFTPACK, align 4, keep-with-next
     72          static float *calculate_twiddles(int size, int direction) {
   \                     calculate_twiddles:
   \        0x0   0xE92D'4FF1        PUSH     {R0,R4-R11,LR}
   \        0x4   0xED2D'8B06        VPUSH    {D8-D10}
   \        0x8   0xE24D'D008        SUB      SP,SP,#+8
   \        0xC   0xEE08'1A10        VMOV     S16,R1
     73              int n=0,a;
   \       0x10   0xE3A0'5000        MOV      R5,#+0
     74              float *twp=NULL;
   \       0x14   0xE3A0'0000        MOV      R0,#+0
   \       0x18   0xE58D'0004        STR      R0,[SP, #+4]
     75              int bit = 0;
   \       0x1C   0xE3A0'8000        MOV      R8,#+0
     76              int logn;
     77              int dual = 1;
   \       0x20   0xE3A0'6001        MOV      R6,#+1
     78          	
     79              if (size == 1) return twp;         
   \       0x24   0xE59D'0020        LDR      R0,[SP, #+32]
   \       0x28   0xE350'0001        CMP      R0,#+1
   \       0x2C   0x1A00'0001        BNE      ??calculate_twiddles_0
   \       0x30   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x34   0xEA00'0055        B        ??calculate_twiddles_1
     80              logn = int_log2(size/2);
   \                     ??calculate_twiddles_0:
   \       0x38   0xE59D'0020        LDR      R0,[SP, #+32]
   \       0x3C   0xE3A0'1002        MOV      R1,#+2
   \       0x40   0x....'....        BL       __aeabi_idiv
   \       0x44   0x....'....        BL       int_log2
   \       0x48   0xE58D'0000        STR      R0,[SP, #+0]
     81          	
     82              for (bit = 0; bit < logn; bit++, dual *= 2) 
   \       0x4C   0xE3A0'7000        MOV      R7,#+0
   \                     ??calculate_twiddles_2:
   \       0x50   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x54   0xE157'0000        CMP      R7,R0
   \       0x58   0xAA00'0009        BGE      ??calculate_twiddles_3
     83                for (a = 1; a < dual; a++) 
   \       0x5C   0xE3A0'0001        MOV      R0,#+1
   \       0x60   0xE1B0'4000        MOVS     R4,R0
   \                     ??calculate_twiddles_4:
   \       0x64   0xE154'0006        CMP      R4,R6
   \       0x68   0xAA00'0002        BGE      ??calculate_twiddles_5
     84          	    n++;
   \       0x6C   0xE295'5001        ADDS     R5,R5,#+1
   \       0x70   0xE294'4001        ADDS     R4,R4,#+1
   \       0x74   0xEAFF'FFFA        B        ??calculate_twiddles_4
   \                     ??calculate_twiddles_5:
   \       0x78   0xE297'7001        ADDS     R7,R7,#+1
   \       0x7C   0xE1B0'6086        LSLS     R6,R6,#+1
   \       0x80   0xEAFF'FFF2        B        ??calculate_twiddles_2
     85          	twp=(float *)malloc(sizeof(float)*2*n);
   \                     ??calculate_twiddles_3:
   \       0x84   0xE1B0'0185        LSLS     R0,R5,#+3
   \       0x88   0x....'....        BL       malloc
   \       0x8C   0xE1B0'8000        MOVS     R8,R0
     86          	n=0;
   \       0x90   0xE3A0'B000        MOV      R11,#+0
     87          	bit=0;
   \       0x94   0xE3A0'0000        MOV      R0,#+0
     88          	dual=1;
   \       0x98   0xE3A0'9001        MOV      R9,#+1
     89              for (bit = 0; bit < logn; bit++, dual *= 2) {
   \       0x9C   0xE3A0'A000        MOV      R10,#+0
   \                     ??calculate_twiddles_6:
   \       0xA0   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xA4   0xE15A'0000        CMP      R10,R0
   \       0xA8   0xAA00'0037        BGE      ??calculate_twiddles_7
     90          		float w_real = (1.0);
   \       0xAC   0xE3A0'05FE        MOV      R0,#+1065353216
   \       0xB0   0xEE08'0A90        VMOV     S17,R0
     91          		float w_imag = (0.0);
   \       0xB4   0xE3A0'0000        MOV      R0,#+0
   \       0xB8   0xEE09'0A10        VMOV     S18,R0
     92          
     93          		float theta = (2.0) * direction * EE_PI / ((2.0) * (float) dual);
   \       0xBC   0xEEB8'0BC8        VCVT.F64.S32 D0,S16
   \       0xC0   0xEEB0'2B00        VMOV.F64 D2,#2.0
   \       0xC4   0xEE20'0B02        VMUL.F64 D0,D0,D2
   \       0xC8   0x....'....        VLDR     D2,??DataTable4
   \       0xCC   0xEE20'0B02        VMUL.F64 D0,D0,D2
   \       0xD0   0xEE01'9A10        VMOV     S2,R9
   \       0xD4   0xEEB8'1AC1        VCVT.F32.S32 S2,S2
   \       0xD8   0xEEB7'1AC1        VCVT.F64.F32 D1,S2
   \       0xDC   0xEEB0'3B00        VMOV.F64 D3,#2.0
   \       0xE0   0xEE21'1B03        VMUL.F64 D1,D1,D3
   \       0xE4   0xEE80'0B01        VDIV.F64 D0,D0,D1
   \       0xE8   0xEEF7'9BC0        VCVT.F32.F64 S19,D0
     94          		float s = sinf(theta);
   \       0xEC   0xEEB0'0A69        VMOV.F32 S0,S19
   \       0xF0   0x....'....        BL       sinf
   \       0xF4   0xEEB0'AA40        VMOV.F32 S20,S0
     95          		float t = sinf(theta / (2.0));
   \       0xF8   0xEEB7'0AE9        VCVT.F64.F32 D0,S19
   \       0xFC   0xEEB0'2B00        VMOV.F64 D2,#2.0
   \      0x100   0xEE80'0B02        VDIV.F64 D0,D0,D2
   \      0x104   0xEEB7'0BC0        VCVT.F32.F64 S0,D0
   \      0x108   0x....'....        BL       sinf
   \      0x10C   0xEEF0'0A40        VMOV.F32 S1,S0
     96          		float s2 = (2.0) * t * t;
   \      0x110   0xEEB7'1AE0        VCVT.F64.F32 D1,S1
   \      0x114   0xEEB0'3B00        VMOV.F64 D3,#2.0
   \      0x118   0xEE21'1B03        VMUL.F64 D1,D1,D3
   \      0x11C   0xEEB7'2AE0        VCVT.F64.F32 D2,S1
   \      0x120   0xEE21'1B02        VMUL.F64 D1,D1,D2
   \      0x124   0xEEB7'0BC1        VCVT.F32.F64 S0,D1
     97          
     98          		for (a = 1; a < dual; a++) {
   \      0x128   0xE3A0'0001        MOV      R0,#+1
   \      0x12C   0xE1B0'4000        MOVS     R4,R0
   \                     ??calculate_twiddles_8:
   \      0x130   0xE154'0009        CMP      R4,R9
   \      0x134   0xAA00'0011        BGE      ??calculate_twiddles_9
     99          			float tmp_real = w_real - s * w_imag - s2 * w_real;
   \      0x138   0xEEB0'1A68        VMOV.F32 S2,S17
   \      0x13C   0xEE0A'1A49        VMLS.F32 S2,S20,S18
   \      0x140   0xEE00'1A68        VMLS.F32 S2,S0,S17
    100          			float tmp_imag = w_imag + s * w_real - s2 * w_imag;
   \      0x144   0xEEF0'1A49        VMOV.F32 S3,S18
   \      0x148   0xEE4A'1A28        VMLA.F32 S3,S20,S17
   \      0x14C   0xEE40'1A49        VMLS.F32 S3,S0,S18
    101          			w_real = tmp_real;
   \      0x150   0xEEF0'8A41        VMOV.F32 S17,S2
    102          			w_imag = tmp_imag;
   \      0x154   0xEEB0'9A61        VMOV.F32 S18,S3
    103          			twp[n++] = w_real;
   \      0x158   0xE1B0'010B        LSLS     R0,R11,#+2
   \      0x15C   0xE098'0000        ADDS     R0,R8,R0
   \      0x160   0xEDC0'8A00        VSTR     S17,[R0, #0]
   \      0x164   0xE29B'0001        ADDS     R0,R11,#+1
    104          			twp[n++] = w_imag;
   \      0x168   0xE1B0'1100        LSLS     R1,R0,#+2
   \      0x16C   0xE098'1001        ADDS     R1,R8,R1
   \      0x170   0xED81'9A00        VSTR     S18,[R1, #0]
   \      0x174   0xE290'B001        ADDS     R11,R0,#+1
    105          		}
   \      0x178   0xE294'4001        ADDS     R4,R4,#+1
   \      0x17C   0xEAFF'FFEB        B        ??calculate_twiddles_8
    106          	}
   \                     ??calculate_twiddles_9:
   \      0x180   0xE29A'A001        ADDS     R10,R10,#+1
   \      0x184   0xE1B0'9089        LSLS     R9,R9,#+1
   \      0x188   0xEAFF'FFC4        B        ??calculate_twiddles_6
    107          	return twp;
   \                     ??calculate_twiddles_7:
   \      0x18C   0xE1B0'0008        MOVS     R0,R8
   \                     ??calculate_twiddles_1:
   \      0x190   0xE28D'D008        ADD      SP,SP,#+8
   \      0x194   0xECBD'8B06        VPOP     {D8-D10}
   \      0x198   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    108          }

   \                                 In section .data, align 4
    109          intparts intparts_zero={0,1,0,0};
   \                     intparts_zero:
   \        0x0   0x00 0x00          DC8 0, 0
   \        0x2   0x0001             DC16 1
   \        0x4   0x0000'0000        DC32 0, 0

   \              0x0000'0000
    110          

   \                                 In section SOFTPACK, align 4, keep-with-next
    111          void *define_params_radix2() {
   \                     define_params_radix2:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    112              radix2_params *params;
    113              int32_t data_index=0;
   \        0x4   0xE3A0'4000        MOV      R4,#+0
    114              init_preset_0();
   \        0x8   0x....'....        BL       init_preset_0
    115              //init_preset_1();
    116              //init_preset_2();
    117              //init_preset_3();
    118              //init_preset_4();
    119              //init_preset_5();	
    120          
    121          	/* parameter setup */
    122          	params=(radix2_params *)calloc(1,sizeof(radix2_params));
   \        0xC   0xE3A0'1040        MOV      R1,#+64
   \       0x10   0xE3A0'0001        MOV      R0,#+1
   \       0x14   0x....'....        BL       calloc
   \       0x18   0xE1B0'5000        MOVS     R5,R0
    123          	if ( params == NULL ){
   \       0x1C   0xE355'0000        CMP      R5,#+0
   \       0x20   0x1A00'0005        BNE      ??define_params_radix2_0
    124                    printf( "Cannot Allocate Memory %s:%d", __FILE__,__LINE__ );
   \       0x24   0xE3A0'207C        MOV      R2,#+124
   \       0x28   0x....'....        LDR      R1,??DataTable5_3
   \       0x2C   0x....'....        LDR      R0,??DataTable5_4
   \       0x30   0x....'....        BL       printf
    125                    return 0;
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0xEA00'003D        B        ??define_params_radix2_1
    126                  }
    127          	params->N=256; /* default */
   \                     ??define_params_radix2_0:
   \       0x3C   0xE3A0'0F40        MOV      R0,#+256
   \       0x40   0xE585'0008        STR      R0,[R5, #+8]
    128          	params->gen_ref=0;
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0xE585'000C        STR      R0,[R5, #+12]
    129          	params->ref_min=intparts_zero;
   \       0x4C   0x....'....        LDR      R1,??DataTable5_5
   \       0x50   0xE295'2014        ADDS     R2,R5,#+20
   \       0x54   0xE891'5008        LDM      R1,{R3,R12,LR}
   \       0x58   0xE882'5008        STM      R2,{R3,R12,LR}
    130          	params->ref_max=intparts_zero;
   \       0x5C   0xE295'2020        ADDS     R2,R5,#+32
   \       0x60   0xE891'5008        LDM      R1,{R3,R12,LR}
   \       0x64   0xE882'5008        STM      R2,{R3,R12,LR}
    131          	params->ref_avg=intparts_zero;
   \       0x68   0xE295'202C        ADDS     R2,R5,#+44
   \       0x6C   0xE891'5008        LDM      R1,{R3,R12,LR}
   \       0x70   0xE882'5008        STM      R2,{R3,R12,LR}
    132          	params->ref_data=NULL;
   \       0x74   0xE585'0010        STR      R0,[R5, #+16]
    133          	params->seed=0;
   \       0x78   0xE585'003C        STR      R0,[R5, #+60]
    134          	params->minbits=MIN_ACC_BITS_FP32;
   \       0x7C   0xE3A0'000E        MOV      R0,#+14
   \       0x80   0xE585'0038        STR      R0,[R5, #+56]
    135          
    136          	//th_parse_buf_flag(dataset,"-i",&data_index);
    137          	//if (pgo_training_run!=0) {
    138          	//	data_index=0; 
    139          	//}
    140          	/* preset datasets */
    141          	if ((data_index>=0) && (data_index<NUM_DATAS)) {
   \       0x84   0xE354'0000        CMP      R4,#+0
   \       0x88   0x4A00'0020        BMI      ??define_params_radix2_2
   \       0x8C   0xE354'0006        CMP      R4,#+6
   \       0x90   0xAA00'001E        BGE      ??define_params_radix2_2
    142          		params->N=presets_radix2[data_index].N; /* default */
   \       0x94   0x....'....        LDR      R0,??DataTable5_6
   \       0x98   0xE1B0'1304        LSLS     R1,R4,#+6
   \       0x9C   0xE090'1001        ADDS     R1,R0,R1
   \       0xA0   0xE591'1008        LDR      R1,[R1, #+8]
   \       0xA4   0xE585'1008        STR      R1,[R5, #+8]
    143          		params->ref_min=presets_radix2[data_index].ref_min;
   \       0xA8   0xE295'1014        ADDS     R1,R5,#+20
   \       0xAC   0xE1B0'2304        LSLS     R2,R4,#+6
   \       0xB0   0xE090'2002        ADDS     R2,R0,R2
   \       0xB4   0xE292'2014        ADDS     R2,R2,#+20
   \       0xB8   0xE892'5008        LDM      R2,{R3,R12,LR}
   \       0xBC   0xE881'5008        STM      R1,{R3,R12,LR}
    144          		params->ref_max=presets_radix2[data_index].ref_max;
   \       0xC0   0xE295'1020        ADDS     R1,R5,#+32
   \       0xC4   0xE1B0'2304        LSLS     R2,R4,#+6
   \       0xC8   0xE090'2002        ADDS     R2,R0,R2
   \       0xCC   0xE292'2020        ADDS     R2,R2,#+32
   \       0xD0   0xE892'5008        LDM      R2,{R3,R12,LR}
   \       0xD4   0xE881'5008        STM      R1,{R3,R12,LR}
    145          		params->ref_avg=presets_radix2[data_index].ref_avg;
   \       0xD8   0xE295'102C        ADDS     R1,R5,#+44
   \       0xDC   0xE1B0'2304        LSLS     R2,R4,#+6
   \       0xE0   0xE090'2002        ADDS     R2,R0,R2
   \       0xE4   0xE292'202C        ADDS     R2,R2,#+44
   \       0xE8   0xE892'5008        LDM      R2,{R3,R12,LR}
   \       0xEC   0xE881'5008        STM      R1,{R3,R12,LR}
    146          		params->ref_data=presets_radix2[data_index].ref_data;
   \       0xF0   0xE1B0'1304        LSLS     R1,R4,#+6
   \       0xF4   0xE090'1001        ADDS     R1,R0,R1
   \       0xF8   0xE591'1010        LDR      R1,[R1, #+16]
   \       0xFC   0xE585'1010        STR      R1,[R5, #+16]
    147          		params->seed=presets_radix2[data_index].seed;
   \      0x100   0xE1B0'1304        LSLS     R1,R4,#+6
   \      0x104   0xE090'0001        ADDS     R0,R0,R1
   \      0x108   0xE590'003C        LDR      R0,[R0, #+60]
   \      0x10C   0xE585'003C        STR      R0,[R5, #+60]
    148          	} 
    149          	/* command line overrides */
    150          	//if (pgo_training_run==0) {
    151          	//	th_parse_buf_flag_unsigned(dataset,"-s",&params->seed);
    152          	//	th_parse_buf_flag_unsigned(dataset,"-n",&params->N);
    153          	//	th_parse_buf_flag(dataset,"-g",&params->gen_ref);
    154          	//}
    155          	/* generate the data */
    156          	params->data=fromint_f32_vector(params->N,params->seed); /* default */
   \                     ??define_params_radix2_2:
   \      0x110   0xE595'103C        LDR      R1,[R5, #+60]
   \      0x114   0xE595'0008        LDR      R0,[R5, #+8]
   \      0x118   0x....'....        BL       fromint_f32_vector
   \      0x11C   0xE585'0000        STR      R0,[R5, #+0]
    157          	params->twp=calculate_twiddles(params->N,-1);
   \      0x120   0xE3E0'1000        MVN      R1,#+0
   \      0x124   0xE595'0008        LDR      R0,[R5, #+8]
   \      0x128   0x....'....        BL       calculate_twiddles
   \      0x12C   0xE585'0004        STR      R0,[R5, #+4]
    158          	
    159          	return params;
   \      0x130   0xE1B0'0005        MOVS     R0,R5
   \                     ??define_params_radix2_1:
   \      0x134   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    160          }
    161          
    162          /*
    163          void *bmark_init_radix2(void *in_params) {
    164          	radix2_params *params=(radix2_params *)in_params;
    165                  radix2_params *myparams;
    166          	if (in_params==NULL){
    167          		printf( "Invalid pointer %s:%d\r\n", __FILE__,__LINE__ );
    168                          return NULL;
    169                  }
    170          	myparams=(radix2_params *)calloc(1,sizeof(radix2_params));
    171          	if ( myparams == NULL ){
    172                    printf( "Cannot Allocate Memory %s:%d\r\n", __FILE__,__LINE__ );
    173                    return NULL;
    174                  }
    175          	memcpy(myparams,params,sizeof(radix2_params));
    176          
    177          	//myparams->data = (float *)aligned_alloc(ALIGN_BOUNDARY, params->N*sizeof(float) );
    178                  myparams->data = (float *)malloc(params->N*sizeof(float) );
    179          	if ( myparams->data == NULL) {
    180                    printf("%s:%d - cannot allocate working array!", __FILE__, __LINE__ );
    181          		return NULL;
    182          	}
    183          
    184          	memcpy(myparams->data,params->data,params->N*sizeof(float));
    185          	
    186          	return myparams;
    187          }
    188          */

   \                                 In section SOFTPACK, align 4, keep-with-next
    189          void t_run_test_radix2(struct TCDef *tcdef,void *in_params) {
   \                     t_run_test_radix2:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xED2D'8B04        VPUSH    {D8-D9}
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
    190          	int i;
    191          	uint32_t test;
    192          	float min=EE_MININI,max=EE_MAXINI,avg=(0.0);
   \       0x10   0x....'....        VLDR     S16,??DataTable5  ;; 0x7e967699
   \       0x14   0x....'....        VLDR     S17,??DataTable5_1  ;; 0xfe967699
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0xEE09'0A10        VMOV     S18,R0
    193          	radix2_params *params=(radix2_params *)in_params;
   \       0x20   0xE1B0'6005        MOVS     R6,R5
    194          	FFT_transform_internal(params->N, params->data, -1, params->twp);
   \       0x24   0xE596'3004        LDR      R3,[R6, #+4]
   \       0x28   0xE3E0'2000        MVN      R2,#+0
   \       0x2C   0xE596'1000        LDR      R1,[R6, #+0]
   \       0x30   0xE596'0008        LDR      R0,[R6, #+8]
   \       0x34   0x....'....        BL       FFT_transform_internal
    195          	for (i=0; i<params->N ; i++) {
   \       0x38   0xE3A0'7000        MOV      R7,#+0
   \                     ??t_run_test_radix2_0:
   \       0x3C   0xE596'0008        LDR      R0,[R6, #+8]
   \       0x40   0xE157'0000        CMP      R7,R0
   \       0x44   0x2A00'001E        BCS      ??t_run_test_radix2_1
    196          		min=(min>params->data[i])?params->data[i]:min;
   \       0x48   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x4C   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x50   0xE090'0001        ADDS     R0,R0,R1
   \       0x54   0xED90'0A00        VLDR     S0,[R0, #0]
   \       0x58   0xEEB4'0A48        VCMP.F32 S0,S16
   \       0x5C   0xEEF1'FA10        FMSTAT
   \       0x60   0x5A00'0004        BPL      ??t_run_test_radix2_2
   \       0x64   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x68   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x6C   0xE090'0001        ADDS     R0,R0,R1
   \       0x70   0xED90'8A00        VLDR     S16,[R0, #0]
   \       0x74   0xEAFF'FFFF        B        ??t_run_test_radix2_3
    197          		max=(max<params->data[i])?params->data[i]:max;
   \                     ??t_run_test_radix2_2:
   \                     ??t_run_test_radix2_3:
   \       0x78   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x7C   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x80   0xE090'0001        ADDS     R0,R0,R1
   \       0x84   0xED90'0A00        VLDR     S0,[R0, #0]
   \       0x88   0xEEF4'8A40        VCMP.F32 S17,S0
   \       0x8C   0xEEF1'FA10        FMSTAT
   \       0x90   0x5A00'0004        BPL      ??t_run_test_radix2_4
   \       0x94   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x98   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x9C   0xE090'0001        ADDS     R0,R0,R1
   \       0xA0   0xEDD0'8A00        VLDR     S17,[R0, #0]
   \       0xA4   0xEAFF'FFFF        B        ??t_run_test_radix2_5
    198          		avg+=params->data[i];
   \                     ??t_run_test_radix2_4:
   \                     ??t_run_test_radix2_5:
   \       0xA8   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xAC   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0xB0   0xE090'0001        ADDS     R0,R0,R1
   \       0xB4   0xED90'0A00        VLDR     S0,[R0, #0]
   \       0xB8   0xEE39'9A00        VADD.F32 S18,S18,S0
    199          	}
   \       0xBC   0xE297'7001        ADDS     R7,R7,#+1
   \       0xC0   0xEAFF'FFDD        B        ??t_run_test_radix2_0
    200          	avg/=params->N;
   \                     ??t_run_test_radix2_1:
   \       0xC4   0xED96'0A02        VLDR     S0,[R6, #+8]
   \       0xC8   0xEEB8'0A40        VCVT.F32.U32 S0,S0
   \       0xCC   0xEE89'9A00        VDIV.F32 S18,S18,S0
    201          	
    202          	test=fp_iaccurate_bits_sp(avg,&params->ref_avg);
   \       0xD0   0xE296'002C        ADDS     R0,R6,#+44
   \       0xD4   0xEEB0'0A49        VMOV.F32 S0,S18
   \       0xD8   0x....'....        BL       fp_iaccurate_bits_sp
    203          	if (test>=params->minbits)
   \       0xDC   0xE596'1038        LDR      R1,[R6, #+56]
   \       0xE0   0xE150'0001        CMP      R0,R1
   \       0xE4   0x3A00'0002        BCC      ??t_run_test_radix2_6
    204          		tcdef->CRC=0;
   \       0xE8   0xE3A0'1000        MOV      R1,#+0
   \       0xEC   0xE1C4'10B0        STRH     R1,[R4, #+0]
   \       0xF0   0xEA00'0001        B        ??t_run_test_radix2_7
    205          	else 
    206          		tcdef->CRC=1;
   \                     ??t_run_test_radix2_6:
   \       0xF4   0xE3A0'1001        MOV      R1,#+1
   \       0xF8   0xE1C4'10B0        STRH     R1,[R4, #+0]
    207          		
    208          	tcdef->v1=test;
   \                     ??t_run_test_radix2_7:
   \       0xFC   0xE584'0014        STR      R0,[R4, #+20]
    209          	tcdef->dbl_data[0]=avg;
   \      0x100   0xED84'9A01        VSTR     S18,[R4, #+4]
    210          	tcdef->dbl_data[1]=min;
   \      0x104   0xED84'8A02        VSTR     S16,[R4, #+8]
    211          	tcdef->dbl_data[2]=max;
   \      0x108   0xEDC4'8A03        VSTR     S17,[R4, #+12]
    212          	
    213          }
   \      0x10C   0xECBD'8B04        VPOP     {D8-D9}
   \      0x110   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    214          
    215          

   \                                 In section SOFTPACK, align 4, keep-with-next
    216          int bmark_clean_radix2(void *in_params) {
   \                     bmark_clean_radix2:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    217          	radix2_params *params=(radix2_params *)in_params;
   \        0x8   0xE1B0'5004        MOVS     R5,R4
    218          	if (params) {
   \        0xC   0xE355'0000        CMP      R5,#+0
   \       0x10   0x0A00'000B        BEQ      ??bmark_clean_radix2_0
    219          		if (params->data)
   \       0x14   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0001        BEQ      ??bmark_clean_radix2_1
    220          			free(params->data);
   \       0x20   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x24   0x....'....        BL       free
    221          		if (params->twp)
   \                     ??bmark_clean_radix2_1:
   \       0x28   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x2C   0xE350'0000        CMP      R0,#+0
   \       0x30   0x0A00'0001        BEQ      ??bmark_clean_radix2_2
    222          			free(params->twp);
   \       0x34   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x38   0x....'....        BL       free
    223          		free(params);
   \                     ??bmark_clean_radix2_2:
   \       0x3C   0xE1B0'0005        MOVS     R0,R5
   \       0x40   0x....'....        BL       free
    224          	}
    225          	return 1;
   \                     ??bmark_clean_radix2_0:
   \       0x44   0xE3A0'0001        MOV      R0,#+1
   \       0x48   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    226          }
    227          

   \                                 In section SOFTPACK, align 4, keep-with-next
    228          void *bmark_fini_radix2(void *in_params) {
   \                     bmark_fini_radix2:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    229              radix2_params *params;
    230              if (in_params==NULL){
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0005        BNE      ??bmark_fini_radix2_0
    231          		printf( "Invalid pointer %s:%d", __FILE__,__LINE__ );
   \       0x10   0xE3A0'20E7        MOV      R2,#+231
   \       0x14   0x....'....        LDR      R1,??DataTable5_3
   \       0x18   0x....'....        LDR      R0,??DataTable5_7
   \       0x1C   0x....'....        BL       printf
    232                          return NULL;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xEA00'0008        B        ??bmark_fini_radix2_1
    233              }
    234          	params=(radix2_params *)in_params;
   \                     ??bmark_fini_radix2_0:
   \       0x28   0xE1B0'5004        MOVS     R5,R4
    235          
    236          	if (params->data)
   \       0x2C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0A00'0001        BEQ      ??bmark_fini_radix2_2
    237          		free(params->data);
   \       0x38   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x3C   0x....'....        BL       free
    238          	free(params);
   \                     ??bmark_fini_radix2_2:
   \       0x40   0xE1B0'0005        MOVS     R0,R5
   \       0x44   0x....'....        BL       free
    239          
    240          	return NULL;
   \       0x48   0xE3A0'0000        MOV      R0,#+0
   \                     ??bmark_fini_radix2_1:
   \       0x4C   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    241          }
    242          
    243          #if BMDEBUG
    244          static void dump_data(int iter, int N, float * data)
    245          {
    246             int i;
    247             for (i=0;i<N;i++)
    248                printf("\t%d, %d, %1.18le\n", iter, i, data[i]);
    249          }
    250          #endif
    251          

   \                                 In section SOFTPACK, align 4, keep-with-next
    252          int th_print_fp(float value)
    253          {
   \                     th_print_fp:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xED2D'0A01        VPUSH    {S0}
   \        0x8   0xE24D'D01C        SUB      SP,SP,#+28
    254          	intparts num;
    255          	int st = load_sp(&value,&num);
   \        0xC   0xE28D'1010        ADD      R1,SP,#+16
   \       0x10   0xE28D'001C        ADD      R0,SP,#+28
   \       0x14   0x....'....        BL       load_sp
   \       0x18   0xE1B0'4000        MOVS     R4,R0
    256          	if (!st)
   \       0x1C   0xE354'0000        CMP      R4,#+0
   \       0x20   0x1A00'0001        BNE      ??th_print_fp_0
    257          		return 0;
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0xEA00'000A        B        ??th_print_fp_1
    258          	printf("{%u,%d,0x%08x,0x%08x}/*%1.18e*/",num.sign,num.exp,num.mant_high32,num.mant_low32,value);
   \                     ??th_print_fp_0:
   \       0x2C   0xED9D'0A07        VLDR     S0,[SP, #+28]
   \       0x30   0xEEB7'0AC0        VCVT.F64.F32 D0,S0
   \       0x34   0xED8D'0B02        VSTR     D0,[SP, #+8]
   \       0x38   0xE59D'0018        LDR      R0,[SP, #+24]
   \       0x3C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x40   0xE59D'3014        LDR      R3,[SP, #+20]
   \       0x44   0xE1DD'21F2        LDRSH    R2,[SP, #+18]
   \       0x48   0xE1DD'11D0        LDRSB    R1,[SP, #+16]
   \       0x4C   0x....'....        LDR      R0,??DataTable5_8
   \       0x50   0x....'....        BL       printf
    259          	return 1;
   \       0x54   0xE3A0'0001        MOV      R0,#+1
   \                     ??th_print_fp_1:
   \       0x58   0xE28D'D020        ADD      SP,SP,#+32
   \       0x5C   0xE8BD'8010        POP      {R4,PC}          ;; return
    260          }
    261          #if 0
    262          int bmark_verify_radix2(void *in_params) {
    263          	int i;
    264          	radix2_params *params=(radix2_params *)in_params;
    265          	if (params->gen_ref) {
    266          		float min=EE_MININI,max=EE_MAXINI,avg=(0.0);
    267          		char sbuf[256];
    268          		for (i=0; i<params->N; i++) {
    269          			printf("\t");
    270          			th_print_fp(params->data[i]);
    271          			if (i<params->N-1)
    272          				th_printf(",\n");
    273          			min=(min>params->data[i])?params->data[i]:min;
    274          			max=(max<params->data[i])?params->data[i]:max;
    275          			avg+=params->data[i];
    276          		}
    277          		//th_printf("}; //ref_data\n\n"); 
    278          		avg/=params->N;
    279          		printf("static intparts ref_avg=%s;\n",th_sprint_fp(avg,sbuf));
    280          		printf("static intparts ref_max=%s;\n",th_sprint_fp(max,sbuf));
    281          		printf("static intparts ref_min=%s;\n",th_sprint_fp(min,sbuf));
    282          		printf("void init_preset_index() {\n");
    283          		printf("presets_radix2[index].ref_data=(intparts *)ref_data_index;\npresets_radix2[index].N=%d;\n",params->N);
    284          		printf("presets_radix2[index].seed=%d;\n",params->seed);
    285          		printf("presets_radix2[index].ref_avg=ref_avg;\npresets_radix2[index].ref_max=ref_max;\npresets_radix2[index].ref_min=ref_min;\n}\n",params->ref_avg,params->ref_max,params->ref_min);
    286          		printf("/**** END DATASET ****/\n");
    287          	} else {
    288          		snr_result resa;
    289          		if (params->ref_data==NULL) {
    290          			th_printf("Cannot validate this dataset! Please generate reference data on reliable hardware and tools using -g!\n");
    291          			return -1;
    292          		}
    293          		resa.bmin_ok=params->minbits;
    294          		ee_ifpbits_buffer(params->data,params->ref_data,params->N,&resa);
    295          	
    296          		if (!resa.pass) return 0;
    297          	}
    298          	return 1;
    299          }
    300          
    301          #endif
    302          

   \                                 In section SOFTPACK, align 4, keep-with-next
    303          static void FFT_transform_internal (int N, float * data, int direction, float *twp) {
   \                     FFT_transform_internal:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   \       0x10   0xE1B0'7003        MOVS     R7,R3
    304              int n = N/2;
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE3A0'1002        MOV      R1,#+2
   \       0x1C   0x....'....        BL       __aeabi_idiv
   \       0x20   0xE1B0'8000        MOVS     R8,R0
    305              int bit = 0;
   \       0x24   0xE3A0'9000        MOV      R9,#+0
    306              int logn;
    307              int dual = 1;
   \       0x28   0xE3A0'A001        MOV      R10,#+1
    308          
    309              if (n == 1) return;         /* Identity operation! */
   \       0x2C   0xE358'0001        CMP      R8,#+1
   \       0x30   0x0A00'0076        BEQ      ??FFT_transform_internal_0
    310              logn = int_log2(n);
   \                     ??FFT_transform_internal_1:
   \       0x34   0xE1B0'0008        MOVS     R0,R8
   \       0x38   0x....'....        BL       int_log2
   \       0x3C   0xE1B0'B000        MOVS     R11,R0
    311          
    312              if (N == 0) return;    
   \       0x40   0xE354'0000        CMP      R4,#+0
   \       0x44   0x0A00'0071        BEQ      ??FFT_transform_internal_0
    313          
    314          #if BMDEBUG
    315              //dump_data(-1, N, data);
    316          #endif
    317              /* bit reverse the input data for decimation in time algorithm */
    318              FFT_bitreverse(N, data) ;
   \                     ??FFT_transform_internal_2:
   \       0x48   0xE1B0'1005        MOVS     R1,R5
   \       0x4C   0xE1B0'0004        MOVS     R0,R4
   \       0x50   0x....'....        BL       FFT_bitreverse
    319          
    320              /* apply fft recursion */
    321              /* this loop executed int_log2(N) times */
    322              for (bit = 0; bit < logn; bit++, dual *= 2) {
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \                     ??FFT_transform_internal_3:
   \       0x58   0xE150'000B        CMP      R0,R11
   \       0x5C   0xAA00'006B        BGE      ??FFT_transform_internal_4
    323                int a;
    324                int b;
    325                float w_real;
    326                float w_imag;
    327          
    328                for (a=0, b = 0; b < n; b += 2 * dual) {
   \       0x60   0xE3A0'2000        MOV      R2,#+0
   \       0x64   0xE3A0'1000        MOV      R1,#+0
   \                     ??FFT_transform_internal_5:
   \       0x68   0xE151'0008        CMP      R1,R8
   \       0x6C   0xAA00'0027        BGE      ??FFT_transform_internal_6
    329                  int i = 2*b ;
   \       0x70   0xE1B0'3081        LSLS     R3,R1,#+1
    330                  int j = 2*(b + dual);
   \       0x74   0xE09A'C001        ADDS     R12,R10,R1
   \       0x78   0xE1B0'C08C        LSLS     R12,R12,#+1
    331          
    332                  float wd_real = data[j] ;
   \       0x7C   0xE1B0'E10C        LSLS     LR,R12,#+2
   \       0x80   0xE095'E00E        ADDS     LR,R5,LR
   \       0x84   0xED9E'1A00        VLDR     S2,[LR, #0]
    333                  float wd_imag = data[j+1] ;
   \       0x88   0xE1B0'E10C        LSLS     LR,R12,#+2
   \       0x8C   0xE095'E00E        ADDS     LR,R5,LR
   \       0x90   0xEDDE'1A01        VLDR     S3,[LR, #+4]
    334                    
    335                  data[j]   = data[i]   - wd_real;
   \       0x94   0xE1B0'E103        LSLS     LR,R3,#+2
   \       0x98   0xE095'E00E        ADDS     LR,R5,LR
   \       0x9C   0xED9E'2A00        VLDR     S4,[LR, #0]
   \       0xA0   0xEE32'2A41        VSUB.F32 S4,S4,S2
   \       0xA4   0xE1B0'E10C        LSLS     LR,R12,#+2
   \       0xA8   0xE095'E00E        ADDS     LR,R5,LR
   \       0xAC   0xED8E'2A00        VSTR     S4,[LR, #0]
    336                  data[j+1] = data[i+1] - wd_imag;
   \       0xB0   0xE1B0'E103        LSLS     LR,R3,#+2
   \       0xB4   0xE095'E00E        ADDS     LR,R5,LR
   \       0xB8   0xED9E'2A01        VLDR     S4,[LR, #+4]
   \       0xBC   0xEE32'2A61        VSUB.F32 S4,S4,S3
   \       0xC0   0xE1B0'E10C        LSLS     LR,R12,#+2
   \       0xC4   0xE095'E00E        ADDS     LR,R5,LR
   \       0xC8   0xED8E'2A01        VSTR     S4,[LR, #+4]
    337                  data[i]  += wd_real;
   \       0xCC   0xE1B0'E103        LSLS     LR,R3,#+2
   \       0xD0   0xE095'E00E        ADDS     LR,R5,LR
   \       0xD4   0xED9E'2A00        VLDR     S4,[LR, #0]
   \       0xD8   0xEE32'2A01        VADD.F32 S4,S4,S2
   \       0xDC   0xE1B0'E103        LSLS     LR,R3,#+2
   \       0xE0   0xE095'E00E        ADDS     LR,R5,LR
   \       0xE4   0xED8E'2A00        VSTR     S4,[LR, #0]
    338                  data[i+1]+= wd_imag;
   \       0xE8   0xE1B0'E103        LSLS     LR,R3,#+2
   \       0xEC   0xE095'E00E        ADDS     LR,R5,LR
   \       0xF0   0xED9E'2A01        VLDR     S4,[LR, #+4]
   \       0xF4   0xEE72'1A21        VADD.F32 S3,S4,S3
   \       0xF8   0xE1B0'3103        LSLS     R3,R3,#+2
   \       0xFC   0xE095'3003        ADDS     R3,R5,R3
   \      0x100   0xEDC3'1A01        VSTR     S3,[R3, #+4]
    339                }
   \      0x104   0xE3A0'3002        MOV      R3,#+2
   \      0x108   0xE021'1A93        MLA      R1,R3,R10,R1
   \      0x10C   0xEAFF'FFD5        B        ??FFT_transform_internal_5
    340                
    341                /* a = 1 .. (dual-1) */
    342                for (a = 1; a < dual; a++) {
   \                     ??FFT_transform_internal_6:
   \      0x110   0xE3A0'3001        MOV      R3,#+1
   \                     ??FFT_transform_internal_7:
   \      0x114   0xE153'000A        CMP      R3,R10
   \      0x118   0xAA00'0039        BGE      ??FFT_transform_internal_8
    343                  /* trignometric recurrence for w-> exp(i theta) w */
    344          	w_real=*twp++;
   \      0x11C   0xED97'1A00        VLDR     S2,[R7, #0]
   \      0x120   0xEEB0'0A41        VMOV.F32 S0,S2
   \      0x124   0xE297'2004        ADDS     R2,R7,#+4
    345          	w_imag=*twp++;
   \      0x128   0xED92'1A00        VLDR     S2,[R2, #0]
   \      0x12C   0xEEF0'0A41        VMOV.F32 S1,S2
   \      0x130   0xE292'7004        ADDS     R7,R2,#+4
    346          
    347                  for (b = 0; b < n; b += 2 * dual) {
   \      0x134   0xE3A0'2000        MOV      R2,#+0
   \      0x138   0xE1B0'1002        MOVS     R1,R2
   \                     ??FFT_transform_internal_9:
   \      0x13C   0xE151'0008        CMP      R1,R8
   \      0x140   0xAA00'002D        BGE      ??FFT_transform_internal_10
    348                    int i = 2*(b + a);
   \      0x144   0xE093'2001        ADDS     R2,R3,R1
   \      0x148   0xE1B0'2082        LSLS     R2,R2,#+1
    349                    int j = 2*(b + a + dual);
   \      0x14C   0xE093'C001        ADDS     R12,R3,R1
   \      0x150   0xE09A'C00C        ADDS     R12,R10,R12
   \      0x154   0xE1B0'C08C        LSLS     R12,R12,#+1
    350          
    351                    float z1_real = data[j];
   \      0x158   0xE1B0'E10C        LSLS     LR,R12,#+2
   \      0x15C   0xE095'E00E        ADDS     LR,R5,LR
   \      0x160   0xED9E'1A00        VLDR     S2,[LR, #0]
    352                    float z1_imag = data[j+1];
   \      0x164   0xE1B0'E10C        LSLS     LR,R12,#+2
   \      0x168   0xE095'E00E        ADDS     LR,R5,LR
   \      0x16C   0xEDDE'1A01        VLDR     S3,[LR, #+4]
    353                        
    354                    float wd_real = w_real * z1_real - w_imag * z1_imag;
   \      0x170   0xEE20'2A01        VMUL.F32 S4,S0,S2
   \      0x174   0xEE00'2AE1        VMLS.F32 S4,S1,S3
    355                    float wd_imag = w_real * z1_imag + w_imag * z1_real;
   \      0x178   0xEE60'2A21        VMUL.F32 S5,S0,S3
   \      0x17C   0xEE40'2A81        VMLA.F32 S5,S1,S2
    356          
    357                    data[j]   = data[i]   - wd_real;
   \      0x180   0xE1B0'E102        LSLS     LR,R2,#+2
   \      0x184   0xE095'E00E        ADDS     LR,R5,LR
   \      0x188   0xED9E'3A00        VLDR     S6,[LR, #0]
   \      0x18C   0xEE33'3A42        VSUB.F32 S6,S6,S4
   \      0x190   0xE1B0'E10C        LSLS     LR,R12,#+2
   \      0x194   0xE095'E00E        ADDS     LR,R5,LR
   \      0x198   0xED8E'3A00        VSTR     S6,[LR, #0]
    358                    data[j+1] = data[i+1] - wd_imag;
   \      0x19C   0xE1B0'E102        LSLS     LR,R2,#+2
   \      0x1A0   0xE095'E00E        ADDS     LR,R5,LR
   \      0x1A4   0xED9E'3A01        VLDR     S6,[LR, #+4]
   \      0x1A8   0xEE33'3A62        VSUB.F32 S6,S6,S5
   \      0x1AC   0xE1B0'E10C        LSLS     LR,R12,#+2
   \      0x1B0   0xE095'E00E        ADDS     LR,R5,LR
   \      0x1B4   0xED8E'3A01        VSTR     S6,[LR, #+4]
    359                    data[i]  += wd_real;
   \      0x1B8   0xE1B0'E102        LSLS     LR,R2,#+2
   \      0x1BC   0xE095'E00E        ADDS     LR,R5,LR
   \      0x1C0   0xED9E'3A00        VLDR     S6,[LR, #0]
   \      0x1C4   0xEE33'3A02        VADD.F32 S6,S6,S4
   \      0x1C8   0xE1B0'E102        LSLS     LR,R2,#+2
   \      0x1CC   0xE095'E00E        ADDS     LR,R5,LR
   \      0x1D0   0xED8E'3A00        VSTR     S6,[LR, #0]
    360                    data[i+1]+= wd_imag;
   \      0x1D4   0xE1B0'E102        LSLS     LR,R2,#+2
   \      0x1D8   0xE095'E00E        ADDS     LR,R5,LR
   \      0x1DC   0xED9E'3A01        VLDR     S6,[LR, #+4]
   \      0x1E0   0xEE73'2A22        VADD.F32 S5,S6,S5
   \      0x1E4   0xE1B0'2102        LSLS     R2,R2,#+2
   \      0x1E8   0xE095'2002        ADDS     R2,R5,R2
   \      0x1EC   0xEDC2'2A01        VSTR     S5,[R2, #+4]
    361                  }
   \      0x1F0   0xE3A0'2002        MOV      R2,#+2
   \      0x1F4   0xE021'1A92        MLA      R1,R2,R10,R1
   \      0x1F8   0xEAFF'FFCF        B        ??FFT_transform_internal_9
    362                }
   \                     ??FFT_transform_internal_10:
   \      0x1FC   0xE293'3001        ADDS     R3,R3,#+1
   \      0x200   0xEAFF'FFC3        B        ??FFT_transform_internal_7
    363              }
   \                     ??FFT_transform_internal_8:
   \      0x204   0xE290'0001        ADDS     R0,R0,#+1
   \      0x208   0xE1B0'A08A        LSLS     R10,R10,#+1
   \      0x20C   0xEAFF'FF91        B        ??FFT_transform_internal_3
    364          #if BMDEBUG
    365              dump_data(bit, N, data);
    366          #endif
    367          }
   \                     ??FFT_transform_internal_4:
   \                     ??FFT_transform_internal_0:
   \      0x210   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    368          
    369          

   \                                 In section SOFTPACK, align 4, keep-with-next
    370          static void FFT_bitreverse(int N, float * data) {
   \                     FFT_bitreverse:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    371              /* This is the Goldrader bit-reversal algorithm */
    372              int n=N/2;
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0xE3A0'1002        MOV      R1,#+2
   \       0x14   0x....'....        BL       __aeabi_idiv
    373              int nm1 = n-1;
   \       0x18   0xE250'1001        SUBS     R1,R0,#+1
    374              int i=0; 
   \       0x1C   0xE3A0'2000        MOV      R2,#+0
    375              int j=0;
   \       0x20   0xE3A0'3000        MOV      R3,#+0
    376              for (; i < nm1; i++) {
   \                     ??FFT_bitreverse_0:
   \       0x24   0xE152'0001        CMP      R2,R1
   \       0x28   0xAA00'0022        BGE      ??FFT_bitreverse_1
    377          
    378                /*int ii = 2*i; */
    379                int ii = i << 1;
   \       0x2C   0xE1B0'C082        LSLS     R12,R2,#+1
    380          
    381                /*int jj = 2*j; */
    382                int jj = j << 1;
   \       0x30   0xE1B0'E083        LSLS     LR,R3,#+1
    383          
    384                /* int k = n / 2 ; */
    385                int k = n >> 1;
   \       0x34   0xE1B0'60C0        ASRS     R6,R0,#+1
    386          
    387                if (i < j) {
   \       0x38   0xE152'0003        CMP      R2,R3
   \       0x3C   0xAA00'0015        BGE      ??FFT_bitreverse_2
    388                  float tmp_real    = data[ii];
   \       0x40   0xE1B0'710C        LSLS     R7,R12,#+2
   \       0x44   0xE095'7007        ADDS     R7,R5,R7
   \       0x48   0xED97'0A00        VLDR     S0,[R7, #0]
    389                  float tmp_imag    = data[ii+1];
   \       0x4C   0xE1B0'710C        LSLS     R7,R12,#+2
   \       0x50   0xE095'7007        ADDS     R7,R5,R7
   \       0x54   0xEDD7'0A01        VLDR     S1,[R7, #+4]
    390                  data[ii]   = data[jj];
   \       0x58   0xE1B0'710C        LSLS     R7,R12,#+2
   \       0x5C   0xE1B0'810E        LSLS     R8,LR,#+2
   \       0x60   0xE795'8008        LDR      R8,[R5, +R8]
   \       0x64   0xE785'8007        STR      R8,[R5, +R7]
    391                  data[ii+1] = data[jj+1];
   \       0x68   0xE1B0'710C        LSLS     R7,R12,#+2
   \       0x6C   0xE095'7007        ADDS     R7,R5,R7
   \       0x70   0xE1B0'810E        LSLS     R8,LR,#+2
   \       0x74   0xE095'8008        ADDS     R8,R5,R8
   \       0x78   0xED98'1A01        VLDR     S2,[R8, #+4]
   \       0x7C   0xED87'1A01        VSTR     S2,[R7, #+4]
    392                  data[jj]   = tmp_real;
   \       0x80   0xE1B0'710E        LSLS     R7,LR,#+2
   \       0x84   0xE095'7007        ADDS     R7,R5,R7
   \       0x88   0xED87'0A00        VSTR     S0,[R7, #0]
    393                  data[jj+1] = tmp_imag; }
   \       0x8C   0xE1B0'710E        LSLS     R7,LR,#+2
   \       0x90   0xE095'7007        ADDS     R7,R5,R7
   \       0x94   0xEDC7'0A01        VSTR     S1,[R7, #+4]
    394          
    395                while (k <= j) 
   \                     ??FFT_bitreverse_2:
   \       0x98   0xE153'0006        CMP      R3,R6
   \       0x9C   0xBA00'0002        BLT      ??FFT_bitreverse_3
    396                {
    397                  /*j = j - k ; */
    398                  j -= k;
   \       0xA0   0xE053'3006        SUBS     R3,R3,R6
    399          
    400                  /*k = k / 2 ;  */
    401                  k >>= 1 ; 
   \       0xA4   0xE1B0'60C6        ASRS     R6,R6,#+1
   \       0xA8   0xEAFF'FFFA        B        ??FFT_bitreverse_2
    402                }
    403                j += k ;
   \                     ??FFT_bitreverse_3:
   \       0xAC   0xE096'3003        ADDS     R3,R6,R3
    404              }
   \       0xB0   0xE292'2001        ADDS     R2,R2,#+1
   \       0xB4   0xEAFF'FFDA        B        ??FFT_bitreverse_0
    405            }
   \                     ??FFT_bitreverse_1:
   \       0xB8   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x5444'2D18        DC32     0x54442D18,0x400921FB

   \              0x4009'21FB

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x7E96'7699        DC32     0x7e967699

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0xFE96'7699        DC32     0xfe967699

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     intparts_zero

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x....'....        DC32     presets_radix2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_7:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_8:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x52          DC8 0x45, 0x52, 0x52, 0x4F, 0x52, 0x3A, 0x20, 0x46

   \              0x52 0x4F    

   \              0x52 0x3A    

   \              0x20 0x46
   \        0x8   0x46 0x54          DC8 0x46, 0x54, 0x20, 0x72, 0x61, 0x64, 0x69, 0x78

   \              0x20 0x72    

   \              0x61 0x64    

   \              0x69 0x78
   \       0x10   0x32 0x2C          DC8 0x32, 0x2C, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20

   \              0x20 0x44    

   \              0x61 0x74    

   \              0x61 0x20
   \       0x18   0x6C 0x65          DC8 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x69

   \              0x6E 0x67    

   \              0x74 0x68    

   \              0x20 0x69
   \       0x20   0x73 0x20          DC8 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20

   \              0x6E 0x6F    

   \              0x74 0x20    

   \              0x61 0x20
   \       0x28   0x70 0x6F          DC8 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66

   \              0x77 0x65    

   \              0x72 0x20    

   \              0x6F 0x66
   \       0x30   0x20 0x32          DC8 0x20, 0x32, 0x21, 0x20, 0x5B, 0x25, 0x64, 0x5D

   \              0x21 0x20    

   \              0x5B 0x25    

   \              0x64 0x5D
   \       0x38   0x0A 0x00          DC8 0x0A, 0
   \       0x3A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x61          DC8 "Cannot Allocate Memory %s:%d"

   \              0x6E 0x6E    

   \              0x6F 0x74    

   \              0x20 0x41    

   \              0x6C 0x6C    

   \              0x6F 0x63    

   \              0x61 0x74    

   \              0x65 0x20    

   \              0x4D 0x65    

   \              0x6D 0x6F    

   \              0x72 0x79    

   \              0x20 0x25    

   \              0x73 0x3A    

   \              0x25 0x64    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C

   \              0x65 0x78    

   \              0x61 0x6D    

   \              0x70 0x6C
   \       0x38   0x65 0x73          DC8 0x65, 0x73, 0x5C, 0x63, 0x6F, 0x72, 0x65, 0x6D

   \              0x5C 0x63    

   \              0x6F 0x72    

   \              0x65 0x6D
   \       0x40   0x61 0x72          DC8 0x61, 0x72, 0x6B, 0x5C, 0x63, 0x6F, 0x72, 0x65

   \              0x6B 0x5C    

   \              0x63 0x6F    

   \              0x72 0x65
   \       0x48   0x6D 0x61          DC8 0x6D, 0x61, 0x72, 0x6B, 0x5C, 0x66, 0x66, 0x74

   \              0x72 0x6B    

   \              0x5C 0x66    

   \              0x66 0x74
   \       0x50   0x5F 0x72          DC8 0x5F, 0x72, 0x61, 0x64, 0x69, 0x78, 0x32, 0x2E

   \              0x61 0x64    

   \              0x69 0x78    

   \              0x32 0x2E
   \       0x58   0x63 0x00          DC8 0x63, 0
   \       0x5A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x49 0x6E          DC8 "Invalid pointer %s:%d"

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x70 0x6F    

   \              0x69 0x6E    

   \              0x74 0x65    

   \              0x72 0x20    

   \              0x25 0x73    

   \              0x3A 0x25    

   \              0x64 0x00
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x7B 0x25          DC8 "{%u,%d,0x%08x,0x%08x}/*%1.18e*/"

   \              0x75 0x2C    

   \              0x25 0x64    

   \              0x2C 0x30    

   \              0x78 0x25    

   \              0x30 0x38    

   \              0x78 0x2C    

   \              0x30 0x78    

   \              0x25 0x30    

   \              0x38 0x78    

   \              0x7D 0x2F    

   \              0x2A 0x25    

   \              0x31 0x2E    

   \              0x31 0x38    

   \              0x65 0x2A    

   \              0x2F 0x00
    406          
    407          #if NEED_INVERSE
    408          static void FFT_inverse(int N, float * data)
    409          {
    410              int n = N/2;
    411              float norm = 0.0;
    412              int i=0;
    413          	float *twp=calculate_twiddles(N,+1);
    414              FFT_transform_internal(N, data, +1,twp);
    415          	th_free(twp);
    416          
    417              /* Normalize */
    418              norm=1.0/((float) n);
    419              for(i=0; i<N; i++)
    420                data[i] *= norm;
    421            
    422          }
    423          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FFT_bitreverse
        24 __aeabi_idiv
      40   FFT_transform_internal
        40   -> FFT_bitreverse
        40   -> int_log2
        40 __aeabi_idiv
      16   bmark_clean_radix2
        16   -> free
      16   bmark_fini_radix2
        16   -> free
        16   -> printf
      72   calculate_twiddles
        72   -> int_log2
        72   -> malloc
        72   -> sinf
        72 __aeabi_idiv
      16   define_params_radix2
        16   -> calculate_twiddles
        16   -> calloc
        16   -> fromint_f32_vector
        16   -> init_preset_0
        16   -> printf
      16   int_log2
        16   -> printf
      40   t_run_test_radix2
        40   -> FFT_transform_internal
        40   -> fp_iaccurate_bits_sp
      40   th_print_fp
        40   -> load_sp
        40   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
      60  ?_0
      32  ?_1
      92  ?_2
      24  ?_3
      32  ?_4
     188  FFT_bitreverse
     532  FFT_transform_internal
      76  bmark_clean_radix2
      80  bmark_fini_radix2
     412  calculate_twiddles
     312  define_params_radix2
      68  int_log2
      12  intparts_zero
     384  presets_radix2
     276  t_run_test_radix2
      96  th_print_fp

 
   384 bytes in section .bss
    12 bytes in section .data
   240 bytes in section .rodata
 2'084 bytes in section SOFTPACK
 
 2'084 bytes of CODE  memory
   240 bytes of CONST memory
   396 bytes of DATA  memory

Errors: none
Warnings: none
