###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         05/May/2020  01:59:57
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EWEC0A.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\ddram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\..\..\lib\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\ddram\List\fft_radix2.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\build\sama5d27-som1-ek\ddram\Obj\fft_radix2.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf      =  flags,floats,int_specials,widths
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\coremark\coremark\fft_radix2.c
      1          /*
      2          (C) 2014 EEMBC(R).  All rights reserved.                            
      3          
      4          All EEMBC Benchmark Software are products of EEMBC 
      5          and are provided under the terms of the EEMBC Benchmark License Agreements.  
      6          The EEMBC Benchmark Software are proprietary intellectual properties of EEMBC and its Members 
      7          and is protected under all applicable laws, including all applicable copyright laws.  
      8          If you received this EEMBC Benchmark Software without having 
      9          a currently effective EEMBC Benchmark License Agreement, you must discontinue use. 
     10          Please refer to LICENSE.md for the specific license agreement that pertains to this Benchmark Software.
     11          */
     12          
     13          /*************************
     14          ** FFT radix 2 **
     15          ** Perform FFT with radix2.
     16          *************************/
     17          //#include "th_cfg.h"
     18          #include <math.h> /* for sin, cos and pow */
     19          #include <stdlib.h>
     20          #include <string.h>
     21          #include "th_rand.h" /* initialize a random data vector */
     22          #include "fft_radix2.h"
     23          #include <stdio.h>
     24          
     25          
     26          #define EE_MININI (1.0e38)
     27          #define EE_MAXINI (-1.0e38)
     28          #define EE_EPSINI (1.0e-37)
     29          #define EE_EPSILON EE_EPSINI
     30          #define BMDEBUG (0)
     31          
     32          //PT: 4/4/2016: w/g decision (undoes th_lib.h for radix only)
     33          #undef  MIN_ACC_BITS_FP64    
     34          #define MIN_ACC_BITS_FP64 25
     35          
     36          #define EE_PI 3.1415926535897932
     37          #define MIN_ACC_BITS_FP32 14
     38          
     39          #if !defined(ALIGN_BOUNDARY)
     40          #define ALIGN_BOUNDARY 64
     41          #endif
     42          radix2_params presets_radix2[NUM_DATAS];
     43          extern void init_preset_0();
     44          /* ======================================================================== */
     45          /*         F U N C T I O N   P R O T O T Y P E S                            */
     46          /* ======================================================================== */
     47          /* file provides :
     48          define - init base input params (segment [within 0..2 boundary], number of coefficients to calculate, number of integration steps)
     49          init -  allocate working memory, assign a[0] and b[0] . 
     50          run - calculate N coefficients in the segment
     51          fini - calculate avg of coeffients then dealloc working memory
     52          verify - SNR average of coefficients vs golden reference, must run at least base iterations for valid output.
     53          clean - deallocate output memory
     54          */
     55          
     56          
     57          
     58          
     59          /* benchmark function declarations */
     60          static void FFT_transform_internal (int N, float * data, int direction, float *twp);
     61          static void FFT_bitreverse(int N, float * data);

   \                                 In section SOFTPACK, align 4, keep-with-next
     62          static int int_log2 (int n)
     63          {
   \                     int_log2:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
     64              int k = 1;
   \        0x4   0xE3A0'1001        MOV      R1,#+1
     65              int log = 0;
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xEA00'0001        B        ??int_log2_0
     66              for(/*k=1*/; k < n; k *= 2, log++);
   \                     ??int_log2_1:
   \       0x10   0xE1A0'1081        LSL      R1,R1,#+1
   \       0x14   0xE284'4001        ADD      R4,R4,#+1
   \                     ??int_log2_0:
   \       0x18   0xE151'0000        CMP      R1,R0
   \       0x1C   0xBAFF'FFFB        BLT      ??int_log2_1
     67              if (n != (1 << log))
   \       0x20   0xE3A0'1001        MOV      R1,#+1
   \       0x24   0xE150'0411        CMP      R0,R1, LSL R4
   \       0x28   0x0A00'0002        BEQ      ??int_log2_2
     68                printf("ERROR: FFT radix2, Data length is not a power of 2! [%d]\n",n);
   \       0x2C   0xE1A0'1000        MOV      R1,R0
   \       0x30   0x....'....        LDR      R0,??DataTable6_2
   \       0x34   0x....'....        BL       printf
     69              return log; 
   \                     ??int_log2_2:
   \       0x38   0xE1A0'0004        MOV      R0,R4
   \       0x3C   0xE8BD'8010        POP      {R4,PC}          ;; return
     70          }

   \                                 In section .data, align 4
   \                     presets_radix2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x60   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x70   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x80   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x90   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xA0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xB0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xC0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xD0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xE0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xF0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x100   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x110   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x120   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x130   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x140   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x150   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x160   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x170   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
     71          
     72          static float *calculate_twiddles(int size, int direction) {
     73              int n=0,a;
     74              float *twp=NULL;
     75              int bit = 0;
     76              int logn;
     77              int dual = 1;
     78          	
     79              if (size == 1) return twp;         
     80              logn = int_log2(size/2);
     81          	
     82              for (bit = 0; bit < logn; bit++, dual *= 2) 
     83                for (a = 1; a < dual; a++) 
     84          	    n++;
     85          	twp=(float *)malloc(sizeof(float)*2*n);
     86          	n=0;
     87          	bit=0;
     88          	dual=1;
     89              for (bit = 0; bit < logn; bit++, dual *= 2) {
     90          		float w_real = (1.0);
     91          		float w_imag = (0.0);
     92          
     93          		float theta = (2.0) * direction * EE_PI / ((2.0) * (float) dual);
     94          		float s = sinf(theta);
     95          		float t = sinf(theta / (2.0));
     96          		float s2 = (2.0) * t * t;
     97          
     98          		for (a = 1; a < dual; a++) {
     99          			float tmp_real = w_real - s * w_imag - s2 * w_real;
    100          			float tmp_imag = w_imag + s * w_real - s2 * w_imag;
    101          			w_real = tmp_real;
    102          			w_imag = tmp_imag;
    103          			twp[n++] = w_real;
    104          			twp[n++] = w_imag;
    105          		}
    106          	}
    107          	return twp;
    108          }
    109          intparts intparts_zero={0,1,0,0};
   \                     intparts_zero:
   \      0x180   0x00 0x00          DC8 0, 0
   \      0x182   0x0001             DC16 1
   \      0x184   0x0000'0000        DC32 0, 0

   \              0x0000'0000
    110          

   \                                 In section SOFTPACK, align 4, keep-with-next
    111          void *define_params_radix2() {
   \                     define_params_radix2:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xED2D'8B04        VPUSH    {D8-D9}
    112              radix2_params *params;
    113              int32_t data_index=0;
    114              init_preset_0();
   \        0x8   0x....'....        BL       init_preset_0
    115              //init_preset_1();
    116              //init_preset_2();
    117              //init_preset_3();
    118              //init_preset_4();
    119              //init_preset_5();	
    120          
    121          	/* parameter setup */
    122          	params=(radix2_params *)calloc(1,sizeof(radix2_params));
   \        0xC   0xE3A0'1040        MOV      R1,#+64
   \       0x10   0xE3A0'0001        MOV      R0,#+1
   \       0x14   0x....'....        BL       calloc
   \       0x18   0xE1B0'4000        MOVS     R4,R0
    123          	if ( params == NULL ){
   \       0x1C   0x1A00'0005        BNE      ??define_params_radix2_0
    124                    printf( "Cannot Allocate Memory %s:%d", __FILE__,__LINE__ );
   \       0x20   0xE3A0'207C        MOV      R2,#+124
   \       0x24   0x....'....        LDR      R1,??DataTable6_3
   \       0x28   0x....'....        LDR      R0,??DataTable6_4
   \       0x2C   0x....'....        BL       printf
    125                    return 0;
   \       0x30   0xE3A0'0000        MOV      R0,#+0
   \       0x34   0x....'....        B        ?Subroutine0
    126                  }
    127          	params->N=256; /* default */
   \                     ??define_params_radix2_0:
   \       0x38   0xE3A0'0F40        MOV      R0,#+256
    128          	params->gen_ref=0;
   \       0x3C   0xE3A0'5000        MOV      R5,#+0
   \       0x40   0xE584'0008        STR      R0,[R4, #+8]
    129          	params->ref_min=intparts_zero;
   \       0x44   0x....'....        LDR      R0,??DataTable6_5
   \       0x48   0xE584'500C        STR      R5,[R4, #+12]
   \       0x4C   0xE280'2F60        ADD      R2,R0,#+384
   \       0x50   0xE284'1014        ADD      R1,R4,#+20
   \       0x54   0xE892'5008        LDM      R2,{R3,R12,LR}
   \       0x58   0xE881'5008        STM      R1,{R3,R12,LR}
    130          	params->ref_max=intparts_zero;
   \       0x5C   0xE280'7F60        ADD      R7,R0,#+384
   \       0x60   0xE284'6020        ADD      R6,R4,#+32
   \       0x64   0xE897'0700        LDM      R7,{R8-R10}
   \       0x68   0xE886'0700        STM      R6,{R8-R10}
    131          	params->ref_avg=intparts_zero;
   \       0x6C   0xE280'1F60        ADD      R1,R0,#+384
   \       0x70   0xE284'B02C        ADD      R11,R4,#+44
   \       0x74   0xE891'100C        LDM      R1,{R2,R3,R12}
   \       0x78   0xE88B'100C        STM      R11,{R2,R3,R12}
    132          	params->ref_data=NULL;
    133          	params->seed=0;
    134          	params->minbits=MIN_ACC_BITS_FP32;
   \       0x7C   0xE3A0'E00E        MOV      LR,#+14
   \       0x80   0xE584'5010        STR      R5,[R4, #+16]
   \       0x84   0xE584'503C        STR      R5,[R4, #+60]
   \       0x88   0xE584'E038        STR      LR,[R4, #+56]
    135          
    136          	//th_parse_buf_flag(dataset,"-i",&data_index);
    137          	//if (pgo_training_run!=0) {
    138          	//	data_index=0; 
    139          	//}
    140          	/* preset datasets */
    141          	if ((data_index>=0) && (data_index<NUM_DATAS)) {
    142          		params->N=presets_radix2[data_index].N; /* default */
   \       0x8C   0xE590'1008        LDR      R1,[R0, #+8]
    143          		params->ref_min=presets_radix2[data_index].ref_min;
   \       0x90   0xE280'3014        ADD      R3,R0,#+20
   \       0x94   0xE284'2014        ADD      R2,R4,#+20
    144          		params->ref_max=presets_radix2[data_index].ref_max;
   \       0x98   0xE280'8020        ADD      R8,R0,#+32
   \       0x9C   0xE284'7020        ADD      R7,R4,#+32
   \       0xA0   0xE584'1008        STR      R1,[R4, #+8]
   \       0xA4   0xE893'5040        LDM      R3,{R6,R12,LR}
   \       0xA8   0xE882'5040        STM      R2,{R6,R12,LR}
   \       0xAC   0xE898'0E00        LDM      R8,{R9-R11}
   \       0xB0   0xE887'0E00        STM      R7,{R9-R11}
    145          		params->ref_avg=presets_radix2[data_index].ref_avg;
   \       0xB4   0xE280'202C        ADD      R2,R0,#+44
   \       0xB8   0xE284'102C        ADD      R1,R4,#+44
   \       0xBC   0xE892'5008        LDM      R2,{R3,R12,LR}
   \       0xC0   0xE881'5008        STM      R1,{R3,R12,LR}
    146          		params->ref_data=presets_radix2[data_index].ref_data;
   \       0xC4   0xE590'6010        LDR      R6,[R0, #+16]
    147          		params->seed=presets_radix2[data_index].seed;
    148          	} 
    149          	/* command line overrides */
    150          	//if (pgo_training_run==0) {
    151          	//	th_parse_buf_flag_unsigned(dataset,"-s",&params->seed);
    152          	//	th_parse_buf_flag_unsigned(dataset,"-n",&params->N);
    153          	//	th_parse_buf_flag(dataset,"-g",&params->gen_ref);
    154          	//}
    155          	/* generate the data */
    156          	params->data=fromint_f32_vector(params->N,params->seed); /* default */
   \       0xC8   0xE3A0'7000        MOV      R7,#+0
   \       0xCC   0xE3A0'8001        MOV      R8,#+1
   \       0xD0   0xE584'6010        STR      R6,[R4, #+16]
   \       0xD4   0xE590'103C        LDR      R1,[R0, #+60]
   \       0xD8   0xE594'0008        LDR      R0,[R4, #+8]
   \       0xDC   0xE584'103C        STR      R1,[R4, #+60]
   \       0xE0   0x....'....        BL       fromint_f32_vector
   \       0xE4   0xE584'0000        STR      R0,[R4, #+0]
    157          	params->twp=calculate_twiddles(params->N,-1);
   \       0xE8   0xE594'0008        LDR      R0,[R4, #+8]
   \       0xEC   0xE350'0001        CMP      R0,#+1
   \       0xF0   0x0A00'0041        BEQ      ??define_params_radix2_1
   \       0xF4   0xE080'0FA0        ADD      R0,R0,R0, LSR #+31
   \       0xF8   0xE1A0'00C0        ASR      R0,R0,#+1
   \       0xFC   0x....'....        BL       int_log2
   \      0x100   0xE1A0'6000        MOV      R6,R0
   \      0x104   0xE356'0000        CMP      R6,#+0
   \      0x108   0xDA00'0006        BLE      ??define_params_radix2_2
   \      0x10C   0xEA00'0002        B        ??define_params_radix2_3
   \                     ??define_params_radix2_4:
   \      0x110   0xE358'0001        CMP      R8,#+1
   \      0x114   0xC248'1001        SUBGT    R1,R8,#+1
   \      0x118   0xC081'7007        ADDGT    R7,R1,R7
   \                     ??define_params_radix2_3:
   \      0x11C   0xE250'0001        SUBS     R0,R0,#+1
   \      0x120   0xE1A0'8088        LSL      R8,R8,#+1
   \      0x124   0x1AFF'FFF9        BNE      ??define_params_radix2_4
   \                     ??define_params_radix2_2:
   \      0x128   0xE1A0'0187        LSL      R0,R7,#+3
   \      0x12C   0xE3A0'7000        MOV      R7,#+0
   \      0x130   0x....'....        BL       malloc
   \      0x134   0xE356'0000        CMP      R6,#+0
   \      0x138   0xE1A0'5000        MOV      R5,R0
   \      0x13C   0xE3A0'8001        MOV      R8,#+1
   \      0x140   0xDA00'002D        BLE      ??define_params_radix2_1
   \                     ??define_params_radix2_5:
   \      0x144   0xEE00'8A90        VMOV     S1,R8
   \      0x148   0xEEF8'0AE0        VCVT.F32.S32 S1,S1
   \      0x14C   0xEEB7'1AE0        VCVT.F64.F32 D1,S1
   \      0x150   0xEEB0'3B00        VMOV.F64 D3,#2.0
   \      0x154   0xEE21'2B03        VMUL.F64 D2,D1,D3
   \      0x158   0x....'....        VLDR     D5,??DataTable5
   \      0x15C   0xE3A0'05FE        MOV      R0,#+1065353216
   \      0x160   0xE3A0'1000        MOV      R1,#+0
   \      0x164   0xEE08'0A10        VMOV     S16,R0
   \      0x168   0xEE08'1A90        VMOV     S17,R1
   \      0x16C   0xEE85'4B02        VDIV.F64 D4,D5,D2
   \      0x170   0xEEF7'9BC4        VCVT.F32.F64 S19,D4
   \      0x174   0xEEB0'0A69        VMOV.F32 S0,S19
   \      0x178   0x....'....        BL       sinf
   \      0x17C   0xE3A0'05FC        MOV      R0,#+1056964608
   \      0x180   0xEEB0'9A40        VMOV.F32 S18,S0
   \      0x184   0xEE06'0A10        VMOV     S12,R0
   \      0x188   0xEE29'0A86        VMUL.F32 S0,S19,S12
   \      0x18C   0x....'....        BL       sinf
   \      0x190   0xEEB7'1AC0        VCVT.F64.F32 D1,S0
   \      0x194   0xEEB0'3B00        VMOV.F64 D3,#2.0
   \      0x198   0xEE21'1B03        VMUL.F64 D1,D1,D3
   \      0x19C   0xEEB7'0AC0        VCVT.F64.F32 D0,S0
   \      0x1A0   0xE358'0001        CMP      R8,#+1
   \      0x1A4   0xEE21'0B00        VMUL.F64 D0,D1,D0
   \      0x1A8   0xEEB7'0BC0        VCVT.F32.F64 S0,D0
   \      0x1AC   0xDA00'000F        BLE      ??define_params_radix2_6
   \      0x1B0   0xE085'0107        ADD      R0,R5,R7, LSL #+2
   \      0x1B4   0xE248'1001        SUB      R1,R8,#+1
   \                     ??define_params_radix2_7:
   \      0x1B8   0xEEB0'1A48        VMOV.F32 S2,S16
   \      0x1BC   0xEEF0'0A68        VMOV.F32 S1,S17
   \      0x1C0   0xEE09'1A68        VMLS.F32 S2,S18,S17
   \      0x1C4   0xEE49'0A08        VMLA.F32 S1,S18,S16
   \      0x1C8   0xE251'1001        SUBS     R1,R1,#+1
   \      0x1CC   0xE287'7002        ADD      R7,R7,#+2
   \      0x1D0   0xEE00'1A48        VMLS.F32 S2,S0,S16
   \      0x1D4   0xEE40'0A68        VMLS.F32 S1,S0,S17
   \      0x1D8   0xEEB0'8A41        VMOV.F32 S16,S2
   \      0x1DC   0xED80'8A00        VSTR     S16,[R0, #0]
   \      0x1E0   0xEEF0'8A60        VMOV.F32 S17,S1
   \      0x1E4   0xEDC0'8A01        VSTR     S17,[R0, #+4]
   \      0x1E8   0xE280'0008        ADD      R0,R0,#+8
   \      0x1EC   0x1AFF'FFF1        BNE      ??define_params_radix2_7
   \                     ??define_params_radix2_6:
   \      0x1F0   0xE256'6001        SUBS     R6,R6,#+1
   \      0x1F4   0xE1A0'8088        LSL      R8,R8,#+1
   \      0x1F8   0x1AFF'FFD1        BNE      ??define_params_radix2_5
   \                     ??define_params_radix2_1:
   \      0x1FC   0xE584'5004        STR      R5,[R4, #+4]
    158          	
    159          	return params;
   \      0x200   0xE1A0'0004        MOV      R0,R4
   \      0x204                      REQUIRE ?Subroutine0
   \      0x204                      ;; // Fall through to label ?Subroutine0
    160          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xECBD'8B04        VPOP     {D8-D9}
   \        0x4   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    161          
    162          /*
    163          void *bmark_init_radix2(void *in_params) {
    164          	radix2_params *params=(radix2_params *)in_params;
    165                  radix2_params *myparams;
    166          	if (in_params==NULL){
    167          		printf( "Invalid pointer %s:%d\r\n", __FILE__,__LINE__ );
    168                          return NULL;
    169                  }
    170          	myparams=(radix2_params *)calloc(1,sizeof(radix2_params));
    171          	if ( myparams == NULL ){
    172                    printf( "Cannot Allocate Memory %s:%d\r\n", __FILE__,__LINE__ );
    173                    return NULL;
    174                  }
    175          	memcpy(myparams,params,sizeof(radix2_params));
    176          
    177          	//myparams->data = (float *)aligned_alloc(ALIGN_BOUNDARY, params->N*sizeof(float) );
    178                  myparams->data = (float *)malloc(params->N*sizeof(float) );
    179          	if ( myparams->data == NULL) {
    180                    printf("%s:%d - cannot allocate working array!", __FILE__, __LINE__ );
    181          		return NULL;
    182          	}
    183          
    184          	memcpy(myparams->data,params->data,params->N*sizeof(float));
    185          	
    186          	return myparams;
    187          }
    188          */

   \                                 In section SOFTPACK, align 4, keep-with-next
    189          void t_run_test_radix2(struct TCDef *tcdef,void *in_params) {
   \                     t_run_test_radix2:
   \        0x0   0xE92D'4FF3        PUSH     {R0,R1,R4-R11,LR}
    190          	int i;
    191          	uint32_t test;
    192          	float min=EE_MININI,max=EE_MAXINI,avg=(0.0);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0xE24D'D004        SUB      SP,SP,#+4
    193          	radix2_params *params=(radix2_params *)in_params;
    194          	FFT_transform_internal(params->N, params->data, -1, params->twp);
   \        0xC   0xE3A0'6000        MOV      R6,#+0
   \       0x10   0xE3A0'9001        MOV      R9,#+1
   \       0x14   0xED2D'8B04        VPUSH    {D8-D9}
   \       0x18   0xE591'A008        LDR      R10,[R1, #+8]
   \       0x1C   0xEE09'0A10        VMOV     S18,R0
   \       0x20   0xE08A'0FAA        ADD      R0,R10,R10, LSR #+31
   \       0x24   0xE591'8004        LDR      R8,[R1, #+4]
   \       0x28   0xE1A0'70C0        ASR      R7,R0,#+1
   \       0x2C   0xE591'4000        LDR      R4,[R1, #+0]
   \       0x30   0xE1A0'5007        MOV      R5,R7
   \       0x34   0x....'....        VLDR     S16,??DataTable6  ;; 0x7e967699
   \       0x38   0xE355'0001        CMP      R5,#+1
   \       0x3C   0x....'....        VLDR     S17,??DataTable6_1  ;; 0xfe967699
   \       0x40   0x0A00'006C        BEQ      ??t_run_test_radix2_0
   \       0x44   0xE1A0'0005        MOV      R0,R5
   \       0x48   0x....'....        BL       int_log2
   \       0x4C   0xE35A'0000        CMP      R10,#+0
   \       0x50   0x0A00'0068        BEQ      ??t_run_test_radix2_0
   \       0x54   0xE247'E001        SUB      LR,R7,#+1
   \       0x58   0xE3A0'A000        MOV      R10,#+0
   \       0x5C   0xE35E'0000        CMP      LR,#+0
   \       0x60   0xE3A0'1000        MOV      R1,#+0
   \       0x64   0xDA00'001A        BLE      ??t_run_test_radix2_1
   \       0x68   0xE1A0'C004        MOV      R12,R4
   \                     ??t_run_test_radix2_2:
   \       0x6C   0xE15A'0001        CMP      R10,R1
   \       0x70   0xE1A0'2081        LSL      R2,R1,#+1
   \       0x74   0xE1A0'30C7        ASR      R3,R7,#+1
   \       0x78   0xAA00'000E        BGE      ??t_run_test_radix2_3
   \       0x7C   0xE794'B102        LDR      R11,[R4, +R2, LSL #+2]
   \       0x80   0xED9C'0A00        VLDR     S0,[R12, #0]
   \       0x84   0xEDDC'0A01        VLDR     S1,[R12, #+4]
   \       0x88   0xE58C'B000        STR      R11,[R12, #+0]
   \       0x8C   0xE284'B004        ADD      R11,R4,#+4
   \       0x90   0xE79B'B102        LDR      R11,[R11, +R2, LSL #+2]
   \       0x94   0xE58C'B004        STR      R11,[R12, #+4]
   \       0x98   0xE084'B102        ADD      R11,R4,R2, LSL #+2
   \       0x9C   0xED8B'0A00        VSTR     S0,[R11, #0]
   \       0xA0   0xE284'B004        ADD      R11,R4,#+4
   \       0xA4   0xE08B'2102        ADD      R2,R11,R2, LSL #+2
   \       0xA8   0xEDC2'0A00        VSTR     S1,[R2, #0]
   \       0xAC   0xEA00'0001        B        ??t_run_test_radix2_3
   \                     ??t_run_test_radix2_4:
   \       0xB0   0xE041'1003        SUB      R1,R1,R3
   \       0xB4   0xE1A0'30C3        ASR      R3,R3,#+1
   \                     ??t_run_test_radix2_3:
   \       0xB8   0xE151'0003        CMP      R1,R3
   \       0xBC   0xAAFF'FFFB        BGE      ??t_run_test_radix2_4
   \       0xC0   0xE28A'A001        ADD      R10,R10,#+1
   \       0xC4   0xE083'1001        ADD      R1,R3,R1
   \       0xC8   0xE15A'000E        CMP      R10,LR
   \       0xCC   0xE28C'C008        ADD      R12,R12,#+8
   \       0xD0   0xBAFF'FFE5        BLT      ??t_run_test_radix2_2
   \                     ??t_run_test_radix2_1:
   \       0xD4   0xE156'0000        CMP      R6,R0
   \       0xD8   0xAA00'0046        BGE      ??t_run_test_radix2_0
   \       0xDC   0xE3A0'2000        MOV      R2,#+0
   \       0xE0   0xE084'3189        ADD      R3,R4,R9, LSL #+3
   \       0xE4   0xE1A0'C004        MOV      R12,R4
   \       0xE8   0xEA00'0010        B        ??t_run_test_radix2_5
   \                     ??t_run_test_radix2_6:
   \       0xEC   0xED93'0A00        VLDR     S0,[R3, #0]
   \       0xF0   0xED9C'1A00        VLDR     S2,[R12, #0]
   \       0xF4   0xEE31'1A40        VSUB.F32 S2,S2,S0
   \       0xF8   0xEDD3'0A01        VLDR     S1,[R3, #+4]
   \       0xFC   0xE082'2089        ADD      R2,R2,R9, LSL #+1
   \      0x100   0xED83'1A00        VSTR     S2,[R3, #0]
   \      0x104   0xEDDC'1A01        VLDR     S3,[R12, #+4]
   \      0x108   0xEE71'1AE0        VSUB.F32 S3,S3,S1
   \      0x10C   0xEDC3'1A01        VSTR     S3,[R3, #+4]
   \      0x110   0xED9C'2A00        VLDR     S4,[R12, #0]
   \      0x114   0xEE32'0A00        VADD.F32 S0,S4,S0
   \      0x118   0xE083'3209        ADD      R3,R3,R9, LSL #+4
   \      0x11C   0xED8C'0A00        VSTR     S0,[R12, #0]
   \      0x120   0xED9C'1A01        VLDR     S2,[R12, #+4]
   \      0x124   0xEE71'0A20        VADD.F32 S1,S2,S1
   \      0x128   0xEDCC'0A01        VSTR     S1,[R12, #+4]
   \      0x12C   0xE08C'C209        ADD      R12,R12,R9, LSL #+4
   \                     ??t_run_test_radix2_5:
   \      0x130   0xE152'0005        CMP      R2,R5
   \      0x134   0xBAFF'FFEC        BLT      ??t_run_test_radix2_6
   \      0x138   0xE359'0001        CMP      R9,#+1
   \      0x13C   0xDA00'002A        BLE      ??t_run_test_radix2_7
   \      0x140   0xE289'7001        ADD      R7,R9,#+1
   \      0x144   0xE284'E008        ADD      LR,R4,#+8
   \      0x148   0xE249'C001        SUB      R12,R9,#+1
   \                     ??t_run_test_radix2_8:
   \      0x14C   0xED98'0A00        VLDR     S0,[R8, #0]
   \      0x150   0xEDD8'0A01        VLDR     S1,[R8, #+4]
   \      0x154   0xE288'8008        ADD      R8,R8,#+8
   \      0x158   0xE3A0'3000        MOV      R3,#+0
   \      0x15C   0xE1A0'200E        MOV      R2,LR
   \      0x160   0xEA00'001B        B        ??t_run_test_radix2_9
   \                     ??t_run_test_radix2_10:
   \      0x164   0xE083'A007        ADD      R10,R3,R7
   \      0x168   0xE083'3089        ADD      R3,R3,R9, LSL #+1
   \      0x16C   0xE1A0'A08A        LSL      R10,R10,#+1
   \      0x170   0xE084'B10A        ADD      R11,R4,R10, LSL #+2
   \      0x174   0xED9B'1A00        VLDR     S2,[R11, #0]
   \      0x178   0xEE20'2A01        VMUL.F32 S4,S0,S2
   \      0x17C   0xE284'B004        ADD      R11,R4,#+4
   \      0x180   0xE08B'B10A        ADD      R11,R11,R10, LSL #+2
   \      0x184   0xEDDB'1A00        VLDR     S3,[R11, #0]
   \      0x188   0xE084'B10A        ADD      R11,R4,R10, LSL #+2
   \      0x18C   0xEE00'2AE1        VMLS.F32 S4,S1,S3
   \      0x190   0xEE60'1A21        VMUL.F32 S3,S0,S3
   \      0x194   0xEE40'1A81        VMLA.F32 S3,S1,S2
   \      0x198   0xED92'1A00        VLDR     S2,[R2, #0]
   \      0x19C   0xEE31'1A42        VSUB.F32 S2,S2,S4
   \      0x1A0   0xED8B'1A00        VSTR     S2,[R11, #0]
   \      0x1A4   0xEDD2'2A01        VLDR     S5,[R2, #+4]
   \      0x1A8   0xEE72'2AE1        VSUB.F32 S5,S5,S3
   \      0x1AC   0xE284'B004        ADD      R11,R4,#+4
   \      0x1B0   0xE08B'A10A        ADD      R10,R11,R10, LSL #+2
   \      0x1B4   0xEDCA'2A00        VSTR     S5,[R10, #0]
   \      0x1B8   0xED92'1A00        VLDR     S2,[R2, #0]
   \      0x1BC   0xEE31'1A02        VADD.F32 S2,S2,S4
   \      0x1C0   0xED82'1A00        VSTR     S2,[R2, #0]
   \      0x1C4   0xED92'2A01        VLDR     S4,[R2, #+4]
   \      0x1C8   0xEE72'1A21        VADD.F32 S3,S4,S3
   \      0x1CC   0xEDC2'1A01        VSTR     S3,[R2, #+4]
   \      0x1D0   0xE082'2209        ADD      R2,R2,R9, LSL #+4
   \                     ??t_run_test_radix2_9:
   \      0x1D4   0xE153'0005        CMP      R3,R5
   \      0x1D8   0xBAFF'FFE1        BLT      ??t_run_test_radix2_10
   \      0x1DC   0xE25C'C001        SUBS     R12,R12,#+1
   \      0x1E0   0xE28E'E008        ADD      LR,LR,#+8
   \      0x1E4   0xE287'7001        ADD      R7,R7,#+1
   \      0x1E8   0x1AFF'FFD7        BNE      ??t_run_test_radix2_8
   \                     ??t_run_test_radix2_7:
   \      0x1EC   0xE286'6001        ADD      R6,R6,#+1
   \      0x1F0   0xE1A0'9089        LSL      R9,R9,#+1
   \      0x1F4   0xEAFF'FFB6        B        ??t_run_test_radix2_1
    195          	for (i=0; i<params->N ; i++) {
   \                     ??t_run_test_radix2_0:
   \      0x1F8   0xE59D'4018        LDR      R4,[SP, #+24]
   \      0x1FC   0xE3A0'0000        MOV      R0,#+0
   \      0x200   0xEA00'000A        B        ??t_run_test_radix2_11
    196          		min=(min>params->data[i])?params->data[i]:min;
   \                     ??t_run_test_radix2_12:
   \      0x204   0xE594'2000        LDR      R2,[R4, #+0]
   \      0x208   0xE082'3100        ADD      R3,R2,R0, LSL #+2
    197          		max=(max<params->data[i])?params->data[i]:max;
    198          		avg+=params->data[i];
    199          	}
   \      0x20C   0xE280'0001        ADD      R0,R0,#+1
   \      0x210   0xED93'0A00        VLDR     S0,[R3, #0]
   \      0x214   0xEEB4'0A48        VCMP.F32 S0,S16
   \      0x218   0xEEF1'FA10        FMSTAT
   \      0x21C   0x4EB0'8A40        VMOVMI.F32 S16,S0
   \      0x220   0xEEF4'8A40        VCMP.F32 S17,S0
   \      0x224   0xEEF1'FA10        FMSTAT
   \      0x228   0x4EF0'8A40        VMOVMI.F32 S17,S0
   \      0x22C   0xEE39'9A00        VADD.F32 S18,S18,S0
   \                     ??t_run_test_radix2_11:
   \      0x230   0xE594'1008        LDR      R1,[R4, #+8]
   \      0x234   0xE150'0001        CMP      R0,R1
   \      0x238   0x3AFF'FFF1        BCC      ??t_run_test_radix2_12
    200          	avg/=params->N;
   \      0x23C   0xEE00'1A10        VMOV     S0,R1
   \      0x240   0xEEB8'0A40        VCVT.F32.U32 S0,S0
   \      0x244   0xEE89'9A00        VDIV.F32 S18,S18,S0
    201          	
    202          	test=fp_iaccurate_bits_sp(avg,&params->ref_avg);
   \      0x248   0xE284'002C        ADD      R0,R4,#+44
   \      0x24C   0xEEB0'0A49        VMOV.F32 S0,S18
   \      0x250   0x....'....        BL       fp_iaccurate_bits_sp
    203          	if (test>=params->minbits)
   \      0x254   0xE594'2038        LDR      R2,[R4, #+56]
   \      0x258   0xE59D'1014        LDR      R1,[SP, #+20]
   \      0x25C   0xE150'0002        CMP      R0,R2
    204          		tcdef->CRC=0;
   \      0x260   0x23A0'3000        MOVCS    R3,#+0
    205          	else 
    206          		tcdef->CRC=1;
   \      0x264   0x33A0'C001        MOVCC    R12,#+1
   \      0x268   0x21C1'30B0        STRHCS   R3,[R1, #+0]
   \      0x26C   0x31C1'C0B0        STRHCC   R12,[R1, #+0]
    207          		
    208          	tcdef->v1=test;
   \      0x270   0xE581'0014        STR      R0,[R1, #+20]
    209          	tcdef->dbl_data[0]=avg;
   \      0x274   0xED81'9A01        VSTR     S18,[R1, #+4]
    210          	tcdef->dbl_data[1]=min;
   \      0x278   0xED81'8A02        VSTR     S16,[R1, #+8]
    211          	tcdef->dbl_data[2]=max;
   \      0x27C   0xEDC1'8A03        VSTR     S17,[R1, #+12]
    212          	
    213          }
   \      0x280   0xECBD'8B04        VPOP     {D8-D9}
   \      0x284   0xE28D'D00C        ADD      SP,SP,#+12
   \      0x288   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    214          
    215          

   \                                 In section SOFTPACK, align 4, keep-with-next
    216          int bmark_clean_radix2(void *in_params) {
   \                     bmark_clean_radix2:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    217          	radix2_params *params=(radix2_params *)in_params;
    218          	if (params) {
   \        0x8   0x0A00'0009        BEQ      ??bmark_clean_radix2_0
    219          		if (params->data)
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x0A00'0000        BEQ      ??bmark_clean_radix2_1
    220          			free(params->data);
   \       0x18   0x....'....        BL       free
    221          		if (params->twp)
   \                     ??bmark_clean_radix2_1:
   \       0x1C   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x0A00'0000        BEQ      ??bmark_clean_radix2_2
    222          			free(params->twp);
   \       0x28   0x....'....        BL       free
    223          		free(params);
   \                     ??bmark_clean_radix2_2:
   \       0x2C   0xE1A0'0004        MOV      R0,R4
   \       0x30   0x....'....        BL       free
    224          	}
    225          	return 1;
   \                     ??bmark_clean_radix2_0:
   \       0x34   0xE3A0'0001        MOV      R0,#+1
   \       0x38   0xE8BD'8010        POP      {R4,PC}          ;; return
    226          }
    227          

   \                                 In section SOFTPACK, align 4, keep-with-next
    228          void *bmark_fini_radix2(void *in_params) {
   \                     bmark_fini_radix2:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    229              radix2_params *params;
    230              if (in_params==NULL){
   \        0x8   0x1A00'0004        BNE      ??bmark_fini_radix2_0
    231          		printf( "Invalid pointer %s:%d", __FILE__,__LINE__ );
   \        0xC   0xE3A0'20E7        MOV      R2,#+231
   \       0x10   0x....'....        LDR      R1,??DataTable6_3
   \       0x14   0x....'....        ADR      R0,?_3
   \       0x18   0x....'....        BL       printf
    232                          return NULL;
   \       0x1C   0xEA00'0005        B        ??bmark_fini_radix2_1
    233              }
    234          	params=(radix2_params *)in_params;
    235          
    236          	if (params->data)
   \                     ??bmark_fini_radix2_0:
   \       0x20   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x24   0xE350'0000        CMP      R0,#+0
   \       0x28   0x0A00'0000        BEQ      ??bmark_fini_radix2_2
    237          		free(params->data);
   \       0x2C   0x....'....        BL       free
    238          	free(params);
   \                     ??bmark_fini_radix2_2:
   \       0x30   0xE1A0'0004        MOV      R0,R4
   \       0x34   0x....'....        BL       free
    239          
    240          	return NULL;
   \                     ??bmark_fini_radix2_1:
   \       0x38   0xE3A0'0000        MOV      R0,#+0
   \       0x3C   0xE8BD'8010        POP      {R4,PC}          ;; return
    241          }
    242          
    243          #if BMDEBUG
    244          static void dump_data(int iter, int N, float * data)
    245          {
    246             int i;
    247             for (i=0;i<N;i++)
    248                printf("\t%d, %d, %1.18le\n", iter, i, data[i]);
    249          }
    250          #endif
    251          

   \                                 In section SOFTPACK, align 4, keep-with-next
    252          int th_print_fp(float value)
    253          {
   \                     th_print_fp:
   \        0x0   0xE92D'4000        PUSH     {LR}
   \        0x4   0xED2D'0A01        VPUSH    {S0}
   \        0x8   0xE24D'D020        SUB      SP,SP,#+32
    254          	intparts num;
    255          	int st = load_sp(&value,&num);
    256          	if (!st)
   \        0xC   0xE28D'1010        ADD      R1,SP,#+16
   \       0x10   0xE28D'0020        ADD      R0,SP,#+32
   \       0x14   0x....'....        BL       load_sp
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'000A        BEQ      ??th_print_fp_0
    257          		return 0;
    258          	printf("{%u,%d,0x%08x,0x%08x}/*%1.18e*/",num.sign,num.exp,num.mant_high32,num.mant_low32,value);
   \       0x20   0xE59D'2018        LDR      R2,[SP, #+24]
   \       0x24   0xE1DD'11D0        LDRSB    R1,[SP, #+16]
   \       0x28   0xED9D'0A08        VLDR     S0,[SP, #+32]
   \       0x2C   0xE58D'2000        STR      R2,[SP, #+0]
   \       0x30   0xE1DD'21F2        LDRSH    R2,[SP, #+18]
   \       0x34   0xE59D'3014        LDR      R3,[SP, #+20]
   \       0x38   0xEEB7'0AC0        VCVT.F64.F32 D0,S0
   \       0x3C   0xED8D'0B02        VSTR     D0,[SP, #+8]
   \       0x40   0x....'....        ADR      R0,?_4
   \       0x44   0x....'....        BL       printf
    259          	return 1;
   \       0x48   0xE3A0'0001        MOV      R0,#+1
   \                     ??th_print_fp_0:
   \       0x4C   0xE28D'D024        ADD      SP,SP,#+36
   \       0x50   0xE8BD'8000        POP      {PC}             ;; return
    260          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x5444'2D18        DC32     0x54442D18,0xC01921FB

   \              0xC019'21FB

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x7E96'7699        DC32     0x7e967699

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0xFE96'7699        DC32     0xfe967699

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     presets_radix2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x52          DC8 0x45, 0x52, 0x52, 0x4F, 0x52, 0x3A, 0x20, 0x46

   \              0x52 0x4F    

   \              0x52 0x3A    

   \              0x20 0x46
   \        0x8   0x46 0x54          DC8 0x46, 0x54, 0x20, 0x72, 0x61, 0x64, 0x69, 0x78

   \              0x20 0x72    

   \              0x61 0x64    

   \              0x69 0x78
   \       0x10   0x32 0x2C          DC8 0x32, 0x2C, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20

   \              0x20 0x44    

   \              0x61 0x74    

   \              0x61 0x20
   \       0x18   0x6C 0x65          DC8 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x69

   \              0x6E 0x67    

   \              0x74 0x68    

   \              0x20 0x69
   \       0x20   0x73 0x20          DC8 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20

   \              0x6E 0x6F    

   \              0x74 0x20    

   \              0x61 0x20
   \       0x28   0x70 0x6F          DC8 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66

   \              0x77 0x65    

   \              0x72 0x20    

   \              0x6F 0x66
   \       0x30   0x20 0x32          DC8 0x20, 0x32, 0x21, 0x20, 0x5B, 0x25, 0x64, 0x5D

   \              0x21 0x20    

   \              0x5B 0x25    

   \              0x64 0x5D
   \       0x38   0x0A 0x00          DC8 0x0A, 0
   \       0x3A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C

   \              0x65 0x78    

   \              0x61 0x6D    

   \              0x70 0x6C
   \       0x38   0x65 0x73          DC8 0x65, 0x73, 0x5C, 0x63, 0x6F, 0x72, 0x65, 0x6D

   \              0x5C 0x63    

   \              0x6F 0x72    

   \              0x65 0x6D
   \       0x40   0x61 0x72          DC8 0x61, 0x72, 0x6B, 0x5C, 0x63, 0x6F, 0x72, 0x65

   \              0x6B 0x5C    

   \              0x63 0x6F    

   \              0x72 0x65
   \       0x48   0x6D 0x61          DC8 0x6D, 0x61, 0x72, 0x6B, 0x5C, 0x66, 0x66, 0x74

   \              0x72 0x6B    

   \              0x5C 0x66    

   \              0x66 0x74
   \       0x50   0x5F 0x72          DC8 0x5F, 0x72, 0x61, 0x64, 0x69, 0x78, 0x32, 0x2E

   \              0x61 0x64    

   \              0x69 0x78    

   \              0x32 0x2E
   \       0x58   0x63 0x00          DC8 0x63, 0
   \       0x5A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x43 0x61          DC8 "Cannot Allocate Memory %s:%d"

   \              0x6E 0x6E    

   \              0x6F 0x74    

   \              0x20 0x41    

   \              0x6C 0x6C    

   \              0x6F 0x63    

   \              0x61 0x74    

   \              0x65 0x20    

   \              0x4D 0x65    

   \              0x6D 0x6F    

   \              0x72 0x79    

   \              0x20 0x25    

   \              0x73 0x3A    

   \              0x25 0x64    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x49 0x6E          DC8 "Invalid pointer %s:%d"

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x70 0x6F    

   \              0x69 0x6E    

   \              0x74 0x65    

   \              0x72 0x20    

   \              0x25 0x73    

   \              0x3A 0x25    

   \              0x64 0x00
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x7B 0x25          DC8 "{%u,%d,0x%08x,0x%08x}/*%1.18e*/"

   \              0x75 0x2C    

   \              0x25 0x64    

   \              0x2C 0x30    

   \              0x78 0x25    

   \              0x30 0x38    

   \              0x78 0x2C    

   \              0x30 0x78    

   \              0x25 0x30    

   \              0x38 0x78    

   \              0x7D 0x2F    

   \              0x2A 0x25    

   \              0x31 0x2E    

   \              0x31 0x38    

   \              0x65 0x2A    

   \              0x2F 0x00
    261          #if 0
    262          int bmark_verify_radix2(void *in_params) {
    263          	int i;
    264          	radix2_params *params=(radix2_params *)in_params;
    265          	if (params->gen_ref) {
    266          		float min=EE_MININI,max=EE_MAXINI,avg=(0.0);
    267          		char sbuf[256];
    268          		for (i=0; i<params->N; i++) {
    269          			printf("\t");
    270          			th_print_fp(params->data[i]);
    271          			if (i<params->N-1)
    272          				th_printf(",\n");
    273          			min=(min>params->data[i])?params->data[i]:min;
    274          			max=(max<params->data[i])?params->data[i]:max;
    275          			avg+=params->data[i];
    276          		}
    277          		//th_printf("}; //ref_data\n\n"); 
    278          		avg/=params->N;
    279          		printf("static intparts ref_avg=%s;\n",th_sprint_fp(avg,sbuf));
    280          		printf("static intparts ref_max=%s;\n",th_sprint_fp(max,sbuf));
    281          		printf("static intparts ref_min=%s;\n",th_sprint_fp(min,sbuf));
    282          		printf("void init_preset_index() {\n");
    283          		printf("presets_radix2[index].ref_data=(intparts *)ref_data_index;\npresets_radix2[index].N=%d;\n",params->N);
    284          		printf("presets_radix2[index].seed=%d;\n",params->seed);
    285          		printf("presets_radix2[index].ref_avg=ref_avg;\npresets_radix2[index].ref_max=ref_max;\npresets_radix2[index].ref_min=ref_min;\n}\n",params->ref_avg,params->ref_max,params->ref_min);
    286          		printf("/**** END DATASET ****/\n");
    287          	} else {
    288          		snr_result resa;
    289          		if (params->ref_data==NULL) {
    290          			th_printf("Cannot validate this dataset! Please generate reference data on reliable hardware and tools using -g!\n");
    291          			return -1;
    292          		}
    293          		resa.bmin_ok=params->minbits;
    294          		ee_ifpbits_buffer(params->data,params->ref_data,params->N,&resa);
    295          	
    296          		if (!resa.pass) return 0;
    297          	}
    298          	return 1;
    299          }
    300          
    301          #endif
    302          
    303          static void FFT_transform_internal (int N, float * data, int direction, float *twp) {
    304              int n = N/2;
    305              int bit = 0;
    306              int logn;
    307              int dual = 1;
    308          
    309              if (n == 1) return;         /* Identity operation! */
    310              logn = int_log2(n);
    311          
    312              if (N == 0) return;    
    313          
    314          #if BMDEBUG
    315              //dump_data(-1, N, data);
    316          #endif
    317              /* bit reverse the input data for decimation in time algorithm */
    318              FFT_bitreverse(N, data) ;
    319          
    320              /* apply fft recursion */
    321              /* this loop executed int_log2(N) times */
    322              for (bit = 0; bit < logn; bit++, dual *= 2) {
    323                int a;
    324                int b;
    325                float w_real;
    326                float w_imag;
    327          
    328                for (a=0, b = 0; b < n; b += 2 * dual) {
    329                  int i = 2*b ;
    330                  int j = 2*(b + dual);
    331          
    332                  float wd_real = data[j] ;
    333                  float wd_imag = data[j+1] ;
    334                    
    335                  data[j]   = data[i]   - wd_real;
    336                  data[j+1] = data[i+1] - wd_imag;
    337                  data[i]  += wd_real;
    338                  data[i+1]+= wd_imag;
    339                }
    340                
    341                /* a = 1 .. (dual-1) */
    342                for (a = 1; a < dual; a++) {
    343                  /* trignometric recurrence for w-> exp(i theta) w */
    344          	w_real=*twp++;
    345          	w_imag=*twp++;
    346          
    347                  for (b = 0; b < n; b += 2 * dual) {
    348                    int i = 2*(b + a);
    349                    int j = 2*(b + a + dual);
    350          
    351                    float z1_real = data[j];
    352                    float z1_imag = data[j+1];
    353                        
    354                    float wd_real = w_real * z1_real - w_imag * z1_imag;
    355                    float wd_imag = w_real * z1_imag + w_imag * z1_real;
    356          
    357                    data[j]   = data[i]   - wd_real;
    358                    data[j+1] = data[i+1] - wd_imag;
    359                    data[i]  += wd_real;
    360                    data[i+1]+= wd_imag;
    361                  }
    362                }
    363              }
    364          #if BMDEBUG
    365              dump_data(bit, N, data);
    366          #endif
    367          }
    368          
    369          
    370          static void FFT_bitreverse(int N, float * data) {
    371              /* This is the Goldrader bit-reversal algorithm */
    372              int n=N/2;
    373              int nm1 = n-1;
    374              int i=0; 
    375              int j=0;
    376              for (; i < nm1; i++) {
    377          
    378                /*int ii = 2*i; */
    379                int ii = i << 1;
    380          
    381                /*int jj = 2*j; */
    382                int jj = j << 1;
    383          
    384                /* int k = n / 2 ; */
    385                int k = n >> 1;
    386          
    387                if (i < j) {
    388                  float tmp_real    = data[ii];
    389                  float tmp_imag    = data[ii+1];
    390                  data[ii]   = data[jj];
    391                  data[ii+1] = data[jj+1];
    392                  data[jj]   = tmp_real;
    393                  data[jj+1] = tmp_imag; }
    394          
    395                while (k <= j) 
    396                {
    397                  /*j = j - k ; */
    398                  j -= k;
    399          
    400                  /*k = k / 2 ;  */
    401                  k >>= 1 ; 
    402                }
    403                j += k ;
    404              }
    405            }
    406          
    407          #if NEED_INVERSE
    408          static void FFT_inverse(int N, float * data)
    409          {
    410              int n = N/2;
    411              float norm = 0.0;
    412              int i=0;
    413          	float *twp=calculate_twiddles(N,+1);
    414              FFT_transform_internal(N, data, +1,twp);
    415          	th_free(twp);
    416          
    417              /* Normalize */
    418              norm=1.0/((float) n);
    419              for(i=0; i<N; i++)
    420                data[i] *= norm;
    421            
    422          }
    423          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   bmark_clean_radix2
         8   -> free
       8   bmark_fini_radix2
         8   -> free
         8   -> printf
      56   define_params_radix2
        56   -> calloc
        56   -> fromint_f32_vector
        56   -> init_preset_0
        56   -> int_log2
        56   -> malloc
        56   -> printf
        56   -> sinf
       8   int_log2
         8   -> printf
      64   t_run_test_radix2
        64   -> fp_iaccurate_bits_sp
        64   -> int_log2
      40   th_print_fp
        40   -> load_sp
        40   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       8  ?Subroutine0
      60  ?_0
      92  ?_1
      32  ?_2
      24  ?_3
      32  ?_4
      60  bmark_clean_radix2
      64  bmark_fini_radix2
     516  define_params_radix2
      64  int_log2
     396  presets_radix2
          intparts_zero
     652  t_run_test_radix2
      84  th_print_fp

 
   396 bytes in section .data
   184 bytes in section .rodata
 1'536 bytes in section SOFTPACK
 
 1'536 bytes of CODE  memory
   184 bytes of CONST memory
   396 bytes of DATA  memory

Errors: none
Warnings: none
