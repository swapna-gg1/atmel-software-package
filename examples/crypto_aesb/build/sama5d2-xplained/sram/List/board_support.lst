###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         22/Oct/2020  11:45:02
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWCDD7.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_AESB -D CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_SECURE_MATRIX -D
#        CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\build\sama5d2-xplained\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\build\sama5d2-xplained\sram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\crypto_aesb\build\sama5d2-xplained\sram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015-2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          #include "string.h"
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "trace.h"
     44          #include "intmath.h"
     45          
     46          #include "irq/irq.h"
     47          #ifdef CONFIG_HAVE_ISC
     48          #include "video/isc.h"
     49          #endif
     50          #include "peripherals/matrix.h"
     51          #include "gpio/pio.h"
     52          #include "peripherals/pmc.h"
     53          #include "sdmmc/sdmmc.h"
     54          #include "extram/smc.h"
     55          #include "peripherals/wdt.h"
     56          
     57          #include "extram/ddram.h"
     58          
     59          #include "arm/mmu_cp15.h"
     60          #include "mm/l1cache.h"
     61          #include "mm/l2cache_l2cc.h"
     62          
     63          #include "board_support.h"
     64          
     65          #ifdef CONFIG_HAVE_PMIC_ACT8945A
     66          #include "power/act8945a.h"
     67          #endif
     68          
     69          /*----------------------------------------------------------------------------
     70           *        Local constants
     71           *----------------------------------------------------------------------------*/
     72          

   \                                 In section SOFTPACK, align 4, keep-with-next
     73          static const struct _l2cc_config l2cc_cfg = {
   \                     l2cc_cfg:
   \        0x0   0x40 0xF8          DC8 64, 248, 219, 1

   \              0xDB 0x01
     74          	.instruct_prefetch = true,	// Instruction prefetch enable
     75          	.data_prefetch = true,	// Data prefetch enable
     76          	.double_linefill = true,
     77          	.incr_double_linefill = true,
     78          	/* Disable Write back (enables write through, Use this setting
     79          	   if DDR2 mem is not write-back) */
     80          	//cfg.no_write_back = true,
     81          	.force_write_alloc = L2CC_FWA_NO_ALLOCATE,
     82          	.offset = 31,
     83          	.prefetch_drop = true,
     84          	.standby_mode = true,
     85          	.dyn_clock_gating = true
     86          };
     87          

   \                                 In section .data, align 4
   \        0x0   0x....'....        DC32 ?_1
     88          static const char* board_name = BOARD_NAME;
     89          
     90          /*----------------------------------------------------------------------------
     91           *        Local variables
     92           *----------------------------------------------------------------------------*/
     93          

   \                                 In section .bss, align 16384
     94          ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     95          
     96          #ifdef CONFIG_HAVE_PMIC_ACT8945A
     97          static struct _act8945a act8945a = {
     98          	.bus = BOARD_ACT8945A_TWI_BUS,
     99          	.addr = BOARD_ACT8945A_TWI_ADDR,
    100          	.desc = {
    101          		.pin_chglev = BOARD_ACT8945A_PIN_CHGLEV,
    102          		.pin_irq = BOARD_ACT8945A_PIN_IRQ,
    103          		.pin_lbo = BOARD_ACT8945A_PIN_LBO
    104          	}
    105          };
    106          
    107          static bool act8945a_initialized = false;
    108          #endif /* CONFIG_HAVE_PMIC_ACT8945A */
    109          
    110          /*----------------------------------------------------------------------------
    111           *        Local functions
    112           *----------------------------------------------------------------------------*/
    113          
    114          static void board_cfg_matrix_default(void)
    115          {
    116          	matrix_set_default_config();
    117          }
    118          
    119          /*----------------------------------------------------------------------------
    120           *        Exported functions
    121           *----------------------------------------------------------------------------*/

   \                                 In section SOFTPACK, align 4, keep-with-next
    122          const char* get_board_name(void)
    123          {
    124          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable6
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    125          }
    126          

   \                                 In section SOFTPACK, align 4, keep-with-next
    127          void board_cfg_clocks(void)
    128          {
   \                     board_cfg_clocks:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
    129          	struct _pmc_plla_cfg plla_config = {
    130          		.count = 0x3f,
    131          	};
   \        0x4   0x....'....        LDR      R1,??DataTable6_1
   \        0x8   0xE891'100C        LDM      R1,{R2,R3,R12}
   \        0xC   0xE24D'D00C        SUB      SP,SP,#+12
    132          
    133          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
    134          	plla_config.mul = BOARD_PMC_PLLA_MUL;
   \       0x10   0xE3A0'E052        MOV      LR,#+82
   \       0x14   0xE1A0'000D        MOV      R0,SP
    135          	plla_config.div = BOARD_PMC_PLLA_DIV;
   \       0x18   0xE3A0'5001        MOV      R5,#+1
   \       0x1C   0xE880'100C        STM      R0,{R2,R3,R12}
   \       0x20   0xE58D'E000        STR      LR,[SP, #+0]
   \       0x24   0xE58D'5004        STR      R5,[SP, #+4]
    136          #else
    137          	switch (pmc_get_main_oscillator_freq()) {
    138          	case 24000000:
    139          		plla_config.mul = 40;
    140          		plla_config.div = 1;
    141          		break;
    142          	case 16000000:
    143          		plla_config.mul = 61;
    144          		plla_config.div = 1;
    145          		break;
    146          	case 12000000:
    147          		plla_config.mul = 82;
    148          		plla_config.div = 1;
    149          		break;
    150          	}
    151          #endif
    152          	pmc_switch_mck_to_slck();
   \       0x28   0x....'....        BL       pmc_switch_mck_to_slck
    153          	pmc_set_mck_h32mxdiv(true);
   \       0x2C   0xE3A0'0001        MOV      R0,#+1
   \       0x30   0x....'....        BL       pmc_set_mck_h32mxdiv
    154          	pmc_set_mck_plladiv2(true);
   \       0x34   0xE3A0'0001        MOV      R0,#+1
   \       0x38   0x....'....        BL       pmc_set_mck_plladiv2
    155          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0x....'....        BL       pmc_set_mck_prescaler
    156          	pmc_set_mck_divider(PMC_MCKR_MDIV_EQ_PCK);
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0x....'....        BL       pmc_set_mck_divider
    157          	pmc_disable_plla();
   \       0x4C   0x....'....        BL       pmc_disable_plla
    158          	pmc_select_external_osc(false);
   \       0x50   0xE3A0'0000        MOV      R0,#+0
   \       0x54   0x....'....        BL       pmc_select_external_osc
    159          	pmc_configure_plla(&plla_config);
   \       0x58   0xE1A0'000D        MOV      R0,SP
   \       0x5C   0x....'....        BL       pmc_configure_plla
    160          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV3);
   \       0x60   0xE3A0'0FC0        MOV      R0,#+768
   \       0x64   0x....'....        BL       pmc_set_mck_divider
    161          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0x....'....        BL       pmc_set_mck_prescaler
    162          	pmc_switch_mck_to_pll();
   \       0x70   0x....'....        BL       pmc_switch_mck_to_pll
    163          }
   \       0x74   0xE28D'D010        ADD      SP,SP,#+16
   \       0x78   0xE8BD'8020        POP      {R5,PC}          ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0, 0, 63

   \              0x0000'0000  

   \              0x0000'003F
    164          

   \                                 In section SOFTPACK, align 4, keep-with-next
    165          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    166          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'5001        MOV      R5,R1
   \       0x10   0xE1A0'6002        MOV      R6,R2
    167          	/* Disable Watchdog */
    168          	wdt_disable();
   \       0x14   0x....'....        BL       wdt_disable
    169          
    170          	/* Disable all PIO interrupts */
    171          	pio_reset_all_it();
   \       0x18   0x....'....        BL       pio_reset_all_it
    172          
    173          	/* Set the external oscillator frequency */
    174          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x1C   0xE3A0'08B7        MOV      R0,#+11993088
   \       0x20   0xE380'0D6C        ORR      R0,R0,#0x1B00
   \       0x24   0x....'....        BL       pmc_set_main_oscillator_freq
    175          
    176          	if (clocks) {
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_0
    177          		/* Configure system clocks */
    178          		board_cfg_clocks();
   \       0x30   0x....'....        BL       board_cfg_clocks
    179          	}
    180          
    181          	/* Setup default interrupt handlers */
    182          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0x34   0x....'....        BL       irq_initialize
    183          
    184          	/* Configure system timer */
    185          	board_cfg_timer();
   \       0x38   0x....'....        BL       board_cfg_timer
    186          
    187          	board_cfg_matrix_default();
   \       0x3C   0x....'....        BL       matrix_set_default_config
    188          
    189          	if (ddram) {
   \       0x40   0xE355'0000        CMP      R5,#+0
   \       0x44   0x0A00'0005        BEQ      ??board_cfg_lowlevel_1
    190          		/* Configure DDRAM */
    191          		board_cfg_ddram();
   \       0x48   0x....'....        BL       board_cfg_matrix_for_ddr
   \       0x4C   0xE3A0'1001        MOV      R1,#+1
   \       0x50   0xE1A0'000D        MOV      R0,SP
   \       0x54   0x....'....        BL       ddram_init_descriptor
   \       0x58   0xE1A0'000D        MOV      R0,SP
   \       0x5C   0x....'....        BL       ddram_configure
    192          	}
    193          
    194          	if (mmu) {
   \                     ??board_cfg_lowlevel_1:
   \       0x60   0xE356'0000        CMP      R6,#+0
   \       0x64   0x0A00'0000        BEQ      ??board_cfg_lowlevel_2
    195          		/* Setup MMU */
    196          		board_cfg_mmu();
   \       0x68   0x....'....        BL       board_cfg_mmu
    197          	}
    198          }
   \                     ??board_cfg_lowlevel_2:
   \       0x6C   0xE28D'D030        ADD      SP,SP,#+48
   \       0x70   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    199          

   \                                 In section SOFTPACK, align 4, keep-with-next
    200          void board_restore_pio_reset_state(void)
    201          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    202          	int i;
    203          
    204          	/* all pins, excluding JTAG and NTRST */
    205          	struct _pin pins[] = {
    206          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    207          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    208          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    209          		{ PIO_GROUP_D, 0xFFFFFFFF ^ PIN_JTAG, PIO_INPUT, PIO_PULLUP },
    210          	};
   \        0x8   0x....'....        LDR      R1,??DataTable6_2
   \        0xC   0xE1A0'000D        MOV      R0,SP
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    211          
    212          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1A0'000D        MOV      R0,SP
   \       0x20   0x....'....        BL       pio_configure
    213          	for (i = 0; i < ARRAY_SIZE(pins); i++)
    214          		pio_clear(&pins[i]);
   \       0x24   0xE1A0'000D        MOV      R0,SP
   \       0x28   0x....'....        BL       pio_clear
   \       0x2C   0xE28D'0010        ADD      R0,SP,#+16
   \       0x30   0x....'....        BL       pio_clear
   \       0x34   0xE28D'0020        ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       pio_clear
   \       0x3C   0xE28D'0030        ADD      R0,SP,#+48
   \       0x40   0x....'....        BL       pio_clear
    215          }
   \       0x44   0xE28D'D044        ADD      SP,SP,#+68
   \       0x48   0xE8BD'8000        POP      {PC}             ;; return
    216          

   \                                 In section SOFTPACK, align 4, keep-with-next
    217          void board_save_misc_power(void)
    218          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    219          	int i;
    220          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'04F8        MOV      R0,#-134217728
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0xE380'0B40        ORR      R0,R0,#0x10000
   \       0x10   0xE3A0'5003        MOV      R5,#+3
   \       0x14   0x....'....        BL       get_tc_id_from_addr
   \       0x18   0xE1A0'4000        MOV      R4,R0
    221          
    222          	/* disable USB clock */
    223          	pmc_disable_upll_clock();
   \       0x1C   0x....'....        BL       pmc_disable_upll_clock
    224          	pmc_disable_upll_bias();
   \       0x20   0x....'....        BL       pmc_disable_upll_bias
    225          
    226          	/* Disable audio clock */
    227          	pmc_disable_audio();
   \       0x24   0x....'....        BL       pmc_disable_audio
    228          
    229          	/* disable system clocks */
    230          #ifdef VARIANT_SRAM
    231          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x....'....        BL       pmc_disable_system_clock
    232          #endif
    233          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0x30   0xE3A0'0001        MOV      R0,#+1
   \       0x34   0x....'....        BL       pmc_disable_system_clock
    234          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x38   0xE3A0'0003        MOV      R0,#+3
   \       0x3C   0x....'....        BL       pmc_disable_system_clock
    235          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UDP);
   \       0x40   0xE3A0'0004        MOV      R0,#+4
   \       0x44   0x....'....        BL       pmc_disable_system_clock
    236          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x48   0xE3A0'0005        MOV      R0,#+5
   \       0x4C   0x....'....        BL       pmc_disable_system_clock
    237          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x50   0xE3A0'0006        MOV      R0,#+6
   \       0x54   0x....'....        BL       pmc_disable_system_clock
    238          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK2);
   \       0x58   0xE3A0'0007        MOV      R0,#+7
   \       0x5C   0x....'....        BL       pmc_disable_system_clock
    239          #ifdef CONFIG_HAVE_ISC
    240          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_ISC);
    241          #endif
    242          
    243          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    244          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x60   0xEA00'0001        B        ??board_save_misc_power_0
    245          		if (i == ID_PIOA)
   \                     ??board_save_misc_power_1:
   \       0x64   0xE355'0012        CMP      R5,#+18
   \       0x68   0x0A00'0003        BEQ      ??board_save_misc_power_2
    246          			continue;
    247          		if (i == tc_id)
   \                     ??board_save_misc_power_0:
   \       0x6C   0xE155'0004        CMP      R5,R4
   \       0x70   0x0A00'0001        BEQ      ??board_save_misc_power_2
    248          			continue;
    249          #ifdef VARIANT_DDRAM
    250          		if (i == ID_MPDDRC)
    251          			continue;
    252          		if (i == ID_SFRBU)
    253          			continue;
    254          #endif
    255          		pmc_disable_peripheral(i);
   \       0x74   0xE1A0'0005        MOV      R0,R5
   \       0x78   0x....'....        BL       pmc_disable_peripheral
    256          	}
   \                     ??board_save_misc_power_2:
   \       0x7C   0xE285'5001        ADD      R5,R5,#+1
   \       0x80   0xE355'004F        CMP      R5,#+79
   \       0x84   0xBAFF'FFF6        BLT      ??board_save_misc_power_1
    257          }
   \       0x88   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    258          

   \                                 In section SOFTPACK, align 4, keep-with-next
    259          void board_cfg_mmu(void)
    260          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
    261          	uint32_t addr;
    262          
    263          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'00E2        BNE      ??board_cfg_mmu_0
    264          		return;
    265          
    266          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    267          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    268          	   be verified for correct operation when write-back is enabled */
    269          
    270          	/* Reset table entries */
    271          	for (addr = 0; addr < 4096; addr++)
    272          		tlb[addr] = 0;
   \       0x10   0x....'....        LDR      R4,??DataTable6_3
   \       0x14   0xE3A0'1C40        MOV      R1,#+16384
   \       0x18   0xE1A0'0004        MOV      R0,R4
   \       0x1C   0x....'....        BL       __aeabi_memclr4
    273          
    274          	/* 0x00000000: ROM */
    275          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    276          	           | TTB_SECT_AP_READ_ONLY
    277          	           | TTB_SECT_DOMAIN(0xf)
    278          	           | TTB_SECT_EXEC
    279          	           | TTB_SECT_CACHEABLE_WB
    280          	           | TTB_TYPE_SECT;
   \       0x20   0xE308'09EE        MOVW     R0,#+35310
    281          
    282          	/* 0x00100000: NFC SRAM */
    283          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    284          	           | TTB_SECT_AP_FULL_ACCESS
    285          	           | TTB_SECT_DOMAIN(0xf)
    286          	           | TTB_SECT_EXEC
    287          	           | TTB_SECT_SHAREABLE_DEVICE
    288          	           | TTB_TYPE_SECT;
   \       0x24   0x....'....        LDR      R1,??DataTable6_4  ;; 0x100de6
    289          
    290          	/* 0x00200000: SRAM */
    291          	tlb[0x002] = TTB_SECT_ADDR(0x00200000)
    292          	           | TTB_SECT_AP_FULL_ACCESS
    293          	           | TTB_SECT_DOMAIN(0xf)
    294          	           | TTB_SECT_EXEC
    295          	           | TTB_SECT_CACHEABLE_WB
    296          	           | TTB_TYPE_SECT;
   \       0x28   0x....'....        LDR      R2,??DataTable6_5  ;; 0x200dee
   \       0x2C   0xE584'0000        STR      R0,[R4, #+0]
   \       0x30   0xE584'1004        STR      R1,[R4, #+4]
   \       0x34   0xE584'2008        STR      R2,[R4, #+8]
    297          
    298          #ifdef CONFIG_HAVE_UDPHS
    299          	/* 0x00300000: UDPHS (RAM) */
    300          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    301          	           | TTB_SECT_AP_FULL_ACCESS
    302          	           | TTB_SECT_DOMAIN(0xf)
    303          	           | TTB_SECT_EXEC_NEVER
    304          	           | TTB_SECT_SHAREABLE_DEVICE
    305          	           | TTB_TYPE_SECT;
    306          
    307          	/* 0x00400000: UHPHS (OHCI) */
    308          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    309          	           | TTB_SECT_AP_FULL_ACCESS
    310          	           | TTB_SECT_DOMAIN(0xf)
    311          	           | TTB_SECT_EXEC_NEVER
    312          	           | TTB_SECT_SHAREABLE_DEVICE
    313          	           | TTB_TYPE_SECT;
    314          
    315          	/* 0x00500000: UDPHS (EHCI) */
    316          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    317          	           | TTB_SECT_AP_FULL_ACCESS
    318          	           | TTB_SECT_DOMAIN(0xf)
    319          	           | TTB_SECT_EXEC_NEVER
    320          	           | TTB_SECT_SHAREABLE_DEVICE
    321          	           | TTB_TYPE_SECT;
    322          #endif /* CONFIG_HAVE_UDPHS */
    323          
    324          	/* 0x00600000: AXIMX */
    325          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    326          	           | TTB_SECT_AP_FULL_ACCESS
    327          	           | TTB_SECT_DOMAIN(0xf)
    328          	           | TTB_SECT_EXEC_NEVER
    329          	           | TTB_SECT_SHAREABLE_DEVICE
    330          	           | TTB_TYPE_SECT;
   \       0x38   0x....'....        LDR      R3,??DataTable6_6  ;; 0x600df6
    331          
    332          	/* 0x00700000: DAP */
    333          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    334          	           | TTB_SECT_AP_FULL_ACCESS
    335          	           | TTB_SECT_DOMAIN(0xf)
    336          	           | TTB_SECT_EXEC_NEVER
    337          	           | TTB_SECT_SHAREABLE_DEVICE
    338          	           | TTB_TYPE_SECT;
   \       0x3C   0xE383'0940        ORR      R0,R3,#0x100000
   \       0x40   0xE584'3018        STR      R3,[R4, #+24]
    339          #ifdef CONFIG_HAVE_PPP
    340          	/* 0x00800000: pPP */
    341          	tlb[0x008] = TTB_SECT_ADDR(0x00800000)
    342          	           | TTB_SECT_AP_FULL_ACCESS
    343          	           | TTB_SECT_DOMAIN(0xf)
    344          	           | TTB_SECT_EXEC_NEVER
    345          	           | TTB_SECT_SHAREABLE_DEVICE
    346          	           | TTB_TYPE_SECT;
    347          #endif
    348          #ifdef CONFIG_HAVE_L2CC
    349          	/* 0x00a00000: L2CC */
    350          	tlb[0x00a] = TTB_SECT_ADDR(0x00a00000)
    351          	           | TTB_SECT_AP_FULL_ACCESS
    352          	           | TTB_SECT_DOMAIN(0xf)
    353          	           | TTB_SECT_EXEC_NEVER
    354          	           | TTB_SECT_SHAREABLE_DEVICE
    355          	           | TTB_TYPE_SECT;
   \       0x44   0xE280'19C0        ADD      R1,R0,#+3145728
    356          	tlb[0x00b] = TTB_SECT_ADDR(0x00b00000)
    357          	           | TTB_SECT_AP_FULL_ACCESS
    358          	           | TTB_SECT_DOMAIN(0xf)
    359          	           | TTB_SECT_EXEC_NEVER
    360          	           | TTB_SECT_SHAREABLE_DEVICE
    361          	           | TTB_TYPE_SECT;
   \       0x48   0xE280'2840        ADD      R2,R0,#+4194304
   \       0x4C   0xE584'001C        STR      R0,[R4, #+28]
   \       0x50   0xE584'1028        STR      R1,[R4, #+40]
   \       0x54   0xE584'202C        STR      R2,[R4, #+44]
    362          #endif
    363          
    364          	/* 0x10000000: EBI Chip Select 0 */
    365          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x58   0xE3A0'1F40        MOV      R1,#+256
   \       0x5C   0xE284'2E40        ADD      R2,R4,#+1024
   \       0x60   0xE300'0DF2        MOVW     R0,#+3570
    366          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    367          	                  | TTB_SECT_AP_FULL_ACCESS
    368          	                  | TTB_SECT_DOMAIN(0xf)
    369          	                  | TTB_SECT_EXEC_NEVER
    370          	                  | TTB_SECT_STRONGLY_ORDERED
    371          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_1:
   \       0x64   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x68   0xE281'1001        ADD      R1,R1,#+1
   \       0x6C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \       0x70   0xE281'1001        ADD      R1,R1,#+1
   \       0x74   0xE482'3004        STR      R3,[R2], #+4
   \       0x78   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \       0x7C   0xE281'1001        ADD      R1,R1,#+1
   \       0x80   0xE482'C004        STR      R12,[R2], #+4
   \       0x84   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x88   0xE281'1001        ADD      R1,R1,#+1
   \       0x8C   0xE351'0F80        CMP      R1,#+512
   \       0x90   0xE482'E004        STR      LR,[R2], #+4
   \       0x94   0xE482'3004        STR      R3,[R2], #+4
   \       0x98   0x3AFF'FFF1        BCC      ??board_cfg_mmu_1
    372          
    373          	/* 0x20000000: DDR Chip Select */
    374          	/* (64MB cacheable, 448MB strongly ordered) */
    375          	for (addr = 0x200; addr < 0x240; addr++)
   \       0x9C   0xE3A0'2F80        MOV      R2,#+512
   \       0xA0   0xE284'3E80        ADD      R3,R4,#+2048
   \       0xA4   0xE240'1004        SUB      R1,R0,#+4
    376          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    377          	                  | TTB_SECT_AP_FULL_ACCESS
    378          	                  | TTB_SECT_DOMAIN(0xf)
    379          	                  | TTB_SECT_EXEC
    380          	                  | TTB_SECT_CACHEABLE_WB
    381          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_2:
   \       0xA8   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xAC   0xE282'2001        ADD      R2,R2,#+1
   \       0xB0   0xE181'EA02        ORR      LR,R1,R2, LSL #+20
   \       0xB4   0xE282'2001        ADD      R2,R2,#+1
   \       0xB8   0xE483'C004        STR      R12,[R3], #+4
   \       0xBC   0xE181'5A02        ORR      R5,R1,R2, LSL #+20
   \       0xC0   0xE282'2001        ADD      R2,R2,#+1
   \       0xC4   0xE483'E004        STR      LR,[R3], #+4
   \       0xC8   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xCC   0xE282'2001        ADD      R2,R2,#+1
   \       0xD0   0xE352'0F90        CMP      R2,#+576
   \       0xD4   0xE483'5004        STR      R5,[R3], #+4
   \       0xD8   0xE483'C004        STR      R12,[R3], #+4
   \       0xDC   0x3AFF'FFF1        BCC      ??board_cfg_mmu_2
    382          	for (addr = 0x240; addr < 0x400; addr++)
   \       0xE0   0xE3A0'3F90        MOV      R3,#+576
   \       0xE4   0xE284'CE90        ADD      R12,R4,#+2304
   \       0xE8   0xE3C0'2010        BIC      R2,R0,#0x10
    383          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    384          	                  | TTB_SECT_AP_FULL_ACCESS
    385          	                  | TTB_SECT_DOMAIN(0xf)
    386          	                  | TTB_SECT_EXEC
    387          	                  | TTB_SECT_STRONGLY_ORDERED
    388          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0xEC   0xE182'EA03        ORR      LR,R2,R3, LSL #+20
   \       0xF0   0xE283'3001        ADD      R3,R3,#+1
   \       0xF4   0xE182'5A03        ORR      R5,R2,R3, LSL #+20
   \       0xF8   0xE283'3001        ADD      R3,R3,#+1
   \       0xFC   0xE48C'E004        STR      LR,[R12], #+4
   \      0x100   0xE182'6A03        ORR      R6,R2,R3, LSL #+20
   \      0x104   0xE283'3001        ADD      R3,R3,#+1
   \      0x108   0xE48C'5004        STR      R5,[R12], #+4
   \      0x10C   0xE182'EA03        ORR      LR,R2,R3, LSL #+20
   \      0x110   0xE283'3001        ADD      R3,R3,#+1
   \      0x114   0xE353'0E40        CMP      R3,#+1024
   \      0x118   0xE48C'6004        STR      R6,[R12], #+4
   \      0x11C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x120   0x3AFF'FFF1        BCC      ??board_cfg_mmu_3
    389          
    390          	/* 0x40000000: DDR AESB Chip Select */
    391          	for (addr = 0x400; addr < 0x600; addr++)
   \      0x124   0xE3A0'3E40        MOV      R3,#+1024
   \      0x128   0xE284'CD40        ADD      R12,R4,#+4096
    392          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    393          	                  | TTB_SECT_AP_FULL_ACCESS
    394          	                  | TTB_SECT_DOMAIN(0xf)
    395          	                  | TTB_SECT_EXEC
    396          	                  | TTB_SECT_CACHEABLE_WB
    397          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_4:
   \      0x12C   0xE181'EA03        ORR      LR,R1,R3, LSL #+20
   \      0x130   0xE283'3001        ADD      R3,R3,#+1
   \      0x134   0xE181'5A03        ORR      R5,R1,R3, LSL #+20
   \      0x138   0xE283'3001        ADD      R3,R3,#+1
   \      0x13C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x140   0xE181'6A03        ORR      R6,R1,R3, LSL #+20
   \      0x144   0xE283'3001        ADD      R3,R3,#+1
   \      0x148   0xE48C'5004        STR      R5,[R12], #+4
   \      0x14C   0xE181'EA03        ORR      LR,R1,R3, LSL #+20
   \      0x150   0xE283'3001        ADD      R3,R3,#+1
   \      0x154   0xE353'0E60        CMP      R3,#+1536
   \      0x158   0xE48C'6004        STR      R6,[R12], #+4
   \      0x15C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x160   0x3AFF'FFF1        BCC      ??board_cfg_mmu_4
    398          
    399          	/* 0x60000000: EBI Chip Select 1 */
    400          	for (addr = 0x600; addr < 0x700; addr++)
   \      0x164   0xE3A0'1E60        MOV      R1,#+1536
   \      0x168   0xE284'3D60        ADD      R3,R4,#+6144
    401          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    402          	                  | TTB_SECT_AP_FULL_ACCESS
    403          	                  | TTB_SECT_DOMAIN(0xf)
    404          	                  | TTB_SECT_EXEC_NEVER
    405          	                  | TTB_SECT_STRONGLY_ORDERED
    406          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_5:
   \      0x16C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x170   0xE281'1001        ADD      R1,R1,#+1
   \      0x174   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x178   0xE281'1001        ADD      R1,R1,#+1
   \      0x17C   0xE483'C004        STR      R12,[R3], #+4
   \      0x180   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x184   0xE281'1001        ADD      R1,R1,#+1
   \      0x188   0xE483'E004        STR      LR,[R3], #+4
   \      0x18C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x190   0xE281'1001        ADD      R1,R1,#+1
   \      0x194   0xE351'0E70        CMP      R1,#+1792
   \      0x198   0xE483'5004        STR      R5,[R3], #+4
   \      0x19C   0xE483'C004        STR      R12,[R3], #+4
   \      0x1A0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_5
    407          
    408          	/* 0x70000000: EBI Chip Select 2 */
    409          	for (addr = 0x700; addr < 0x800; addr++)
   \      0x1A4   0xE3A0'1E70        MOV      R1,#+1792
   \      0x1A8   0xE284'3D70        ADD      R3,R4,#+7168
    410          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    411          	                  | TTB_SECT_AP_FULL_ACCESS
    412          	                  | TTB_SECT_DOMAIN(0xf)
    413          	                  | TTB_SECT_EXEC_NEVER
    414          	                  | TTB_SECT_STRONGLY_ORDERED
    415          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_6:
   \      0x1AC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1B0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1B4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x1B8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1BC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1C0   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x1C4   0xE281'1001        ADD      R1,R1,#+1
   \      0x1C8   0xE483'E004        STR      LR,[R3], #+4
   \      0x1CC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1D0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1D4   0xE351'0E80        CMP      R1,#+2048
   \      0x1D8   0xE483'5004        STR      R5,[R3], #+4
   \      0x1DC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1E0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_6
    416          
    417          	/* 0x80000000: EBI Chip Select 3 */
    418          	for (addr = 0x800; addr < 0x900; addr++)
   \      0x1E4   0xE3A0'1E80        MOV      R1,#+2048
   \      0x1E8   0xE284'3D80        ADD      R3,R4,#+8192
    419          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    420          	                  | TTB_SECT_AP_FULL_ACCESS
    421          	                  | TTB_SECT_DOMAIN(0xf)
    422          	                  | TTB_SECT_EXEC_NEVER
    423          	                  | TTB_SECT_STRONGLY_ORDERED
    424          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_7:
   \      0x1EC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1F0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1F4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x1F8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1FC   0xE483'C004        STR      R12,[R3], #+4
   \      0x200   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x204   0xE281'1001        ADD      R1,R1,#+1
   \      0x208   0xE483'E004        STR      LR,[R3], #+4
   \      0x20C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x210   0xE281'1001        ADD      R1,R1,#+1
   \      0x214   0xE351'0E90        CMP      R1,#+2304
   \      0x218   0xE483'5004        STR      R5,[R3], #+4
   \      0x21C   0xE483'C004        STR      R12,[R3], #+4
   \      0x220   0x3AFF'FFF1        BCC      ??board_cfg_mmu_7
    425          
    426          	/* 0x90000000: QSPI0/1 AESB MEM */
    427          	for (addr = 0x900; addr < 0xa00; addr++)
   \      0x224   0xE3A0'1E90        MOV      R1,#+2304
   \      0x228   0xE284'3D90        ADD      R3,R4,#+9216
    428          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    429          	                  | TTB_SECT_AP_FULL_ACCESS
    430          	                  | TTB_SECT_DOMAIN(0xf)
    431          	                  | TTB_SECT_EXEC
    432          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    433          	                  | TTB_SECT_CACHEABLE_WB
    434          #else
    435          	                  | TTB_SECT_STRONGLY_ORDERED
    436          #endif
    437          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_8:
   \      0x22C   0xE182'CA01        ORR      R12,R2,R1, LSL #+20
   \      0x230   0xE281'1001        ADD      R1,R1,#+1
   \      0x234   0xE182'EA01        ORR      LR,R2,R1, LSL #+20
   \      0x238   0xE281'1001        ADD      R1,R1,#+1
   \      0x23C   0xE483'C004        STR      R12,[R3], #+4
   \      0x240   0xE182'5A01        ORR      R5,R2,R1, LSL #+20
   \      0x244   0xE281'1001        ADD      R1,R1,#+1
   \      0x248   0xE483'E004        STR      LR,[R3], #+4
   \      0x24C   0xE182'CA01        ORR      R12,R2,R1, LSL #+20
   \      0x250   0xE281'1001        ADD      R1,R1,#+1
   \      0x254   0xE351'0EA0        CMP      R1,#+2560
   \      0x258   0xE483'5004        STR      R5,[R3], #+4
   \      0x25C   0xE483'C004        STR      R12,[R3], #+4
   \      0x260   0x3AFF'FFF1        BCC      ??board_cfg_mmu_8
    438          
    439          	/* 0xa0000000: SDMMC0 */
    440          	for (addr = 0xa00; addr < 0xb00; addr++)
   \      0x264   0xE3A0'1EA0        MOV      R1,#+2560
   \      0x268   0xE284'3DA0        ADD      R3,R4,#+10240
    441          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    442          	                  | TTB_SECT_AP_FULL_ACCESS
    443          	                  | TTB_SECT_DOMAIN(0xf)
    444          	                  | TTB_SECT_EXEC_NEVER
    445          	                  //| TTB_SECT_SHAREABLE_DEVICE
    446          	                  | TTB_SECT_STRONGLY_ORDERED
    447          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_9:
   \      0x26C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x270   0xE281'1001        ADD      R1,R1,#+1
   \      0x274   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x278   0xE281'1001        ADD      R1,R1,#+1
   \      0x27C   0xE483'C004        STR      R12,[R3], #+4
   \      0x280   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x284   0xE281'1001        ADD      R1,R1,#+1
   \      0x288   0xE483'E004        STR      LR,[R3], #+4
   \      0x28C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x290   0xE281'1001        ADD      R1,R1,#+1
   \      0x294   0xE351'0EB0        CMP      R1,#+2816
   \      0x298   0xE483'5004        STR      R5,[R3], #+4
   \      0x29C   0xE483'C004        STR      R12,[R3], #+4
   \      0x2A0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_9
    448          
    449          	/* 0xb0000000: SDMMC1 */
    450          	for (addr = 0xb00; addr < 0xc00; addr++)
   \      0x2A4   0xE3A0'1EB0        MOV      R1,#+2816
   \      0x2A8   0xE284'3DB0        ADD      R3,R4,#+11264
    451          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    452          	                  | TTB_SECT_AP_FULL_ACCESS
    453          	                  | TTB_SECT_DOMAIN(0xf)
    454          	                  | TTB_SECT_EXEC_NEVER
    455          	                  //| TTB_SECT_SHAREABLE_DEVICE
    456          	                  | TTB_SECT_STRONGLY_ORDERED
    457          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_10:
   \      0x2AC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2B0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2B4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x2B8   0xE281'1001        ADD      R1,R1,#+1
   \      0x2BC   0xE483'C004        STR      R12,[R3], #+4
   \      0x2C0   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x2C4   0xE281'1001        ADD      R1,R1,#+1
   \      0x2C8   0xE483'E004        STR      LR,[R3], #+4
   \      0x2CC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2D0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2D4   0xE351'0EC0        CMP      R1,#+3072
   \      0x2D8   0xE483'5004        STR      R5,[R3], #+4
   \      0x2DC   0xE483'C004        STR      R12,[R3], #+4
   \      0x2E0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_10
    458          
    459          	/* 0xc0000000: NFC Command Register */
    460          	for (addr = 0xc00; addr < 0xd00; addr++)
   \      0x2E4   0xE3A0'1EC0        MOV      R1,#+3072
   \      0x2E8   0xE284'3DC0        ADD      R3,R4,#+12288
    461          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    462          	                  | TTB_SECT_AP_FULL_ACCESS
    463          	                  | TTB_SECT_DOMAIN(0xf)
    464          	                  | TTB_SECT_EXEC_NEVER
    465          	                  //| TTB_SECT_SHAREABLE_DEVICE
    466          	                  | TTB_SECT_STRONGLY_ORDERED
    467          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_11:
   \      0x2EC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2F0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2F4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x2F8   0xE281'1001        ADD      R1,R1,#+1
   \      0x2FC   0xE483'C004        STR      R12,[R3], #+4
   \      0x300   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x304   0xE281'1001        ADD      R1,R1,#+1
   \      0x308   0xE483'E004        STR      LR,[R3], #+4
   \      0x30C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x310   0xE281'1001        ADD      R1,R1,#+1
   \      0x314   0xE351'0ED0        CMP      R1,#+3328
   \      0x318   0xE483'5004        STR      R5,[R3], #+4
   \      0x31C   0xE483'C004        STR      R12,[R3], #+4
   \      0x320   0x3AFF'FFF1        BCC      ??board_cfg_mmu_11
    468          
    469          	/* 0xd0000000: QSPI0/1 MEM */
    470          	for (addr = 0xd00; addr < 0xe00; addr++)
   \      0x324   0xE3A0'0ED0        MOV      R0,#+3328
   \      0x328   0xE284'1DD0        ADD      R1,R4,#+13312
    471          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    472          	                  | TTB_SECT_AP_FULL_ACCESS
    473          	                  | TTB_SECT_DOMAIN(0xf)
    474          	                  | TTB_SECT_EXEC
    475          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    476          	                  | TTB_SECT_CACHEABLE_WB
    477          #else
    478          	                  | TTB_SECT_STRONGLY_ORDERED
    479          #endif
    480          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_12:
   \      0x32C   0xE182'3A00        ORR      R3,R2,R0, LSL #+20
   \      0x330   0xE280'0001        ADD      R0,R0,#+1
   \      0x334   0xE182'CA00        ORR      R12,R2,R0, LSL #+20
   \      0x338   0xE280'0001        ADD      R0,R0,#+1
   \      0x33C   0xE481'3004        STR      R3,[R1], #+4
   \      0x340   0xE182'EA00        ORR      LR,R2,R0, LSL #+20
   \      0x344   0xE280'0001        ADD      R0,R0,#+1
   \      0x348   0xE481'C004        STR      R12,[R1], #+4
   \      0x34C   0xE182'3A00        ORR      R3,R2,R0, LSL #+20
   \      0x350   0xE280'0001        ADD      R0,R0,#+1
   \      0x354   0xE350'0EE0        CMP      R0,#+3584
   \      0x358   0xE481'E004        STR      LR,[R1], #+4
   \      0x35C   0xE481'3004        STR      R3,[R1], #+4
   \      0x360   0x3AFF'FFF1        BCC      ??board_cfg_mmu_12
    481          
    482          	/* 0xf0000000: Internal Peripherals */
    483          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    484          	           | TTB_SECT_AP_FULL_ACCESS
    485          	           | TTB_SECT_DOMAIN(0xf)
    486          	           | TTB_SECT_EXEC
    487          	           | TTB_SECT_STRONGLY_ORDERED
    488          	           | TTB_TYPE_SECT;
   \      0x364   0xE3A0'0DF0        MOV      R0,#+15360
   \      0x368   0xE382'14F0        ORR      R1,R2,#0xF0000000
   \      0x36C   0xE784'1000        STR      R1,[R4, +R0]
    489          
    490          	/* 0xf8000000: Internal Peripherals */
    491          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    492          	           | TTB_SECT_AP_FULL_ACCESS
    493          	           | TTB_SECT_DOMAIN(0xf)
    494          	           | TTB_SECT_EXEC
    495          	           | TTB_SECT_STRONGLY_ORDERED
    496          	           | TTB_TYPE_SECT;
   \      0x370   0xE084'0000        ADD      R0,R4,R0
   \      0x374   0xE381'2680        ORR      R2,R1,#0x8000000
    497          
    498          	/* 0xfc000000: Internal Peripherals */
    499          	tlb[0xfc0] = TTB_SECT_ADDR(0xfc000000)
    500          	           | TTB_SECT_AP_FULL_ACCESS
    501          	           | TTB_SECT_DOMAIN(0xf)
    502          	           | TTB_SECT_EXEC
    503          	           | TTB_SECT_STRONGLY_ORDERED
    504          	           | TTB_TYPE_SECT;
   \      0x378   0xE381'36C0        ORR      R3,R1,#0xC000000
   \      0x37C   0xE580'2200        STR      R2,[R0, #+512]
   \      0x380   0xE580'3300        STR      R3,[R0, #+768]
    505          
    506          	/* Enable MMU, I-Cache and D-Cache */
    507          	mmu_configure(tlb);
   \      0x384   0xE1A0'0004        MOV      R0,R4
   \      0x388   0x....'....        BL       mmu_configure
    508          	icache_enable();
   \      0x38C   0x....'....        BL       icache_enable
    509          	mmu_enable();
   \      0x390   0x....'....        BL       mmu_enable
    510          	dcache_enable();
   \      0x394   0xE8BD'4070        POP      {R4-R6,LR}
   \      0x398   0x....'....        B        dcache_enable    ;; tailcall
   \                     ??board_cfg_mmu_0:
   \      0x39C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    511          }
    512          

   \                                 In section SOFTPACK, align 4, keep-with-next
    513          void board_cfg_l2cc(void)
    514          {
    515          	l2cc_configure(&l2cc_cfg);
   \                     board_cfg_l2cc:
   \        0x0   0x....'....        ADR      R0,l2cc_cfg
   \        0x4   0x....'....        B        l2cc_configure   ;; tailcall
    516          }
    517          

   \                                 In section SOFTPACK, align 4, keep-with-next
    518          void board_cfg_matrix_for_ddr(void)
    519          {
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    520          	int i;
    521          
    522          	/* Disable write protection */
    523          	matrix_remove_write_protection(MATRIX0);
   \        0x4   0xE3A0'44F0        MOV      R4,#-268435456
   \        0x8   0xE384'4B60        ORR      R4,R4,#0x18000
   \        0xC   0xE1A0'0004        MOV      R0,R4
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    524          
    525          	/* External DDR */
    526          	/* DDR port 0 not used */
    527          	for (i = H64MX_SLAVE_DDR_PORT1; i <= H64MX_SLAVE_DDR_PORT7; i++) {
    528          		matrix_configure_slave_sec(MATRIX0, i, 0xff, 0xff, 0xff);
   \       0x14   0xE3A0'10FF        MOV      R1,#+255
   \       0x18   0xE3A0'30FF        MOV      R3,#+255
   \       0x1C   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x20   0xE3A0'20FF        MOV      R2,#+255
   \       0x24   0xE3A0'1003        MOV      R1,#+3
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    529          		matrix_set_slave_split_addr(MATRIX0, i, MATRIX_AREA_128M, 0xf);
   \       0x30   0xE3A0'300F        MOV      R3,#+15
   \       0x34   0xE3A0'200F        MOV      R2,#+15
   \       0x38   0xE3A0'1003        MOV      R1,#+3
   \       0x3C   0xE1A0'0004        MOV      R0,R4
   \       0x40   0x....'....        BL       matrix_set_slave_split_addr
    530          		matrix_set_slave_region_size(MATRIX0, i, MATRIX_AREA_128M, 0x1);
   \       0x44   0xE3A0'3001        MOV      R3,#+1
   \       0x48   0xE3A0'200F        MOV      R2,#+15
   \       0x4C   0xE3A0'1003        MOV      R1,#+3
   \       0x50   0xE1A0'0004        MOV      R0,R4
   \       0x54   0x....'....        BL       matrix_set_slave_region_size
   \       0x58   0xE3A0'00FF        MOV      R0,#+255
   \       0x5C   0xE3A0'30FF        MOV      R3,#+255
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x64   0xE3A0'20FF        MOV      R2,#+255
   \       0x68   0xE3A0'1004        MOV      R1,#+4
   \       0x6C   0xE1A0'0004        MOV      R0,R4
   \       0x70   0x....'....        BL       matrix_configure_slave_sec
   \       0x74   0xE3A0'300F        MOV      R3,#+15
   \       0x78   0xE3A0'200F        MOV      R2,#+15
   \       0x7C   0xE3A0'1004        MOV      R1,#+4
   \       0x80   0xE1A0'0004        MOV      R0,R4
   \       0x84   0x....'....        BL       matrix_set_slave_split_addr
   \       0x88   0xE3A0'3001        MOV      R3,#+1
   \       0x8C   0xE3A0'200F        MOV      R2,#+15
   \       0x90   0xE3A0'1004        MOV      R1,#+4
   \       0x94   0xE1A0'0004        MOV      R0,R4
   \       0x98   0x....'....        BL       matrix_set_slave_region_size
   \       0x9C   0xE3A0'00FF        MOV      R0,#+255
   \       0xA0   0xE3A0'30FF        MOV      R3,#+255
   \       0xA4   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xA8   0xE3A0'20FF        MOV      R2,#+255
   \       0xAC   0xE3A0'1005        MOV      R1,#+5
   \       0xB0   0xE1A0'0004        MOV      R0,R4
   \       0xB4   0x....'....        BL       matrix_configure_slave_sec
   \       0xB8   0xE3A0'300F        MOV      R3,#+15
   \       0xBC   0xE3A0'200F        MOV      R2,#+15
   \       0xC0   0xE3A0'1005        MOV      R1,#+5
   \       0xC4   0xE1A0'0004        MOV      R0,R4
   \       0xC8   0x....'....        BL       matrix_set_slave_split_addr
   \       0xCC   0xE3A0'3001        MOV      R3,#+1
   \       0xD0   0xE3A0'200F        MOV      R2,#+15
   \       0xD4   0xE3A0'1005        MOV      R1,#+5
   \       0xD8   0xE1A0'0004        MOV      R0,R4
   \       0xDC   0x....'....        BL       matrix_set_slave_region_size
   \       0xE0   0xE3A0'00FF        MOV      R0,#+255
   \       0xE4   0xE3A0'30FF        MOV      R3,#+255
   \       0xE8   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xEC   0xE3A0'20FF        MOV      R2,#+255
   \       0xF0   0xE3A0'1006        MOV      R1,#+6
   \       0xF4   0xE1A0'0004        MOV      R0,R4
   \       0xF8   0x....'....        BL       matrix_configure_slave_sec
   \       0xFC   0xE3A0'300F        MOV      R3,#+15
   \      0x100   0xE3A0'200F        MOV      R2,#+15
   \      0x104   0xE3A0'1006        MOV      R1,#+6
   \      0x108   0xE1A0'0004        MOV      R0,R4
   \      0x10C   0x....'....        BL       matrix_set_slave_split_addr
   \      0x110   0xE3A0'3001        MOV      R3,#+1
   \      0x114   0xE3A0'200F        MOV      R2,#+15
   \      0x118   0xE3A0'1006        MOV      R1,#+6
   \      0x11C   0xE1A0'0004        MOV      R0,R4
   \      0x120   0x....'....        BL       matrix_set_slave_region_size
   \      0x124   0xE3A0'00FF        MOV      R0,#+255
   \      0x128   0xE3A0'30FF        MOV      R3,#+255
   \      0x12C   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x130   0xE3A0'20FF        MOV      R2,#+255
   \      0x134   0xE3A0'1007        MOV      R1,#+7
   \      0x138   0xE1A0'0004        MOV      R0,R4
   \      0x13C   0x....'....        BL       matrix_configure_slave_sec
   \      0x140   0xE3A0'300F        MOV      R3,#+15
   \      0x144   0xE3A0'200F        MOV      R2,#+15
   \      0x148   0xE3A0'1007        MOV      R1,#+7
   \      0x14C   0xE1A0'0004        MOV      R0,R4
   \      0x150   0x....'....        BL       matrix_set_slave_split_addr
   \      0x154   0xE3A0'3001        MOV      R3,#+1
   \      0x158   0xE3A0'200F        MOV      R2,#+15
   \      0x15C   0xE3A0'1007        MOV      R1,#+7
   \      0x160   0xE1A0'0004        MOV      R0,R4
   \      0x164   0x....'....        BL       matrix_set_slave_region_size
   \      0x168   0xE3A0'00FF        MOV      R0,#+255
   \      0x16C   0xE3A0'30FF        MOV      R3,#+255
   \      0x170   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x174   0xE3A0'20FF        MOV      R2,#+255
   \      0x178   0xE3A0'1008        MOV      R1,#+8
   \      0x17C   0xE1A0'0004        MOV      R0,R4
   \      0x180   0x....'....        BL       matrix_configure_slave_sec
   \      0x184   0xE3A0'300F        MOV      R3,#+15
   \      0x188   0xE3A0'200F        MOV      R2,#+15
   \      0x18C   0xE3A0'1008        MOV      R1,#+8
   \      0x190   0xE1A0'0004        MOV      R0,R4
   \      0x194   0x....'....        BL       matrix_set_slave_split_addr
   \      0x198   0xE3A0'3001        MOV      R3,#+1
   \      0x19C   0xE3A0'200F        MOV      R2,#+15
   \      0x1A0   0xE3A0'1008        MOV      R1,#+8
   \      0x1A4   0xE1A0'0004        MOV      R0,R4
   \      0x1A8   0x....'....        BL       matrix_set_slave_region_size
   \      0x1AC   0xE3A0'00FF        MOV      R0,#+255
   \      0x1B0   0xE3A0'30FF        MOV      R3,#+255
   \      0x1B4   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x1B8   0xE3A0'20FF        MOV      R2,#+255
   \      0x1BC   0xE3A0'1009        MOV      R1,#+9
   \      0x1C0   0xE1A0'0004        MOV      R0,R4
   \      0x1C4   0x....'....        BL       matrix_configure_slave_sec
   \      0x1C8   0xE3A0'300F        MOV      R3,#+15
   \      0x1CC   0xE3A0'200F        MOV      R2,#+15
   \      0x1D0   0xE3A0'1009        MOV      R1,#+9
   \      0x1D4   0xE1A0'0004        MOV      R0,R4
   \      0x1D8   0x....'....        BL       matrix_set_slave_split_addr
   \      0x1DC   0xE1A0'0004        MOV      R0,R4
   \      0x1E0   0xE28D'D008        ADD      SP,SP,#+8
   \      0x1E4   0xE8BD'4010        POP      {R4,LR}
   \      0x1E8   0xE3A0'3001        MOV      R3,#+1
   \      0x1EC   0xE3A0'200F        MOV      R2,#+15
   \      0x1F0   0xE3A0'1009        MOV      R1,#+9
   \      0x1F4   0x....'....        B        matrix_set_slave_region_size  ;; tailcall
    531          	}
    532          }
    533          

   \                                 In section SOFTPACK, align 4, keep-with-next
    534          void board_cfg_matrix_for_nand(void)
    535          {
   \                     board_cfg_matrix_for_nand:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    536          	/* Disable write protection */
    537          	matrix_remove_write_protection(MATRIX1);
   \        0x4   0xE3A0'44FC        MOV      R4,#-67108864
   \        0x8   0xE384'4BF0        ORR      R4,R4,#0x3C000
   \        0xC   0xE1A0'0004        MOV      R0,R4
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    538          
    539          	/* NFC Command Register */
    540          	matrix_configure_slave_sec(MATRIX1,
    541          			H32MX_SLAVE_NFC_CMD, 0xc0, 0xc0, 0xc0);
   \       0x14   0xE3A0'10C0        MOV      R1,#+192
   \       0x18   0xE3A0'30C0        MOV      R3,#+192
   \       0x1C   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x20   0xE3A0'20C0        MOV      R2,#+192
   \       0x24   0xE3A0'1003        MOV      R1,#+3
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    542          	matrix_set_slave_split_addr(MATRIX1,
    543          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x30   0xE3A0'30C0        MOV      R3,#+192
   \       0x34   0xE3A0'200F        MOV      R2,#+15
   \       0x38   0xE3A0'1003        MOV      R1,#+3
   \       0x3C   0xE1A0'0004        MOV      R0,R4
   \       0x40   0x....'....        BL       matrix_set_slave_split_addr
    544          	matrix_set_slave_region_size(MATRIX1,
    545          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x44   0xE3A0'30C0        MOV      R3,#+192
   \       0x48   0xE3A0'200F        MOV      R2,#+15
   \       0x4C   0xE3A0'1003        MOV      R1,#+3
   \       0x50   0xE1A0'0004        MOV      R0,R4
   \       0x54   0x....'....        BL       matrix_set_slave_region_size
    546          
    547          	/* NFC SRAM */
    548          	matrix_configure_slave_sec(MATRIX1,
    549          			H32MX_SLAVE_NFC_SRAM, 0x1, 0x1, 0x1);
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xE3A0'3001        MOV      R3,#+1
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x64   0xE3A0'2001        MOV      R2,#+1
   \       0x68   0xE3A0'1004        MOV      R1,#+4
   \       0x6C   0xE1A0'0004        MOV      R0,R4
   \       0x70   0x....'....        BL       matrix_configure_slave_sec
    550          	matrix_set_slave_split_addr(MATRIX1,
    551          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x74   0xE3A0'3001        MOV      R3,#+1
   \       0x78   0xE3A0'2001        MOV      R2,#+1
   \       0x7C   0xE3A0'1004        MOV      R1,#+4
   \       0x80   0xE1A0'0004        MOV      R0,R4
   \       0x84   0x....'....        BL       matrix_set_slave_split_addr
    552          	matrix_set_slave_region_size(MATRIX1,
    553          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x88   0xE1A0'0004        MOV      R0,R4
   \       0x8C   0xE28D'D008        ADD      SP,SP,#+8
   \       0x90   0xE8BD'4010        POP      {R4,LR}
   \       0x94   0xE3A0'3001        MOV      R3,#+1
   \       0x98   0xE3A0'2001        MOV      R2,#+1
   \       0x9C   0xE3A0'1004        MOV      R1,#+4
   \       0xA0   0x....'....        B        matrix_set_slave_region_size  ;; tailcall
    554          }
    555          

   \                                 In section SOFTPACK, align 4, keep-with-next
    556          void board_cfg_ddram(void)
    557          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
    558          #ifdef BOARD_DDRAM_TYPE
    559          	board_cfg_matrix_for_ddr();
   \        0x8   0x....'....        BL       board_cfg_matrix_for_ddr
    560          	struct _mpddrc_desc desc;
    561          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \        0xC   0xE3A0'1001        MOV      R1,#+1
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0x....'....        BL       ddram_init_descriptor
    562          	ddram_configure(&desc);
   \       0x18   0xE1A0'000D        MOV      R0,SP
   \       0x1C   0x....'....        BL       ddram_configure
    563          #endif
    564          }
   \       0x20   0xE28D'D034        ADD      SP,SP,#+52
   \       0x24   0xE8BD'8000        POP      {PC}             ;; return
    565          
    566          #ifdef CONFIG_HAVE_NAND_FLASH
    567          void board_cfg_nand_flash(void)
    568          {
    569          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    570          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    571          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
    572          	board_cfg_matrix_for_nand();
    573          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
    574          #else
    575          	trace_fatal("Cannot configure NAND: target board has no NAND definitions!");
    576          #endif
    577          }
    578          #endif /* CONFIG_HAVE_NAND_FLASH */
    579          
    580          #ifdef CONFIG_HAVE_SDMMC
    581          #if defined(BOARD_SDMMC0_PINS) || defined(BOARD_SDMMC1_PINS)
    582          static void board_cfg_sd_clk_caps(uint32_t periph_id, uint32_t *caps0,
    583              uint32_t *caps1)
    584          {
    585          		uint32_t base_freq, mult_freq, val;
    586          
    587          		/* Retrieve the frequency of BASECLK and TEOCLK.
    588          		 * Usual values of this frequency are 12 MHz, 24 MHz. */
    589          		base_freq = pmc_get_main_clock();
    590          		base_freq = ROUND_INT_DIV(base_freq, 1000000lu);
    591          		val = base_freq > (SDMMC_CA0R_BASECLKF_Msk >> SDMMC_CA0R_BASECLKF_Pos)
    592          		    ? 0 : base_freq;
    593          		*caps0 |= SDMMC_CA0R_BASECLKF(val);
    594          		val = base_freq > (SDMMC_CA0R_TEOCLKF_Msk >> SDMMC_CA0R_TEOCLKF_Pos)
    595          		    ? 0 : base_freq;
    596          		*caps0 |= SDMMC_CA0R_TEOCLKF(val) | SDMMC_CA0R_TEOCLKU;
    597          
    598          		/* Retrieve the frequency of MULTCLK.
    599          		 * Usual values of this frequency are 100 MHz, 104 MHz. */
    600          		mult_freq = pmc_get_gck_clock(periph_id);
    601          		base_freq *= 1000000lu;
    602          		val = ROUND_INT_DIV(mult_freq, base_freq);
    603          		val = val < 2 ? 1 : val - 1;
    604          		val = min_u32(val, SDMMC_CA1R_CLKMULT_Msk >> SDMMC_CA1R_CLKMULT_Pos);
    605          		*caps1 |= SDMMC_CA1R_CLKMULT(val);
    606          }
    607          #endif
    608          
    609          bool board_cfg_sdmmc(uint32_t periph_id)
    610          {
    611          	switch (periph_id) {
    612          #ifdef SDMMC0
    613          	case ID_SDMMC0:
    614          	{
    615          #if defined(BOARD_SDMMC0_CAPS0) && defined(BOARD_SDMMC0_PINS)
    616          		struct _pin pins[] = BOARD_SDMMC0_PINS;
    617          		uint32_t caps0 = BOARD_SDMMC0_CAPS0, caps1 = 0;
    618          
    619          #ifdef CONFIG_BOARD_SAMA5D2_XPLAINED
    620          		struct _pin vsel_pin = PIN_SDMMC0_VDDSEL_IOS1;
    621          		int vsel_ix;
    622          
    623          #ifndef SDMMC_TRIM_LOW_VOLTAGE
    624          		/* Set PMIC output 7 to 1.8V (VDDSDHC1V8) */
    625          		if (!act8945a_initialized) {
    626          			board_cfg_pmic();
    627          			if (!act8945a_initialized)
    628          				return false;
    629          		}
    630          		if (!act8945a_set_regulator_voltage(&act8945a, 7, 1800))
    631          			return false;
    632          		if (!act8945a_enable_regulator(&act8945a, 7, true))
    633          			return false;
    634          #endif
    635          
    636          		/* The PIOs of SDMMC0 normally include SDMMC0_VDDSEL. On regular
    637          		 * SAMA5D2-XULT, the SDMMC0_VDDSEL line has a pull-down resistor
    638          		 * hence at power-on time VCCQ is 3.3V. In this default config
    639          		 * we enable SDMMC0_VDDSEL, which can switch VCCQ to 1.8V.
    640          		 * Changing VCCQ on the fly is required with UHS-I SD cards. It
    641          		 * is illegal with e.MMC devices. Detect if the board has been
    642          		 * modified to supply 1.8V VCCQ at power-on time.
    643          		 * First, search for the SDMMC0_VDDSEL PIO on this board. */
    644          		for (vsel_ix = 0; vsel_ix < ARRAY_SIZE(pins); vsel_ix++)
    645          			if (pins[vsel_ix].mask == vsel_pin.mask
    646          			    && pins[vsel_ix].group == vsel_pin.group)
    647          				break;
    648          		if (vsel_ix < ARRAY_SIZE(pins)) {
    649          			/* Second, sense whether the SDMMC0_VDDSEL line is
    650          			 * pulled up or down */
    651          			vsel_pin.type = PIO_INPUT;
    652          			vsel_pin.attribute = PIO_PULLUP;
    653          			pio_configure(&vsel_pin, 1);
    654          			if (pio_get(&vsel_pin)) {
    655          				/* The line is pulled up => at power-on time
    656          				 * VCCQ is 1.8V. If the SDMMC0_VDDSEL function
    657          				 * was enabled, then everytime SRR:SWRSTALL was
    658          				 * triggered, VCCQ would switch to 3.3V. */
    659          				pins[vsel_ix].type = PIO_OUTPUT_1;
    660          				pins[vsel_ix].attribute = PIO_DEFAULT;
    661          				/* Deviation from the specification: we use the
    662          				 * Voltage Support capabilities to indicate the
    663          				 * supported signaling levels (VCCQ). */
    664          				caps0 &= ~SDMMC_CA0R_V33VSUP;
    665          				caps0 &= ~SDMMC_CA0R_V30VSUP;
    666          				caps0 |= SDMMC_CA0R_V18VSUP;
    667          			}
    668          		}
    669          #endif
    670          		/* Program capabilities for SDMMC0 */
    671          		board_cfg_sd_clk_caps(ID_SDMMC0, &caps0, &caps1);
    672          		sdmmc_set_capabilities(SDMMC0, caps0, SDMMC_CA0R_SLTYPE_Msk |
    673          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    674          		    SDMMC_CA0R_ED8SUP | SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    675          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    676          
    677          		/* Configure SDMMC0 pins */
    678          		pio_configure(pins, ARRAY_SIZE(pins));
    679          		return true;
    680          #else
    681          		trace_fatal("Cannot configure SDMMC0: target board has no SDMMC0 definitions!");
    682          		return false;
    683          #endif
    684          	}
    685          #endif
    686          	case ID_SDMMC1:
    687          	{
    688          #if defined(BOARD_SDMMC1_CAPS0) && defined(BOARD_SDMMC1_PINS)
    689          		const struct _pin pins[] = BOARD_SDMMC1_PINS;
    690          		uint32_t caps0 = BOARD_SDMMC1_CAPS0, caps1 = 0;
    691          
    692          		/* Program capabilities for SDMMC1 */
    693          		board_cfg_sd_clk_caps(ID_SDMMC1, &caps0, &caps1);
    694          		sdmmc_set_capabilities(SDMMC1, caps0, SDMMC_CA0R_SLTYPE_Msk |
    695          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    696          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    697          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    698          
    699          		/* Configure SDMMC1 pins */
    700          		pio_configure(pins, ARRAY_SIZE(pins));
    701          		return true;
    702          #else
    703          		trace_fatal("Cannot configure SDMMC1: target board has no SDMMC1 definitions!");
    704          		return false;
    705          #endif
    706          	}
    707          	default:
    708          		return false;
    709          	}
    710          }
    711          #endif /* CONFIG_HAVE_SDMMC */
    712          

   \                                 In section SOFTPACK, align 4, keep-with-next
    713          void board_cfg_pmic(void)
    714          {
    715          #ifdef CONFIG_HAVE_PMIC_ACT8945A
    716          	if (act8945a_initialized)
    717          		return;
    718          
    719          	if (!act8945a_configure(&act8945a))
    720          		goto Fail;
    721          #if defined(CONFIG_BOARD_SAMA5D2_XPLAINED)
    722          	/* Set PMIC output 6 to 2.5V (VDD_LED) */
    723          	if (!act8945a_set_regulator_voltage(&act8945a, 6, 2500))
    724          		goto Fail;
    725          	if (!act8945a_enable_regulator(&act8945a, 6, true))
    726          		goto Fail;
    727          #endif
    728          	act8945a_initialized = true;
    729          	return;
    730          
    731          Fail:
    732          	trace_error("Error initializing ACT8945A PMIC\r\n");
    733          #endif
    734          }
   \                     board_cfg_pmic:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x0010'0DE6        DC32     0x100de6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x0020'0DEE        DC32     0x200dee

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x0060'0DF6        DC32     0x600df6

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFF8'3FFF        DC32 4'294'459'391
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x73 0x61          DC8 "sama5d2-xult"

   \              0x6D 0x61    

   \              0x35 0x64    

   \              0x32 0x2D    

   \              0x78 0x75    

   \              0x6C 0x74    

   \              0x00
   \        0xD   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   board_cfg_clocks
        24   -> pmc_configure_plla
        24   -> pmc_disable_plla
        24   -> pmc_select_external_osc
        24   -> pmc_set_mck_divider
        24   -> pmc_set_mck_h32mxdiv
        24   -> pmc_set_mck_plladiv2
        24   -> pmc_set_mck_prescaler
        24   -> pmc_switch_mck_to_pll
        24   -> pmc_switch_mck_to_slck
      56   board_cfg_ddram
        56   -> board_cfg_matrix_for_ddr
        56   -> ddram_configure
        56   -> ddram_init_descriptor
       0   board_cfg_l2cc
         0   -> l2cc_configure
      64   board_cfg_lowlevel
        64   -> board_cfg_clocks
        64   -> board_cfg_matrix_for_ddr
        64   -> board_cfg_mmu
        64   -> board_cfg_timer
        64   -> ddram_configure
        64   -> ddram_init_descriptor
        64   -> irq_initialize
        64   -> matrix_set_default_config
        64   -> pio_reset_all_it
        64   -> pmc_set_main_oscillator_freq
        64   -> wdt_disable
      16   board_cfg_matrix_for_ddr
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
         0   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
      16   board_cfg_matrix_for_nand
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
         0   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
      16   board_cfg_mmu
        16   -> __aeabi_memclr4
         0   -> dcache_enable
        16   -> icache_enable
        16   -> mmu_configure
        16   -> mmu_enable
        16   -> mmu_is_enabled
       0   board_cfg_pmic
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_audio
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_bias
        16   -> pmc_disable_upll_clock
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable6
        4  ??DataTable6_1
        4  ??DataTable6_2
        4  ??DataTable6_3
        4  ??DataTable6_4
        4  ??DataTable6_5
        4  ??DataTable6_6
       64  ?_0
       16  ?_1
       12  ?_2
      124  board_cfg_clocks
       40  board_cfg_ddram
        8  board_cfg_l2cc
      116  board_cfg_lowlevel
      504  board_cfg_matrix_for_ddr
      164  board_cfg_matrix_for_nand
      928  board_cfg_mmu
        4  board_cfg_pmic
        4  board_name
       76  board_restore_pio_reset_state
      140  board_save_misc_power
        8  get_board_name
        4  l2cc_cfg
   16'384  tlb

 
 16'384 bytes in section .bss
      4 bytes in section .data
     92 bytes in section .rodata
  2'144 bytes in section SOFTPACK
 
  2'144 bytes of CODE  memory
     92 bytes of CONST memory
 16'388 bytes of DATA  memory

Errors: none
Warnings: none
