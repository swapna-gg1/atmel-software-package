###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         13/Jan/2021  09:45:23
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usartd.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW87B2.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usartd.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\build\sama5d2-xplained\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\build\sama5d2-xplained\sram\List\usartd.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\tc\build\sama5d2-xplained\sram\Obj\usartd.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\serial\usartd.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <assert.h>
     35          #include <stdint.h>
     36          #include <string.h>
     37          
     38          #include "callback.h"
     39          #include "chip.h"
     40          #include "dma/dma.h"
     41          #include "io.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void writeb(void volatile *, uint8_t)
   \                     writeb:
   \        0x0   0xE5C0'1000        STRB     R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void writehw(void volatile *, uint16_t)
   \                     writehw:
   \        0x0   0xE1C0'10B0        STRH     R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void writew(void volatile *, uint32_t)
   \                     writew:
   \        0x0   0xE580'1000        STR      R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void readb(void const volatile *, uint8_t *)
   \                     readb:
   \        0x0   0xE5D0'2000        LDRB     R2,[R0, #+0]
   \        0x4   0xE5C1'2000        STRB     R2,[R1, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void readhw(void const volatile *, uint16_t *)
   \                     readhw:
   \        0x0   0xE1D0'20B0        LDRH     R2,[R0, #+0]
   \        0x4   0xE1C1'20B0        STRH     R2,[R1, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __vfp void readw(void const volatile *, uint32_t *)
   \                     readw:
   \        0x0   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x4   0xE581'2000        STR      R2,[R1, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     42          #include "irq/irq.h"
     43          #include "mm/cache.h"
     44          #include "mutex.h"
     45          #ifdef CONFIG_HAVE_FLEXCOM
     46          #include "peripherals/flexcom.h"
     47          #endif
     48          #include "peripherals/pmc.h"
     49          #include "serial/usart.h"
     50          #include "serial/usartd.h"
     51          #include "trace.h"
     52          
     53          /*----------------------------------------------------------------------------
     54           *        Definition
     55           *----------------------------------------------------------------------------*/
     56          
     57          #define USARTD_ATTRIBUTE_MASK     (0)
     58          #define USARTD_POLLING_THRESHOLD  16
     59          

   \                                 In section .bss, align 4
     60          static struct _usart_desc *_serial[USART_IFACE_COUNT];
   \                     _serial:
   \        0x0                      DS8 20
     61          
     62          /*----------------------------------------------------------------------------
     63           *        Internal functions
     64           *----------------------------------------------------------------------------*/
     65          

   \                                 In section SOFTPACK, align 4, keep-with-next
     66          static int _usartd_dma_write_callback(void* arg, void* arg2)
     67          {
   \                     _usartd_dma_write_callback:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     68          	uint8_t iface = (uint32_t)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
     69          	assert(iface < USART_IFACE_COUNT);
   \       0x10   0xE1B0'0006        MOVS     R0,R6
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0xE350'0005        CMP      R0,#+5
   \       0x1C   0xBA00'0004        BLT      ??_usartd_dma_write_callback_0
   \       0x20   0xE3A0'2045        MOV      R2,#+69
   \       0x24   0x....'....        LDR      R1,??DataTable13
   \       0x28   0x....'....        LDR      R0,??DataTable13_1
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
     70          
     71          	dma_reset_channel(_serial[iface]->dma.tx.channel);
   \                     ??_usartd_dma_write_callback_0:
   \       0x34   0x....'....        LDR      R7,??DataTable13_2
   \       0x38   0xE1B0'0006        MOVS     R0,R6
   \       0x3C   0xE6EF'0070        UXTB     R0,R0
   \       0x40   0xE1B0'0100        LSLS     R0,R0,#+2
   \       0x44   0xE797'0000        LDR      R0,[R7, +R0]
   \       0x48   0xE590'0074        LDR      R0,[R0, #+116]
   \       0x4C   0x....'....        BL       dma_reset_channel
     72          
     73          	mutex_unlock(&_serial[iface]->tx.mutex);
   \       0x50   0xE1B0'0006        MOVS     R0,R6
   \       0x54   0xE6EF'0070        UXTB     R0,R0
   \       0x58   0xE1B0'0100        LSLS     R0,R0,#+2
   \       0x5C   0xE797'0000        LDR      R0,[R7, +R0]
   \       0x60   0xE290'0030        ADDS     R0,R0,#+48
   \       0x64   0x....'....        BL       mutex_unlock
     74          
     75          	callback_call(&_serial[iface]->tx.callback, NULL);
   \       0x68   0xE3A0'1000        MOV      R1,#+0
   \       0x6C   0xE1B0'0006        MOVS     R0,R6
   \       0x70   0xE6EF'0070        UXTB     R0,R0
   \       0x74   0xE1B0'0100        LSLS     R0,R0,#+2
   \       0x78   0xE797'0000        LDR      R0,[R7, +R0]
   \       0x7C   0xE290'0044        ADDS     R0,R0,#+68
   \       0x80   0x....'....        BL       callback_call
     76          
     77          	return 0;
   \       0x84   0xE3A0'0000        MOV      R0,#+0
   \       0x88   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
     78          }
     79          

   \                                 In section SOFTPACK, align 4, keep-with-next
     80          static int _usartd_dma_read_callback(void* arg, void* arg2)
     81          {
   \                     _usartd_dma_read_callback:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     82          	uint8_t iface = (uint32_t)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
     83          	assert(iface < USART_IFACE_COUNT);
   \       0x10   0xE1B0'0006        MOVS     R0,R6
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0xE350'0005        CMP      R0,#+5
   \       0x1C   0xBA00'0004        BLT      ??_usartd_dma_read_callback_0
   \       0x20   0xE3A0'2053        MOV      R2,#+83
   \       0x24   0x....'....        LDR      R1,??DataTable13
   \       0x28   0x....'....        LDR      R0,??DataTable13_1
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
     84          	struct _usart_desc *desc = _serial[iface];
   \                     ??_usartd_dma_read_callback_0:
   \       0x34   0x....'....        LDR      R0,??DataTable13_2
   \       0x38   0xE1B0'1006        MOVS     R1,R6
   \       0x3C   0xE6EF'1071        UXTB     R1,R1
   \       0x40   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x44   0xE790'7001        LDR      R7,[R0, +R1]
     85          	struct _dma_channel* channel = desc->dma.rx.channel;
   \       0x48   0xE597'8058        LDR      R8,[R7, #+88]
     86          
     87          	if (desc->timeout > 0) {
   \       0x4C   0xE597'0010        LDR      R0,[R7, #+16]
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'0005        BEQ      ??_usartd_dma_read_callback_1
     88          		desc->addr->US_CR = US_CR_STTTO;
   \       0x58   0xE3A0'0E80        MOV      R0,#+2048
   \       0x5C   0xE597'1000        LDR      R1,[R7, #+0]
   \       0x60   0xE581'0000        STR      R0,[R1, #+0]
     89          		usart_disable_it(desc->addr, US_IDR_TIMEOUT);
   \       0x64   0xE3A0'1F40        MOV      R1,#+256
   \       0x68   0xE597'0000        LDR      R0,[R7, #+0]
   \       0x6C   0x....'....        BL       usart_disable_it
     90          	}
     91          
     92          	if (!dma_is_transfer_done(channel))
   \                     ??_usartd_dma_read_callback_1:
   \       0x70   0xE1B0'0008        MOVS     R0,R8
   \       0x74   0x....'....        BL       dma_is_transfer_done
   \       0x78   0xE350'0000        CMP      R0,#+0
   \       0x7C   0x1A00'0001        BNE      ??_usartd_dma_read_callback_2
     93          		dma_stop_transfer(channel);
   \       0x80   0xE1B0'0008        MOVS     R0,R8
   \       0x84   0x....'....        BL       dma_stop_transfer
     94          	dma_fifo_flush(channel);
   \                     ??_usartd_dma_read_callback_2:
   \       0x88   0xE1B0'0008        MOVS     R0,R8
   \       0x8C   0x....'....        BL       dma_fifo_flush
     95          
     96          	desc->rx.transferred = dma_get_transferred_data_len(channel, desc->dma.rx.cfg_dma.chunk_size, desc->dma.rx.cfg.len);
   \       0x90   0xE597'2070        LDR      R2,[R7, #+112]
   \       0x94   0xE597'1060        LDR      R1,[R7, #+96]
   \       0x98   0xE6EF'1071        UXTB     R1,R1
   \       0x9C   0xE1B0'0008        MOVS     R0,R8
   \       0xA0   0x....'....        BL       dma_get_transferred_data_len
   \       0xA4   0xE1C7'02B4        STRH     R0,[R7, #+36]
     97          	dma_reset_channel(desc->dma.rx.channel);
   \       0xA8   0xE597'0058        LDR      R0,[R7, #+88]
   \       0xAC   0x....'....        BL       dma_reset_channel
     98          
     99          	if (desc->rx.transferred > 0)
   \       0xB0   0xE1D7'02B4        LDRH     R0,[R7, #+36]
   \       0xB4   0xE350'0000        CMP      R0,#+0
   \       0xB8   0x0A00'0002        BEQ      ??_usartd_dma_read_callback_3
    100          		cache_invalidate_region(desc->dma.rx.cfg.daddr, desc->rx.transferred);
   \       0xBC   0xE1D7'12B4        LDRH     R1,[R7, #+36]
   \       0xC0   0xE597'006C        LDR      R0,[R7, #+108]
   \       0xC4   0x....'....        BL       cache_invalidate_region
    101          
    102          	desc->rx.buffer.size = 0;
   \                     ??_usartd_dma_read_callback_3:
   \       0xC8   0xE3A0'0000        MOV      R0,#+0
   \       0xCC   0xE587'001C        STR      R0,[R7, #+28]
    103          
    104          	mutex_unlock(&desc->rx.mutex);
   \       0xD0   0xE297'0014        ADDS     R0,R7,#+20
   \       0xD4   0x....'....        BL       mutex_unlock
    105          
    106          	callback_call(&desc->rx.callback, NULL);
   \       0xD8   0xE3A0'1000        MOV      R1,#+0
   \       0xDC   0xE297'0028        ADDS     R0,R7,#+40
   \       0xE0   0x....'....        BL       callback_call
    107          
    108          	return 0;
   \       0xE4   0xE3A0'0000        MOV      R0,#+0
   \       0xE8   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    109          }
    110          

   \                                 In section SOFTPACK, align 4, keep-with-next
    111          static void _usartd_dma_read(uint8_t iface)
    112          {
   \                     _usartd_dma_read:
   \        0x0   0xE92D'41FC        PUSH     {R2-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    113          	struct _callback _cb;
    114          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??_usartd_dma_read_0
   \       0x18   0xE3A0'2072        MOV      R2,#+114
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    115          	struct _usart_desc* desc = _serial[iface];
   \                     ??_usartd_dma_read_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'5001        LDR      R5,[R0, +R1]
    116          
    117          	memset(&desc->dma.rx.cfg, 0x0, sizeof(desc->dma.rx.cfg));
   \       0x40   0xE3A0'600C        MOV      R6,#+12
   \       0x44   0xE3A0'7000        MOV      R7,#+0
   \       0x48   0xE295'8068        ADDS     R8,R5,#+104
   \       0x4C   0xE1B0'2007        MOVS     R2,R7
   \       0x50   0xE1B0'1006        MOVS     R1,R6
   \       0x54   0xE1B0'0008        MOVS     R0,R8
   \       0x58   0x....'....        BL       __aeabi_memset
   \       0x5C   0xE1B0'0008        MOVS     R0,R8
    118          
    119          	desc->dma.rx.cfg.saddr = (void *)&desc->addr->US_RHR;
   \       0x60   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x64   0xE290'0018        ADDS     R0,R0,#+24
   \       0x68   0xE585'0068        STR      R0,[R5, #+104]
    120          	desc->dma.rx.cfg.daddr = desc->rx.buffer.data;
   \       0x6C   0xE595'0018        LDR      R0,[R5, #+24]
   \       0x70   0xE585'006C        STR      R0,[R5, #+108]
    121          	desc->dma.rx.cfg.len = desc->rx.buffer.size;
   \       0x74   0xE595'001C        LDR      R0,[R5, #+28]
   \       0x78   0xE585'0070        STR      R0,[R5, #+112]
    122          	dma_configure_transfer(desc->dma.rx.channel, &desc->dma.rx.cfg_dma, &desc->dma.rx.cfg, 1);
   \       0x7C   0xE3A0'3001        MOV      R3,#+1
   \       0x80   0xE295'2068        ADDS     R2,R5,#+104
   \       0x84   0xE295'105C        ADDS     R1,R5,#+92
   \       0x88   0xE595'0058        LDR      R0,[R5, #+88]
   \       0x8C   0x....'....        BL       dma_configure_transfer
    123          
    124          	callback_set(&_cb, _usartd_dma_read_callback, (void*)(uint32_t)iface);
   \       0x90   0xE1B0'2004        MOVS     R2,R4
   \       0x94   0xE6EF'2072        UXTB     R2,R2
   \       0x98   0x....'....        ADR      R1,_usartd_dma_read_callback
   \       0x9C   0xE1B0'000D        MOVS     R0,SP
   \       0xA0   0x....'....        BL       callback_set
    125          	dma_set_callback(desc->dma.rx.channel, &_cb);
   \       0xA4   0xE1B0'100D        MOVS     R1,SP
   \       0xA8   0xE595'0058        LDR      R0,[R5, #+88]
   \       0xAC   0x....'....        BL       dma_set_callback
    126          	usart_enable_it(desc->addr, US_IER_TIMEOUT);
   \       0xB0   0xE3A0'1F40        MOV      R1,#+256
   \       0xB4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xB8   0x....'....        BL       usart_enable_it
    127          	usart_restart_rx_timeout(desc->addr);
   \       0xBC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xC0   0x....'....        BL       usart_restart_rx_timeout
    128          	dma_start_transfer(desc->dma.rx.channel);
   \       0xC4   0xE595'0058        LDR      R0,[R5, #+88]
   \       0xC8   0x....'....        BL       dma_start_transfer
    129          }
   \       0xCC   0xE8BD'81F3        POP      {R0,R1,R4-R8,PC}  ;; return
    130          

   \                                 In section SOFTPACK, align 4, keep-with-next
    131          static void _usartd_dma_write(uint8_t iface)
    132          {
   \                     _usartd_dma_write:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE24D'D014        SUB      SP,SP,#+20
   \        0x8   0xE1B0'4000        MOVS     R4,R0
    133          	struct _callback _cb;
    134          	assert(iface < USART_IFACE_COUNT);
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0xE6EF'0070        UXTB     R0,R0
   \       0x14   0xE350'0005        CMP      R0,#+5
   \       0x18   0xBA00'0004        BLT      ??_usartd_dma_write_0
   \       0x1C   0xE3A0'2086        MOV      R2,#+134
   \       0x20   0x....'....        LDR      R1,??DataTable13
   \       0x24   0x....'....        LDR      R0,??DataTable13_1
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    135          	struct _usart_desc* desc = _serial[iface];
   \                     ??_usartd_dma_write_0:
   \       0x30   0x....'....        LDR      R0,??DataTable13_2
   \       0x34   0xE1B0'1004        MOVS     R1,R4
   \       0x38   0xE6EF'1071        UXTB     R1,R1
   \       0x3C   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x40   0xE790'5001        LDR      R5,[R0, +R1]
    136          	struct _dma_transfer_cfg cfg;
    137          
    138          	cfg.saddr = desc->tx.buffer.data;
   \       0x44   0xE595'0034        LDR      R0,[R5, #+52]
   \       0x48   0xE58D'0000        STR      R0,[SP, #+0]
    139          	cfg.daddr = (void *)&desc->addr->US_THR;
   \       0x4C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x50   0xE290'001C        ADDS     R0,R0,#+28
   \       0x54   0xE58D'0004        STR      R0,[SP, #+4]
    140          	cfg.len = desc->tx.buffer.size;
   \       0x58   0xE595'0038        LDR      R0,[R5, #+56]
   \       0x5C   0xE58D'0008        STR      R0,[SP, #+8]
    141          	dma_configure_transfer(desc->dma.tx.channel, &desc->dma.tx.cfg_dma, &cfg, 1);
   \       0x60   0xE3A0'3001        MOV      R3,#+1
   \       0x64   0xE1B0'200D        MOVS     R2,SP
   \       0x68   0xE295'1078        ADDS     R1,R5,#+120
   \       0x6C   0xE595'0074        LDR      R0,[R5, #+116]
   \       0x70   0x....'....        BL       dma_configure_transfer
    142          
    143          	callback_set(&_cb, _usartd_dma_write_callback, (void*)(uint32_t)iface);
   \       0x74   0xE1B0'2004        MOVS     R2,R4
   \       0x78   0xE6EF'2072        UXTB     R2,R2
   \       0x7C   0x....'....        ADR      R1,_usartd_dma_write_callback
   \       0x80   0xE28D'000C        ADD      R0,SP,#+12
   \       0x84   0x....'....        BL       callback_set
    144          	dma_set_callback(desc->dma.tx.channel, &_cb);
   \       0x88   0xE28D'100C        ADD      R1,SP,#+12
   \       0x8C   0xE595'0074        LDR      R0,[R5, #+116]
   \       0x90   0x....'....        BL       dma_set_callback
    145          	cache_clean_region(cfg.saddr, cfg.len);
   \       0x94   0xE59D'1008        LDR      R1,[SP, #+8]
   \       0x98   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x9C   0x....'....        BL       cache_clean_region
    146          	dma_start_transfer(desc->dma.tx.channel);
   \       0xA0   0xE595'0074        LDR      R0,[R5, #+116]
   \       0xA4   0x....'....        BL       dma_start_transfer
    147          }
   \       0xA8   0xE28D'D014        ADD      SP,SP,#+20
   \       0xAC   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    148          

   \                                 In section SOFTPACK, align 4, keep-with-next
    149          static void _usartd_handler(uint32_t source, void* user_arg)
    150          {
   \                     _usartd_handler:
   \        0x0   0xE92D'4FF3        PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xE24D'D004        SUB      SP,SP,#+4
    151          	int iface;
    152          	uint32_t status = 0;
   \        0x8   0xE3A0'8000        MOV      R8,#+0
   \        0xC   0xE58D'8000        STR      R8,[SP, #+0]
    153          	Usart* addr = get_usart_addr_from_id(source);
   \       0x10   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x14   0x....'....        BL       get_usart_addr_from_id
   \       0x18   0xE1B0'4000        MOVS     R4,R0
    154          	bool _rx_stop = true;
   \       0x1C   0xE3A0'9001        MOV      R9,#+1
   \       0x20   0xE1B0'5009        MOVS     R5,R9
    155          	bool _tx_stop = true;
   \       0x24   0xE1B0'6009        MOVS     R6,R9
    156          
    157          	for (iface = 0; iface < USART_IFACE_COUNT; iface++) {
   \       0x28   0xE3A0'7000        MOV      R7,#+0
   \                     ??_usartd_handler_0:
   \       0x2C   0xE357'0005        CMP      R7,#+5
   \       0x30   0xAA00'0009        BGE      ??_usartd_handler_1
    158          		if (_serial[iface]->addr == addr) {
   \       0x34   0x....'....        LDR      R0,??DataTable13_2
   \       0x38   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x44   0xE150'0004        CMP      R0,R4
   \       0x48   0x1A00'0001        BNE      ??_usartd_handler_2
    159          			status = 1;
   \       0x4C   0xE58D'9000        STR      R9,[SP, #+0]
    160          			break;
   \       0x50   0xEA00'0001        B        ??_usartd_handler_1
    161          		}
    162          	}
   \                     ??_usartd_handler_2:
   \       0x54   0xE297'7001        ADDS     R7,R7,#+1
   \       0x58   0xEAFF'FFF3        B        ??_usartd_handler_0
    163          
    164          	if (!status) {
   \                     ??_usartd_handler_1:
   \       0x5C   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x1A00'0003        BNE      ??_usartd_handler_3
    165          		/* async descriptor not found, disable interrupt */
    166          		usart_disable_it(addr, US_IDR_RXRDY | US_IDR_TXRDY | US_IDR_TXEMPTY | US_IDR_TIMEOUT);
   \       0x68   0xE300'1303        MOVW     R1,#+771
   \       0x6C   0xE1B0'0004        MOVS     R0,R4
   \       0x70   0x....'....        BL       usart_disable_it
    167          		return;
   \       0x74   0xEA00'006B        B        ??_usartd_handler_4
    168          	}
    169          
    170          	struct _usart_desc* desc = _serial[iface];
   \                     ??_usartd_handler_3:
   \       0x78   0x....'....        LDR      R0,??DataTable13_2
   \       0x7C   0xE1B0'1107        LSLS     R1,R7,#+2
   \       0x80   0xE790'A001        LDR      R10,[R0, +R1]
    171          	status = usart_get_masked_status(addr);
   \       0x84   0xE1B0'0004        MOVS     R0,R4
   \       0x88   0x....'....        BL       usart_get_masked_status
   \       0x8C   0xE1B0'B000        MOVS     R11,R0
    172          	desc->rx.has_timeout = false;
   \       0x90   0xE5CA'8026        STRB     R8,[R10, #+38]
    173          
    174          	if (USART_STATUS_RXRDY(status)) {
   \       0x94   0xE31B'0001        TST      R11,#0x1
   \       0x98   0x0A00'0014        BEQ      ??_usartd_handler_5
    175          		if (desc->rx.buffer.size) {
   \       0x9C   0xE59A'001C        LDR      R0,[R10, #+28]
   \       0xA0   0xE350'0000        CMP      R0,#+0
   \       0xA4   0x0A00'0011        BEQ      ??_usartd_handler_5
    176          			desc->rx.buffer.data[desc->rx.transferred] = usart_get_char(addr);
   \       0xA8   0xE1B0'0004        MOVS     R0,R4
   \       0xAC   0x....'....        BL       usart_get_char
   \       0xB0   0xE59A'1018        LDR      R1,[R10, #+24]
   \       0xB4   0xE1DA'22B4        LDRH     R2,[R10, #+36]
   \       0xB8   0xE7C1'0002        STRB     R0,[R1, +R2]
    177          			desc->rx.transferred++;
   \       0xBC   0xE1DA'02B4        LDRH     R0,[R10, #+36]
   \       0xC0   0xE290'0001        ADDS     R0,R0,#+1
   \       0xC4   0xE1CA'02B4        STRH     R0,[R10, #+36]
    178          
    179          			if (desc->rx.transferred >= desc->rx.buffer.size)
   \       0xC8   0xE1DA'02B4        LDRH     R0,[R10, #+36]
   \       0xCC   0xE59A'101C        LDR      R1,[R10, #+28]
   \       0xD0   0xE150'0001        CMP      R0,R1
   \       0xD4   0x3A00'0003        BCC      ??_usartd_handler_6
    180          				usart_disable_it(addr, US_IDR_RXRDY);
   \       0xD8   0xE3A0'1001        MOV      R1,#+1
   \       0xDC   0xE1B0'0004        MOVS     R0,R4
   \       0xE0   0x....'....        BL       usart_disable_it
   \       0xE4   0xEA00'0001        B        ??_usartd_handler_5
    181          			else
    182          				_rx_stop = false;
   \                     ??_usartd_handler_6:
   \       0xE8   0xE1B0'0008        MOVS     R0,R8
   \       0xEC   0xE1B0'5000        MOVS     R5,R0
    183          		}
    184          	}
    185          
    186          	if (USART_STATUS_TXRDY(status)) {
   \                     ??_usartd_handler_5:
   \       0xF0   0xE31B'0002        TST      R11,#0x2
   \       0xF4   0x0A00'0016        BEQ      ??_usartd_handler_7
    187          		if (desc->tx.buffer.size) {
   \       0xF8   0xE59A'0038        LDR      R0,[R10, #+56]
   \       0xFC   0xE350'0000        CMP      R0,#+0
   \      0x100   0x0A00'0013        BEQ      ??_usartd_handler_7
    188          			usart_put_char(addr, desc->tx.buffer.data[desc->tx.transferred]);
   \      0x104   0xE59A'0034        LDR      R0,[R10, #+52]
   \      0x108   0xE1DA'14B0        LDRH     R1,[R10, #+64]
   \      0x10C   0xE7D0'1001        LDRB     R1,[R0, +R1]
   \      0x110   0xE1B0'0004        MOVS     R0,R4
   \      0x114   0x....'....        BL       usart_put_char
    189          			desc->tx.transferred++;
   \      0x118   0xE1DA'04B0        LDRH     R0,[R10, #+64]
   \      0x11C   0xE290'0001        ADDS     R0,R0,#+1
   \      0x120   0xE1CA'04B0        STRH     R0,[R10, #+64]
    190          
    191          			if (desc->tx.transferred > desc->tx.buffer.size) {
   \      0x124   0xE59A'0038        LDR      R0,[R10, #+56]
   \      0x128   0xE1DA'14B0        LDRH     R1,[R10, #+64]
   \      0x12C   0xE150'0001        CMP      R0,R1
   \      0x130   0x2A00'0005        BCS      ??_usartd_handler_8
    192          				usart_disable_it(addr, US_IDR_TXRDY);
   \      0x134   0xE3A0'1002        MOV      R1,#+2
   \      0x138   0xE1B0'0004        MOVS     R0,R4
   \      0x13C   0x....'....        BL       usart_disable_it
    193          				usart_enable_it(addr, US_IER_TXEMPTY);
   \      0x140   0xE3A0'1F80        MOV      R1,#+512
   \      0x144   0xE1B0'0004        MOVS     R0,R4
   \      0x148   0x....'....        BL       usart_enable_it
    194          			}
    195          			_tx_stop = false;
   \                     ??_usartd_handler_8:
   \      0x14C   0xE1B0'0008        MOVS     R0,R8
   \      0x150   0xE1B0'6000        MOVS     R6,R0
    196          		}
    197          	}
    198          
    199          	if (USART_STATUS_TIMEOUT(status)) {
   \                     ??_usartd_handler_7:
   \      0x154   0xE31B'0F40        TST      R11,#0x100
   \      0x158   0x0A00'001C        BEQ      ??_usartd_handler_9
    200          		switch (desc->transfer_mode) {
   \      0x15C   0xE5DA'000C        LDRB     R0,[R10, #+12]
   \      0x160   0xE350'0001        CMP      R0,#+1
   \      0x164   0x0A00'0002        BEQ      ??_usartd_handler_10
   \      0x168   0xE350'0002        CMP      R0,#+2
   \      0x16C   0x0A00'0007        BEQ      ??_usartd_handler_11
   \      0x170   0xEA00'0009        B        ??_usartd_handler_12
    201          		case USARTD_MODE_ASYNC:
    202          			desc->addr->US_CR = US_CR_STTTO;
   \                     ??_usartd_handler_10:
   \      0x174   0xE3A0'0E80        MOV      R0,#+2048
   \      0x178   0xE59A'1000        LDR      R1,[R10, #+0]
   \      0x17C   0xE581'0000        STR      R0,[R1, #+0]
    203          			usart_disable_it(addr, US_IDR_TIMEOUT);
   \      0x180   0xE3A0'1F40        MOV      R1,#+256
   \      0x184   0xE1B0'0004        MOVS     R0,R4
   \      0x188   0x....'....        BL       usart_disable_it
    204          			break;
   \      0x18C   0xEA00'0002        B        ??_usartd_handler_12
    205          		case USARTD_MODE_DMA:
    206          			_usartd_dma_read_callback((void *)iface, NULL);
   \                     ??_usartd_handler_11:
   \      0x190   0xE3A0'1000        MOV      R1,#+0
   \      0x194   0xE1B0'0007        MOVS     R0,R7
   \      0x198   0x....'....        BL       _usartd_dma_read_callback
    207          			break;
    208          		}
    209          
    210          		if (desc->rx.buffer.size)
   \                     ??_usartd_handler_12:
   \      0x19C   0xE59A'001C        LDR      R0,[R10, #+28]
   \      0x1A0   0xE350'0000        CMP      R0,#+0
   \      0x1A4   0x0A00'0002        BEQ      ??_usartd_handler_13
    211          			usart_disable_it(addr, US_IDR_RXRDY);
   \      0x1A8   0xE3A0'1001        MOV      R1,#+1
   \      0x1AC   0xE1B0'0004        MOVS     R0,R4
   \      0x1B0   0x....'....        BL       usart_disable_it
    212          
    213          		if (desc->tx.buffer.size)
   \                     ??_usartd_handler_13:
   \      0x1B4   0xE59A'0038        LDR      R0,[R10, #+56]
   \      0x1B8   0xE350'0000        CMP      R0,#+0
   \      0x1BC   0x0A00'0002        BEQ      ??_usartd_handler_14
    214          			usart_disable_it(addr, US_IDR_TXRDY | US_IDR_TXEMPTY);
   \      0x1C0   0xE300'1202        MOVW     R1,#+514
   \      0x1C4   0xE1B0'0004        MOVS     R0,R4
   \      0x1C8   0x....'....        BL       usart_disable_it
    215          
    216          		desc->rx.has_timeout = true;
   \                     ??_usartd_handler_14:
   \      0x1CC   0xE5CA'9026        STRB     R9,[R10, #+38]
    217          	}
    218          
    219          	if (USART_STATUS_TXEMPTY(status)) {
   \                     ??_usartd_handler_9:
   \      0x1D0   0xE31B'0F80        TST      R11,#0x200
   \      0x1D4   0x0A00'0002        BEQ      ??_usartd_handler_15
    220          		usart_disable_it(addr, US_IDR_TXEMPTY);
   \      0x1D8   0xE3A0'1F80        MOV      R1,#+512
   \      0x1DC   0xE1B0'0004        MOVS     R0,R4
   \      0x1E0   0x....'....        BL       usart_disable_it
    221          	}
    222          
    223          	if (_rx_stop) {
   \                     ??_usartd_handler_15:
   \      0x1E4   0xE1B0'0005        MOVS     R0,R5
   \      0x1E8   0xE6EF'0070        UXTB     R0,R0
   \      0x1EC   0xE350'0000        CMP      R0,#+0
   \      0x1F0   0x0A00'0005        BEQ      ??_usartd_handler_16
    224          		desc->addr->US_CR = US_CR_STTTO;
   \      0x1F4   0xE3A0'0E80        MOV      R0,#+2048
   \      0x1F8   0xE59A'1000        LDR      R1,[R10, #+0]
   \      0x1FC   0xE581'0000        STR      R0,[R1, #+0]
    225          		desc->rx.buffer.size = 0;
   \      0x200   0xE58A'801C        STR      R8,[R10, #+28]
    226          		mutex_unlock(&desc->rx.mutex);
   \      0x204   0xE29A'0014        ADDS     R0,R10,#+20
   \      0x208   0x....'....        BL       mutex_unlock
    227          	}
    228          	if (_tx_stop) {
   \                     ??_usartd_handler_16:
   \      0x20C   0xE1B0'0006        MOVS     R0,R6
   \      0x210   0xE6EF'0070        UXTB     R0,R0
   \      0x214   0xE350'0000        CMP      R0,#+0
   \      0x218   0x0A00'0002        BEQ      ??_usartd_handler_17
    229          		desc->tx.buffer.size = 0;
   \      0x21C   0xE58A'8038        STR      R8,[R10, #+56]
    230          		mutex_unlock(&desc->tx.mutex);
   \      0x220   0xE29A'0030        ADDS     R0,R10,#+48
   \      0x224   0x....'....        BL       mutex_unlock
    231          	}
    232          }
   \                     ??_usartd_handler_17:
   \                     ??_usartd_handler_4:
   \      0x228   0xE8BD'8FF7        POP      {R0-R2,R4-R11,PC}  ;; return
    233          

   \                                 In section SOFTPACK, align 4, keep-with-next
    234          void usartd_configure(uint8_t iface, struct _usart_desc* config)
    235          {
   \                     usartd_configure:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    236          	uint32_t id = get_usart_id_from_addr(config->addr);
   \        0xC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x10   0x....'....        BL       get_usart_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    237          	assert(id < ID_PERIPH_COUNT);
   \       0x18   0xE356'004F        CMP      R6,#+79
   \       0x1C   0x3A00'0004        BCC      ??usartd_configure_0
   \       0x20   0xE3A0'20ED        MOV      R2,#+237
   \       0x24   0x....'....        LDR      R1,??DataTable13
   \       0x28   0x....'....        LDR      R0,??DataTable13_3
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
    238          	assert(iface < USART_IFACE_COUNT);
   \                     ??usartd_configure_0:
   \       0x34   0xE1B0'0004        MOVS     R0,R4
   \       0x38   0xE6EF'0070        UXTB     R0,R0
   \       0x3C   0xE350'0005        CMP      R0,#+5
   \       0x40   0xBA00'0004        BLT      ??usartd_configure_1
   \       0x44   0xE3A0'20EE        MOV      R2,#+238
   \       0x48   0x....'....        LDR      R1,??DataTable13
   \       0x4C   0x....'....        LDR      R0,??DataTable13_1
   \       0x50   0x....'....        BL       __aeabi_assert
   \       0x54   0x....'....        BL       __iar_EmptyStepPoint
    239          
    240          	_serial[iface] = config;
   \                     ??usartd_configure_1:
   \       0x58   0x....'....        LDR      R0,??DataTable13_2
   \       0x5C   0xE1B0'1004        MOVS     R1,R4
   \       0x60   0xE6EF'1071        UXTB     R1,R1
   \       0x64   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x68   0xE780'5001        STR      R5,[R0, +R1]
    241          
    242          #ifdef CONFIG_HAVE_FLEXCOM
    243          	Flexcom* flexcom = get_flexcom_addr_from_id(id);
   \       0x6C   0xE1B0'0006        MOVS     R0,R6
   \       0x70   0x....'....        BL       get_flexcom_addr_from_id
   \       0x74   0xE1B0'7000        MOVS     R7,R0
    244          	if (flexcom) {
   \       0x78   0xE357'0000        CMP      R7,#+0
   \       0x7C   0x0A00'0002        BEQ      ??usartd_configure_2
    245          		flexcom_select(flexcom, FLEX_MR_OPMODE_USART);
   \       0x80   0xE3A0'1001        MOV      R1,#+1
   \       0x84   0xE1B0'0007        MOVS     R0,R7
   \       0x88   0x....'....        BL       flexcom_select
    246          	}
    247          #endif
    248          	pmc_configure_peripheral(id, NULL, true);
   \                     ??usartd_configure_2:
   \       0x8C   0xE3A0'2001        MOV      R2,#+1
   \       0x90   0xE3A0'1000        MOV      R1,#+0
   \       0x94   0xE1B0'0006        MOVS     R0,R6
   \       0x98   0x....'....        BL       pmc_configure_peripheral
    249          	usart_configure(config->addr, config->mode, config->baudrate);
   \       0x9C   0xE595'2008        LDR      R2,[R5, #+8]
   \       0xA0   0xE595'1004        LDR      R1,[R5, #+4]
   \       0xA4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xA8   0x....'....        BL       usart_configure
    250          	usart_set_rx_timeout(config->addr, config->baudrate, config->timeout);
   \       0xAC   0xE595'2010        LDR      R2,[R5, #+16]
   \       0xB0   0xE595'1008        LDR      R1,[R5, #+8]
   \       0xB4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xB8   0x....'....        BL       usart_set_rx_timeout
    251          	irq_add_handler(get_usart_id_from_addr(config->addr), _usartd_handler, NULL);
   \       0xBC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xC0   0x....'....        BL       get_usart_id_from_addr
   \       0xC4   0xE3A0'2000        MOV      R2,#+0
   \       0xC8   0x....'....        ADR      R1,_usartd_handler
   \       0xCC   0x....'....        BL       irq_add_handler
    252          	/* Enable USART interrupt */
    253          	irq_enable(id);
   \       0xD0   0xE1B0'0006        MOVS     R0,R6
   \       0xD4   0x....'....        BL       irq_enable
    254          
    255          #ifdef CONFIG_HAVE_USART_FIFO
    256          	config->fifo.rx.size = get_peripheral_fifo_depth(config->addr);
   \       0xD8   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xDC   0x....'....        BL       get_peripheral_fifo_depth
   \       0xE0   0xE1C5'04BE        STRH     R0,[R5, #+78]
    257          	config->fifo.tx.size = get_peripheral_fifo_depth(config->addr);
   \       0xE4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xE8   0x....'....        BL       get_peripheral_fifo_depth
   \       0xEC   0xE1C5'05B2        STRH     R0,[R5, #+82]
    258          	usart_fifo_configure(config->addr, config->fifo.tx.threshold,
    259          						 config->fifo.rx.threshold, config->fifo.rx.threshold);
   \       0xF0   0xE1D5'35B0        LDRH     R3,[R5, #+80]
   \       0xF4   0xE6EF'3073        UXTB     R3,R3
   \       0xF8   0xE1D5'25B0        LDRH     R2,[R5, #+80]
   \       0xFC   0xE6EF'2072        UXTB     R2,R2
   \      0x100   0xE1D5'15B4        LDRH     R1,[R5, #+84]
   \      0x104   0xE6EF'1071        UXTB     R1,R1
   \      0x108   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x10C   0x....'....        BL       usart_fifo_configure
    260          	if (config->use_fifo)
   \      0x110   0xE5D5'004C        LDRB     R0,[R5, #+76]
   \      0x114   0xE350'0000        CMP      R0,#+0
   \      0x118   0x0A00'0001        BEQ      ??usartd_configure_3
    261          		usart_fifo_enable(config->addr);
   \      0x11C   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x120   0x....'....        BL       usart_fifo_enable
    262          #endif
    263          
    264          	config->dma.rx.cfg_dma.incr_saddr = false;
   \                     ??usartd_configure_3:
   \      0x124   0xE3A0'0000        MOV      R0,#+0
   \      0x128   0xE5C5'0064        STRB     R0,[R5, #+100]
    265          	config->dma.rx.cfg_dma.incr_daddr = true;
   \      0x12C   0xE3A0'1001        MOV      R1,#+1
   \      0x130   0xE5C5'1065        STRB     R1,[R5, #+101]
    266          	config->dma.rx.cfg_dma.loop = false;
   \      0x134   0xE5C5'0066        STRB     R0,[R5, #+102]
    267          	config->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \      0x138   0xE585'005C        STR      R0,[R5, #+92]
    268          	config->dma.rx.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x13C   0xE585'0060        STR      R0,[R5, #+96]
    269          
    270          	config->dma.tx.cfg_dma.incr_saddr = true;
   \      0x140   0xE5C5'1080        STRB     R1,[R5, #+128]
    271          	config->dma.tx.cfg_dma.incr_daddr = false;
   \      0x144   0xE5C5'0081        STRB     R0,[R5, #+129]
    272          	config->dma.tx.cfg_dma.loop = false;
   \      0x148   0xE5C5'0082        STRB     R0,[R5, #+130]
    273          	config->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \      0x14C   0xE585'0078        STR      R0,[R5, #+120]
    274          	config->dma.tx.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x150   0xE585'007C        STR      R0,[R5, #+124]
    275          
    276          	config->dma.rx.channel = dma_allocate_channel(id, DMA_PERIPH_MEMORY);
   \      0x154   0xE3A0'10FF        MOV      R1,#+255
   \      0x158   0xE1B0'0006        MOVS     R0,R6
   \      0x15C   0xE6EF'0070        UXTB     R0,R0
   \      0x160   0x....'....        BL       dma_allocate_channel
   \      0x164   0xE585'0058        STR      R0,[R5, #+88]
    277          	assert(config->dma.rx.channel);
   \      0x168   0xE595'0058        LDR      R0,[R5, #+88]
   \      0x16C   0xE350'0000        CMP      R0,#+0
   \      0x170   0x1A00'0004        BNE      ??usartd_configure_4
   \      0x174   0xE300'2115        MOVW     R2,#+277
   \      0x178   0x....'....        LDR      R1,??DataTable13
   \      0x17C   0x....'....        LDR      R0,??DataTable13_4
   \      0x180   0x....'....        BL       __aeabi_assert
   \      0x184   0x....'....        BL       __iar_EmptyStepPoint
    278          
    279          	config->dma.tx.channel = dma_allocate_channel(DMA_PERIPH_MEMORY, id);
   \                     ??usartd_configure_4:
   \      0x188   0xE1B0'1006        MOVS     R1,R6
   \      0x18C   0xE6EF'1071        UXTB     R1,R1
   \      0x190   0xE3A0'00FF        MOV      R0,#+255
   \      0x194   0x....'....        BL       dma_allocate_channel
   \      0x198   0xE585'0074        STR      R0,[R5, #+116]
    280          	assert(config->dma.tx.channel);
   \      0x19C   0xE595'0074        LDR      R0,[R5, #+116]
   \      0x1A0   0xE350'0000        CMP      R0,#+0
   \      0x1A4   0x1A00'0004        BNE      ??usartd_configure_5
   \      0x1A8   0xE3A0'2F46        MOV      R2,#+280
   \      0x1AC   0x....'....        LDR      R1,??DataTable13
   \      0x1B0   0x....'....        LDR      R0,??DataTable13_5
   \      0x1B4   0x....'....        BL       __aeabi_assert
   \      0x1B8   0x....'....        BL       __iar_EmptyStepPoint
    281          }
   \                     ??usartd_configure_5:
   \      0x1BC   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    282          

   \                                 In section SOFTPACK, align 4, keep-with-next
    283          uint32_t usartd_transfer(uint8_t iface, struct _buffer* buf, struct _callback* cb)
    284          {
   \                     usartd_transfer:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    285          	assert(iface < USART_IFACE_COUNT);
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0xE6EF'0070        UXTB     R0,R0
   \       0x18   0xE350'0005        CMP      R0,#+5
   \       0x1C   0xBA00'0004        BLT      ??usartd_transfer_0
   \       0x20   0xE300'211D        MOVW     R2,#+285
   \       0x24   0x....'....        LDR      R1,??DataTable13
   \       0x28   0x....'....        LDR      R0,??DataTable13_1
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
    286          	struct _usart_desc *desc = _serial[iface];
   \                     ??usartd_transfer_0:
   \       0x34   0x....'....        LDR      R0,??DataTable13_2
   \       0x38   0xE1B0'1004        MOVS     R1,R4
   \       0x3C   0xE6EF'1071        UXTB     R1,R1
   \       0x40   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x44   0xE790'7001        LDR      R7,[R0, +R1]
    287          	uint8_t tmode;
    288          	uint32_t csr;
    289          	uint32_t i;
    290          
    291          	if ((buf == NULL) || (buf->size == 0))
   \       0x48   0xE355'0000        CMP      R5,#+0
   \       0x4C   0x0A00'0002        BEQ      ??usartd_transfer_1
   \       0x50   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x54   0xE350'0000        CMP      R0,#+0
   \       0x58   0x1A00'0001        BNE      ??usartd_transfer_2
    292          		return USARTD_SUCCESS;
   \                     ??usartd_transfer_1:
   \       0x5C   0xE3A0'0000        MOV      R0,#+0
   \       0x60   0xEA00'00F8        B        ??usartd_transfer_3
    293          
    294          	if (buf->attr & USARTD_BUF_ATTR_READ) {
   \                     ??usartd_transfer_2:
   \       0x64   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \       0x68   0xE310'0002        TST      R0,#0x2
   \       0x6C   0x0A00'0011        BEQ      ??usartd_transfer_4
    295          		if (!mutex_try_lock(&desc->rx.mutex))
   \       0x70   0xE297'0014        ADDS     R0,R7,#+20
   \       0x74   0x....'....        BL       mutex_try_lock
   \       0x78   0xE350'0000        CMP      R0,#+0
   \       0x7C   0x1A00'0001        BNE      ??usartd_transfer_5
    296          			return USARTD_ERROR_LOCK;
   \       0x80   0xE3A0'0003        MOV      R0,#+3
   \       0x84   0xEA00'00EF        B        ??usartd_transfer_3
    297          
    298          		desc->rx.transferred = 0;
   \                     ??usartd_transfer_5:
   \       0x88   0xE3A0'9000        MOV      R9,#+0
   \       0x8C   0xE1C7'92B4        STRH     R9,[R7, #+36]
    299          		desc->rx.buffer.data = buf->data;
   \       0x90   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x94   0xE587'0018        STR      R0,[R7, #+24]
    300          		desc->rx.buffer.size = buf->size;
   \       0x98   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x9C   0xE587'001C        STR      R0,[R7, #+28]
    301          		desc->rx.buffer.attr = buf->attr;
   \       0xA0   0xE595'0008        LDR      R0,[R5, #+8]
   \       0xA4   0xE587'0020        STR      R0,[R7, #+32]
    302          		callback_copy(&desc->rx.callback, cb);
   \       0xA8   0xE1B0'1006        MOVS     R1,R6
   \       0xAC   0xE297'0028        ADDS     R0,R7,#+40
   \       0xB0   0x....'....        BL       callback_copy
    303          
    304          		desc->rx.has_timeout = false;
   \       0xB4   0xE5C7'9026        STRB     R9,[R7, #+38]
    305          	}
    306          
    307          	if (buf->attr & USARTD_BUF_ATTR_WRITE) {
   \                     ??usartd_transfer_4:
   \       0xB8   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \       0xBC   0xE310'0001        TST      R0,#0x1
   \       0xC0   0x0A00'0010        BEQ      ??usartd_transfer_6
    308          		if (!mutex_try_lock(&desc->tx.mutex))
   \       0xC4   0xE297'0030        ADDS     R0,R7,#+48
   \       0xC8   0x....'....        BL       mutex_try_lock
   \       0xCC   0xE350'0000        CMP      R0,#+0
   \       0xD0   0x1A00'0001        BNE      ??usartd_transfer_7
    309          			return USARTD_ERROR_LOCK;
   \       0xD4   0xE3A0'0003        MOV      R0,#+3
   \       0xD8   0xEA00'00DA        B        ??usartd_transfer_3
    310          
    311          		desc->tx.transferred = 0;
   \                     ??usartd_transfer_7:
   \       0xDC   0xE3A0'0000        MOV      R0,#+0
   \       0xE0   0xE1C7'04B0        STRH     R0,[R7, #+64]
    312          		desc->tx.buffer.data = buf->data;
   \       0xE4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xE8   0xE587'0034        STR      R0,[R7, #+52]
    313          		desc->tx.buffer.size = buf->size;
   \       0xEC   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xF0   0xE587'0038        STR      R0,[R7, #+56]
    314          		desc->tx.buffer.attr = buf->attr;
   \       0xF4   0xE595'0008        LDR      R0,[R5, #+8]
   \       0xF8   0xE587'003C        STR      R0,[R7, #+60]
    315          		callback_copy(&desc->tx.callback, cb);
   \       0xFC   0xE1B0'1006        MOVS     R1,R6
   \      0x100   0xE297'0044        ADDS     R0,R7,#+68
   \      0x104   0x....'....        BL       callback_copy
    316          	}
    317          
    318          	tmode = desc->transfer_mode;
   \                     ??usartd_transfer_6:
   \      0x108   0xE5D7'900C        LDRB     R9,[R7, #+12]
    319          
    320          	/* If short transfer detected, use POLLING mode */
    321          	if (tmode != USARTD_MODE_POLLING)
   \      0x10C   0xE1B0'0009        MOVS     R0,R9
   \      0x110   0xE6EF'0070        UXTB     R0,R0
   \      0x114   0xE350'0000        CMP      R0,#+0
   \      0x118   0x0A00'0004        BEQ      ??usartd_transfer_8
    322          		if (buf->size < USARTD_POLLING_THRESHOLD)
   \      0x11C   0xE595'0004        LDR      R0,[R5, #+4]
   \      0x120   0xE350'0010        CMP      R0,#+16
   \      0x124   0x2A00'0001        BCS      ??usartd_transfer_8
    323          			tmode = USARTD_MODE_POLLING;
   \      0x128   0xE3A0'0000        MOV      R0,#+0
   \      0x12C   0xE1B0'9000        MOVS     R9,R0
    324          
    325          	switch (tmode) {
   \                     ??usartd_transfer_8:
   \      0x130   0xE1B0'0009        MOVS     R0,R9
   \      0x134   0xE6EF'0070        UXTB     R0,R0
   \      0x138   0xE350'0000        CMP      R0,#+0
   \      0x13C   0x0A00'0003        BEQ      ??usartd_transfer_9
   \      0x140   0xE350'0002        CMP      R0,#+2
   \      0x144   0x0A00'00AC        BEQ      ??usartd_transfer_10
   \      0x148   0x3A00'009A        BCC      ??usartd_transfer_11
   \      0x14C   0xEA00'00B5        B        ??usartd_transfer_12
    326          	case USARTD_MODE_POLLING:
    327          		i = 0;
   \                     ??usartd_transfer_9:
   \      0x150   0xE3A0'A000        MOV      R10,#+0
   \      0x154   0xE1B0'B00A        MOVS     R11,R10
    328          
    329          		if (buf->attr & USARTD_BUF_ATTR_READ) {
   \      0x158   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \      0x15C   0xE310'0002        TST      R0,#0x2
   \      0x160   0x0A00'0003        BEQ      ??usartd_transfer_13
    330          			desc->addr->US_CSR;
   \      0x164   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x168   0xE590'0014        LDR      R0,[R0, #+20]
    331          			usart_restart_rx_timeout(desc->addr);
   \      0x16C   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x170   0x....'....        BL       usart_restart_rx_timeout
    332          		}
    333          
    334          		while (i < buf->size) {
   \                     ??usartd_transfer_13:
   \      0x174   0xE595'0004        LDR      R0,[R5, #+4]
   \      0x178   0xE15B'0000        CMP      R11,R0
   \      0x17C   0x2A00'008C        BCS      ??usartd_transfer_14
    335          			if (i < desc->tx.buffer.size) {
   \      0x180   0xE597'0038        LDR      R0,[R7, #+56]
   \      0x184   0xE15B'0000        CMP      R11,R0
   \      0x188   0x2A00'003A        BCS      ??usartd_transfer_15
    336          #ifdef CONFIG_HAVE_USART_FIFO
    337          				if (desc->use_fifo) {
   \      0x18C   0xE5D7'004C        LDRB     R0,[R7, #+76]
   \      0x190   0xE350'0000        CMP      R0,#+0
   \      0x194   0x0A00'0022        BEQ      ??usartd_transfer_16
    338          					if ((desc->fifo.tx.size - usart_fifo_get_tx_size(desc->addr)) > 0) {
   \      0x198   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x19C   0x....'....        BL       usart_fifo_get_tx_size
   \      0x1A0   0xE1D7'15B2        LDRH     R1,[R7, #+82]
   \      0x1A4   0xE051'0000        SUBS     R0,R1,R0
   \      0x1A8   0xE350'0000        CMP      R0,#+0
   \      0x1AC   0x0A00'0026        BEQ      ??usartd_transfer_17
    339          						if ((desc->tx.buffer.size - i) >= 4) {
   \      0x1B0   0xE597'0038        LDR      R0,[R7, #+56]
   \      0x1B4   0xE050'000B        SUBS     R0,R0,R11
   \      0x1B8   0xE350'0004        CMP      R0,#+4
   \      0x1BC   0x3A00'0006        BCC      ??usartd_transfer_18
    340          							writew(&desc->addr->US_THR, *(uint32_t*)&desc->tx.buffer.data[i]);
   \      0x1C0   0xE597'0034        LDR      R0,[R7, #+52]
   \      0x1C4   0xE790'100B        LDR      R1,[R0, +R11]
   \      0x1C8   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x1CC   0xE290'001C        ADDS     R0,R0,#+28
   \      0x1D0   0x....'....        BL       writew
    341          							i += 4;
   \      0x1D4   0xE29B'B004        ADDS     R11,R11,#+4
   \      0x1D8   0xEA00'001B        B        ??usartd_transfer_17
    342          						} else if ((desc->tx.buffer.size - i) >= 2) {
   \                     ??usartd_transfer_18:
   \      0x1DC   0xE597'0038        LDR      R0,[R7, #+56]
   \      0x1E0   0xE050'000B        SUBS     R0,R0,R11
   \      0x1E4   0xE350'0002        CMP      R0,#+2
   \      0x1E8   0x3A00'0006        BCC      ??usartd_transfer_19
    343          							writehw(&desc->addr->US_THR, *(uint16_t*)&desc->tx.buffer.data[i]);
   \      0x1EC   0xE597'0034        LDR      R0,[R7, #+52]
   \      0x1F0   0xE190'10BB        LDRH     R1,[R0, +R11]
   \      0x1F4   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x1F8   0xE290'001C        ADDS     R0,R0,#+28
   \      0x1FC   0x....'....        BL       writehw
    344          							i += 2;
   \      0x200   0xE29B'B002        ADDS     R11,R11,#+2
   \      0x204   0xEA00'0010        B        ??usartd_transfer_17
    345          						} else {
    346          							writeb(&desc->addr->US_THR, *(uint8_t*)&desc->tx.buffer.data[i]);
   \                     ??usartd_transfer_19:
   \      0x208   0xE597'0034        LDR      R0,[R7, #+52]
   \      0x20C   0xE7D0'100B        LDRB     R1,[R0, +R11]
   \      0x210   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x214   0xE290'001C        ADDS     R0,R0,#+28
   \      0x218   0x....'....        BL       writeb
    347          							i += 1;
   \      0x21C   0xE29B'B001        ADDS     R11,R11,#+1
   \      0x220   0xEA00'0009        B        ??usartd_transfer_17
    348          						}
    349          					}
    350          				} else
    351          #endif /* CONFIG_HAVE_USART_FIFO */
    352          				{
    353          					/* Wait for the transmitter to be ready */
    354          					while (!USART_STATUS_TXRDY(desc->addr->US_CSR));
   \                     ??usartd_transfer_16:
   \      0x224   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x228   0xE590'0014        LDR      R0,[R0, #+20]
   \      0x22C   0xE310'0002        TST      R0,#0x2
   \      0x230   0x0AFF'FFFB        BEQ      ??usartd_transfer_16
    355          
    356          					writeb(&desc->addr->US_THR, desc->tx.buffer.data[i]);
   \      0x234   0xE597'0034        LDR      R0,[R7, #+52]
   \      0x238   0xE7D0'100B        LDRB     R1,[R0, +R11]
   \      0x23C   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x240   0xE290'001C        ADDS     R0,R0,#+28
   \      0x244   0x....'....        BL       writeb
    357          					i++;
   \      0x248   0xE29B'B001        ADDS     R11,R11,#+1
    358          				}
    359          				desc->tx.transferred = i;
   \                     ??usartd_transfer_17:
   \      0x24C   0xE1C7'B4B0        STRH     R11,[R7, #+64]
    360          
    361          				if (desc->tx.transferred >= desc->tx.buffer.size) {
   \      0x250   0xE1D7'04B0        LDRH     R0,[R7, #+64]
   \      0x254   0xE597'1038        LDR      R1,[R7, #+56]
   \      0x258   0xE150'0001        CMP      R0,R1
   \      0x25C   0x3A00'0005        BCC      ??usartd_transfer_15
    362          					desc->tx.buffer.size = 0;
   \      0x260   0xE587'A038        STR      R10,[R7, #+56]
    363          					mutex_unlock(&desc->tx.mutex);
   \      0x264   0xE297'0030        ADDS     R0,R7,#+48
   \      0x268   0x....'....        BL       mutex_unlock
    364          					callback_call(&desc->tx.callback, NULL);
   \      0x26C   0xE3A0'1000        MOV      R1,#+0
   \      0x270   0xE297'0044        ADDS     R0,R7,#+68
   \      0x274   0x....'....        BL       callback_call
    365          				}
    366          			}
    367          			if (i < desc->rx.buffer.size) {
   \                     ??usartd_transfer_15:
   \      0x278   0xE597'001C        LDR      R0,[R7, #+28]
   \      0x27C   0xE15B'0000        CMP      R11,R0
   \      0x280   0x2AFF'FFBB        BCS      ??usartd_transfer_13
    368          #ifdef CONFIG_HAVE_USART_FIFO
    369          				if (desc->use_fifo) {
   \      0x284   0xE5D7'004C        LDRB     R0,[R7, #+76]
   \      0x288   0xE350'0000        CMP      R0,#+0
   \      0x28C   0x0A00'0022        BEQ      ??usartd_transfer_20
    370          					if ((desc->fifo.rx.size - usart_fifo_get_rx_size(desc->addr)) > 0) {
   \      0x290   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x294   0x....'....        BL       usart_fifo_get_rx_size
   \      0x298   0xE1D7'14BE        LDRH     R1,[R7, #+78]
   \      0x29C   0xE051'0000        SUBS     R0,R1,R0
   \      0x2A0   0xE350'0000        CMP      R0,#+0
   \      0x2A4   0x0A00'0036        BEQ      ??usartd_transfer_21
    371          						if ((desc->rx.buffer.size - i) >= 4) {
   \      0x2A8   0xE597'001C        LDR      R0,[R7, #+28]
   \      0x2AC   0xE050'000B        SUBS     R0,R0,R11
   \      0x2B0   0xE350'0004        CMP      R0,#+4
   \      0x2B4   0x3A00'0006        BCC      ??usartd_transfer_22
    372          							readw(&desc->addr->US_RHR, (uint32_t*)&desc->rx.buffer.data[i]);
   \      0x2B8   0xE597'0018        LDR      R0,[R7, #+24]
   \      0x2BC   0xE090'100B        ADDS     R1,R0,R11
   \      0x2C0   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x2C4   0xE290'0018        ADDS     R0,R0,#+24
   \      0x2C8   0x....'....        BL       readw
    373          							i += 4;
   \      0x2CC   0xE29B'B004        ADDS     R11,R11,#+4
   \      0x2D0   0xEA00'002B        B        ??usartd_transfer_21
    374          						} else if (usart_fifo_get_rx_size(desc->addr) >= 2) {
   \                     ??usartd_transfer_22:
   \      0x2D4   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x2D8   0x....'....        BL       usart_fifo_get_rx_size
   \      0x2DC   0xE350'0002        CMP      R0,#+2
   \      0x2E0   0x3A00'0006        BCC      ??usartd_transfer_23
    375          							readhw(&desc->addr->US_RHR, (uint16_t*)&desc->rx.buffer.data[i]);
   \      0x2E4   0xE597'0018        LDR      R0,[R7, #+24]
   \      0x2E8   0xE090'100B        ADDS     R1,R0,R11
   \      0x2EC   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x2F0   0xE290'0018        ADDS     R0,R0,#+24
   \      0x2F4   0x....'....        BL       readhw
    376          							i += 2;
   \      0x2F8   0xE29B'B002        ADDS     R11,R11,#+2
   \      0x2FC   0xEA00'0020        B        ??usartd_transfer_21
    377          						} else {
    378          							readb(&desc->addr->US_RHR, (uint8_t*)&desc->rx.buffer.data[i]);
   \                     ??usartd_transfer_23:
   \      0x300   0xE597'0018        LDR      R0,[R7, #+24]
   \      0x304   0xE090'100B        ADDS     R1,R0,R11
   \      0x308   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x30C   0xE290'0018        ADDS     R0,R0,#+24
   \      0x310   0x....'....        BL       readb
    379          							i += 1;
   \      0x314   0xE29B'B001        ADDS     R11,R11,#+1
   \      0x318   0xEA00'0019        B        ??usartd_transfer_21
    380          						}
    381          					}
    382          				} else
    383          #endif /* CONFIG_HAVE_USART_FIFO */
    384          				{
    385          					/* Wait for the transmitter to be ready */
    386          					csr = desc->addr->US_CSR;
   \                     ??usartd_transfer_20:
   \      0x31C   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x320   0xE590'0014        LDR      R0,[R0, #+20]
   \      0x324   0xE1B0'8000        MOVS     R8,R0
    387          					while (!USART_STATUS_RXRDY(csr)) {
   \                     ??usartd_transfer_24:
   \      0x328   0xE318'0001        TST      R8,#0x1
   \      0x32C   0x1A00'000E        BNE      ??usartd_transfer_25
    388          						if (USART_STATUS_TIMEOUT(csr)) {
   \      0x330   0xE318'0F40        TST      R8,#0x100
   \      0x334   0x0A00'0008        BEQ      ??usartd_transfer_26
    389          							desc->addr->US_CR = US_CR_STTTO;
   \      0x338   0xE3A0'0E80        MOV      R0,#+2048
   \      0x33C   0xE597'1000        LDR      R1,[R7, #+0]
   \      0x340   0xE581'0000        STR      R0,[R1, #+0]
    390          							desc->rx.buffer.size = 0;
   \      0x344   0xE587'A01C        STR      R10,[R7, #+28]
    391          							desc->rx.transferred = i;
   \      0x348   0xE1C7'B2B4        STRH     R11,[R7, #+36]
    392          							mutex_unlock(&desc->rx.mutex);
   \      0x34C   0xE297'0014        ADDS     R0,R7,#+20
   \      0x350   0x....'....        BL       mutex_unlock
    393          							return USARTD_ERROR_TIMEOUT;
   \      0x354   0xE3A0'0005        MOV      R0,#+5
   \      0x358   0xEA00'003A        B        ??usartd_transfer_3
    394          						}
    395          						csr = desc->addr->US_CSR;
   \                     ??usartd_transfer_26:
   \      0x35C   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x360   0xE590'0014        LDR      R0,[R0, #+20]
   \      0x364   0xE1B0'8000        MOVS     R8,R0
   \      0x368   0xEAFF'FFEE        B        ??usartd_transfer_24
    396          					}
    397          
    398          					readb(&desc->addr->US_RHR, &desc->rx.buffer.data[i]);
   \                     ??usartd_transfer_25:
   \      0x36C   0xE597'0018        LDR      R0,[R7, #+24]
   \      0x370   0xE090'100B        ADDS     R1,R0,R11
   \      0x374   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x378   0xE290'0018        ADDS     R0,R0,#+24
   \      0x37C   0x....'....        BL       readb
    399          					i++;
   \      0x380   0xE29B'B001        ADDS     R11,R11,#+1
    400          				}
    401          				desc->rx.transferred = i;
   \                     ??usartd_transfer_21:
   \      0x384   0xE1C7'B2B4        STRH     R11,[R7, #+36]
    402          
    403          				if (desc->rx.transferred >= desc->rx.buffer.size) {
   \      0x388   0xE1D7'02B4        LDRH     R0,[R7, #+36]
   \      0x38C   0xE597'101C        LDR      R1,[R7, #+28]
   \      0x390   0xE150'0001        CMP      R0,R1
   \      0x394   0x3AFF'FF76        BCC      ??usartd_transfer_13
    404          					desc->rx.buffer.size = 0;
   \      0x398   0xE587'A01C        STR      R10,[R7, #+28]
    405          					mutex_unlock(&desc->rx.mutex);
   \      0x39C   0xE297'0014        ADDS     R0,R7,#+20
   \      0x3A0   0x....'....        BL       mutex_unlock
    406          					callback_call(&desc->rx.callback, NULL);
   \      0x3A4   0xE3A0'1000        MOV      R1,#+0
   \      0x3A8   0xE297'0028        ADDS     R0,R7,#+40
   \      0x3AC   0x....'....        BL       callback_call
   \      0x3B0   0xEAFF'FF6F        B        ??usartd_transfer_13
    407          				}
    408          			}
    409          		}
    410          		break;
   \                     ??usartd_transfer_14:
   \      0x3B4   0xEA00'0022        B        ??usartd_transfer_27
    411          
    412          	case USARTD_MODE_ASYNC:
    413          		if (buf->attr & USARTD_BUF_ATTR_WRITE)
   \                     ??usartd_transfer_11:
   \      0x3B8   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \      0x3BC   0xE310'0001        TST      R0,#0x1
   \      0x3C0   0x0A00'0002        BEQ      ??usartd_transfer_28
    414          			usart_enable_it(desc->addr, US_IER_TXRDY);
   \      0x3C4   0xE3A0'1002        MOV      R1,#+2
   \      0x3C8   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x3CC   0x....'....        BL       usart_enable_it
    415          
    416          		if (buf->attr & USARTD_BUF_ATTR_READ) {
   \                     ??usartd_transfer_28:
   \      0x3D0   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \      0x3D4   0xE310'0002        TST      R0,#0x2
   \      0x3D8   0x0A00'0006        BEQ      ??usartd_transfer_29
    417          			usart_get_status(desc->addr);
   \      0x3DC   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x3E0   0x....'....        BL       usart_get_status
    418          
    419          			usart_restart_rx_timeout(desc->addr);
   \      0x3E4   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x3E8   0x....'....        BL       usart_restart_rx_timeout
    420          			usart_enable_it(desc->addr, US_IER_RXRDY | US_IER_TIMEOUT);
   \      0x3EC   0xE300'1101        MOVW     R1,#+257
   \      0x3F0   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x3F4   0x....'....        BL       usart_enable_it
    421          		}
    422          		break;
   \                     ??usartd_transfer_29:
   \      0x3F8   0xEA00'0011        B        ??usartd_transfer_27
    423          
    424          	case USARTD_MODE_DMA:
    425          		if (buf->attr & USARTD_BUF_ATTR_WRITE)
   \                     ??usartd_transfer_10:
   \      0x3FC   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \      0x400   0xE310'0001        TST      R0,#0x1
   \      0x404   0x0A00'0001        BEQ      ??usartd_transfer_30
    426          			_usartd_dma_write(0);
   \      0x408   0xE3A0'0000        MOV      R0,#+0
   \      0x40C   0x....'....        BL       _usartd_dma_write
    427          		if (buf->attr & USARTD_BUF_ATTR_READ)
   \                     ??usartd_transfer_30:
   \      0x410   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \      0x414   0xE310'0002        TST      R0,#0x2
   \      0x418   0x0A00'0001        BEQ      ??usartd_transfer_31
    428          			_usartd_dma_read(0);
   \      0x41C   0xE3A0'0000        MOV      R0,#+0
   \      0x420   0x....'....        BL       _usartd_dma_read
    429          		break;
   \                     ??usartd_transfer_31:
   \      0x424   0xEA00'0006        B        ??usartd_transfer_27
    430          
    431          	default:
    432          		trace_fatal("Unknown Usart mode!\r\n");
   \                     ??usartd_transfer_12:
   \      0x428   0x....'....        LDR      R0,??DataTable13_6
   \      0x42C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x430   0xE350'0000        CMP      R0,#+0
   \      0x434   0x0A00'0001        BEQ      ??usartd_transfer_32
   \      0x438   0x....'....        LDR      R0,??DataTable13_7
   \      0x43C   0x....'....        BL       printf
   \                     ??usartd_transfer_32:
   \      0x440   0xEAFF'FFFE        B        ??usartd_transfer_32
    433          	}
    434          
    435          	return USARTD_SUCCESS;
   \                     ??usartd_transfer_27:
   \      0x444   0xE3A0'0000        MOV      R0,#+0
   \                     ??usartd_transfer_3:
   \      0x448   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    436          }
    437          

   \                                 In section SOFTPACK, align 4, keep-with-next
    438          void usartd_finish_rx_transfer(uint8_t iface)
    439          {
   \                     usartd_finish_rx_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    440          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_finish_rx_transfer_0
   \       0x18   0xE3A0'2F6E        MOV      R2,#+440
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    441          	mutex_unlock(&_serial[iface]->rx.mutex);
   \                     ??usartd_finish_rx_transfer_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0014        ADDS     R0,R0,#+20
   \       0x44   0x....'....        BL       mutex_unlock
    442          }
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
    443          

   \                                 In section SOFTPACK, align 4, keep-with-next
    444          void usartd_finish_tx_transfer(uint8_t iface)
    445          {
   \                     usartd_finish_tx_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    446          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_finish_tx_transfer_0
   \       0x18   0xE300'21BE        MOVW     R2,#+446
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    447          	mutex_unlock(&_serial[iface]->tx.mutex);
   \                     ??usartd_finish_tx_transfer_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0030        ADDS     R0,R0,#+48
   \       0x44   0x....'....        BL       mutex_unlock
    448          }
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
    449          

   \                                 In section SOFTPACK, align 4, keep-with-next
    450          uint32_t usartd_rx_is_busy(const uint8_t iface)
    451          {
   \                     usartd_rx_is_busy:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    452          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_rx_is_busy_0
   \       0x18   0xE3A0'2F71        MOV      R2,#+452
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    453          	return mutex_is_locked(&_serial[iface]->rx.mutex);
   \                     ??usartd_rx_is_busy_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0014        ADDS     R0,R0,#+20
   \       0x44   0x....'....        BL       mutex_is_locked
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
    454          }
    455          

   \                                 In section SOFTPACK, align 4, keep-with-next
    456          uint32_t usartd_tx_is_busy(const uint8_t iface)
    457          {
   \                     usartd_tx_is_busy:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    458          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_tx_is_busy_0
   \       0x18   0xE300'21CA        MOVW     R2,#+458
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    459          	return mutex_is_locked(&_serial[iface]->tx.mutex);
   \                     ??usartd_tx_is_busy_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0030        ADDS     R0,R0,#+48
   \       0x44   0x....'....        BL       mutex_is_locked
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
    460          }
    461          

   \                                 In section SOFTPACK, align 4, keep-with-next
    462          void usartd_wait_rx_transfer(const uint8_t iface)
    463          {
   \                     usartd_wait_rx_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    464          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_wait_rx_transfer_0
   \       0x18   0xE3A0'2F74        MOV      R2,#+464
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    465          	while (mutex_is_locked(&_serial[iface]->rx.mutex));
   \                     ??usartd_wait_rx_transfer_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0014        ADDS     R0,R0,#+20
   \       0x44   0x....'....        BL       mutex_is_locked
   \       0x48   0xE350'0000        CMP      R0,#+0
   \       0x4C   0x1AFF'FFF6        BNE      ??usartd_wait_rx_transfer_0
    466          }
   \       0x50   0xE8BD'8010        POP      {R4,PC}          ;; return
    467          

   \                                 In section SOFTPACK, align 4, keep-with-next
    468          void usartd_wait_tx_transfer(const uint8_t iface)
    469          {
   \                     usartd_wait_tx_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    470          	assert(iface < USART_IFACE_COUNT);
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0xE6EF'0070        UXTB     R0,R0
   \       0x10   0xE350'0005        CMP      R0,#+5
   \       0x14   0xBA00'0004        BLT      ??usartd_wait_tx_transfer_0
   \       0x18   0xE300'21D6        MOVW     R2,#+470
   \       0x1C   0x....'....        LDR      R1,??DataTable13
   \       0x20   0x....'....        LDR      R0,??DataTable13_1
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
    471          	while (mutex_is_locked(&_serial[iface]->tx.mutex));
   \                     ??usartd_wait_tx_transfer_0:
   \       0x2C   0x....'....        LDR      R0,??DataTable13_2
   \       0x30   0xE1B0'1004        MOVS     R1,R4
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0xE1B0'1101        LSLS     R1,R1,#+2
   \       0x3C   0xE790'0001        LDR      R0,[R0, +R1]
   \       0x40   0xE290'0030        ADDS     R0,R0,#+48
   \       0x44   0x....'....        BL       mutex_is_locked
   \       0x48   0xE350'0000        CMP      R0,#+0
   \       0x4C   0x1AFF'FFF6        BNE      ??usartd_wait_tx_transfer_0
    472          }
   \       0x50   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     _serial

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x66          DC8 "iface < (5)"

   \              0x61 0x63    

   \              0x65 0x20    

   \              0x3C 0x20    

   \              0x28 0x35    

   \              0x29 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6C

   \              0x73 0x65    

   \              0x72 0x69    

   \              0x61 0x6C
   \       0x40   0x5C 0x75          DC8 0x5C, 0x75, 0x73, 0x61, 0x72, 0x74, 0x64, 0x2E

   \              0x73 0x61    

   \              0x72 0x74    

   \              0x64 0x2E
   \       0x48   0x63 0x00          DC8 0x63, 0
   \       0x4A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x64          DC8 "id < (79)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x37 0x39    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x63 0x6F          DC8 "config->dma.rx.channel"

   \              0x6E 0x66    

   \              0x69 0x67    

   \              0x2D 0x3E    

   \              0x64 0x6D    

   \              0x61 0x2E    

   \              0x72 0x78    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x17   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x63 0x6F          DC8 "config->dma.tx.channel"

   \              0x6E 0x66    

   \              0x69 0x67    

   \              0x2D 0x3E    

   \              0x64 0x6D    

   \              0x61 0x2E    

   \              0x74 0x78    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x17   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x2D 0x46          DC8 "-F- Unknown Usart mode!\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x6B 0x6E    

   \              0x6F 0x77    

   \              0x6E 0x20    

   \              0x55 0x73    

   \              0x61 0x72    

   \              0x74 0x20    

   \              0x6D 0x6F    

   \              0x64 0x65    

   \              0x21 0x0D    

   \              0x0A 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   _usartd_dma_read
        32   -> __aeabi_assert
        32   -> __aeabi_memset
        32   -> __iar_EmptyStepPoint
        32   -> callback_set
        32   -> dma_configure_transfer
        32   -> dma_set_callback
        32   -> dma_start_transfer
        32   -> usart_enable_it
        32   -> usart_restart_rx_timeout
      24   _usartd_dma_read_callback
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> cache_invalidate_region
        24   -> callback_call
        24   -> dma_fifo_flush
        24   -> dma_get_transferred_data_len
        24   -> dma_is_transfer_done
        24   -> dma_reset_channel
        24   -> dma_stop_transfer
        24   -> mutex_unlock
        24   -> usart_disable_it
      32   _usartd_dma_write
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> cache_clean_region
        32   -> callback_set
        32   -> dma_configure_transfer
        32   -> dma_set_callback
        32   -> dma_start_transfer
      24   _usartd_dma_write_callback
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> callback_call
        24   -> dma_reset_channel
        24   -> mutex_unlock
      48   _usartd_handler
        48   -> _usartd_dma_read_callback
        48   -> get_usart_addr_from_id
        48   -> mutex_unlock
        48   -> usart_disable_it
        48   -> usart_enable_it
        48   -> usart_get_char
        48   -> usart_get_masked_status
        48   -> usart_put_char
       0   readb
       0   readhw
       0   readw
      24   usartd_configure
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> dma_allocate_channel
        24   -> flexcom_select
        24   -> get_flexcom_addr_from_id
        24   -> get_peripheral_fifo_depth
        24   -> get_usart_id_from_addr
        24   -> irq_add_handler
        24   -> irq_enable
        24   -> pmc_configure_peripheral
        24   -> usart_configure
        24   -> usart_fifo_configure
        24   -> usart_fifo_enable
        24   -> usart_set_rx_timeout
       8   usartd_finish_rx_transfer
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_unlock
       8   usartd_finish_tx_transfer
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_unlock
       8   usartd_rx_is_busy
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_is_locked
      40   usartd_transfer
        40   -> __aeabi_assert
        40   -> __iar_EmptyStepPoint
        40   -> _usartd_dma_read
        40   -> _usartd_dma_write
        40   -> callback_call
        40   -> callback_copy
        40   -> mutex_try_lock
        40   -> mutex_unlock
        40   -> printf
        40   -> readb
        40   -> readhw
        40   -> readw
        40   -> usart_enable_it
        40   -> usart_fifo_get_rx_size
        40   -> usart_fifo_get_tx_size
        40   -> usart_get_status
        40   -> usart_restart_rx_timeout
        40   -> writeb
        40   -> writehw
        40   -> writew
       8   usartd_tx_is_busy
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_is_locked
       8   usartd_wait_rx_transfer
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_is_locked
       8   usartd_wait_tx_transfer
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> mutex_is_locked
       0   writeb
       0   writehw
       0   writew


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
      12  ?_0
      76  ?_1
      12  ?_2
      24  ?_3
      24  ?_4
      28  ?_5
      20  _serial
     208  _usartd_dma_read
     236  _usartd_dma_read_callback
     176  _usartd_dma_write
     140  _usartd_dma_write_callback
     556  _usartd_handler
      12  readb
      12  readhw
      12  readw
     448  usartd_configure
      76  usartd_finish_rx_transfer
      76  usartd_finish_tx_transfer
      76  usartd_rx_is_busy
   1'100  usartd_transfer
      76  usartd_tx_is_busy
      84  usartd_wait_rx_transfer
      84  usartd_wait_tx_transfer
       8  writeb
       8  writehw
       8  writew

 
    20 bytes in section .bss
   176 bytes in section .rodata
 3'428 bytes in section SOFTPACK
 
 3'428 bytes of CODE  memory
   176 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
