###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         05/Jan/2021  12:18:35
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twid.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWAC8C.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twid.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List\twid.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj\twid.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twid.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <assert.h>
     35          #include <string.h>
     36          
     37          #include "callback.h"
     38          #include "dma/dma.h"
     39          #include "errno.h"
     40          #include "i2c/twi.h"
     41          #include "i2c/twid.h"
     42          #include "io.h"
     43          #include "irq/irq.h"
     44          #include "mm/cache.h"
     45          #include "peripherals/bus.h"
     46          #ifdef CONFIG_HAVE_FLEXCOM
     47          #include "peripherals/flexcom.h"
     48          #endif
     49          #include "peripherals/pmc.h"
     50          #include "timer.h"
     51          #include "trace.h"
     52          
     53          /*----------------------------------------------------------------------------
     54           *        Definitions
     55           *----------------------------------------------------------------------------*/
     56          
     57          #define TWID_POLLING_THRESHOLD  16
     58          #define TWID_TIMEOUT            100
     59          
     60          /** \brief twi asynchronous transfer descriptor.*/
     61          struct _async_desc
     62          {
     63          	bool master;
     64          	union {
     65          		struct _twi_desc *twi_desc;
     66          		struct _twi_slave_desc *twi_slave_desc;
     67          	};
     68          	uint32_t twi_id;
     69          	struct _buffer buf;
     70          	uint32_t transferred; /**< Number of already transferred bytes. */
     71          };
     72          
     73          /*----------------------------------------------------------------------------
     74           *        Local variables
     75           *----------------------------------------------------------------------------*/
     76          

   \                                 In section .bss, align 4
     77          static struct _async_desc async_desc[TWI_IFACE_COUNT];
   \                     async_desc:
   \        0x0                      DS8 84

   \                                 In section .bss, align 1
     78          static uint8_t adesc_index = 0;
   \                     adesc_index:
   \        0x0                      DS8 1
     79          
     80          /*----------------------------------------------------------------------------
     81           *        Local functions
     82           *----------------------------------------------------------------------------*/
     83          
     84          /*
     85           *
     86           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     87          static bool _check_nack(struct _twi_desc *desc)
     88          {
   \                     _check_nack:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
     89          #ifdef CONFIG_HAVE_TWI_FIFO
     90          	if (desc->use_fifo) {
     91          		if (twi_fifo_is_locked(desc->addr)) {
     92          			twi_fifo_unlock(desc->addr);
     93          			twi_fifo_flush_tx(desc->addr);
     94          			trace_error("twid: command NACK\r\n");
     95          			twid_configure(desc);
     96          			return true;
     97          		}
     98          
     99          		return false;
    100          	}
    101          #endif
    102          
    103          	if (twi_get_status(desc->addr) & TWI_SR_NACK) {
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       twi_get_status
   \       0x10   0xE310'0F40        TST      R0,#0x100
   \       0x14   0x0A00'0009        BEQ      ??_check_nack_0
    104          		trace_error("twid: command NACK\r\n");
   \       0x18   0x....'....        LDR      R0,??DataTable7
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0xE350'0002        CMP      R0,#+2
   \       0x24   0x3A00'0001        BCC      ??_check_nack_1
   \       0x28   0x....'....        LDR      R0,??DataTable8
   \       0x2C   0x....'....        BL       printf
    105          		twid_configure(desc);
   \                     ??_check_nack_1:
   \       0x30   0xE1B0'0004        MOVS     R0,R4
   \       0x34   0x....'....        BL       twid_configure
    106          		return true;
   \       0x38   0xE3A0'0001        MOV      R0,#+1
   \       0x3C   0xEA00'0000        B        ??_check_nack_2
    107          	}
    108          
    109          	return false;
   \                     ??_check_nack_0:
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \                     ??_check_nack_2:
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
    110          }
    111          
    112          /*
    113           *
    114           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    115          static bool _check_rx_timeout(struct _twi_desc* desc)
    116          {
   \                     _check_rx_timeout:
   \        0x0   0xE92D'401F        PUSH     {R0-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    117          	struct _timeout timeout;
    118          
    119          #ifdef CONFIG_HAVE_TWI_FIFO
    120          	if (desc->use_fifo)
    121          		return false;
    122          #endif
    123          
    124          	timer_start_timeout(&timeout, desc->timeout);
   \        0x8   0xE594'2014        LDR      R2,[R4, #+20]
   \        0xC   0xE3B0'3000        MOVS     R3,#+0
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        BL       timer_start_timeout
    125          	while (!twi_is_byte_received(desc->addr)) {
   \                     ??_check_rx_timeout_0:
   \       0x18   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       twi_is_byte_received
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'000D        BNE      ??_check_rx_timeout_1
    126          		if (timer_timeout_reached(&timeout)) {
   \       0x28   0xE1B0'000D        MOVS     R0,SP
   \       0x2C   0x....'....        BL       timer_timeout_reached
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0AFF'FFF7        BEQ      ??_check_rx_timeout_0
    127          			trace_error("twid: Device doesn't answer (RX TIMEOUT)\r\n");
   \       0x38   0x....'....        LDR      R0,??DataTable7
   \       0x3C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x40   0xE350'0002        CMP      R0,#+2
   \       0x44   0x3A00'0001        BCC      ??_check_rx_timeout_2
   \       0x48   0x....'....        LDR      R0,??DataTable8_1
   \       0x4C   0x....'....        BL       printf
    128          			twid_configure(desc);
   \                     ??_check_rx_timeout_2:
   \       0x50   0xE1B0'0004        MOVS     R0,R4
   \       0x54   0x....'....        BL       twid_configure
    129          			return true;
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xEA00'0000        B        ??_check_rx_timeout_3
    130          		}
    131          	}
    132          
    133          	return false;
   \                     ??_check_rx_timeout_1:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \                     ??_check_rx_timeout_3:
   \       0x64   0xE28D'D010        ADD      SP,SP,#+16
   \       0x68   0xE8BD'8010        POP      {R4,PC}          ;; return
    134          }
    135          
    136          /*
    137           *
    138           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    139          static bool _check_tx_timeout(struct _twi_desc* desc)
    140          {
   \                     _check_tx_timeout:
   \        0x0   0xE92D'401F        PUSH     {R0-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    141          	struct _timeout timeout;
    142          
    143          #ifdef CONFIG_HAVE_TWI_FIFO
    144          	if (desc->use_fifo)
    145          		return false;
    146          #endif
    147          
    148          	timer_start_timeout(&timeout, desc->timeout);
   \        0x8   0xE594'2014        LDR      R2,[R4, #+20]
   \        0xC   0xE3B0'3000        MOVS     R3,#+0
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        BL       timer_start_timeout
    149          	while (!twi_is_byte_sent(desc->addr)) {
   \                     ??_check_tx_timeout_0:
   \       0x18   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       twi_is_byte_sent
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'000D        BNE      ??_check_tx_timeout_1
    150          		if (timer_timeout_reached(&timeout)) {
   \       0x28   0xE1B0'000D        MOVS     R0,SP
   \       0x2C   0x....'....        BL       timer_timeout_reached
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0AFF'FFF7        BEQ      ??_check_tx_timeout_0
    151          			trace_error("twid: Device doesn't answer (TX TIMEOUT)\r\n");
   \       0x38   0x....'....        LDR      R0,??DataTable7
   \       0x3C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x40   0xE350'0002        CMP      R0,#+2
   \       0x44   0x3A00'0001        BCC      ??_check_tx_timeout_2
   \       0x48   0x....'....        LDR      R0,??DataTable8_2
   \       0x4C   0x....'....        BL       printf
    152          			twid_configure(desc);
   \                     ??_check_tx_timeout_2:
   \       0x50   0xE1B0'0004        MOVS     R0,R4
   \       0x54   0x....'....        BL       twid_configure
    153          			return true;
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xEA00'0000        B        ??_check_tx_timeout_3
    154          		}
    155          	}
    156          
    157          	return false;
   \                     ??_check_tx_timeout_1:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \                     ??_check_tx_timeout_3:
   \       0x64   0xE28D'D010        ADD      SP,SP,#+16
   \       0x68   0xE8BD'8010        POP      {R4,PC}          ;; return
    158          }
    159          

   \                                 In section SOFTPACK, align 4, keep-with-next
    160          static int _twid_wait_twi_transfer(struct _twi_desc* desc)
    161          {
   \                     _twid_wait_twi_transfer:
   \        0x0   0xE92D'401F        PUSH     {R0-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    162          	struct _timeout timeout;
    163          
    164          	timer_start_timeout(&timeout, desc->timeout);
   \        0x8   0xE594'2014        LDR      R2,[R4, #+20]
   \        0xC   0xE3B0'3000        MOVS     R3,#+0
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        BL       timer_start_timeout
    165          	while (!twi_is_transfer_complete(desc->addr)) {
   \                     ??_twid_wait_twi_transfer_0:
   \       0x18   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x1C   0x....'....        BL       twi_is_transfer_complete
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'000D        BNE      ??_twid_wait_twi_transfer_1
    166          		if (timer_timeout_reached(&timeout)) {
   \       0x28   0xE1B0'000D        MOVS     R0,SP
   \       0x2C   0x....'....        BL       timer_timeout_reached
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0AFF'FFF7        BEQ      ??_twid_wait_twi_transfer_0
    167          			trace_error("twid: Unable to complete transfer!\r\n");
   \       0x38   0x....'....        LDR      R0,??DataTable7
   \       0x3C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x40   0xE350'0002        CMP      R0,#+2
   \       0x44   0x3A00'0001        BCC      ??_twid_wait_twi_transfer_2
   \       0x48   0x....'....        LDR      R0,??DataTable8_3
   \       0x4C   0x....'....        BL       printf
    168          			twid_configure(desc);
   \                     ??_twid_wait_twi_transfer_2:
   \       0x50   0xE1B0'0004        MOVS     R0,R4
   \       0x54   0x....'....        BL       twid_configure
    169          			return -ETIMEDOUT;
   \       0x58   0xE3E0'004C        MVN      R0,#+76
   \       0x5C   0xEA00'0000        B        ??_twid_wait_twi_transfer_3
    170          		}
    171          	}
    172          
    173          	return 0;
   \                     ??_twid_wait_twi_transfer_1:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \                     ??_twid_wait_twi_transfer_3:
   \       0x64   0xE28D'D010        ADD      SP,SP,#+16
   \       0x68   0xE8BD'8010        POP      {R4,PC}          ;; return
    174          }
    175          

   \                                 In section SOFTPACK, align 4, keep-with-next
    176          static int _twid_dma_read_callback(void* arg, void* arg2)
    177          {
   \                     _twid_dma_read_callback:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    178          	struct _twi_desc* desc = (struct _twi_desc *)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
    179          
    180          	cache_invalidate_region(desc->dma.rx.cfg.daddr, desc->dma.rx.cfg.len);
   \       0x10   0xE596'103C        LDR      R1,[R6, #+60]
   \       0x14   0xE596'0038        LDR      R0,[R6, #+56]
   \       0x18   0x....'....        BL       cache_invalidate_region
    181          
    182          	dma_reset_channel(desc->dma.rx.channel);
   \       0x1C   0xE596'0024        LDR      R0,[R6, #+36]
   \       0x20   0x....'....        BL       dma_reset_channel
    183          
    184          	if (_check_rx_timeout(desc)) {
   \       0x24   0xE1B0'0006        MOVS     R0,R6
   \       0x28   0x....'....        BL       _check_rx_timeout
   \       0x2C   0xE350'0000        CMP      R0,#+0
   \       0x30   0x0A00'0003        BEQ      ??_twid_dma_read_callback_0
    185          		mutex_unlock(&desc->mutex);
   \       0x34   0xE296'0018        ADDS     R0,R6,#+24
   \       0x38   0x....'....        BL       mutex_unlock
    186          		return -ETIMEDOUT;
   \       0x3C   0xE3E0'004C        MVN      R0,#+76
   \       0x40   0xEA00'001D        B        ??_twid_dma_read_callback_1
    187          	}
    188          
    189          	if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \                     ??_twid_dma_read_callback_0:
   \       0x44   0xE1D6'01B0        LDRH     R0,[R6, #+16]
   \       0x48   0xE310'0D80        TST      R0,#0x2000
   \       0x4C   0x0A00'0001        BEQ      ??_twid_dma_read_callback_2
    190          		twi_send_stop_condition(desc->addr);
   \       0x50   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x54   0x....'....        BL       twi_send_stop_condition
    191          
    192          #ifdef CONFIG_HAVE_FIFO
    193          	if (!desc->use_fifo)
    194          #endif
    195          	{
    196          		((uint8_t*)desc->dma.rx.cfg.daddr)[desc->dma.rx.cfg.len] = twi_read_byte(desc->addr);
   \                     ??_twid_dma_read_callback_2:
   \       0x58   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x5C   0x....'....        BL       twi_read_byte
   \       0x60   0xE596'1038        LDR      R1,[R6, #+56]
   \       0x64   0xE596'203C        LDR      R2,[R6, #+60]
   \       0x68   0xE7C1'0002        STRB     R0,[R1, +R2]
    197          
    198          		if (_check_rx_timeout(desc)) {
   \       0x6C   0xE1B0'0006        MOVS     R0,R6
   \       0x70   0x....'....        BL       _check_rx_timeout
   \       0x74   0xE350'0000        CMP      R0,#+0
   \       0x78   0x0A00'0003        BEQ      ??_twid_dma_read_callback_3
    199          			mutex_unlock(&desc->mutex);
   \       0x7C   0xE296'0018        ADDS     R0,R6,#+24
   \       0x80   0x....'....        BL       mutex_unlock
    200          			return -ETIMEDOUT;
   \       0x84   0xE3E0'004C        MVN      R0,#+76
   \       0x88   0xEA00'000B        B        ??_twid_dma_read_callback_1
    201          		}
    202          
    203          		((uint8_t*)desc->dma.rx.cfg.daddr)[desc->dma.rx.cfg.len + 1] = twi_read_byte(desc->addr);
   \                     ??_twid_dma_read_callback_3:
   \       0x8C   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x90   0x....'....        BL       twi_read_byte
   \       0x94   0xE596'1038        LDR      R1,[R6, #+56]
   \       0x98   0xE596'203C        LDR      R2,[R6, #+60]
   \       0x9C   0xE091'1002        ADDS     R1,R1,R2
   \       0xA0   0xE5C1'0001        STRB     R0,[R1, #+1]
    204          	}
    205          
    206          	mutex_unlock(&desc->mutex);
   \       0xA4   0xE296'0018        ADDS     R0,R6,#+24
   \       0xA8   0x....'....        BL       mutex_unlock
    207          
    208          	callback_call(&desc->callback, NULL);
   \       0xAC   0xE3A0'1000        MOV      R1,#+0
   \       0xB0   0xE296'001C        ADDS     R0,R6,#+28
   \       0xB4   0x....'....        BL       callback_call
    209          
    210          	return 0;
   \       0xB8   0xE3A0'0000        MOV      R0,#+0
   \                     ??_twid_dma_read_callback_1:
   \       0xBC   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    211          }
    212          

   \                                 In section SOFTPACK, align 4, keep-with-next
    213          static void _twid_dma_read(struct _twi_desc* desc, struct _buffer* buffer)
    214          {
   \                     _twid_dma_read:
   \        0x0   0xE92D'43FE        PUSH     {R1-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    215          	struct _callback _cb;
    216          	uint32_t id = get_twi_id_from_addr(desc->addr);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_twi_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    217          
    218          	memset(&desc->dma.rx.cfg, 0x0, sizeof(desc->dma.rx.cfg));
   \       0x18   0xE3A0'700C        MOV      R7,#+12
   \       0x1C   0xE3A0'8000        MOV      R8,#+0
   \       0x20   0xE294'9034        ADDS     R9,R4,#+52
   \       0x24   0xE1B0'2008        MOVS     R2,R8
   \       0x28   0xE1B0'1007        MOVS     R1,R7
   \       0x2C   0xE1B0'0009        MOVS     R0,R9
   \       0x30   0x....'....        BL       __aeabi_memset
   \       0x34   0xE1B0'0009        MOVS     R0,R9
    219          
    220          	desc->dma.rx.cfg.saddr = (void*)&desc->addr->TWI_RHR;
   \       0x38   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x3C   0xE290'0030        ADDS     R0,R0,#+48
   \       0x40   0xE584'0034        STR      R0,[R4, #+52]
    221          	desc->dma.rx.cfg.daddr = buffer->data;
   \       0x44   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x48   0xE584'0038        STR      R0,[R4, #+56]
    222          
    223          	if(!desc->dma.rx.channel)
   \       0x4C   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x1A00'0004        BNE      ??_twid_dma_read_0
    224          		desc->dma.rx.channel = dma_allocate_channel(id, DMA_PERIPH_MEMORY);
   \       0x58   0xE3A0'10FF        MOV      R1,#+255
   \       0x5C   0xE1B0'0006        MOVS     R0,R6
   \       0x60   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x64   0x....'....        BL       dma_allocate_channel
   \       0x68   0xE584'0024        STR      R0,[R4, #+36]
    225          	assert(desc->dma.rx.channel);
   \                     ??_twid_dma_read_0:
   \       0x6C   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x70   0xE350'0000        CMP      R0,#+0
   \       0x74   0x1A00'0004        BNE      ??_twid_dma_read_1
   \       0x78   0xE3A0'20E1        MOV      R2,#+225
   \       0x7C   0x....'....        LDR      R1,??DataTable8_4
   \       0x80   0x....'....        LDR      R0,??DataTable8_5
   \       0x84   0x....'....        BL       __aeabi_assert
   \       0x88   0x....'....        BL       __iar_EmptyStepPoint
    226          
    227          #ifdef CONFIG_HAVE_TWI_FIFO
    228          	if (desc->use_fifo) {
    229          		if ((buffer->size % 4) == 0) {
    230          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_FOUR_DATA;
    231          			desc->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
    232          		} else if ((buffer->size % 2) == 0)  {
    233          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_TWO_DATA;
    234          			desc->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
    235          		} else {
    236          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_ONE_DATA;
    237          			desc->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
    238          		}
    239          		desc->dma.rx.cfg.len = buffer->size;
    240          	} else {
    241          		desc->dma.rx.cfg.len = buffer->size - 2;
    242          		desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_ONE_DATA;
    243          		desc->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
    244          	}
    245          #else
    246          	desc->dma.rx.cfg.len = buffer->size - 2;
   \                     ??_twid_dma_read_1:
   \       0x8C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x90   0xE250'0002        SUBS     R0,R0,#+2
   \       0x94   0xE584'003C        STR      R0,[R4, #+60]
    247          	desc->dma.rx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \       0x98   0xE3A0'0000        MOV      R0,#+0
   \       0x9C   0xE584'0028        STR      R0,[R4, #+40]
    248          #endif
    249          	dma_configure_transfer(desc->dma.rx.channel, &desc->dma.rx.cfg_dma, &desc->dma.rx.cfg, 1);
   \       0xA0   0xE3A0'3001        MOV      R3,#+1
   \       0xA4   0xE294'2034        ADDS     R2,R4,#+52
   \       0xA8   0xE294'1028        ADDS     R1,R4,#+40
   \       0xAC   0xE594'0024        LDR      R0,[R4, #+36]
   \       0xB0   0x....'....        BL       dma_configure_transfer
    250          	callback_set(&_cb, _twid_dma_read_callback, (void*)desc);
   \       0xB4   0xE1B0'2004        MOVS     R2,R4
   \       0xB8   0x....'....        ADR      R1,_twid_dma_read_callback
   \       0xBC   0xE1B0'000D        MOVS     R0,SP
   \       0xC0   0x....'....        BL       callback_set
    251          	dma_set_callback(desc->dma.rx.channel, &_cb);
   \       0xC4   0xE1B0'100D        MOVS     R1,SP
   \       0xC8   0xE594'0024        LDR      R0,[R4, #+36]
   \       0xCC   0x....'....        BL       dma_set_callback
    252          	dma_start_transfer(desc->dma.rx.channel);
   \       0xD0   0xE594'0024        LDR      R0,[R4, #+36]
   \       0xD4   0x....'....        BL       dma_start_transfer
    253          
    254          	if (desc->flags & BUS_I2C_BUF_ATTR_START)
   \       0xD8   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0xDC   0xE310'0D40        TST      R0,#0x1000
   \       0xE0   0x0A00'0001        BEQ      ??_twid_dma_read_2
    255          		twi_send_start_condition(desc->addr);
   \       0xE4   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xE8   0x....'....        BL       twi_send_start_condition
    256          }
   \                     ??_twid_dma_read_2:
   \       0xEC   0xE8BD'83F7        POP      {R0-R2,R4-R9,PC}  ;; return
    257          

   \                                 In section SOFTPACK, align 4, keep-with-next
    258          static int _twid_dma_write_callback(void* arg, void* arg2)
    259          {
   \                     _twid_dma_write_callback:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    260          	struct _twi_desc* desc = (struct _twi_desc *)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
    261          
    262          	dma_reset_channel(desc->dma.tx.channel);
   \       0x10   0xE596'0040        LDR      R0,[R6, #+64]
   \       0x14   0x....'....        BL       dma_reset_channel
    263          
    264          	if (_check_tx_timeout(desc)) {
   \       0x18   0xE1B0'0006        MOVS     R0,R6
   \       0x1C   0x....'....        BL       _check_tx_timeout
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x0A00'0003        BEQ      ??_twid_dma_write_callback_0
    265          		mutex_unlock(&desc->mutex);
   \       0x28   0xE296'0018        ADDS     R0,R6,#+24
   \       0x2C   0x....'....        BL       mutex_unlock
    266          		return -ETIMEDOUT;
   \       0x30   0xE3E0'004C        MVN      R0,#+76
   \       0x34   0xEA00'000A        B        ??_twid_dma_write_callback_1
    267          	}
    268          
    269          	if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \                     ??_twid_dma_write_callback_0:
   \       0x38   0xE1D6'01B0        LDRH     R0,[R6, #+16]
   \       0x3C   0xE310'0D80        TST      R0,#0x2000
   \       0x40   0x0A00'0001        BEQ      ??_twid_dma_write_callback_2
    270          		twi_send_stop_condition(desc->addr);
   \       0x44   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x48   0x....'....        BL       twi_send_stop_condition
    271          
    272          #ifdef CONFIG_HAVE_TWI_FIFO
    273          	if (!desc->use_fifo)
    274          		twi_write_byte(desc->addr, ((uint8_t *)desc->dma.tx.cfg.saddr)[desc->dma.tx.cfg.len]);
    275          #endif
    276          
    277          	mutex_unlock(&desc->mutex);
   \                     ??_twid_dma_write_callback_2:
   \       0x4C   0xE296'0018        ADDS     R0,R6,#+24
   \       0x50   0x....'....        BL       mutex_unlock
    278          
    279          	callback_call(&desc->callback, NULL);
   \       0x54   0xE3A0'1000        MOV      R1,#+0
   \       0x58   0xE296'001C        ADDS     R0,R6,#+28
   \       0x5C   0x....'....        BL       callback_call
    280          
    281          	return 0;
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \                     ??_twid_dma_write_callback_1:
   \       0x64   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    282          }
    283          

   \                                 In section SOFTPACK, align 4, keep-with-next
    284          static void _twid_dma_write(struct _twi_desc* desc, struct _buffer* buffer)
    285          {
   \                     _twid_dma_write:
   \        0x0   0xE92D'43FE        PUSH     {R1-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    286          	struct _callback _cb;
    287          	uint32_t id = get_twi_id_from_addr(desc->addr);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_twi_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    288          
    289          	memset(&desc->dma.tx.cfg, 0x0, sizeof(desc->dma.tx.cfg));
   \       0x18   0xE3A0'700C        MOV      R7,#+12
   \       0x1C   0xE3A0'8000        MOV      R8,#+0
   \       0x20   0xE294'9050        ADDS     R9,R4,#+80
   \       0x24   0xE1B0'2008        MOVS     R2,R8
   \       0x28   0xE1B0'1007        MOVS     R1,R7
   \       0x2C   0xE1B0'0009        MOVS     R0,R9
   \       0x30   0x....'....        BL       __aeabi_memset
   \       0x34   0xE1B0'0009        MOVS     R0,R9
    290          
    291          	if(!desc->dma.tx.channel)
   \       0x38   0xE594'0040        LDR      R0,[R4, #+64]
   \       0x3C   0xE350'0000        CMP      R0,#+0
   \       0x40   0x1A00'0004        BNE      ??_twid_dma_write_0
    292          		desc->dma.tx.channel = dma_allocate_channel(DMA_PERIPH_MEMORY, id);
   \       0x44   0xE1B0'1006        MOVS     R1,R6
   \       0x48   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x4C   0xE3A0'00FF        MOV      R0,#+255
   \       0x50   0x....'....        BL       dma_allocate_channel
   \       0x54   0xE584'0040        STR      R0,[R4, #+64]
    293          	assert(desc->dma.tx.channel);
   \                     ??_twid_dma_write_0:
   \       0x58   0xE594'0040        LDR      R0,[R4, #+64]
   \       0x5C   0xE350'0000        CMP      R0,#+0
   \       0x60   0x1A00'0005        BNE      ??_twid_dma_write_1
   \       0x64   0xE3A0'2025        MOV      R2,#+37
   \       0x68   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x6C   0x....'....        LDR      R1,??DataTable8_4
   \       0x70   0x....'....        LDR      R0,??DataTable8_6
   \       0x74   0x....'....        BL       __aeabi_assert
   \       0x78   0x....'....        BL       __iar_EmptyStepPoint
    294          
    295          	desc->dma.tx.cfg.saddr = buffer->data;
   \                     ??_twid_dma_write_1:
   \       0x7C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x80   0xE584'0050        STR      R0,[R4, #+80]
    296          	desc->dma.tx.cfg.daddr = (void*)&desc->addr->TWI_THR;
   \       0x84   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x88   0xE290'0034        ADDS     R0,R0,#+52
   \       0x8C   0xE584'0054        STR      R0,[R4, #+84]
    297          #ifdef CONFIG_HAVE_TWI_FIFO
    298          	if (desc->use_fifo) {
    299          		if ((buffer->size % 4) == 0) {
    300          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_FOUR_DATA;
    301          			desc->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
    302          		} else if ((buffer->size % 2) == 0) {
    303          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_TWO_DATA;
    304          			desc->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
    305          		} else {
    306          			desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_ONE_DATA;
    307          			desc->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
    308          		}
    309          		desc->dma.tx.cfg.len = buffer->size;
    310          	} else {
    311          		desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_ONE_DATA;
    312          		desc->dma.tx.cfg.len = buffer->size - 1;
    313          		desc->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
    314          	}
    315          #else
    316          	desc->dma.tx.cfg.len = buffer->size - 1;
   \       0x90   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x94   0xE250'0001        SUBS     R0,R0,#+1
   \       0x98   0xE584'0058        STR      R0,[R4, #+88]
    317          	desc->dma.tx.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \       0x9C   0xE3A0'0000        MOV      R0,#+0
   \       0xA0   0xE584'0044        STR      R0,[R4, #+68]
    318          #endif
    319          	dma_configure_transfer(desc->dma.tx.channel, &desc->dma.tx.cfg_dma, &desc->dma.tx.cfg, 1);
   \       0xA4   0xE3A0'3001        MOV      R3,#+1
   \       0xA8   0xE294'2050        ADDS     R2,R4,#+80
   \       0xAC   0xE294'1044        ADDS     R1,R4,#+68
   \       0xB0   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xB4   0x....'....        BL       dma_configure_transfer
    320          	callback_set(&_cb, _twid_dma_write_callback, (void*)desc);
   \       0xB8   0xE1B0'2004        MOVS     R2,R4
   \       0xBC   0x....'....        ADR      R1,_twid_dma_write_callback
   \       0xC0   0xE1B0'000D        MOVS     R0,SP
   \       0xC4   0x....'....        BL       callback_set
    321          	dma_set_callback(desc->dma.tx.channel, &_cb);
   \       0xC8   0xE1B0'100D        MOVS     R1,SP
   \       0xCC   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xD0   0x....'....        BL       dma_set_callback
    322          	cache_clean_region(desc->dma.tx.cfg.saddr, desc->dma.tx.cfg.len);
   \       0xD4   0xE594'1058        LDR      R1,[R4, #+88]
   \       0xD8   0xE594'0050        LDR      R0,[R4, #+80]
   \       0xDC   0x....'....        BL       cache_clean_region
    323          	dma_start_transfer(desc->dma.tx.channel);
   \       0xE0   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xE4   0x....'....        BL       dma_start_transfer
    324          }
   \       0xE8   0xE8BD'83F7        POP      {R0-R2,R4-R9,PC}  ;; return
    325          
    326          /*
    327           *
    328           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    329          static void _twid_handler(uint32_t source, void* user_arg)
    330          {
   \                     _twid_handler:
   \        0x0   0xE92D'4FF1        PUSH     {R0,R4-R11,LR}
   \        0x4   0xE1B0'5001        MOVS     R5,R1
    331          	uint32_t status = 0;
   \        0x8   0xE3A0'6000        MOV      R6,#+0
   \        0xC   0xE1B0'B006        MOVS     R11,R6
    332          	Twi* addr;
    333          	uint32_t buf_size;
    334          	bool use_fifo = false;
   \       0x10   0xE1B0'7006        MOVS     R7,R6
    335          	struct _async_desc* adesc = (struct _async_desc*)user_arg;
   \       0x14   0xE1B0'8005        MOVS     R8,R5
    336          
    337          	addr = adesc->twi_desc->addr;
   \       0x18   0xE598'0004        LDR      R0,[R8, #+4]
   \       0x1C   0xE590'9000        LDR      R9,[R0, #+0]
    338          	status = twi_get_masked_status(addr);
   \       0x20   0xE1B0'0009        MOVS     R0,R9
   \       0x24   0x....'....        BL       twi_get_masked_status
   \       0x28   0xE1B0'A000        MOVS     R10,R0
    339          
    340          #if defined(CONFIG_HAVE_TWI_FIFO)
    341          	use_fifo = adesc->twi_desc->use_fifo;
    342          #endif
    343          
    344          	if (TWI_STATUS_RXRDY(status)) {
   \       0x2C   0xE31A'0002        TST      R10,#0x2
   \       0x30   0x0A00'002B        BEQ      ??_twid_handler_0
    345          		if (use_fifo) {
   \       0x34   0xE1B0'0007        MOVS     R0,R7
   \       0x38   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x3C   0xE350'0000        CMP      R0,#+0
   \       0x40   0x1A00'000A        BNE      ??_twid_handler_1
    346          #ifdef CONFIG_HAVE_TWI_FIFO
    347          			uint8_t size = twi_fifo_get_rx_size(addr);
    348          
    349          			adesc->transferred += twi_fifo_read(addr, &adesc->buf.data[adesc->transferred], size);
    350          
    351          			if ((adesc->buf.size - adesc->transferred) >= 4)
    352          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_FOUR_DATA;
    353          			else if ((adesc->buf.size - adesc->transferred) >= 2)
    354          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_TWO_DATA;
    355          			else
    356          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_ONE_DATA;
    357          
    358          			buf_size = adesc->buf.size;
    359          #endif /* CONFIG_HAVE_TWI_FIFO */
    360          		} else {
    361          			adesc->buf.data[adesc->transferred] = twi_read_byte(addr);
   \       0x44   0xE1B0'0009        MOVS     R0,R9
   \       0x48   0x....'....        BL       twi_read_byte
   \       0x4C   0xE598'100C        LDR      R1,[R8, #+12]
   \       0x50   0xE598'2018        LDR      R2,[R8, #+24]
   \       0x54   0xE7C1'0002        STRB     R0,[R1, +R2]
    362          			adesc->transferred++;
   \       0x58   0xE598'0018        LDR      R0,[R8, #+24]
   \       0x5C   0xE290'0001        ADDS     R0,R0,#+1
   \       0x60   0xE588'0018        STR      R0,[R8, #+24]
    363          			buf_size = adesc->buf.size - 1;
   \       0x64   0xE598'0010        LDR      R0,[R8, #+16]
   \       0x68   0xE250'0001        SUBS     R0,R0,#+1
   \       0x6C   0xE1B0'4000        MOVS     R4,R0
    364          		}
    365          
    366          		/* Only one byte remaining, send stop condition */
    367          		if (adesc->transferred == buf_size)
   \                     ??_twid_handler_1:
   \       0x70   0xE598'0018        LDR      R0,[R8, #+24]
   \       0x74   0xE150'0004        CMP      R0,R4
   \       0x78   0x1A00'0005        BNE      ??_twid_handler_2
    368          			if (adesc->twi_desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \       0x7C   0xE598'0004        LDR      R0,[R8, #+4]
   \       0x80   0xE1D0'01B0        LDRH     R0,[R0, #+16]
   \       0x84   0xE310'0D80        TST      R0,#0x2000
   \       0x88   0x0A00'0001        BEQ      ??_twid_handler_2
    369          				twi_send_stop_condition(addr);
   \       0x8C   0xE1B0'0009        MOVS     R0,R9
   \       0x90   0x....'....        BL       twi_send_stop_condition
    370          
    371          		if (adesc->transferred == adesc->buf.size) {
   \                     ??_twid_handler_2:
   \       0x94   0xE598'0018        LDR      R0,[R8, #+24]
   \       0x98   0xE598'1010        LDR      R1,[R8, #+16]
   \       0x9C   0xE150'0001        CMP      R0,R1
   \       0xA0   0x1A00'004B        BNE      ??_twid_handler_3
    372          			twi_disable_it(addr, TWI_IDR_RXRDY);
   \       0xA4   0xE3A0'1002        MOV      R1,#+2
   \       0xA8   0xE1B0'0009        MOVS     R0,R9
   \       0xAC   0x....'....        BL       twi_disable_it
    373          			if (adesc->twi_desc->flags & BUS_I2C_BUF_ATTR_STOP) {
   \       0xB0   0xE598'0004        LDR      R0,[R8, #+4]
   \       0xB4   0xE1D0'01B0        LDRH     R0,[R0, #+16]
   \       0xB8   0xE310'0D80        TST      R0,#0x2000
   \       0xBC   0x0A00'0003        BEQ      ??_twid_handler_4
    374          				twi_enable_it(addr, TWI_IER_TXCOMP);
   \       0xC0   0xE3A0'1001        MOV      R1,#+1
   \       0xC4   0xE1B0'0009        MOVS     R0,R9
   \       0xC8   0x....'....        BL       twi_enable_it
   \       0xCC   0xEA00'0040        B        ??_twid_handler_3
    375          			} else {
    376          				adesc->twi_id = 0;
   \                     ??_twid_handler_4:
   \       0xD0   0xE588'6008        STR      R6,[R8, #+8]
    377          				mutex_unlock(&adesc->twi_desc->mutex);
   \       0xD4   0xE598'0004        LDR      R0,[R8, #+4]
   \       0xD8   0xE290'0018        ADDS     R0,R0,#+24
   \       0xDC   0x....'....        BL       mutex_unlock
   \       0xE0   0xEA00'003B        B        ??_twid_handler_3
    378          			}
    379          		}
    380          	} else if (TWI_STATUS_TXRDY(status)) {
   \                     ??_twid_handler_0:
   \       0xE4   0xE31A'0004        TST      R10,#0x4
   \       0xE8   0x0A00'002A        BEQ      ??_twid_handler_5
    381          		if (use_fifo) {
   \       0xEC   0xE1B0'0007        MOVS     R0,R7
   \       0xF0   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0xF4   0xE350'0000        CMP      R0,#+0
   \       0xF8   0x1A00'0012        BNE      ??_twid_handler_6
    382          #ifdef CONFIG_HAVE_TWI_FIFO
    383          			uint8_t len = 0;
    384          			uint8_t size = adesc->twi_desc->fifo.tx.size - twi_fifo_get_tx_size(addr);
    385          
    386          			if ((adesc->buf.size - adesc->transferred) > size)
    387          				len = size;
    388          			else
    389          				len = adesc->buf.size - adesc->transferred;
    390          			adesc->transferred += twi_fifo_write(addr, &adesc->buf.data[adesc->transferred], len);
    391          
    392          			/* Transfer finished ? */
    393          			if (adesc->transferred == adesc->buf.size)
    394          				if (adesc->twi_desc->flags & BUS_I2C_BUF_ATTR_STOP)
    395          					twi_send_stop_condition(addr);
    396          
    397          			if ((adesc->buf.size - adesc->transferred) >= 4)
    398          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_FOUR_DATA;
    399          			else if ((adesc->buf.size - adesc->transferred) >= 2)
    400          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_TWO_DATA;
    401          			else
    402          				addr->TWI_FMR = (addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_ONE_DATA;
    403          #endif /* CONFIG_HAVE_TWI_FIFO */
    404          		} else {
    405          			/* Transfer finished ? */
    406          			if (adesc->transferred == adesc->buf.size - 1)
   \       0xFC   0xE598'0018        LDR      R0,[R8, #+24]
   \      0x100   0xE598'1010        LDR      R1,[R8, #+16]
   \      0x104   0xE251'1001        SUBS     R1,R1,#+1
   \      0x108   0xE150'0001        CMP      R0,R1
   \      0x10C   0x1A00'0005        BNE      ??_twid_handler_7
    407          				if (adesc->twi_desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \      0x110   0xE598'0004        LDR      R0,[R8, #+4]
   \      0x114   0xE1D0'01B0        LDRH     R0,[R0, #+16]
   \      0x118   0xE310'0D80        TST      R0,#0x2000
   \      0x11C   0x0A00'0001        BEQ      ??_twid_handler_7
    408          					twi_send_stop_condition(addr);
   \      0x120   0xE1B0'0009        MOVS     R0,R9
   \      0x124   0x....'....        BL       twi_send_stop_condition
    409          
    410          			twi_write_byte(addr, adesc->buf.data[adesc->transferred]);
   \                     ??_twid_handler_7:
   \      0x128   0xE598'000C        LDR      R0,[R8, #+12]
   \      0x12C   0xE598'1018        LDR      R1,[R8, #+24]
   \      0x130   0xE7D0'1001        LDRB     R1,[R0, +R1]
   \      0x134   0xE1B0'0009        MOVS     R0,R9
   \      0x138   0x....'....        BL       twi_write_byte
    411          			adesc->transferred++;
   \      0x13C   0xE598'0018        LDR      R0,[R8, #+24]
   \      0x140   0xE290'0001        ADDS     R0,R0,#+1
   \      0x144   0xE588'0018        STR      R0,[R8, #+24]
    412          		}
    413          
    414          		if (adesc->transferred >= adesc->buf.size){
   \                     ??_twid_handler_6:
   \      0x148   0xE598'0018        LDR      R0,[R8, #+24]
   \      0x14C   0xE598'1010        LDR      R1,[R8, #+16]
   \      0x150   0xE150'0001        CMP      R0,R1
   \      0x154   0x3A00'001E        BCC      ??_twid_handler_3
    415          			twi_disable_it(addr, TWI_IDR_TXRDY);
   \      0x158   0xE3A0'1004        MOV      R1,#+4
   \      0x15C   0xE1B0'0009        MOVS     R0,R9
   \      0x160   0x....'....        BL       twi_disable_it
    416          			if (adesc->twi_desc->flags & BUS_I2C_BUF_ATTR_STOP) {
   \      0x164   0xE598'0004        LDR      R0,[R8, #+4]
   \      0x168   0xE1D0'01B0        LDRH     R0,[R0, #+16]
   \      0x16C   0xE310'0D80        TST      R0,#0x2000
   \      0x170   0x0A00'0003        BEQ      ??_twid_handler_8
    417          				twi_enable_it(addr, TWI_IER_TXCOMP);
   \      0x174   0xE3A0'1001        MOV      R1,#+1
   \      0x178   0xE1B0'0009        MOVS     R0,R9
   \      0x17C   0x....'....        BL       twi_enable_it
   \      0x180   0xEA00'0013        B        ??_twid_handler_3
    418          			} else {
    419          				adesc->twi_id = 0;
   \                     ??_twid_handler_8:
   \      0x184   0xE588'6008        STR      R6,[R8, #+8]
    420          				mutex_unlock(&adesc->twi_desc->mutex);
   \      0x188   0xE598'0004        LDR      R0,[R8, #+4]
   \      0x18C   0xE290'0018        ADDS     R0,R0,#+24
   \      0x190   0x....'....        BL       mutex_unlock
   \      0x194   0xEA00'000E        B        ??_twid_handler_3
    421          			}
    422          		}
    423          	}
    424          	/* Transfer complete*/
    425          	else if (TWI_STATUS_TXCOMP(status)) {
   \                     ??_twid_handler_5:
   \      0x198   0xE31A'0001        TST      R10,#0x1
   \      0x19C   0x0A00'000C        BEQ      ??_twid_handler_3
    426          		irq_disable(adesc->twi_id);
   \      0x1A0   0xE598'0008        LDR      R0,[R8, #+8]
   \      0x1A4   0x....'....        BL       irq_disable
    427          		twi_disable_it(addr, TWI_IDR_TXCOMP);
   \      0x1A8   0xE3A0'1001        MOV      R1,#+1
   \      0x1AC   0xE1B0'0009        MOVS     R0,R9
   \      0x1B0   0x....'....        BL       twi_disable_it
    428          		adesc->twi_id = 0;
   \      0x1B4   0xE588'6008        STR      R6,[R8, #+8]
    429          		mutex_unlock(&adesc->twi_desc->mutex);
   \      0x1B8   0xE598'0004        LDR      R0,[R8, #+4]
   \      0x1BC   0xE290'0018        ADDS     R0,R0,#+24
   \      0x1C0   0x....'....        BL       mutex_unlock
    430          		callback_call(&adesc->twi_desc->callback, NULL);
   \      0x1C4   0xE3A0'1000        MOV      R1,#+0
   \      0x1C8   0xE598'0004        LDR      R0,[R8, #+4]
   \      0x1CC   0xE290'001C        ADDS     R0,R0,#+28
   \      0x1D0   0x....'....        BL       callback_call
    431          	}
    432          }
   \                     ??_twid_handler_3:
   \      0x1D4   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    433          
    434          /*
    435           *
    436           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    437          static int _twid_poll_read(struct _twi_desc* desc, struct _buffer* buffer)
    438          {
   \                     _twid_poll_read:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    439          	int i;
    440          	Twi* addr = desc->addr;
   \        0xC   0xE594'7000        LDR      R7,[R4, #+0]
    441          	int32_t size;
    442          	bool use_fifo = false;
   \       0x10   0xE3A0'8000        MOV      R8,#+0
    443          
    444          #if defined(CONFIG_HAVE_TWI_FIFO)
    445          	use_fifo = desc->use_fifo;
    446          #endif
    447          
    448          	if (use_fifo)
   \       0x14   0xE1B0'0008        MOVS     R0,R8
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x0A00'0001        BEQ      ??_twid_poll_read_0
    449          		size = buffer->size;
   \       0x24   0xE595'9004        LDR      R9,[R5, #+4]
   \       0x28   0xEA00'0001        B        ??_twid_poll_read_1
    450          	else
    451          		size = buffer->size - 1;
   \                     ??_twid_poll_read_0:
   \       0x2C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x30   0xE250'9001        SUBS     R9,R0,#+1
    452          	if (size < 0)
   \                     ??_twid_poll_read_1:
   \       0x34   0xE359'0000        CMP      R9,#+0
   \       0x38   0x5A00'0001        BPL      ??_twid_poll_read_2
    453          		size = 0;
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0xE1B0'9000        MOVS     R9,R0
    454          
    455          	if (desc->flags & BUS_I2C_BUF_ATTR_START)
   \                     ??_twid_poll_read_2:
   \       0x44   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0x48   0xE310'0D40        TST      R0,#0x1000
   \       0x4C   0x0A00'0001        BEQ      ??_twid_poll_read_3
    456          		twi_send_start_condition(addr);
   \       0x50   0xE1B0'0007        MOVS     R0,R7
   \       0x54   0x....'....        BL       twi_send_start_condition
    457          
    458          	if (use_fifo) {
   \                     ??_twid_poll_read_3:
   \       0x58   0xE1B0'0008        MOVS     R0,R8
   \       0x5C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x1A00'0013        BNE      ??_twid_poll_read_4
    459          #ifdef CONFIG_HAVE_TWI_FIFO
    460          		for (i = 0 ; i < size ; ) {
    461          			int len;
    462          
    463          			do {
    464          				uint8_t _size;
    465          
    466          				do {
    467          					_size = twi_fifo_get_rx_size(desc->addr);
    468          				} while (_size == 0);
    469          
    470          				if (size > _size)
    471          					len = _size;
    472          				else
    473          					len = size;
    474          			} while (len == 0);
    475          
    476          			i += twi_fifo_read(desc->addr, &buffer->data[i], len);
    477          
    478          			if ((i < size) && _check_nack(desc))
    479          				return -ECONNABORTED;
    480          		}
    481          #endif /* CONFIG_HAVE_TWI_FIFO */
    482          	} else {
    483          		for (i = 0 ; i < size ; i++) {
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xE1B0'6000        MOVS     R6,R0
   \                     ??_twid_poll_read_5:
   \       0x70   0xE156'0009        CMP      R6,R9
   \       0x74   0xAA00'000F        BGE      ??_twid_poll_read_4
    484          			if (_check_rx_timeout(desc))
   \       0x78   0xE1B0'0004        MOVS     R0,R4
   \       0x7C   0x....'....        BL       _check_rx_timeout
   \       0x80   0xE350'0000        CMP      R0,#+0
   \       0x84   0x1A00'000B        BNE      ??_twid_poll_read_4
    485          				break;
    486          
    487          			buffer->data[i] = twi_read_byte(addr);
   \                     ??_twid_poll_read_6:
   \       0x88   0xE1B0'0007        MOVS     R0,R7
   \       0x8C   0x....'....        BL       twi_read_byte
   \       0x90   0xE595'1000        LDR      R1,[R5, #+0]
   \       0x94   0xE7C1'0006        STRB     R0,[R1, +R6]
    488          
    489          			if (_check_nack(desc))
   \       0x98   0xE1B0'0004        MOVS     R0,R4
   \       0x9C   0x....'....        BL       _check_nack
   \       0xA0   0xE350'0000        CMP      R0,#+0
   \       0xA4   0x0A00'0001        BEQ      ??_twid_poll_read_7
    490          				return -ECONNABORTED;
   \       0xA8   0xE3E0'000C        MVN      R0,#+12
   \       0xAC   0xEA00'001D        B        ??_twid_poll_read_8
    491          		}
   \                     ??_twid_poll_read_7:
   \       0xB0   0xE296'6001        ADDS     R6,R6,#+1
   \       0xB4   0xEAFF'FFED        B        ??_twid_poll_read_5
    492          	}
    493          
    494          	/* Before receive last data, send stop */
    495          	if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \                     ??_twid_poll_read_4:
   \       0xB8   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0xBC   0xE310'0D80        TST      R0,#0x2000
   \       0xC0   0x0A00'0001        BEQ      ??_twid_poll_read_9
    496          		twi_send_stop_condition(addr);
   \       0xC4   0xE1B0'0007        MOVS     R0,R7
   \       0xC8   0x....'....        BL       twi_send_stop_condition
    497          
    498          	if ((size == (buffer->size - 1)) || (size == 0)) {
   \                     ??_twid_poll_read_9:
   \       0xCC   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xD0   0xE250'0001        SUBS     R0,R0,#+1
   \       0xD4   0xE159'0000        CMP      R9,R0
   \       0xD8   0x0A00'0001        BEQ      ??_twid_poll_read_10
   \       0xDC   0xE359'0000        CMP      R9,#+0
   \       0xE0   0x1A00'0009        BNE      ??_twid_poll_read_11
    499          		if (_check_rx_timeout(desc))
   \                     ??_twid_poll_read_10:
   \       0xE4   0xE1B0'0004        MOVS     R0,R4
   \       0xE8   0x....'....        BL       _check_rx_timeout
   \       0xEC   0xE350'0000        CMP      R0,#+0
   \       0xF0   0x0A00'0001        BEQ      ??_twid_poll_read_12
    500          			return -ETIMEDOUT;
   \       0xF4   0xE3E0'004C        MVN      R0,#+76
   \       0xF8   0xEA00'000A        B        ??_twid_poll_read_8
    501          		buffer->data[i] = twi_read_byte(addr);
   \                     ??_twid_poll_read_12:
   \       0xFC   0xE1B0'0007        MOVS     R0,R7
   \      0x100   0x....'....        BL       twi_read_byte
   \      0x104   0xE595'1000        LDR      R1,[R5, #+0]
   \      0x108   0xE7C1'0006        STRB     R0,[R1, +R6]
    502          	}
    503          
    504          	/* wait transfer to be finished */
    505          	if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \                     ??_twid_poll_read_11:
   \      0x10C   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \      0x110   0xE310'0D80        TST      R0,#0x2000
   \      0x114   0x0A00'0002        BEQ      ??_twid_poll_read_13
    506          		return _twid_wait_twi_transfer(desc);
   \      0x118   0xE1B0'0004        MOVS     R0,R4
   \      0x11C   0x....'....        BL       _twid_wait_twi_transfer
   \      0x120   0xEA00'0000        B        ??_twid_poll_read_8
    507          	return 0;
   \                     ??_twid_poll_read_13:
   \      0x124   0xE3A0'0000        MOV      R0,#+0
   \                     ??_twid_poll_read_8:
   \      0x128   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    508          }
    509          

   \                                 In section SOFTPACK, align 4, keep-with-next
    510          static int _twid_poll_write(struct _twi_desc* desc, struct _buffer* buffer)
    511          {
   \                     _twid_poll_write:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    512          	int i = 0;
   \        0xC   0xE3A0'6000        MOV      R6,#+0
    513          	int size;
    514          	bool use_fifo = false;
   \       0x10   0xE3A0'7000        MOV      R7,#+0
    515          
    516          #if defined(CONFIG_HAVE_TWI_FIFO)
    517          	use_fifo = desc->use_fifo;
    518          #endif
    519          
    520          	if (use_fifo)
   \       0x14   0xE1B0'0007        MOVS     R0,R7
   \       0x18   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x0A00'0001        BEQ      ??_twid_poll_write_0
    521          		size = buffer->size;
   \       0x24   0xE595'8004        LDR      R8,[R5, #+4]
   \       0x28   0xEA00'0001        B        ??_twid_poll_write_1
    522          	else
    523          		size = buffer->size - 1;
   \                     ??_twid_poll_write_0:
   \       0x2C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x30   0xE250'8001        SUBS     R8,R0,#+1
    524          	if (size < 0)
   \                     ??_twid_poll_write_1:
   \       0x34   0xE358'0000        CMP      R8,#+0
   \       0x38   0x5A00'0001        BPL      ??_twid_poll_write_2
    525          		size = 0;
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0xE1B0'8000        MOVS     R8,R0
    526          
    527          	/* If only one byte send stop immediatly */
    528          	if (buffer->size <= 1)
   \                     ??_twid_poll_write_2:
   \       0x44   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x48   0xE350'0002        CMP      R0,#+2
   \       0x4C   0x2A00'0004        BCS      ??_twid_poll_write_3
    529          		if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \       0x50   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0x54   0xE310'0D80        TST      R0,#0x2000
   \       0x58   0x0A00'0001        BEQ      ??_twid_poll_write_3
    530          			twi_send_stop_condition(desc->addr);
   \       0x5C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x60   0x....'....        BL       twi_send_stop_condition
    531          
    532          	if (use_fifo) {
   \                     ??_twid_poll_write_3:
   \       0x64   0xE1B0'0007        MOVS     R0,R7
   \       0x68   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x6C   0xE350'0000        CMP      R0,#+0
   \       0x70   0x1A00'0013        BNE      ??_twid_poll_write_4
    533          #ifdef CONFIG_HAVE_TWI_FIFO
    534          		for (i = 0 ; i < size ; ) {
    535          			uint8_t len;
    536          			do {
    537          				volatile uint8_t _size =  twi_fifo_get_tx_size(desc->addr);
    538          
    539          				/* Fill the FIFO as much as possible */
    540          				len = desc->fifo.tx.size - _size;
    541          				len = len > (size) ? size : len;
    542          			} while (len == 0);
    543          
    544          			i += twi_fifo_write(desc->addr, &buffer->data[i], len);
    545          
    546          			if ((i < size - 1) && _check_nack(desc))
    547          				return -ECONNABORTED;
    548          		}
    549          #endif /* CONFIG_HAVE_TWI_FIFO */
    550          	} else {
    551          		for (i = 0 ; i < size ; i++) {
   \       0x74   0xE3A0'0000        MOV      R0,#+0
   \       0x78   0xE1B0'6000        MOVS     R6,R0
   \                     ??_twid_poll_write_5:
   \       0x7C   0xE156'0008        CMP      R6,R8
   \       0x80   0xAA00'000F        BGE      ??_twid_poll_write_4
    552          			if (_check_tx_timeout(desc))
   \       0x84   0xE1B0'0004        MOVS     R0,R4
   \       0x88   0x....'....        BL       _check_tx_timeout
   \       0x8C   0xE350'0000        CMP      R0,#+0
   \       0x90   0x1A00'000B        BNE      ??_twid_poll_write_4
    553          				break;
    554          			twi_write_byte(desc->addr, buffer->data[i]);
   \                     ??_twid_poll_write_6:
   \       0x94   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x98   0xE7D0'1006        LDRB     R1,[R0, +R6]
   \       0x9C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xA0   0x....'....        BL       twi_write_byte
    555          
    556          			if (_check_nack(desc))
   \       0xA4   0xE1B0'0004        MOVS     R0,R4
   \       0xA8   0x....'....        BL       _check_nack
   \       0xAC   0xE350'0000        CMP      R0,#+0
   \       0xB0   0x0A00'0001        BEQ      ??_twid_poll_write_7
    557          				return -ECONNABORTED;
   \       0xB4   0xE3E0'000C        MVN      R0,#+12
   \       0xB8   0xEA00'0022        B        ??_twid_poll_write_8
    558          		}
   \                     ??_twid_poll_write_7:
   \       0xBC   0xE296'6001        ADDS     R6,R6,#+1
   \       0xC0   0xEAFF'FFED        B        ??_twid_poll_write_5
    559          	}
    560          
    561          	if (buffer->size > 1)
   \                     ??_twid_poll_write_4:
   \       0xC4   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xC8   0xE350'0002        CMP      R0,#+2
   \       0xCC   0x3A00'0004        BCC      ??_twid_poll_write_9
    562          		if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \       0xD0   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0xD4   0xE310'0D80        TST      R0,#0x2000
   \       0xD8   0x0A00'0001        BEQ      ??_twid_poll_write_9
    563          			twi_send_stop_condition(desc->addr);
   \       0xDC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xE0   0x....'....        BL       twi_send_stop_condition
    564          
    565          	if (size == (buffer->size - 1)) {
   \                     ??_twid_poll_write_9:
   \       0xE4   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xE8   0xE250'0001        SUBS     R0,R0,#+1
   \       0xEC   0xE158'0000        CMP      R8,R0
   \       0xF0   0x1A00'000D        BNE      ??_twid_poll_write_10
    566          		if (_check_tx_timeout(desc))
   \       0xF4   0xE1B0'0004        MOVS     R0,R4
   \       0xF8   0x....'....        BL       _check_tx_timeout
   \       0xFC   0xE350'0000        CMP      R0,#+0
   \      0x100   0x0A00'0001        BEQ      ??_twid_poll_write_11
    567          			return -ETIMEDOUT;
   \      0x104   0xE3E0'004C        MVN      R0,#+76
   \      0x108   0xEA00'000E        B        ??_twid_poll_write_8
    568          		twi_write_byte(desc->addr, buffer->data[i]);
   \                     ??_twid_poll_write_11:
   \      0x10C   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x110   0xE7D0'1006        LDRB     R1,[R0, +R6]
   \      0x114   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x118   0x....'....        BL       twi_write_byte
    569          		while(!twi_is_byte_sent(desc->addr));
   \                     ??_twid_poll_write_12:
   \      0x11C   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x120   0x....'....        BL       twi_is_byte_sent
   \      0x124   0xE350'0000        CMP      R0,#+0
   \      0x128   0x0AFF'FFFB        BEQ      ??_twid_poll_write_12
    570          	}
    571          
    572          	/* wait transfer to be finished */
    573          	if (desc->flags & BUS_I2C_BUF_ATTR_STOP)
   \                     ??_twid_poll_write_10:
   \      0x12C   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \      0x130   0xE310'0D80        TST      R0,#0x2000
   \      0x134   0x0A00'0002        BEQ      ??_twid_poll_write_13
    574          		return _twid_wait_twi_transfer(desc);
   \      0x138   0xE1B0'0004        MOVS     R0,R4
   \      0x13C   0x....'....        BL       _twid_wait_twi_transfer
   \      0x140   0xEA00'0000        B        ??_twid_poll_write_8
    575          	return 0;
   \                     ??_twid_poll_write_13:
   \      0x144   0xE3A0'0000        MOV      R0,#+0
   \                     ??_twid_poll_write_8:
   \      0x148   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    576          }
    577          
    578          #ifdef CONFIG_HAVE_TWI_FIFO
    579          
    580          static void twid_fifo_configure(struct _twi_desc *desc)
    581          {
    582          	desc->fifo.rx.size = get_peripheral_fifo_depth(desc->addr);
    583          	desc->fifo.rx.threshold = desc->fifo.rx.size / 2;
    584          	desc->fifo.tx.size = get_peripheral_fifo_depth(desc->addr);
    585          	desc->fifo.tx.threshold = desc->fifo.tx.size / 2;
    586          	twi_fifo_configure(desc->addr, desc->fifo.tx.threshold, desc->fifo.rx.threshold,
    587          			   TWI_FMR_RXRDYM_FOUR_DATA | TWI_FMR_TXRDYM_FOUR_DATA);
    588          }
    589          
    590          #endif /* CONFIG_HAVE_TWI_FIFO */
    591          

   \                                 In section SOFTPACK, align 4, keep-with-next
    592          static void _twid_slave_handler(uint32_t source, void* user_arg)
    593          {
   \                     _twid_slave_handler:
   \        0x0   0xE92D'47F0        PUSH     {R4-R10,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    594          	uint32_t status;
    595          	Twi* twi;
    596          	struct _twi_slave_desc *desc;
    597          	struct _async_desc* adesc = (struct _async_desc*)user_arg;
   \        0xC   0xE1B0'6005        MOVS     R6,R5
    598          
    599          	desc = adesc->twi_slave_desc;
   \       0x10   0xE596'7004        LDR      R7,[R6, #+4]
    600          	twi = adesc->twi_slave_desc->twi;
   \       0x14   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x18   0xE590'8000        LDR      R8,[R0, #+0]
    601          	status = twi_get_status(twi);
   \       0x1C   0xE1B0'0008        MOVS     R0,R8
   \       0x20   0x....'....        BL       twi_get_status
   \       0x24   0xE1B0'9000        MOVS     R9,R0
    602          
    603          	if (TWI_STATUS_GACC(status))
   \       0x28   0xE319'0020        TST      R9,#0x20
   \       0x2C   0x1A00'0064        BNE      ??_twid_slave_handler_0
    604          		return;
    605          
    606          	if (TWI_STATUS_EOSACC(status) || TWI_STATUS_TXCOMP(status)) {
   \                     ??_twid_slave_handler_1:
   \       0x30   0xE3A0'0001        MOV      R0,#+1
   \       0x34   0xE380'0E80        ORR      R0,R0,#0x800
   \       0x38   0xE110'0009        TST      R0,R9
   \       0x3C   0x0A00'0012        BEQ      ??_twid_slave_handler_2
    607          		twi_disable_it(twi, TWI_IDR_RXRDY | TWI_IDR_TXRDY | TWI_IER_TXCOMP);
   \       0x40   0xE3A0'1007        MOV      R1,#+7
   \       0x44   0xE1B0'0008        MOVS     R0,R8
   \       0x48   0x....'....        BL       twi_disable_it
    608          
    609          		if (desc->state == TWID_SLAVE_STATE_STARTED) {
   \       0x4C   0xE5D7'0006        LDRB     R0,[R7, #+6]
   \       0x50   0xE350'0001        CMP      R0,#+1
   \       0x54   0x1A00'0008        BNE      ??_twid_slave_handler_3
    610          			desc->state = TWID_SLAVE_STATE_STOPPED;
   \       0x58   0xE3A0'0000        MOV      R0,#+0
   \       0x5C   0xE5C7'0006        STRB     R0,[R7, #+6]
    611          			if (desc->ops->on_stop)
   \       0x60   0xE597'0008        LDR      R0,[R7, #+8]
   \       0x64   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x0A00'0002        BEQ      ??_twid_slave_handler_3
    612          				desc->ops->on_stop();
   \       0x70   0xE597'0008        LDR      R0,[R7, #+8]
   \       0x74   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x78   0xE12F'FF30        BLX      R0
    613          		}
    614          
    615          		twi_enable_it(desc->twi, TWI_IER_SVACC);
   \                     ??_twid_slave_handler_3:
   \       0x7C   0xE3A0'1010        MOV      R1,#+16
   \       0x80   0xE597'0000        LDR      R0,[R7, #+0]
   \       0x84   0x....'....        BL       twi_enable_it
   \       0x88   0xEA00'004D        B        ??_twid_slave_handler_4
    616          	}
    617          	else if (TWI_STATUS_SVACC(status)) {
   \                     ??_twid_slave_handler_2:
   \       0x8C   0xE319'0010        TST      R9,#0x10
   \       0x90   0x0A00'004B        BEQ      ??_twid_slave_handler_4
    618          		if (desc->state == TWID_SLAVE_STATE_STOPPED) {
   \       0x94   0xE5D7'0006        LDRB     R0,[R7, #+6]
   \       0x98   0xE350'0000        CMP      R0,#+0
   \       0x9C   0x1A00'000B        BNE      ??_twid_slave_handler_5
    619          			twi_disable_it(twi, TWI_IDR_SVACC);
   \       0xA0   0xE3A0'1010        MOV      R1,#+16
   \       0xA4   0xE1B0'0008        MOVS     R0,R8
   \       0xA8   0x....'....        BL       twi_disable_it
    620          
    621          			desc->state = TWID_SLAVE_STATE_STARTED;
   \       0xAC   0xE3A0'0001        MOV      R0,#+1
   \       0xB0   0xE5C7'0006        STRB     R0,[R7, #+6]
    622          
    623          			if (desc->ops->on_start)
   \       0xB4   0xE597'0008        LDR      R0,[R7, #+8]
   \       0xB8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xBC   0xE350'0000        CMP      R0,#+0
   \       0xC0   0x0A00'0002        BEQ      ??_twid_slave_handler_5
    624          				desc->ops->on_start();
   \       0xC4   0xE597'0008        LDR      R0,[R7, #+8]
   \       0xC8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xCC   0xE12F'FF30        BLX      R0
    625          		}
    626          
    627          		if (TWI_STATUS_SVREAD(status)) {
   \                     ??_twid_slave_handler_5:
   \       0xD0   0xE319'0008        TST      R9,#0x8
   \       0xD4   0x0A00'001C        BEQ      ??_twid_slave_handler_6
    628          			twi_disable_it(twi, TWI_IER_RXRDY);
   \       0xD8   0xE3A0'1002        MOV      R1,#+2
   \       0xDC   0xE1B0'0008        MOVS     R0,R8
   \       0xE0   0x....'....        BL       twi_disable_it
    629          			twi_enable_it(twi, TWI_IER_TXRDY | TWI_IER_TXCOMP);
   \       0xE4   0xE3A0'1005        MOV      R1,#+5
   \       0xE8   0xE1B0'0008        MOVS     R0,R8
   \       0xEC   0x....'....        BL       twi_enable_it
    630          
    631          			if (TWI_STATUS_TXRDY(status) && !TWI_STATUS_NACK(status)) {
   \       0xF0   0xE219'0F41        ANDS     R0,R9,#0x104
   \       0xF4   0xE350'0004        CMP      R0,#+4
   \       0xF8   0x1A00'0031        BNE      ??_twid_slave_handler_4
    632          				int16_t err = -1;
   \       0xFC   0xE3E0'A000        MVN      R10,#+0
    633          				if (desc->ops->on_write)
   \      0x100   0xE597'0008        LDR      R0,[R7, #+8]
   \      0x104   0xE590'000C        LDR      R0,[R0, #+12]
   \      0x108   0xE350'0000        CMP      R0,#+0
   \      0x10C   0x0A00'0003        BEQ      ??_twid_slave_handler_7
    634          					err = desc->ops->on_write();
   \      0x110   0xE597'0008        LDR      R0,[R7, #+8]
   \      0x114   0xE590'000C        LDR      R0,[R0, #+12]
   \      0x118   0xE12F'FF30        BLX      R0
   \      0x11C   0xE1B0'A000        MOVS     R10,R0
    635          				if (err > 0)
   \                     ??_twid_slave_handler_7:
   \      0x120   0xE1B0'000A        MOVS     R0,R10
   \      0x124   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x128   0xE1B0'0840        ASRS     R0,R0,#+16
   \      0x12C   0xE350'0001        CMP      R0,#+1
   \      0x130   0xBA00'0023        BLT      ??_twid_slave_handler_4
    636          					twi_write_byte(twi, err);
   \      0x134   0xE1B0'000A        MOVS     R0,R10
   \      0x138   0xE1B0'1000        MOVS     R1,R0
   \      0x13C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \      0x140   0xE1B0'0008        MOVS     R0,R8
   \      0x144   0x....'....        BL       twi_write_byte
   \      0x148   0xEA00'001D        B        ??_twid_slave_handler_4
    637          			}
    638          		} else {
    639          			twi_disable_it(twi, TWI_IER_TXRDY);
   \                     ??_twid_slave_handler_6:
   \      0x14C   0xE3A0'1004        MOV      R1,#+4
   \      0x150   0xE1B0'0008        MOVS     R0,R8
   \      0x154   0x....'....        BL       twi_disable_it
    640          			twi_enable_it(twi, TWI_IER_RXRDY | TWI_IER_TXCOMP);
   \      0x158   0xE3A0'1003        MOV      R1,#+3
   \      0x15C   0xE1B0'0008        MOVS     R0,R8
   \      0x160   0x....'....        BL       twi_enable_it
    641          
    642          			if (TWI_STATUS_RXRDY(status)) {
   \      0x164   0xE319'0002        TST      R9,#0x2
   \      0x168   0x0A00'0015        BEQ      ??_twid_slave_handler_4
    643          				int16_t err = -1;
   \      0x16C   0xE3E0'A000        MVN      R10,#+0
    644          				if (desc->ops->on_read)
   \      0x170   0xE597'0008        LDR      R0,[R7, #+8]
   \      0x174   0xE590'0008        LDR      R0,[R0, #+8]
   \      0x178   0xE350'0000        CMP      R0,#+0
   \      0x17C   0x0A00'0006        BEQ      ??_twid_slave_handler_8
    645          					err = desc->ops->on_read(twi_read_byte(twi));
   \      0x180   0xE1B0'0008        MOVS     R0,R8
   \      0x184   0x....'....        BL       twi_read_byte
   \      0x188   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \      0x18C   0xE597'1008        LDR      R1,[R7, #+8]
   \      0x190   0xE591'1008        LDR      R1,[R1, #+8]
   \      0x194   0xE12F'FF31        BLX      R1
   \      0x198   0xE1B0'A000        MOVS     R10,R0
    646          				if (err > 0)
   \                     ??_twid_slave_handler_8:
   \      0x19C   0xE1B0'000A        MOVS     R0,R10
   \      0x1A0   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x1A4   0xE1B0'0840        ASRS     R0,R0,#+16
   \      0x1A8   0xE350'0001        CMP      R0,#+1
   \      0x1AC   0xBA00'0004        BLT      ??_twid_slave_handler_4
    647          					twi_write_byte(twi, err);
   \      0x1B0   0xE1B0'000A        MOVS     R0,R10
   \      0x1B4   0xE1B0'1000        MOVS     R1,R0
   \      0x1B8   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \      0x1BC   0xE1B0'0008        MOVS     R0,R8
   \      0x1C0   0x....'....        BL       twi_write_byte
    648          			}
    649          		}
    650          	}
    651          
    652          }
   \                     ??_twid_slave_handler_4:
   \                     ??_twid_slave_handler_0:
   \      0x1C4   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    653          
    654          /*
    655           *
    656           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    657          static int _twid_transfer(struct _twi_desc* desc, struct _buffer* buf,  struct _callback* cb)
    658          {
   \                     _twid_transfer:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'5000        MOVS     R5,R0
   \        0x8   0xE1B0'6001        MOVS     R6,R1
   \        0xC   0xE1B0'7002        MOVS     R7,R2
    659          	int err = 0;
   \       0x10   0xE3A0'8000        MOV      R8,#+0
    660          	uint32_t id;
    661          	uint8_t tmode;
    662          
    663          	if (!mutex_try_lock(&desc->mutex))
   \       0x14   0xE295'0018        ADDS     R0,R5,#+24
   \       0x18   0x....'....        BL       mutex_try_lock
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x1A00'0001        BNE      ??_twid_transfer_0
    664          		return -EBUSY;
   \       0x24   0xE3E0'0009        MVN      R0,#+9
   \       0x28   0xEA00'00A2        B        ??_twid_transfer_1
    665          
    666          	callback_copy(&desc->callback, cb);
   \                     ??_twid_transfer_0:
   \       0x2C   0xE1B0'1007        MOVS     R1,R7
   \       0x30   0xE295'001C        ADDS     R0,R5,#+28
   \       0x34   0x....'....        BL       callback_copy
    667          	desc->flags = buf->attr;
   \       0x38   0xE596'0008        LDR      R0,[R6, #+8]
   \       0x3C   0xE585'0010        STR      R0,[R5, #+16]
    668          	tmode = desc->transfer_mode;
   \       0x40   0xE595'900C        LDR      R9,[R5, #+12]
    669          
    670          	/* If short transfer detected, use POLLING mode */
    671          	if (tmode != BUS_TRANSFER_MODE_POLLING) {
   \       0x44   0xE1B0'0009        MOVS     R0,R9
   \       0x48   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x0A00'0004        BEQ      ??_twid_transfer_2
    672          		if (buf->size < TWID_POLLING_THRESHOLD)
   \       0x54   0xE596'0004        LDR      R0,[R6, #+4]
   \       0x58   0xE350'0010        CMP      R0,#+16
   \       0x5C   0x2A00'0001        BCS      ??_twid_transfer_2
    673          			tmode = BUS_TRANSFER_MODE_POLLING;
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \       0x64   0xE1B0'9000        MOVS     R9,R0
    674          	}
    675          
    676          	if (desc->flags & BUS_I2C_BUF_ATTR_START) {
   \                     ??_twid_transfer_2:
   \       0x68   0xE1D5'01B0        LDRH     R0,[R5, #+16]
   \       0x6C   0xE310'0D40        TST      R0,#0x1000
   \       0x70   0x0A00'000F        BEQ      ??_twid_transfer_3
    677          		if (desc->flags & BUS_BUF_ATTR_TX) {
   \       0x74   0xE5D5'0010        LDRB     R0,[R5, #+16]
   \       0x78   0xE310'0002        TST      R0,#0x2
   \       0x7C   0x0A00'0006        BEQ      ??_twid_transfer_4
    678          			twi_init_write(desc->addr, desc->slave_addr, 0, 0);
   \       0x80   0xE3A0'3000        MOV      R3,#+0
   \       0x84   0xE3A0'2000        MOV      R2,#+0
   \       0x88   0xE595'1008        LDR      R1,[R5, #+8]
   \       0x8C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x90   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x94   0x....'....        BL       twi_init_write
   \       0x98   0xEA00'0005        B        ??_twid_transfer_3
    679          #ifdef CONFIG_HAVE_TWI_FIFO
    680          			if (desc->use_fifo)
    681          				twi_fifo_flush_tx(desc->addr);
    682          #endif
    683          		} else {
    684          			twi_init_read(desc->addr, desc->slave_addr, 0, 0);
   \                     ??_twid_transfer_4:
   \       0x9C   0xE3A0'3000        MOV      R3,#+0
   \       0xA0   0xE3A0'2000        MOV      R2,#+0
   \       0xA4   0xE595'1008        LDR      R1,[R5, #+8]
   \       0xA8   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0xAC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xB0   0x....'....        BL       twi_init_read
    685          #ifdef CONFIG_HAVE_TWI_FIFO
    686          			if (desc->use_fifo)
    687          				twi_fifo_flush_rx(desc->addr);
    688          #endif
    689          		}
    690          	}
    691          
    692          	switch (tmode) {
   \                     ??_twid_transfer_3:
   \       0xB4   0xE1B0'0009        MOVS     R0,R9
   \       0xB8   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0xBC   0xE350'0000        CMP      R0,#+0
   \       0xC0   0x0A00'0054        BEQ      ??_twid_transfer_5
   \       0xC4   0xE350'0002        CMP      R0,#+2
   \       0xC8   0x0A00'0066        BEQ      ??_twid_transfer_6
   \       0xCC   0x2A00'0070        BCS      ??_twid_transfer_7
    693          	case BUS_TRANSFER_MODE_ASYNC:
    694          		/* Copy descriptor to async descriptor */
    695          		async_desc[adesc_index].twi_desc = desc;
   \                     ??_twid_transfer_8:
   \       0xD0   0x....'....        LDR      R10,??DataTable8_7
   \       0xD4   0x....'....        LDR      R11,??DataTable8_8
   \       0xD8   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \       0xDC   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \       0xE0   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \       0xE4   0xE580'5004        STR      R5,[R0, #+4]
    696          		/* Init param used by interrupt handler */
    697          		async_desc[adesc_index].transferred = 0;
   \       0xE8   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \       0xEC   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \       0xF0   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \       0xF4   0xE3A0'1000        MOV      R1,#+0
   \       0xF8   0xE580'1018        STR      R1,[R0, #+24]
    698          		async_desc[adesc_index].buf.data = buf->data;
   \       0xFC   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x100   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x104   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \      0x108   0xE596'1000        LDR      R1,[R6, #+0]
   \      0x10C   0xE580'100C        STR      R1,[R0, #+12]
    699          		async_desc[adesc_index].buf.size = buf->size;
   \      0x110   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x114   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x118   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \      0x11C   0xE596'1004        LDR      R1,[R6, #+4]
   \      0x120   0xE580'1010        STR      R1,[R0, #+16]
    700          		async_desc[adesc_index].buf.attr = buf->attr;
   \      0x124   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x128   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x12C   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \      0x130   0xE596'1008        LDR      R1,[R6, #+8]
   \      0x134   0xE580'1014        STR      R1,[R0, #+20]
    701          		id = get_twi_id_from_addr(desc->addr);
   \      0x138   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x13C   0x....'....        BL       get_twi_id_from_addr
   \      0x140   0xE1B0'4000        MOVS     R4,R0
    702          		async_desc[adesc_index].twi_id = id;
   \      0x144   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x148   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x14C   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \      0x150   0xE580'4008        STR      R4,[R0, #+8]
    703          
    704          		/* Set TWI handler */
    705          		irq_add_handler(id, _twid_handler, &async_desc[adesc_index]);
   \      0x154   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x158   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x15C   0xE09B'2101        ADDS     R2,R11,R1, LSL #+2
   \      0x160   0x....'....        LDR      R1,??DataTable8_9
   \      0x164   0xE1B0'0004        MOVS     R0,R4
   \      0x168   0x....'....        BL       irq_add_handler
    706          		/* Enable TWI interrupt */
    707          		irq_enable(id);
   \      0x16C   0xE1B0'0004        MOVS     R0,R4
   \      0x170   0x....'....        BL       irq_enable
    708          
    709          		if (desc->flags & BUS_BUF_ATTR_TX) {
   \      0x174   0xE5D5'0010        LDRB     R0,[R5, #+16]
   \      0x178   0xE310'0002        TST      R0,#0x2
   \      0x17C   0x0A00'0017        BEQ      ??_twid_transfer_9
    710          			if (_check_tx_timeout(desc)) {
   \      0x180   0xE1B0'0005        MOVS     R0,R5
   \      0x184   0x....'....        BL       _check_tx_timeout
   \      0x188   0xE350'0000        CMP      R0,#+0
   \      0x18C   0x0A00'0006        BEQ      ??_twid_transfer_10
    711          				twi_disable_it(desc->addr, TWI_IER_TXRDY);
   \      0x190   0xE3A0'1004        MOV      R1,#+4
   \      0x194   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x198   0x....'....        BL       twi_disable_it
    712          				irq_disable(id);
   \      0x19C   0xE1B0'0004        MOVS     R0,R4
   \      0x1A0   0x....'....        BL       irq_disable
    713          				return -ETIMEDOUT;
   \      0x1A4   0xE3E0'004C        MVN      R0,#+76
   \      0x1A8   0xEA00'0042        B        ??_twid_transfer_1
    714          			}
    715          
    716          #ifdef CONFIG_HAVE_TWI_FIFO
    717          			if (desc->use_fifo)
    718          				desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_TXRDYM_Msk) | TWI_FMR_TXRDYM_FOUR_DATA;
    719          #endif /* CONFIG_HAVE_TWI_FIFO */
    720          
    721          			/* Start twi with send first byte */
    722          			async_desc[adesc_index].transferred = 1;
   \                     ??_twid_transfer_10:
   \      0x1AC   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x1B0   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \      0x1B4   0xE09B'0101        ADDS     R0,R11,R1, LSL #+2
   \      0x1B8   0xE3A0'1001        MOV      R1,#+1
   \      0x1BC   0xE580'1018        STR      R1,[R0, #+24]
    723          			twi_enable_it(desc->addr, TWI_IER_TXRDY);
   \      0x1C0   0xE3A0'1004        MOV      R1,#+4
   \      0x1C4   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x1C8   0x....'....        BL       twi_enable_it
    724          			twi_write_byte(desc->addr, buf->data[0]);
   \      0x1CC   0xE596'0000        LDR      R0,[R6, #+0]
   \      0x1D0   0xE5D0'1000        LDRB     R1,[R0, #+0]
   \      0x1D4   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x1D8   0x....'....        BL       twi_write_byte
   \      0x1DC   0xEA00'0007        B        ??_twid_transfer_11
    725          		} else {
    726          #ifdef CONFIG_HAVE_TWI_FIFO
    727          			if (desc->use_fifo)
    728          				desc->addr->TWI_FMR = (desc->addr->TWI_FMR & ~TWI_FMR_RXRDYM_Msk) | TWI_FMR_RXRDYM_FOUR_DATA;
    729          #endif /* CONFIG_HAVE_TWI_FIFO */
    730          
    731          			/* Enable read interrupt and start the transfer */
    732          			twi_enable_it(desc->addr, TWI_IER_RXRDY);
   \                     ??_twid_transfer_9:
   \      0x1E0   0xE3A0'1002        MOV      R1,#+2
   \      0x1E4   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x1E8   0x....'....        BL       twi_enable_it
    733          
    734          			if (desc->flags & BUS_I2C_BUF_ATTR_START)
   \      0x1EC   0xE1D5'01B0        LDRH     R0,[R5, #+16]
   \      0x1F0   0xE310'0D40        TST      R0,#0x1000
   \      0x1F4   0x0A00'0001        BEQ      ??_twid_transfer_11
    735          				twi_send_start_condition(desc->addr);
   \      0x1F8   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x1FC   0x....'....        BL       twi_send_start_condition
    736          		}
    737          
    738          		adesc_index = (adesc_index + 1) % TWI_IFACE_COUNT;
   \                     ??_twid_transfer_11:
   \      0x200   0xE5DA'0000        LDRB     R0,[R10, #+0]
   \      0x204   0xE290'0001        ADDS     R0,R0,#+1
   \      0x208   0xE3A0'1003        MOV      R1,#+3
   \      0x20C   0x....'....        BL       __aeabi_idivmod
   \      0x210   0xE5CA'1000        STRB     R1,[R10, #+0]
    739          		break;
   \      0x214   0xEA00'0026        B        ??_twid_transfer_12
    740          
    741          	case BUS_TRANSFER_MODE_POLLING:
    742          		if (desc->flags & BUS_BUF_ATTR_TX)
   \                     ??_twid_transfer_5:
   \      0x218   0xE5D5'0010        LDRB     R0,[R5, #+16]
   \      0x21C   0xE310'0002        TST      R0,#0x2
   \      0x220   0x0A00'0004        BEQ      ??_twid_transfer_13
    743          			err = _twid_poll_write(desc, buf);
   \      0x224   0xE1B0'1006        MOVS     R1,R6
   \      0x228   0xE1B0'0005        MOVS     R0,R5
   \      0x22C   0x....'....        BL       _twid_poll_write
   \      0x230   0xE1B0'8000        MOVS     R8,R0
   \      0x234   0xEA00'0003        B        ??_twid_transfer_14
    744          		else
    745          			err = _twid_poll_read(desc, buf);
   \                     ??_twid_transfer_13:
   \      0x238   0xE1B0'1006        MOVS     R1,R6
   \      0x23C   0xE1B0'0005        MOVS     R0,R5
   \      0x240   0x....'....        BL       _twid_poll_read
   \      0x244   0xE1B0'8000        MOVS     R8,R0
    746          
    747          		if (err == 0)
   \                     ??_twid_transfer_14:
   \      0x248   0xE358'0000        CMP      R8,#+0
   \      0x24C   0x1A00'0002        BNE      ??_twid_transfer_15
    748          			callback_call(&desc->callback, NULL);
   \      0x250   0xE3A0'1000        MOV      R1,#+0
   \      0x254   0xE295'001C        ADDS     R0,R5,#+28
   \      0x258   0x....'....        BL       callback_call
    749          		mutex_unlock(&desc->mutex);
   \                     ??_twid_transfer_15:
   \      0x25C   0xE295'0018        ADDS     R0,R5,#+24
   \      0x260   0x....'....        BL       mutex_unlock
    750          		break;
   \      0x264   0xEA00'0012        B        ??_twid_transfer_12
    751          
    752          	case BUS_TRANSFER_MODE_DMA:
    753          		if (desc->flags & BUS_BUF_ATTR_TX)
   \                     ??_twid_transfer_6:
   \      0x268   0xE5D5'0010        LDRB     R0,[R5, #+16]
   \      0x26C   0xE310'0002        TST      R0,#0x2
   \      0x270   0x0A00'0003        BEQ      ??_twid_transfer_16
    754          			_twid_dma_write(desc, buf);
   \      0x274   0xE1B0'1006        MOVS     R1,R6
   \      0x278   0xE1B0'0005        MOVS     R0,R5
   \      0x27C   0x....'....        BL       _twid_dma_write
   \      0x280   0xEA00'0002        B        ??_twid_transfer_17
    755          		else
    756          			_twid_dma_read(desc, buf);
   \                     ??_twid_transfer_16:
   \      0x284   0xE1B0'1006        MOVS     R1,R6
   \      0x288   0xE1B0'0005        MOVS     R0,R5
   \      0x28C   0x....'....        BL       _twid_dma_read
    757          		break;
   \                     ??_twid_transfer_17:
   \      0x290   0xEA00'0007        B        ??_twid_transfer_12
    758          
    759          	default:
    760          		trace_error("Unknown TWI transfer mode");
   \                     ??_twid_transfer_7:
   \      0x294   0x....'....        LDR      R0,??DataTable7
   \      0x298   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x29C   0xE350'0002        CMP      R0,#+2
   \      0x2A0   0x3A00'0001        BCC      ??_twid_transfer_18
   \      0x2A4   0x....'....        LDR      R0,??DataTable8_10
   \      0x2A8   0x....'....        BL       printf
    761          		err = -ENOTSUP;
   \                     ??_twid_transfer_18:
   \      0x2AC   0xE3E0'003C        MVN      R0,#+60
   \      0x2B0   0xE1B0'8000        MOVS     R8,R0
    762          	}
    763          
    764          	return err;
   \                     ??_twid_transfer_12:
   \      0x2B4   0xE1B0'0008        MOVS     R0,R8
   \                     ??_twid_transfer_1:
   \      0x2B8   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    765          }
    766          
    767          /*----------------------------------------------------------------------------
    768           *        External functions
    769           *----------------------------------------------------------------------------*/
    770          

   \                                 In section SOFTPACK, align 4, keep-with-next
    771          int twid_configure(struct _twi_desc* desc)
    772          {
   \                     twid_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    773          	uint32_t id = get_twi_id_from_addr(desc->addr);
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       get_twi_id_from_addr
   \       0x10   0xE1B0'5000        MOVS     R5,R0
    774          	assert(id < ID_PERIPH_COUNT);
   \       0x14   0xE355'0033        CMP      R5,#+51
   \       0x18   0x3A00'0005        BCC      ??twid_configure_0
   \       0x1C   0xE3A0'2006        MOV      R2,#+6
   \       0x20   0xE382'2FC0        ORR      R2,R2,#0x300
   \       0x24   0x....'....        LDR      R1,??DataTable8_4
   \       0x28   0x....'....        LDR      R0,??DataTable8_11
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
    775          
    776          	if (desc->timeout == 0)
   \                     ??twid_configure_0:
   \       0x34   0xE594'0014        LDR      R0,[R4, #+20]
   \       0x38   0xE350'0000        CMP      R0,#+0
   \       0x3C   0x1A00'0001        BNE      ??twid_configure_1
    777          		desc->timeout = TWID_TIMEOUT;
   \       0x40   0xE3A0'0064        MOV      R0,#+100
   \       0x44   0xE584'0014        STR      R0,[R4, #+20]
    778          
    779          #ifdef CONFIG_HAVE_FLEXCOM
    780          	Flexcom* flexcom = get_flexcom_addr_from_id(get_twi_id_from_addr(desc->addr));
   \                     ??twid_configure_1:
   \       0x48   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x4C   0x....'....        BL       get_twi_id_from_addr
   \       0x50   0x....'....        BL       get_flexcom_addr_from_id
   \       0x54   0xE1B0'6000        MOVS     R6,R0
    781          	if (flexcom)
   \       0x58   0xE356'0000        CMP      R6,#+0
   \       0x5C   0x0A00'0002        BEQ      ??twid_configure_2
    782          		flexcom_select(flexcom, FLEX_MR_OPMODE_TWI);
   \       0x60   0xE3A0'1003        MOV      R1,#+3
   \       0x64   0xE1B0'0006        MOVS     R0,R6
   \       0x68   0x....'....        BL       flexcom_select
    783          #endif
    784          
    785          	pmc_configure_peripheral(id, NULL, true);
   \                     ??twid_configure_2:
   \       0x6C   0xE3A0'2001        MOV      R2,#+1
   \       0x70   0xE3A0'1000        MOV      R1,#+0
   \       0x74   0xE1B0'0005        MOVS     R0,R5
   \       0x78   0x....'....        BL       pmc_configure_peripheral
    786          	twi_configure_master(desc->addr, desc->freq);
   \       0x7C   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x80   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x84   0x....'....        BL       twi_configure_master
    787          #ifdef CONFIG_HAVE_TWI_FIFO
    788          	twid_fifo_configure(desc);
    789          	if (desc->use_fifo)
    790          		twi_fifo_enable(desc->addr, true);
    791          #endif
    792          
    793          	if(desc->dma.rx.channel) {
   \       0x88   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x8C   0xE350'0000        CMP      R0,#+0
   \       0x90   0x0A00'0005        BEQ      ??twid_configure_3
    794          		dma_stop_transfer(desc->dma.rx.channel);
   \       0x94   0xE594'0024        LDR      R0,[R4, #+36]
   \       0x98   0x....'....        BL       dma_stop_transfer
    795          		dma_free_channel(desc->dma.rx.channel);
   \       0x9C   0xE594'0024        LDR      R0,[R4, #+36]
   \       0xA0   0x....'....        BL       dma_free_channel
    796          		desc->dma.rx.channel = NULL;
   \       0xA4   0xE3A0'0000        MOV      R0,#+0
   \       0xA8   0xE584'0024        STR      R0,[R4, #+36]
    797          	}
    798          	desc->dma.rx.cfg_dma.incr_saddr = false;
   \                     ??twid_configure_3:
   \       0xAC   0xE3A0'7000        MOV      R7,#+0
   \       0xB0   0xE5C4'7030        STRB     R7,[R4, #+48]
    799          	desc->dma.rx.cfg_dma.incr_daddr = true;
   \       0xB4   0xE3A0'8001        MOV      R8,#+1
   \       0xB8   0xE5C4'8031        STRB     R8,[R4, #+49]
    800          	desc->dma.rx.cfg_dma.loop = false;
   \       0xBC   0xE5C4'7032        STRB     R7,[R4, #+50]
    801          	desc->dma.rx.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \       0xC0   0xE584'702C        STR      R7,[R4, #+44]
    802          
    803          	if(desc->dma.tx.channel) {
   \       0xC4   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xC8   0xE350'0000        CMP      R0,#+0
   \       0xCC   0x0A00'0004        BEQ      ??twid_configure_4
    804          		dma_stop_transfer(desc->dma.tx.channel);
   \       0xD0   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xD4   0x....'....        BL       dma_stop_transfer
    805          		dma_free_channel(desc->dma.tx.channel);
   \       0xD8   0xE594'0040        LDR      R0,[R4, #+64]
   \       0xDC   0x....'....        BL       dma_free_channel
    806          		desc->dma.tx.channel = NULL;
   \       0xE0   0xE584'7040        STR      R7,[R4, #+64]
    807          	}
    808          	desc->dma.tx.cfg_dma.incr_saddr = true;
   \                     ??twid_configure_4:
   \       0xE4   0xE5C4'804C        STRB     R8,[R4, #+76]
    809          	desc->dma.tx.cfg_dma.incr_daddr = false;
   \       0xE8   0xE5C4'704D        STRB     R7,[R4, #+77]
    810          	desc->dma.tx.cfg_dma.loop = false;
   \       0xEC   0xE5C4'704E        STRB     R7,[R4, #+78]
    811          	desc->dma.tx.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \       0xF0   0xE584'7048        STR      R7,[R4, #+72]
    812          
    813          	desc->mutex = 0;
   \       0xF4   0xE584'7018        STR      R7,[R4, #+24]
    814          
    815          	return 0;
   \       0xF8   0xE3A0'0000        MOV      R0,#+0
   \       0xFC   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    816          }
    817          

   \                                 In section SOFTPACK, align 4, keep-with-next
    818          int twid_slave_configure(struct _twi_slave_desc *desc, struct _twi_slave_ops* ops)
    819          {
   \                     twid_slave_configure:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    820          	uint32_t twi_id = get_twi_id_from_addr(desc->twi);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_twi_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    821          
    822          	irq_disable(twi_id);
   \       0x18   0xE1B0'0006        MOVS     R0,R6
   \       0x1C   0x....'....        BL       irq_disable
    823          	twi_disable_it(desc->twi, 0xffffffff);
   \       0x20   0xE3E0'1000        MVN      R1,#+0
   \       0x24   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x28   0x....'....        BL       twi_disable_it
    824          
    825          	desc->ops = ops;
   \       0x2C   0xE584'5008        STR      R5,[R4, #+8]
    826          	desc->state = TWID_SLAVE_STATE_STOPPED;
   \       0x30   0xE3A0'0000        MOV      R0,#+0
   \       0x34   0xE5C4'0006        STRB     R0,[R4, #+6]
    827          
    828          	async_desc[adesc_index].twi_id = twi_id;
   \       0x38   0x....'....        LDR      R7,??DataTable8_7
   \       0x3C   0x....'....        LDR      R8,??DataTable8_8
   \       0x40   0xE5D7'0000        LDRB     R0,[R7, #+0]
   \       0x44   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \       0x48   0xE098'0101        ADDS     R0,R8,R1, LSL #+2
   \       0x4C   0xE580'6008        STR      R6,[R0, #+8]
    829          	async_desc[adesc_index].twi_slave_desc = desc;
   \       0x50   0xE5D7'0000        LDRB     R0,[R7, #+0]
   \       0x54   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \       0x58   0xE098'0101        ADDS     R0,R8,R1, LSL #+2
   \       0x5C   0xE580'4004        STR      R4,[R0, #+4]
    830          
    831          #ifdef CONFIG_HAVE_FLEXCOM
    832          	Flexcom* flexcom = get_flexcom_addr_from_id(get_twi_id_from_addr(desc->twi));
   \       0x60   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x64   0x....'....        BL       get_twi_id_from_addr
   \       0x68   0x....'....        BL       get_flexcom_addr_from_id
   \       0x6C   0xE1B0'9000        MOVS     R9,R0
    833          	if (flexcom)
   \       0x70   0xE359'0000        CMP      R9,#+0
   \       0x74   0x0A00'0002        BEQ      ??twid_slave_configure_0
    834          		flexcom_select(flexcom, FLEX_MR_OPMODE_TWI);
   \       0x78   0xE3A0'1003        MOV      R1,#+3
   \       0x7C   0xE1B0'0009        MOVS     R0,R9
   \       0x80   0x....'....        BL       flexcom_select
    835          #endif
    836          
    837          	/* Configure TWI slave */
    838          	pmc_configure_peripheral(twi_id, NULL, true);
   \                     ??twid_slave_configure_0:
   \       0x84   0xE3A0'2001        MOV      R2,#+1
   \       0x88   0xE3A0'1000        MOV      R1,#+0
   \       0x8C   0xE1B0'0006        MOVS     R0,R6
   \       0x90   0x....'....        BL       pmc_configure_peripheral
    839          	twi_configure_slave(desc->twi, desc->addr);
   \       0x94   0xE1D4'10B4        LDRH     R1,[R4, #+4]
   \       0x98   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x9C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xA0   0x....'....        BL       twi_configure_slave
    840          	irq_add_handler(twi_id, _twid_slave_handler, &async_desc[adesc_index]);
   \       0xA4   0xE5D7'0000        LDRB     R0,[R7, #+0]
   \       0xA8   0xE060'1180        RSB      R1,R0,R0, LSL #+3
   \       0xAC   0xE098'2101        ADDS     R2,R8,R1, LSL #+2
   \       0xB0   0x....'....        LDR      R1,??DataTable8_12
   \       0xB4   0xE1B0'0006        MOVS     R0,R6
   \       0xB8   0x....'....        BL       irq_add_handler
    841          	twi_enable_it(desc->twi, TWI_IER_SVACC | TWI_IER_EOSACC);
   \       0xBC   0xE3A0'1E81        MOV      R1,#+2064
   \       0xC0   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xC4   0x....'....        BL       twi_enable_it
    842          	irq_enable(twi_id);
   \       0xC8   0xE1B0'0006        MOVS     R0,R6
   \       0xCC   0x....'....        BL       irq_enable
    843          
    844          	adesc_index = (adesc_index + 1) % TWI_IFACE_COUNT;
   \       0xD0   0xE5D7'0000        LDRB     R0,[R7, #+0]
   \       0xD4   0xE290'0001        ADDS     R0,R0,#+1
   \       0xD8   0xE3A0'1003        MOV      R1,#+3
   \       0xDC   0x....'....        BL       __aeabi_idivmod
   \       0xE0   0xE5C7'1000        STRB     R1,[R7, #+0]
    845          
    846          	return 0;
   \       0xE4   0xE3A0'0000        MOV      R0,#+0
   \       0xE8   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    847          }
    848          

   \                                 In section SOFTPACK, align 4, keep-with-next
    849          int twid_transfer(struct _twi_desc* desc, struct _buffer* buf, int buffers, struct _callback* cb)
    850          {
   \                     twid_transfer:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   \       0x10   0xE1B0'7003        MOVS     R7,R3
    851          	int b;
    852          	int err;
    853          
    854          	if (buf == NULL)
   \       0x14   0xE355'0000        CMP      R5,#+0
   \       0x18   0x1A00'0001        BNE      ??twid_transfer_0
    855          		return -EINVAL;
   \       0x1C   0xE3E0'001B        MVN      R0,#+27
   \       0x20   0xEA00'002A        B        ??twid_transfer_1
    856          
    857          	for (b = 0 ; b < buffers ; b++) {
   \                     ??twid_transfer_0:
   \       0x24   0xE3A0'9000        MOV      R9,#+0
   \                     ??twid_transfer_2:
   \       0x28   0xE159'0006        CMP      R9,R6
   \       0x2C   0xAA00'0026        BGE      ??twid_transfer_3
    858          		if ((buf[b].attr & (BUS_BUF_ATTR_TX | BUS_BUF_ATTR_RX)) == 0)
   \       0x30   0xE089'0089        ADD      R0,R9,R9, LSL #+1
   \       0x34   0xE095'0100        ADDS     R0,R5,R0, LSL #+2
   \       0x38   0xE5D0'0008        LDRB     R0,[R0, #+8]
   \       0x3C   0xE310'0003        TST      R0,#0x3
   \       0x40   0x1A00'0001        BNE      ??twid_transfer_4
    859          			return -EINVAL;
   \       0x44   0xE3E0'001B        MVN      R0,#+27
   \       0x48   0xEA00'0020        B        ??twid_transfer_1
    860          
    861          		if ((buf[b].attr & (BUS_BUF_ATTR_TX | BUS_BUF_ATTR_RX)) == (BUS_BUF_ATTR_TX | BUS_BUF_ATTR_RX))
   \                     ??twid_transfer_4:
   \       0x4C   0xE089'0089        ADD      R0,R9,R9, LSL #+1
   \       0x50   0xE095'0100        ADDS     R0,R5,R0, LSL #+2
   \       0x54   0xE5D0'0008        LDRB     R0,[R0, #+8]
   \       0x58   0xE210'0003        ANDS     R0,R0,#0x3
   \       0x5C   0xE350'0003        CMP      R0,#+3
   \       0x60   0x1A00'0001        BNE      ??twid_transfer_5
    862          			return -EINVAL;
   \       0x64   0xE3E0'001B        MVN      R0,#+27
   \       0x68   0xEA00'0018        B        ??twid_transfer_1
    863          
    864          		if (b == (buffers - 1)) {
   \                     ??twid_transfer_5:
   \       0x6C   0xE256'0001        SUBS     R0,R6,#+1
   \       0x70   0xE159'0000        CMP      R9,R0
   \       0x74   0x1A00'0006        BNE      ??twid_transfer_6
    865          			err = _twid_transfer(desc, &buf[b], cb);
   \       0x78   0xE1B0'2007        MOVS     R2,R7
   \       0x7C   0xE089'0089        ADD      R0,R9,R9, LSL #+1
   \       0x80   0xE095'1100        ADDS     R1,R5,R0, LSL #+2
   \       0x84   0xE1B0'0004        MOVS     R0,R4
   \       0x88   0x....'....        BL       _twid_transfer
   \       0x8C   0xE1B0'8000        MOVS     R8,R0
   \       0x90   0xEA00'0005        B        ??twid_transfer_7
    866          		} else {
    867          #if defined(CONFIG_SOC_SAM9XX5) || defined(CONFIG_SOC_SAMA5D3)
    868          			/* workaround for IP versions that do not support manual restart */
    869          			if (buf[b + 1].attr & BUS_I2C_BUF_ATTR_START)
    870          				buf[b].attr |= BUS_I2C_BUF_ATTR_STOP;
    871          #endif
    872          			err = _twid_transfer(desc, &buf[b], NULL);
   \                     ??twid_transfer_6:
   \       0x94   0xE3A0'2000        MOV      R2,#+0
   \       0x98   0xE089'0089        ADD      R0,R9,R9, LSL #+1
   \       0x9C   0xE095'1100        ADDS     R1,R5,R0, LSL #+2
   \       0xA0   0xE1B0'0004        MOVS     R0,R4
   \       0xA4   0x....'....        BL       _twid_transfer
   \       0xA8   0xE1B0'8000        MOVS     R8,R0
    873          		}
    874          		if (err < 0)
   \                     ??twid_transfer_7:
   \       0xAC   0xE358'0000        CMP      R8,#+0
   \       0xB0   0x5A00'0001        BPL      ??twid_transfer_8
    875          			return err;
   \       0xB4   0xE1B0'0008        MOVS     R0,R8
   \       0xB8   0xEA00'0004        B        ??twid_transfer_1
    876          		twid_wait_transfer(desc);
   \                     ??twid_transfer_8:
   \       0xBC   0xE1B0'0004        MOVS     R0,R4
   \       0xC0   0x....'....        BL       twid_wait_transfer
    877          	}
   \       0xC4   0xE299'9001        ADDS     R9,R9,#+1
   \       0xC8   0xEAFF'FFD6        B        ??twid_transfer_2
    878          
    879          	return 0;
   \                     ??twid_transfer_3:
   \       0xCC   0xE3A0'0000        MOV      R0,#+0
   \                     ??twid_transfer_1:
   \       0xD0   0xE8BD'83F2        POP      {R1,R4-R9,PC}    ;; return
    880          }
    881          

   \                                 In section SOFTPACK, align 4, keep-with-next
    882          bool twid_is_busy(const struct _twi_desc* desc)
    883          {
   \                     twid_is_busy:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    884          	return mutex_is_locked(&desc->mutex);
   \        0x8   0xE294'0018        ADDS     R0,R4,#+24
   \        0xC   0x....'....        BL       mutex_is_locked
   \       0x10   0xE8BD'8010        POP      {R4,PC}          ;; return
    885          }
    886          

   \                                 In section SOFTPACK, align 4, keep-with-next
    887          void twid_wait_transfer(const struct _twi_desc* desc)
    888          {
   \                     twid_wait_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    889          	while (twid_is_busy(desc)) {
   \                     ??twid_wait_transfer_0:
   \        0x8   0xE1B0'0004        MOVS     R0,R4
   \        0xC   0x....'....        BL       twid_is_busy
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x0A00'0004        BEQ      ??twid_wait_transfer_1
    890          		if (desc->transfer_mode == BUS_TRANSFER_MODE_DMA)
   \       0x18   0xE594'000C        LDR      R0,[R4, #+12]
   \       0x1C   0xE350'0002        CMP      R0,#+2
   \       0x20   0x1AFF'FFF8        BNE      ??twid_wait_transfer_0
    891          			dma_poll();
   \       0x24   0x....'....        BL       dma_poll
   \       0x28   0xEAFF'FFF6        B        ??twid_wait_transfer_0
    892          	}
    893          }
   \                     ??twid_wait_transfer_1:
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     adesc_index

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     async_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     _twid_handler

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x....'....        DC32     _twid_slave_handler

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x45          DC8 "-E- twid: command NACK\015\012"

   \              0x2D 0x20    

   \              0x74 0x77    

   \              0x69 0x64    

   \              0x3A 0x20    

   \              0x63 0x6F    

   \              0x6D 0x6D    

   \              0x61 0x6E    

   \              0x64 0x20    

   \              0x4E 0x41    

   \              0x43 0x4B    

   \              0x0D 0x0A    

   \              0x00
   \       0x19   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x45          DC8 "-E- twid: Device doesn't answer (RX TIMEOUT)\015\012"

   \              0x2D 0x20    

   \              0x74 0x77    

   \              0x69 0x64    

   \              0x3A 0x20    

   \              0x44 0x65    

   \              0x76 0x69    

   \              0x63 0x65    

   \              0x20 0x64    

   \              0x6F 0x65    

   \              0x73 0x6E    

   \              0x27 0x74    

   \              0x20 0x61    

   \              0x6E 0x73    

   \              0x77 0x65    

   \              0x72 0x20    

   \              0x28 0x52    

   \              0x58 0x20    

   \              0x54 0x49    

   \              0x4D 0x45    

   \              0x4F 0x55    

   \              0x54 0x29    

   \              0x0D 0x0A    

   \              0x00
   \       0x2F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x45          DC8 "-E- twid: Device doesn't answer (TX TIMEOUT)\015\012"

   \              0x2D 0x20    

   \              0x74 0x77    

   \              0x69 0x64    

   \              0x3A 0x20    

   \              0x44 0x65    

   \              0x76 0x69    

   \              0x63 0x65    

   \              0x20 0x64    

   \              0x6F 0x65    

   \              0x73 0x6E    

   \              0x27 0x74    

   \              0x20 0x61    

   \              0x6E 0x73    

   \              0x77 0x65    

   \              0x72 0x20    

   \              0x28 0x54    

   \              0x58 0x20    

   \              0x54 0x49    

   \              0x4D 0x45    

   \              0x4F 0x55    

   \              0x54 0x29    

   \              0x0D 0x0A    

   \              0x00
   \       0x2F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x45          DC8 "-E- twid: Unable to complete transfer!\015\012"

   \              0x2D 0x20    

   \              0x74 0x77    

   \              0x69 0x64    

   \              0x3A 0x20    

   \              0x55 0x6E    

   \              0x61 0x62    

   \              0x6C 0x65    

   \              0x20 0x74    

   \              0x6F 0x20    

   \              0x63 0x6F    

   \              0x6D 0x70    

   \              0x6C 0x65    

   \              0x74 0x65    

   \              0x20 0x74    

   \              0x72 0x61    

   \              0x6E 0x73    

   \              0x66 0x65    

   \              0x72 0x21    

   \              0x0D 0x0A    

   \              0x00
   \       0x29   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x64 0x65          DC8 "desc->dma.rx.channel"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x64 0x6D    

   \              0x61 0x2E    

   \              0x72 0x78    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x69, 0x32, 0x63, 0x5C, 0x74, 0x77

   \              0x69 0x32    

   \              0x63 0x5C    

   \              0x74 0x77
   \       0x40   0x69 0x64          DC8 0x69, 0x64, 0x2E, 0x63, 0

   \              0x2E 0x63    

   \              0x00
   \       0x45   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x64 0x65          DC8 "desc->dma.tx.channel"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x64 0x6D    

   \              0x61 0x2E    

   \              0x74 0x78    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x2D 0x45          DC8 "-E- Unknown TWI transfer mode"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x6B 0x6E    

   \              0x6F 0x77    

   \              0x6E 0x20    

   \              0x54 0x57    

   \              0x49 0x20    

   \              0x74 0x72    

   \              0x61 0x6E    

   \              0x73 0x66    

   \              0x65 0x72    

   \              0x20 0x6D    

   \              0x6F 0x64    

   \              0x65 0x00
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x69 0x64          DC8 "id < (51)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x35 0x31    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _check_nack
         8   -> printf
         8   -> twi_get_status
         8   -> twid_configure
      24   _check_rx_timeout
        24   -> printf
        24   -> timer_start_timeout
        24   -> timer_timeout_reached
        24   -> twi_is_byte_received
        24   -> twid_configure
      24   _check_tx_timeout
        24   -> printf
        24   -> timer_start_timeout
        24   -> timer_timeout_reached
        24   -> twi_is_byte_sent
        24   -> twid_configure
      40   _twid_dma_read
        40   -> __aeabi_assert
        40   -> __aeabi_memset
        40   -> __iar_EmptyStepPoint
        40   -> callback_set
        40   -> dma_allocate_channel
        40   -> dma_configure_transfer
        40   -> dma_set_callback
        40   -> dma_start_transfer
        40   -> get_twi_id_from_addr
        40   -> twi_send_start_condition
      16   _twid_dma_read_callback
        16   -> _check_rx_timeout
        16   -> cache_invalidate_region
        16   -> callback_call
        16   -> dma_reset_channel
        16   -> mutex_unlock
        16   -> twi_read_byte
        16   -> twi_send_stop_condition
      40   _twid_dma_write
        40   -> __aeabi_assert
        40   -> __aeabi_memset
        40   -> __iar_EmptyStepPoint
        40   -> cache_clean_region
        40   -> callback_set
        40   -> dma_allocate_channel
        40   -> dma_configure_transfer
        40   -> dma_set_callback
        40   -> dma_start_transfer
        40   -> get_twi_id_from_addr
      16   _twid_dma_write_callback
        16   -> _check_tx_timeout
        16   -> callback_call
        16   -> dma_reset_channel
        16   -> mutex_unlock
        16   -> twi_send_stop_condition
      40   _twid_handler
        40   -> callback_call
        40   -> irq_disable
        40   -> mutex_unlock
        40   -> twi_disable_it
        40   -> twi_enable_it
        40   -> twi_get_masked_status
        40   -> twi_read_byte
        40   -> twi_send_stop_condition
        40   -> twi_write_byte
      32   _twid_poll_read
        32   -> _check_nack
        32   -> _check_rx_timeout
        32   -> _twid_wait_twi_transfer
        32   -> twi_read_byte
        32   -> twi_send_start_condition
        32   -> twi_send_stop_condition
      24   _twid_poll_write
        24   -> _check_nack
        24   -> _check_tx_timeout
        24   -> _twid_wait_twi_transfer
        24   -> twi_is_byte_sent
        24   -> twi_send_stop_condition
        24   -> twi_write_byte
      32   _twid_slave_handler
        32   -- Indirect call
        32   -> twi_disable_it
        32   -> twi_enable_it
        32   -> twi_get_status
        32   -> twi_read_byte
        32   -> twi_write_byte
      40   _twid_transfer
        40   -> _check_tx_timeout
        40   -> _twid_dma_read
        40   -> _twid_dma_write
        40   -> _twid_poll_read
        40   -> _twid_poll_write
        40   -> callback_call
        40   -> callback_copy
        40   -> get_twi_id_from_addr
        40   -> irq_add_handler
        40   -> irq_disable
        40   -> irq_enable
        40   -> mutex_try_lock
        40   -> mutex_unlock
        40   -> printf
        40   -> twi_disable_it
        40   -> twi_enable_it
        40   -> twi_init_read
        40   -> twi_init_write
        40   -> twi_send_start_condition
        40   -> twi_write_byte
        40 __aeabi_idivmod
      24   _twid_wait_twi_transfer
        24   -> printf
        24   -> timer_start_timeout
        24   -> timer_timeout_reached
        24   -> twi_is_transfer_complete
        24   -> twid_configure
      24   twid_configure
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> dma_free_channel
        24   -> dma_stop_transfer
        24   -> flexcom_select
        24   -> get_flexcom_addr_from_id
        24   -> get_twi_id_from_addr
        24   -> pmc_configure_peripheral
        24   -> twi_configure_master
       8   twid_is_busy
         8   -> mutex_is_locked
      32   twid_slave_configure
        32   -> flexcom_select
        32   -> get_flexcom_addr_from_id
        32   -> get_twi_id_from_addr
        32   -> irq_add_handler
        32   -> irq_disable
        32   -> irq_enable
        32   -> pmc_configure_peripheral
        32   -> twi_configure_slave
        32   -> twi_disable_it
        32   -> twi_enable_it
        32 __aeabi_idivmod
      32   twid_transfer
        32   -> _twid_transfer
        32   -> twid_wait_transfer
       8   twid_wait_transfer
         8   -> dma_poll
         8   -> twid_is_busy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      28  ?_0
      48  ?_1
      48  ?_2
      44  ?_3
      24  ?_4
      72  ?_5
      24  ?_6
      32  ?_7
      12  ?_8
      72  _check_nack
     108  _check_rx_timeout
     108  _check_tx_timeout
     240  _twid_dma_read
     192  _twid_dma_read_callback
     236  _twid_dma_write
     104  _twid_dma_write_callback
     472  _twid_handler
     300  _twid_poll_read
     332  _twid_poll_write
     456  _twid_slave_handler
     700  _twid_transfer
     108  _twid_wait_twi_transfer
       1  adesc_index
      84  async_desc
     256  twid_configure
      20  twid_is_busy
     236  twid_slave_configure
     212  twid_transfer
      48  twid_wait_transfer

 
    85 bytes in section .bss
   332 bytes in section .rodata
 4'256 bytes in section SOFTPACK
 
 4'256 bytes of CODE  memory
   332 bytes of CONST memory
    85 bytes of DATA  memory

Errors: none
Warnings: none
