###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         05/Jan/2021  12:18:35
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twi.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWAC0E.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twi.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List\twi.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj\twi.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\i2c\twi.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup twi_module Working with TWI
     31           * \section Purpose
     32           * The TWI driver provides the interface to configure and use the TWI
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li> Configures a TWI peripheral to operate in master mode, at the given
     38           * frequency (in Hz) using twi_configure(). </li>
     39           * <li> Sends a STOP condition on the TWI using twi_stop().</li>
     40           * <li> twi_send_start_condition generate a START condition on the TWI bus with
     41           * the specified slave. Should be called explicitely.
     42           * <li> Starts a read operation on the TWI bus with the specified slave using
     43           * twi_start_read(). Data must then be read using twi_read_byte() whenever
     44           * a byte is available (poll using twi_is_byte_received()).</li>
     45           * <li> Starts a write operation on the TWI to access the selected slave using
     46           * twi_start_write(). A byte of data must be provided to start the write;
     47           * other bytes are written next.</li>
     48           * <li> Sends a byte of data to one of the TWI slaves on the bus using twi_write_byte().
     49           * This function must be called once before twi_start_write() with the first byte of data
     50           * to send, then it shall be called repeatedly after that to send the remaining bytes.</li>
     51           * <li> Check if a byte has been received and can be read on the given TWI
     52           * peripheral using twi_is_byte_received().<
     53           * Check if a byte has been sent using twi_byte_sent().</li>
     54           * <li> Check if the current transmission is complete (the STOP has been sent)
     55           * using twi_is_transfer_complete().</li>
     56           * <li> Enables & disable the selected interrupts sources on a TWI peripheral
     57           * using twi_enable_it() and twi_enable_it().</li>
     58           * <li> Get current status register of the given TWI peripheral using
     59           * twi_get_status(). Get current status register of the given TWI peripheral, but
     60           * masking interrupt sources which are not currently enabled using
     61           * twi_get_masked_status().</li>
     62           * </ul>
     63           * For more accurate information, please look at the TWI section of the
     64           * Datasheet.
     65           *
     66           * Related files :\n
     67           * \ref twi.c\n
     68           * \ref twi.h.\n
     69          */
     70          /*@{*/
     71          /*@}*/
     72          
     73          /**
     74           * \file
     75           *
     76           * Implementation of Two Wire Interface (TWI).
     77           *
     78           */
     79          
     80          /*----------------------------------------------------------------------------
     81           *        Headers
     82           *----------------------------------------------------------------------------*/
     83          
     84          #include "chip.h"
     85          #include "i2c/twi.h"
     86          #include "peripherals/pmc.h"
     87          #include "trace.h"
     88          #include "intmath.h"
     89          
     90          #include "timer.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void writeb(void volatile *, uint8_t)
   \                     writeb:
   \        0x0   0xE5C0'1000        STRB     R1,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void readb(void const volatile *, uint8_t *)
   \                     readb:
   \        0x0   0xE5D0'2000        LDRB     R2,[R0, #+0]
   \        0x4   0xE5C1'2000        STRB     R2,[R1, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     91          #include "io.h"
     92          
     93          #include <stddef.h>
     94          #include <assert.h>
     95          
     96          /*----------------------------------------------------------------------------
     97           *        Definitions
     98           *----------------------------------------------------------------------------*/
     99          
    100          #if defined(CONFIG_SOC_SAM9XX5) || defined(CONFIG_SOC_SAM9X60)
    101          #define TWI_CLK_OFFSET (4)
    102          #elif defined(CONFIG_SOC_SAMA5D2)
    103          #define TWI_CLK_OFFSET (3) /* TODO: handle GCK case (offset=0) */
    104          #elif defined(CONFIG_SOC_SAMA5D3)
    105          #define TWI_CLK_OFFSET (4)
    106          #elif defined(CONFIG_SOC_SAMA5D4)
    107          #define TWI_CLK_OFFSET (4)
    108          #elif defined(CONFIG_SOC_SAMV71)
    109          #define TWI_CLK_OFFSET (3)
    110          #else
    111          #error Unsupported SoC!
    112          #endif
    113          
    114          
    115          /*----------------------------------------------------------------------------
    116           *        Exported functions
    117           *----------------------------------------------------------------------------*/
    118          

   \                                 In section SOFTPACK, align 4, keep-with-next
    119          uint32_t twi_configure_master(Twi *twi, uint32_t twi_clock)
    120          {
   \                     twi_configure_master:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'A001        MOVS     R10,R1
    121          	uint32_t ck_div, clh_div, clock;
    122          	uint32_t hold = 0;
   \        0xC   0xE3A0'9000        MOV      R9,#+0
    123          	uint32_t id = get_twi_id_from_addr(twi);
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       get_twi_id_from_addr
   \       0x18   0xE1B0'8000        MOVS     R8,R0
    124          
    125          	assert(twi);
   \       0x1C   0xE354'0000        CMP      R4,#+0
   \       0x20   0x1A00'0004        BNE      ??twi_configure_master_0
   \       0x24   0xE3A0'207D        MOV      R2,#+125
   \       0x28   0x....'....        LDR      R1,??DataTable16
   \       0x2C   0x....'....        ADR      R0,??DataTable6  ;; "twi"
   \       0x30   0x....'....        BL       __aeabi_assert
   \       0x34   0x....'....        BL       __iar_EmptyStepPoint
    126          	assert(id < ID_PERIPH_COUNT);
   \                     ??twi_configure_master_0:
   \       0x38   0xE358'0033        CMP      R8,#+51
   \       0x3C   0x3A00'0004        BCC      ??twi_configure_master_1
   \       0x40   0xE3A0'207E        MOV      R2,#+126
   \       0x44   0x....'....        LDR      R1,??DataTable16
   \       0x48   0x....'....        LDR      R0,??DataTable16_1
   \       0x4C   0x....'....        BL       __aeabi_assert
   \       0x50   0x....'....        BL       __iar_EmptyStepPoint
    127          
    128          	/* TWI software reset */
    129          	twi->TWI_CR = TWI_CR_SWRST;
   \                     ??twi_configure_master_1:
   \       0x54   0xE3A0'0080        MOV      R0,#+128
   \       0x58   0xE584'0000        STR      R0,[R4, #+0]
    130          
    131          	/* Configure dummy slave address */
    132          	twi->TWI_MMR = 0;
   \       0x5C   0xE3A0'0000        MOV      R0,#+0
   \       0x60   0xE584'0004        STR      R0,[R4, #+4]
    133          
    134          	/* Compute clock */
    135          	clock = pmc_get_peripheral_clock(id);
   \       0x64   0xE1B0'0008        MOVS     R0,R8
   \       0x68   0x....'....        BL       pmc_get_peripheral_clock
   \       0x6C   0xE1B0'6000        MOVS     R6,R0
    136          	for (ck_div = 0; ck_div < 7; ck_div++) {
   \       0x70   0xE3A0'7000        MOV      R7,#+0
   \                     ??twi_configure_master_2:
   \       0x74   0xE357'0007        CMP      R7,#+7
   \       0x78   0x2A00'0009        BCS      ??twi_configure_master_3
    137          		clh_div = ((clock / twi_clock) - 2 * TWI_CLK_OFFSET) >> ck_div;
   \       0x7C   0xE1B0'0006        MOVS     R0,R6
   \       0x80   0xE1B0'100A        MOVS     R1,R10
   \       0x84   0x....'....        BL       __aeabi_uidiv
   \       0x88   0xE250'0008        SUBS     R0,R0,#+8
   \       0x8C   0xE1B0'0730        LSRS     R0,R0,R7
   \       0x90   0xE1B0'5000        MOVS     R5,R0
    138          		if (clh_div <= 511)
   \       0x94   0xE355'0F80        CMP      R5,#+512
   \       0x98   0x3A00'0001        BCC      ??twi_configure_master_3
    139          			break;
    140          	}
   \                     ??twi_configure_master_4:
   \       0x9C   0xE297'7001        ADDS     R7,R7,#+1
   \       0xA0   0xEAFF'FFF3        B        ??twi_configure_master_2
    141          
    142          #ifdef TWI_CWGR_HOLD
    143          	/* Compute holding time (I2C spec requires 300ns) */
    144          	hold = TWI_CWGR_HOLD(CEIL_INT_DIV((uint32_t)(0.3 * clock), 1000000) - 3);
   \                     ??twi_configure_master_3:
   \       0xA4   0xE1B0'0006        MOVS     R0,R6
   \       0xA8   0x....'....        BL       __aeabi_ui2d
   \       0xAC   0x....'....        ADR      R2,??DataTable8
   \       0xB0   0xE892'000C        LDM      R2,{R2,R3}
   \       0xB4   0x....'....        BL       __aeabi_dmul
   \       0xB8   0x....'....        BL       __aeabi_d2uiz
   \       0xBC   0x....'....        LDR      R1,??DataTable16_2  ;; 0xf423f
   \       0xC0   0xE091'0000        ADDS     R0,R1,R0
   \       0xC4   0xE3A0'1AF4        MOV      R1,#+999424
   \       0xC8   0xE381'1F90        ORR      R1,R1,#0x240
   \       0xCC   0x....'....        BL       __aeabi_uidiv
   \       0xD0   0xE250'0003        SUBS     R0,R0,#+3
   \       0xD4   0xE3A0'157C        MOV      R1,#+520093696
   \       0xD8   0xE011'BC00        ANDS     R11,R1,R0, LSL #+24
    145          #endif
    146          
    147          	/* Configure clock */
    148          	twi->TWI_CWGR = TWI_CWGR_CKDIV(ck_div)
    149          	              | TWI_CWGR_CHDIV(clh_div >> 1)
    150          	              | TWI_CWGR_CLDIV(clh_div >> 1)
    151          	              | hold;
   \       0xDC   0xE3A0'0A70        MOV      R0,#+458752
   \       0xE0   0xE010'0807        ANDS     R0,R0,R7, LSL #+16
   \       0xE4   0xE3A0'1CFF        MOV      R1,#+65280
   \       0xE8   0xE011'1385        ANDS     R1,R1,R5, LSL #+7
   \       0xEC   0xE191'0000        ORRS     R0,R1,R0
   \       0xF0   0xE3A0'10FF        MOV      R1,#+255
   \       0xF4   0xE011'10A5        ANDS     R1,R1,R5, LSR #+1
   \       0xF8   0xE191'0000        ORRS     R0,R1,R0
   \       0xFC   0xE19B'0000        ORRS     R0,R11,R0
   \      0x100   0xE584'0010        STR      R0,[R4, #+16]
    152          
    153          	/* Set master mode */
    154          	twi->TWI_CR = TWI_CR_SVDIS;
   \      0x104   0xE3A0'0020        MOV      R0,#+32
   \      0x108   0xE584'0000        STR      R0,[R4, #+0]
    155          	twi->TWI_CR = TWI_CR_MSEN;
   \      0x10C   0xE3A0'0004        MOV      R0,#+4
   \      0x110   0xE584'0000        STR      R0,[R4, #+0]
    156          
    157          	return clock / ((clh_div << ck_div) + 2 * TWI_CLK_OFFSET);
   \      0x114   0xE1B0'0006        MOVS     R0,R6
   \      0x118   0xE3A0'1008        MOV      R1,#+8
   \      0x11C   0xE091'1715        ADDS     R1,R1,R5, LSL R7
   \      0x120   0x....'....        BL       __aeabi_uidiv
   \      0x124   0xE8BD'8FF2        POP      {R1,R4-R11,PC}   ;; return
    158          }
    159          

   \                                 In section SOFTPACK, align 4, keep-with-next
    160          void twi_configure_slave(Twi *twi, uint8_t slave_address)
    161          {
   \                     twi_configure_slave:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    162          	assert(twi);
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0004        BNE      ??twi_configure_slave_0
   \       0x14   0xE3A0'20A2        MOV      R2,#+162
   \       0x18   0x....'....        LDR      R1,??DataTable16
   \       0x1C   0x....'....        ADR      R0,??DataTable6  ;; "twi"
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    163          
    164          	/* TWI software reset */
    165          	twi->TWI_CR = TWI_CR_SWRST;
   \                     ??twi_configure_slave_0:
   \       0x28   0xE3A0'0080        MOV      R0,#+128
   \       0x2C   0xE584'0000        STR      R0,[R4, #+0]
    166          
    167          	/* Configure slave address. */
    168          	twi->TWI_SMR = TWI_SMR_SADR(slave_address);
   \       0x30   0xE1B0'0005        MOVS     R0,R5
   \       0x34   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x38   0xE3A0'187F        MOV      R1,#+8323072
   \       0x3C   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \       0x40   0xE584'0008        STR      R0,[R4, #+8]
    169          
    170          	/* Set Slave Mode */
    171          	twi->TWI_CR = TWI_CR_MSDIS;
   \       0x44   0xE3A0'0008        MOV      R0,#+8
   \       0x48   0xE584'0000        STR      R0,[R4, #+0]
    172          	twi->TWI_CR = TWI_CR_SVEN;
   \       0x4C   0xE3A0'0010        MOV      R0,#+16
   \       0x50   0xE584'0000        STR      R0,[R4, #+0]
    173          }
   \       0x54   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    174          

   \                                 In section SOFTPACK, align 4, keep-with-next
    175          void twi_stop(Twi *twi)
    176          {
   \                     twi_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    177          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_stop_0
   \       0x10   0xE3A0'20B1        MOV      R2,#+177
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    178          	twi->TWI_CR = TWI_CR_STOP;
   \                     ??twi_stop_0:
   \       0x24   0xE3A0'0002        MOV      R0,#+2
   \       0x28   0xE584'0000        STR      R0,[R4, #+0]
    179          }
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
    180          

   \                                 In section SOFTPACK, align 4, keep-with-next
    181          void twi_init_read(Twi *twi, uint8_t address, uint32_t iaddress, uint8_t isize)
    182          {
   \                     twi_init_read:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   \       0x10   0xE1B0'7003        MOVS     R7,R3
    183          	assert(twi != NULL);
   \       0x14   0xE354'0000        CMP      R4,#+0
   \       0x18   0x1A00'0004        BNE      ??twi_init_read_0
   \       0x1C   0xE3A0'20B7        MOV      R2,#+183
   \       0x20   0x....'....        LDR      R1,??DataTable16
   \       0x24   0x....'....        LDR      R0,??DataTable16_3
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    184          	assert((address & 0x80) == 0);
   \                     ??twi_init_read_0:
   \       0x30   0xE315'0080        TST      R5,#0x80
   \       0x34   0x0A00'0004        BEQ      ??twi_init_read_1
   \       0x38   0xE3A0'20B8        MOV      R2,#+184
   \       0x3C   0x....'....        LDR      R1,??DataTable16
   \       0x40   0x....'....        LDR      R0,??DataTable16_4
   \       0x44   0x....'....        BL       __aeabi_assert
   \       0x48   0x....'....        BL       __iar_EmptyStepPoint
    185          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twi_init_read_1:
   \       0x4C   0xE316'04FF        TST      R6,#0xFF000000
   \       0x50   0x0A00'0004        BEQ      ??twi_init_read_2
   \       0x54   0xE3A0'20B9        MOV      R2,#+185
   \       0x58   0x....'....        LDR      R1,??DataTable16
   \       0x5C   0x....'....        LDR      R0,??DataTable16_5
   \       0x60   0x....'....        BL       __aeabi_assert
   \       0x64   0x....'....        BL       __iar_EmptyStepPoint
    186          	assert(isize < 4);
   \                     ??twi_init_read_2:
   \       0x68   0xE1B0'0007        MOVS     R0,R7
   \       0x6C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x70   0xE350'0004        CMP      R0,#+4
   \       0x74   0xBA00'0004        BLT      ??twi_init_read_3
   \       0x78   0xE3A0'20BA        MOV      R2,#+186
   \       0x7C   0x....'....        LDR      R1,??DataTable16
   \       0x80   0x....'....        LDR      R0,??DataTable16_6
   \       0x84   0x....'....        BL       __aeabi_assert
   \       0x88   0x....'....        BL       __iar_EmptyStepPoint
    187          
    188          	/* Set slave address and number of internal address bytes. */
    189          	twi->TWI_MMR = TWI_MMR_DADR(address) | TWI_MMR_MREAD | TWI_MMR_IADRSZ(isize);
   \                     ??twi_init_read_3:
   \       0x8C   0xE1B0'0005        MOVS     R0,R5
   \       0x90   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x94   0xE3A0'187F        MOV      R1,#+8323072
   \       0x98   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \       0x9C   0xE1B0'1007        MOVS     R1,R7
   \       0xA0   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0xA4   0xE3A0'2FC0        MOV      R2,#+768
   \       0xA8   0xE012'1401        ANDS     R1,R2,R1, LSL #+8
   \       0xAC   0xE191'0000        ORRS     R0,R1,R0
   \       0xB0   0xE390'0D40        ORRS     R0,R0,#0x1000
   \       0xB4   0xE584'0004        STR      R0,[R4, #+4]
    190          	/* Set internal address bytes */
    191          	twi->TWI_IADR = TWI_IADR_IADR(iaddress);
   \       0xB8   0xE3D6'04FF        BICS     R0,R6,#0xFF000000
   \       0xBC   0xE584'000C        STR      R0,[R4, #+12]
    192          }
   \       0xC0   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    193          

   \                                 In section SOFTPACK, align 4, keep-with-next
    194          uint8_t twi_read_byte(Twi *twi)
    195          {
   \                     twi_read_byte:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    196          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_read_byte_0
   \       0x10   0xE3A0'20C4        MOV      R2,#+196
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    197          	uint8_t value;
    198          	readb(&twi->TWI_RHR, &value);
   \                     ??twi_read_byte_0:
   \       0x24   0xE1B0'100D        MOVS     R1,SP
   \       0x28   0xE294'0030        ADDS     R0,R4,#+48
   \       0x2C   0x....'....        BL       readb
    199          	return value;
   \       0x30   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \       0x34   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
    200          }
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void twi_write_byte(Twi *twi, uint8_t byte)
    203          {
   \                     twi_write_byte:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    204          	assert(twi != NULL);
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0004        BNE      ??twi_write_byte_0
   \       0x14   0xE3A0'20CC        MOV      R2,#+204
   \       0x18   0x....'....        LDR      R1,??DataTable16
   \       0x1C   0x....'....        LDR      R0,??DataTable16_3
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    205          	writeb(&twi->TWI_THR, byte);
   \                     ??twi_write_byte_0:
   \       0x28   0xE1B0'1005        MOVS     R1,R5
   \       0x2C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x30   0xE294'0034        ADDS     R0,R4,#+52
   \       0x34   0x....'....        BL       writeb
    206          }
   \       0x38   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    207          

   \                                 In section SOFTPACK, align 4, keep-with-next
    208          void twi_init_write(Twi *twi, uint8_t address, uint32_t iaddress, uint8_t isize)
    209          {
   \                     twi_init_write:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   \       0x10   0xE1B0'7003        MOVS     R7,R3
    210          	assert(twi != NULL);
   \       0x14   0xE354'0000        CMP      R4,#+0
   \       0x18   0x1A00'0004        BNE      ??twi_init_write_0
   \       0x1C   0xE3A0'20D2        MOV      R2,#+210
   \       0x20   0x....'....        LDR      R1,??DataTable16
   \       0x24   0x....'....        LDR      R0,??DataTable16_3
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
    211          	assert((address & 0x80) == 0);
   \                     ??twi_init_write_0:
   \       0x30   0xE315'0080        TST      R5,#0x80
   \       0x34   0x0A00'0004        BEQ      ??twi_init_write_1
   \       0x38   0xE3A0'20D3        MOV      R2,#+211
   \       0x3C   0x....'....        LDR      R1,??DataTable16
   \       0x40   0x....'....        LDR      R0,??DataTable16_4
   \       0x44   0x....'....        BL       __aeabi_assert
   \       0x48   0x....'....        BL       __iar_EmptyStepPoint
    212          	assert((iaddress & 0xFF000000) == 0);
   \                     ??twi_init_write_1:
   \       0x4C   0xE316'04FF        TST      R6,#0xFF000000
   \       0x50   0x0A00'0004        BEQ      ??twi_init_write_2
   \       0x54   0xE3A0'20D4        MOV      R2,#+212
   \       0x58   0x....'....        LDR      R1,??DataTable16
   \       0x5C   0x....'....        LDR      R0,??DataTable16_5
   \       0x60   0x....'....        BL       __aeabi_assert
   \       0x64   0x....'....        BL       __iar_EmptyStepPoint
    213          	assert(isize < 4);
   \                     ??twi_init_write_2:
   \       0x68   0xE1B0'0007        MOVS     R0,R7
   \       0x6C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x70   0xE350'0004        CMP      R0,#+4
   \       0x74   0xBA00'0004        BLT      ??twi_init_write_3
   \       0x78   0xE3A0'20D5        MOV      R2,#+213
   \       0x7C   0x....'....        LDR      R1,??DataTable16
   \       0x80   0x....'....        LDR      R0,??DataTable16_6
   \       0x84   0x....'....        BL       __aeabi_assert
   \       0x88   0x....'....        BL       __iar_EmptyStepPoint
    214          
    215          	/* Set slave address and number of internal address bytes. */
    216          	twi->TWI_MMR = TWI_MMR_DADR(address) | TWI_MMR_IADRSZ(isize);
   \                     ??twi_init_write_3:
   \       0x8C   0xE1B0'0005        MOVS     R0,R5
   \       0x90   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x94   0xE3A0'187F        MOV      R1,#+8323072
   \       0x98   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \       0x9C   0xE1B0'1007        MOVS     R1,R7
   \       0xA0   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0xA4   0xE3A0'2FC0        MOV      R2,#+768
   \       0xA8   0xE012'1401        ANDS     R1,R2,R1, LSL #+8
   \       0xAC   0xE191'0000        ORRS     R0,R1,R0
   \       0xB0   0xE584'0004        STR      R0,[R4, #+4]
    217          	/* Set internal address bytes. */
    218          	twi->TWI_IADR = TWI_IADR_IADR(iaddress);
   \       0xB4   0xE3D6'04FF        BICS     R0,R6,#0xFF000000
   \       0xB8   0xE584'000C        STR      R0,[R4, #+12]
    219          }
   \       0xBC   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
    220          

   \                                 In section SOFTPACK, align 4, keep-with-next
    221          uint8_t twi_is_byte_received(Twi *twi)
    222          {
   \                     twi_is_byte_received:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    223          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_is_byte_received_0
   \       0x10   0xE3A0'20DF        MOV      R2,#+223
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    224          	return (twi->TWI_SR & TWI_SR_RXRDY) == TWI_SR_RXRDY;
   \                     ??twi_is_byte_received_0:
   \       0x24   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x28   0xE1B0'00A0        LSRS     R0,R0,#+1
   \       0x2C   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    225          }
    226          

   \                                 In section SOFTPACK, align 4, keep-with-next
    227          uint8_t twi_is_byte_sent(Twi *twi)
    228          {
   \                     twi_is_byte_sent:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    229          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_is_byte_sent_0
   \       0x10   0xE3A0'20E5        MOV      R2,#+229
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    230          	return (twi->TWI_SR & TWI_SR_TXRDY) == TWI_SR_TXRDY;
   \                     ??twi_is_byte_sent_0:
   \       0x24   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x28   0xE1B0'0120        LSRS     R0,R0,#+2
   \       0x2C   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    231          }
    232          

   \                                 In section SOFTPACK, align 4, keep-with-next
    233          uint8_t twi_is_transfer_complete(Twi *twi)
    234          {
   \                     twi_is_transfer_complete:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    235          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_is_transfer_complete_0
   \       0x10   0xE3A0'20EB        MOV      R2,#+235
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    236          	return (twi->TWI_SR & TWI_SR_TXCOMP) == TWI_SR_TXCOMP;
   \                     ??twi_is_transfer_complete_0:
   \       0x24   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x28   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
    237          }
    238          

   \                                 In section SOFTPACK, align 4, keep-with-next
    239          void twi_enable_it(Twi *twi, uint32_t sources)
    240          {
   \                     twi_enable_it:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    241          	assert(twi != NULL);
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0004        BNE      ??twi_enable_it_0
   \       0x14   0xE3A0'20F1        MOV      R2,#+241
   \       0x18   0x....'....        LDR      R1,??DataTable16
   \       0x1C   0x....'....        LDR      R0,??DataTable16_3
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    242          	twi->TWI_IER = sources;
   \                     ??twi_enable_it_0:
   \       0x28   0xE584'5024        STR      R5,[R4, #+36]
    243          }
   \       0x2C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    244          

   \                                 In section SOFTPACK, align 4, keep-with-next
    245          void twi_disable_it(Twi *twi, uint32_t sources)
    246          {
   \                     twi_disable_it:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    247          	assert(twi != NULL);
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x1A00'0004        BNE      ??twi_disable_it_0
   \       0x14   0xE3A0'20F7        MOV      R2,#+247
   \       0x18   0x....'....        LDR      R1,??DataTable16
   \       0x1C   0x....'....        LDR      R0,??DataTable16_3
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    248          	twi->TWI_IDR = sources;
   \                     ??twi_disable_it_0:
   \       0x28   0xE584'5028        STR      R5,[R4, #+40]
    249          }
   \       0x2C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    250          

   \                                 In section SOFTPACK, align 4, keep-with-next
    251          uint32_t twi_get_status(Twi *twi)
    252          {
   \                     twi_get_status:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    253          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_get_status_0
   \       0x10   0xE3A0'20FD        MOV      R2,#+253
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    254          	return twi->TWI_SR;
   \                     ??twi_get_status_0:
   \       0x24   0xE594'0020        LDR      R0,[R4, #+32]
   \       0x28   0xE8BD'8010        POP      {R4,PC}          ;; return
    255          }
    256          

   \                                 In section SOFTPACK, align 4, keep-with-next
    257          uint32_t twi_get_masked_status(Twi *twi)
    258          {
   \                     twi_get_masked_status:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    259          	uint32_t status;
    260          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_get_masked_status_0
   \       0x10   0xE3A0'2F41        MOV      R2,#+260
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    261          	status = twi->TWI_SR;
   \                     ??twi_get_masked_status_0:
   \       0x24   0xE594'0020        LDR      R0,[R4, #+32]
    262          	status &= twi->TWI_IMR;
   \       0x28   0xE594'102C        LDR      R1,[R4, #+44]
   \       0x2C   0xE011'0000        ANDS     R0,R1,R0
    263          	return status;
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    264          }
    265          

   \                                 In section SOFTPACK, align 4, keep-with-next
    266          void twi_send_stop_condition(Twi *twi)
    267          {
   \                     twi_send_stop_condition:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    268          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0004        BNE      ??twi_send_stop_condition_0
   \       0x10   0xE3A0'2F43        MOV      R2,#+268
   \       0x14   0x....'....        LDR      R1,??DataTable16
   \       0x18   0x....'....        LDR      R0,??DataTable16_3
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
    269          	twi->TWI_CR = TWI_CR_STOP;
   \                     ??twi_send_stop_condition_0:
   \       0x24   0xE3A0'0002        MOV      R0,#+2
   \       0x28   0xE584'0000        STR      R0,[R4, #+0]
    270          }
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
    271          

   \                                 In section SOFTPACK, align 4, keep-with-next
    272          void twi_send_start_condition(Twi *twi)
    273          {
   \                     twi_send_start_condition:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    274          	assert(twi != NULL);
   \        0x8   0xE354'0000        CMP      R4,#+0
   \        0xC   0x1A00'0005        BNE      ??twi_send_start_condition_0
   \       0x10   0xE3A0'2012        MOV      R2,#+18
   \       0x14   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x18   0x....'....        LDR      R1,??DataTable16
   \       0x1C   0x....'....        LDR      R0,??DataTable16_3
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
    275          	twi->TWI_CR = TWI_CR_START;
   \                     ??twi_send_start_condition_0:
   \       0x28   0xE3A0'0001        MOV      R0,#+1
   \       0x2C   0xE584'0000        STR      R0,[R4, #+0]
    276          }
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x74 0x77          DC8      "twi"

   \              0x69 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x3333'3333        DC32     0x33333333,0x3FD33333

   \              0x3FD3'3333

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x000F'423F        DC32     0xf423f

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .rodata, align 4
   \        0x0   0x74 0x77          DC8 "twi"

   \              0x69 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x69, 0x32, 0x63, 0x5C, 0x74, 0x77

   \              0x69 0x32    

   \              0x63 0x5C    

   \              0x74 0x77
   \       0x40   0x69 0x2E          DC8 0x69, 0x2E, 0x63, 0

   \              0x63 0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x69 0x64          DC8 "id < (51)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x35 0x31    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x74 0x77          DC8 "twi != ((void*)0)"

   \              0x69 0x20    

   \              0x21 0x3D    

   \              0x20 0x28    

   \              0x28 0x76    

   \              0x6F 0x69    

   \              0x64 0x2A    

   \              0x29 0x30    

   \              0x29 0x00
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x28 0x61          DC8 "(address & 0x80) == 0"

   \              0x64 0x64    

   \              0x72 0x65    

   \              0x73 0x73    

   \              0x20 0x26    

   \              0x20 0x30    

   \              0x78 0x38    

   \              0x30 0x29    

   \              0x20 0x3D    

   \              0x3D 0x20    

   \              0x30 0x00
   \       0x16   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x28 0x69          DC8 "(iaddress & 0xFF000000) == 0"

   \              0x61 0x64    

   \              0x64 0x72    

   \              0x65 0x73    

   \              0x73 0x20    

   \              0x26 0x20    

   \              0x30 0x78    

   \              0x46 0x46    

   \              0x30 0x30    

   \              0x30 0x30    

   \              0x30 0x30    

   \              0x29 0x20    

   \              0x3D 0x3D    

   \              0x20 0x30    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x69 0x73          DC8 "isize < 4"

   \              0x69 0x7A    

   \              0x65 0x20    

   \              0x3C 0x20    

   \              0x34 0x00
   \        0xA   0x00 0x00          DC8 0, 0
    277          
    278          #ifdef CONFIG_HAVE_TWI_ALTERNATE_CMD
    279          
    280          void twi_alt_cmd_configure_write(Twi *twi, uint8_t len)
    281          {
    282          	assert(twi != NULL);
    283          	twi->TWI_ACR = TWI_ACR_DATAL(len);
    284          }
    285          
    286          void twi_alt_cmd_configure_read(Twi *twi, uint8_t len)
    287          {
    288          	assert(twi != NULL);
    289          	twi->TWI_ACR = TWI_ACR_DATAL(len) | TWI_ACR_DIR;
    290          }
    291          
    292          void twi_alt_cmd_enable(Twi *twi)
    293          {
    294          	twi->TWI_CR = TWI_CR_ACMEN;
    295          }
    296          
    297          void twi_alt_cmd_disable(Twi *twi)
    298          {
    299          	twi->TWI_CR = TWI_CR_ACMDIS;
    300          }
    301          
    302          #endif /* CONFIG_HAVE_TWI_ALTERNATE_CMD */
    303          
    304          #ifdef CONFIG_HAVE_TWI_FIFO
    305          
    306          void twi_fifo_configure(Twi *twi, uint8_t tx_thres, uint8_t rx_thres, uint32_t rdym)
    307          {
    308          	assert(twi != NULL);
    309          
    310          	/* Configure FIFO */
    311          	twi->TWI_FMR = TWI_FMR_TXFTHRES(tx_thres) | TWI_FMR_RXFTHRES(rx_thres) | rdym;
    312          }
    313          
    314          void twi_fifo_enable(Twi *twi, bool master)
    315          {
    316          	assert(twi != NULL);
    317          
    318          	/* Enable TWI master and slave mode and activate FIFO */
    319          	twi->TWI_CR = TWI_CR_MSDIS | TWI_CR_SVDIS;
    320          	twi->TWI_CR = TWI_CR_FIFOEN;
    321          	twi->TWI_CR = TWI_CR_TXFCLR | TWI_CR_RXFCLR;
    322          
    323          	if (master)
    324          		twi->TWI_CR = TWI_CR_MSEN;
    325          	else
    326          		twi->TWI_CR = TWI_CR_SVEN;
    327          }
    328          
    329          void twi_fifo_disable(Twi *twi, bool master)
    330          {
    331          	assert(twi != NULL);
    332          
    333          	/* Disable TWI master and slave mode and activate FIFO */
    334          	twi->TWI_CR = TWI_CR_MSDIS | TWI_CR_SVDIS;
    335          	twi->TWI_CR = TWI_CR_TXFCLR | TWI_CR_RXFCLR;
    336          	twi->TWI_CR = TWI_CR_FIFODIS;
    337          
    338          	if (master)
    339          		twi->TWI_CR = TWI_CR_MSEN;
    340          	else
    341          		twi->TWI_CR = TWI_CR_SVEN;
    342          }
    343          
    344          uint32_t twi_fifo_get_rx_size(Twi *twi)
    345          {
    346          	assert(twi != NULL);
    347          
    348          	return (twi->TWI_FLR & TWI_FLR_RXFL_Msk) >> TWI_FLR_RXFL_Pos;
    349          }
    350          
    351          uint32_t twi_fifo_get_tx_size(Twi *twi)
    352          {
    353          	assert(twi != NULL);
    354          
    355          	return (twi->TWI_FLR & TWI_FLR_TXFL_Msk) >> TWI_FLR_TXFL_Pos;
    356          }
    357          
    358          uint8_t twi_fifo_write(Twi *twi, uint8_t *data, uint8_t size)
    359          {
    360          	uint8_t i;
    361          
    362          	assert(twi != NULL);
    363          
    364          	for (i = 0 ; i < size ; ) {
    365          		if ((size - i) >= 4) {
    366          			writew(&twi->TWI_THR,  *(uint32_t*)&data[i]);
    367          			i += 4;
    368          		} else if ((size - i) >= 2) {
    369          			writehw(&twi->TWI_THR, *(uint16_t*)&data[i]);
    370          			i += 2;
    371          		} else {
    372          			writeb(&twi->TWI_THR,  *(uint8_t*)&data[i]);
    373          			i += 1;
    374          		}
    375          	}
    376          
    377          	return i;
    378          }
    379          
    380          uint8_t twi_fifo_read(Twi *twi, uint8_t *data, uint8_t size)
    381          {
    382          	uint8_t i;
    383          
    384          	assert(twi != NULL);
    385          
    386          	for (i = 0 ; i < size ; ) {
    387          		if ((size - i) >= 4) {
    388          			readw(&twi->TWI_RHR, (uint32_t*)&data[i]);
    389          			i += 4;
    390          		} else if ((size - i) >= 2) {
    391          			readhw(&twi->TWI_RHR, (uint16_t*)&data[i]);
    392          			i += 2;
    393          		} else {
    394          			readb(&twi->TWI_RHR,  (uint8_t*)&data[i]);
    395          			i += 1;
    396          		}
    397          	}
    398          
    399          	return i;
    400          }
    401          
    402          void twi_fifo_flush_rx(Twi *twi)
    403          {
    404          	assert(twi != NULL);
    405          	twi->TWI_CR = TWI_CR_RXFCLR;
    406          }
    407          
    408          void twi_fifo_flush_tx(Twi *twi)
    409          {
    410          	assert(twi != NULL);
    411          	twi->TWI_CR = TWI_CR_TXFCLR;
    412          }
    413          
    414          bool twi_fifo_is_locked(Twi *twi)
    415          {
    416          	assert(twi != NULL);
    417          	return twi->TWI_SR & TWI_SR_LOCK;
    418          }
    419          
    420          void twi_fifo_unlock(Twi *twi)
    421          {
    422          	assert(twi != NULL);
    423          	twi->TWI_CR = TWI_CR_LOCKCLR;
    424          }
    425          
    426          #endif /* CONFIG_HAVE_TWI_FIFO */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   readb
      40   twi_configure_master
        40   -> __aeabi_assert
        40   -> __aeabi_d2uiz
        40   -> __aeabi_dmul
        40   -> __aeabi_ui2d
        40   -> __iar_EmptyStepPoint
        40   -> get_twi_id_from_addr
        40   -> pmc_get_peripheral_clock
        40 __aeabi_uidiv
      16   twi_configure_slave
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_disable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   twi_enable_it
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   twi_get_masked_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_get_status
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      24   twi_init_read
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   twi_init_write
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       8   twi_is_byte_received
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_byte_sent
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_is_transfer_complete
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   twi_read_byte
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> readb
       8   twi_send_start_condition
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_send_stop_condition
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   twi_stop
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   twi_write_byte
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> writeb
       0   writeb


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable6
       8  ??DataTable8
       4  ?_0
      68  ?_1
      12  ?_2
      20  ?_3
      24  ?_4
      32  ?_5
      12  ?_6
      12  readb
     296  twi_configure_master
      88  twi_configure_slave
      48  twi_disable_it
      48  twi_enable_it
      52  twi_get_masked_status
      44  twi_get_status
     196  twi_init_read
     192  twi_init_write
      52  twi_is_byte_received
      52  twi_is_byte_sent
      48  twi_is_transfer_complete
      56  twi_read_byte
      52  twi_send_start_condition
      48  twi_send_stop_condition
      48  twi_stop
      60  twi_write_byte
       8  writeb

 
   172 bytes in section .rodata
 1'440 bytes in section SOFTPACK
 
 1'440 bytes of CODE  memory
   172 bytes of CONST memory

Errors: none
Warnings: none
