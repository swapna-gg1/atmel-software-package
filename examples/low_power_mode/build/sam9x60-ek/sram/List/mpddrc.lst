###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         05/Jan/2021  12:18:32
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\mpddrc.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EWA0DC.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\mpddrc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List\mpddrc.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj\mpddrc.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __iar_require _Printf         
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\mpddrc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          #include "chip.h"
     31          #include "barriers.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void dmb(void)
   \                     `dmb`:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
     32          #include "timer.h"
     33          #include "trace.h"
     34          
     35          #include "extram/mpddrc.h"
     36          #include "peripherals/pmc.h"
     37          #include "peripherals/sfrbu.h"
     38          
     39          #include <assert.h>
     40          #include <stdlib.h>
     41          
     42          #ifndef MPDDRC_LPR_LPCB_DISABLED
     43          #define MPDDRC_LPR_LPCB_DISABLED			(MPDDRC_LPR_LPCB_NOLOWPOWER)
     44          #endif
     45          

   \                                 In section SOFTPACK, align 4, keep-with-next
     46          static void _set_ddr_timings(struct _mpddrc_desc* desc)
     47          {
     48          #ifdef CONFIG_HAVE_MPDDRC_SDRAM_ONLY
     49          	uint8_t trc_trfc, txsr;
     50          
     51          	/* single register value for tRC and tRFC, use max */
     52          	trc_trfc = desc->timings.trc;
     53          	if (desc->timings.trfc > trc_trfc)
     54          		trc_trfc = desc->timings.trfc;
     55          
     56          	/* single register value for tXSRD and tXSNR */
     57          	txsr = desc->timings.txsrd;
     58          	if (desc->timings.txsnr > txsr)
     59          		txsr = desc->timings.txsnr;
     60          
     61          	uint32_t cr = MPDDRC->MPDDRC_CR;
     62          	cr &= ~(MPDDRC_CR_TWR_Msk |
     63          	        MPDDRC_CR_TRC_TRFC_Msk |
     64          	        MPDDRC_CR_TRP_Msk |
     65          	        MPDDRC_CR_TRCD_Msk |
     66          	        MPDDRC_CR_TRAS_Msk |
     67          	        MPDDRC_CR_TXSR_Msk);
     68          	cr |= MPDDRC_CR_TWR(desc->timings.twr)
     69          	    | MPDDRC_CR_TRC_TRFC(trc_trfc)
     70          	    | MPDDRC_CR_TRP(desc->timings.trp)
     71          	    | MPDDRC_CR_TRCD(desc->timings.trcd)
     72          	    | MPDDRC_CR_TRAS(desc->timings.tras)
     73          	    | MPDDRC_CR_TXSR(txsr);
     74          	MPDDRC->MPDDRC_CR = cr;
     75          #ifdef MPDDRC_CFR1_UNAL_SUPPORTED
     76          	MPDDRC->MPDDRC_CFR1 |= MPDDRC_CFR1_UNAL_SUPPORTED;
     77          #endif
     78          #else /* !CONFIG_HAVE_MPDDRC_SDRAM_ONLY */
     79          	MPDDRC->MPDDRC_TPR0 = MPDDRC_TPR0_TMRD(desc->timings.tmrd)
     80          	                    | MPDDRC_TPR0_TWTR(desc->timings.twtr)
     81          	                    | MPDDRC_TPR0_TRRD(desc->timings.trrd)
     82          	                    | MPDDRC_TPR0_TRP(desc->timings.trp)
     83          	                    | MPDDRC_TPR0_TRC(desc->timings.trc)
     84          	                    | MPDDRC_TPR0_TWR(desc->timings.twr)
     85          	                    | MPDDRC_TPR0_TRCD(desc->timings.trcd)
     86          	                    | MPDDRC_TPR0_TRAS(desc->timings.tras);
   \                     _set_ddr_timings:
   \        0x0   0xE5D0'1014        LDRB     R1,[R0, #+20]
   \        0x4   0xE5D0'2015        LDRB     R2,[R0, #+21]
   \        0x8   0xE3A0'3670        MOV      R3,#+117440512
   \        0xC   0xE013'2C02        ANDS     R2,R3,R2, LSL #+24
   \       0x10   0xE192'1E01        ORRS     R1,R2,R1, LSL #+28
   \       0x14   0xE5D0'2016        LDRB     R2,[R0, #+22]
   \       0x18   0xE3A0'38F0        MOV      R3,#+15728640
   \       0x1C   0xE013'2A02        ANDS     R2,R3,R2, LSL #+20
   \       0x20   0xE192'1001        ORRS     R1,R2,R1
   \       0x24   0xE5D0'2017        LDRB     R2,[R0, #+23]
   \       0x28   0xE3A0'3AF0        MOV      R3,#+983040
   \       0x2C   0xE013'2802        ANDS     R2,R3,R2, LSL #+16
   \       0x30   0xE192'1001        ORRS     R1,R2,R1
   \       0x34   0xE5D0'2018        LDRB     R2,[R0, #+24]
   \       0x38   0xE3A0'3CF0        MOV      R3,#+61440
   \       0x3C   0xE013'2602        ANDS     R2,R3,R2, LSL #+12
   \       0x40   0xE192'1001        ORRS     R1,R2,R1
   \       0x44   0xE5D0'2019        LDRB     R2,[R0, #+25]
   \       0x48   0xE3A0'3EF0        MOV      R3,#+3840
   \       0x4C   0xE013'2402        ANDS     R2,R3,R2, LSL #+8
   \       0x50   0xE192'1001        ORRS     R1,R2,R1
   \       0x54   0xE5D0'201A        LDRB     R2,[R0, #+26]
   \       0x58   0xE3A0'30F0        MOV      R3,#+240
   \       0x5C   0xE013'2202        ANDS     R2,R3,R2, LSL #+4
   \       0x60   0xE192'1001        ORRS     R1,R2,R1
   \       0x64   0xE5D0'201B        LDRB     R2,[R0, #+27]
   \       0x68   0xE212'200F        ANDS     R2,R2,#0xF
   \       0x6C   0xE192'1001        ORRS     R1,R2,R1
   \       0x70   0xE3E0'20F3        MVN      R2,#+243
   \       0x74   0xE3C2'2D5C        BIC      R2,R2,#0x1700
   \       0x78   0xE582'1000        STR      R1,[R2, #+0]
     87          	MPDDRC->MPDDRC_TPR1 = MPDDRC_TPR1_TXP(desc->timings.txp)
     88          	                    | MPDDRC_TPR1_TXSRD(desc->timings.txsrd)
     89          	                    | MPDDRC_TPR1_TXSNR(desc->timings.txsnr)
     90          	                    | MPDDRC_TPR1_TRFC(desc->timings.trfc);
   \       0x7C   0xE5D0'101C        LDRB     R1,[R0, #+28]
   \       0x80   0xE3A0'26F0        MOV      R2,#+251658240
   \       0x84   0xE012'1C01        ANDS     R1,R2,R1, LSL #+24
   \       0x88   0xE5D0'201D        LDRB     R2,[R0, #+29]
   \       0x8C   0xE191'1802        ORRS     R1,R1,R2, LSL #+16
   \       0x90   0xE5D0'201E        LDRB     R2,[R0, #+30]
   \       0x94   0xE191'1402        ORRS     R1,R1,R2, LSL #+8
   \       0x98   0xE5D0'201F        LDRB     R2,[R0, #+31]
   \       0x9C   0xE212'207F        ANDS     R2,R2,#0x7F
   \       0xA0   0xE192'1001        ORRS     R1,R2,R1
   \       0xA4   0xE3E0'20EF        MVN      R2,#+239
   \       0xA8   0xE3C2'2D5C        BIC      R2,R2,#0x1700
   \       0xAC   0xE582'1000        STR      R1,[R2, #+0]
     91          
     92          #ifdef CONFIG_HAVE_MPDDRC_SDRAM
     93          	if (desc->type == MPDDRC_TYPE_SDRAM)
     94          		return;
     95          #endif
     96          	MPDDRC->MPDDRC_TPR2 = MPDDRC_TPR2_TFAW(desc->timings.tfaw)
     97          	                    | MPDDRC_TPR2_TRTP(desc->timings.trtp)
     98          	                    | MPDDRC_TPR2_TRPA(desc->timings.trpa)
     99          	                    | MPDDRC_TPR2_TXARDS(desc->timings.txards)
    100          	                    | MPDDRC_TPR2_TXARD(desc->timings.txard);
   \       0xB0   0xE5D0'1020        LDRB     R1,[R0, #+32]
   \       0xB4   0xE3A0'2AF0        MOV      R2,#+983040
   \       0xB8   0xE012'1801        ANDS     R1,R2,R1, LSL #+16
   \       0xBC   0xE5D0'2021        LDRB     R2,[R0, #+33]
   \       0xC0   0xE3A0'3C70        MOV      R3,#+28672
   \       0xC4   0xE013'2602        ANDS     R2,R3,R2, LSL #+12
   \       0xC8   0xE192'1001        ORRS     R1,R2,R1
   \       0xCC   0xE5D0'2022        LDRB     R2,[R0, #+34]
   \       0xD0   0xE3A0'3EF0        MOV      R3,#+3840
   \       0xD4   0xE013'2402        ANDS     R2,R3,R2, LSL #+8
   \       0xD8   0xE192'1001        ORRS     R1,R2,R1
   \       0xDC   0xE5D0'2023        LDRB     R2,[R0, #+35]
   \       0xE0   0xE3A0'30F0        MOV      R3,#+240
   \       0xE4   0xE013'2202        ANDS     R2,R3,R2, LSL #+4
   \       0xE8   0xE192'1001        ORRS     R1,R2,R1
   \       0xEC   0xE5D0'2024        LDRB     R2,[R0, #+36]
   \       0xF0   0xE212'200F        ANDS     R2,R2,#0xF
   \       0xF4   0xE192'1001        ORRS     R1,R2,R1
   \       0xF8   0xE3E0'20EB        MVN      R2,#+235
   \       0xFC   0xE3C2'2D5C        BIC      R2,R2,#0x1700
   \      0x100   0xE582'1000        STR      R1,[R2, #+0]
    101          #endif /* !CONFIG_HAVE_MPDDRC_SDRAM_ONLY */
    102          }
   \      0x104   0xE12F'FF1E        BX       LR               ;; return
    103          
    104          /* Compute BA[] offset according to configuration */

   \                                 In section SOFTPACK, align 4, keep-with-next
    105          static uint32_t _compute_ba_offset(void)
    106          {
    107          	uint8_t nc, nr;
    108          	bool interleaved, dbw16;
    109          
    110          #if defined CONFIG_HAVE_MPDDRC_SDRAM_ONLY
    111          	nc = ((MPDDRC->MPDDRC_CR & MPDDRC_CR_NC_Msk) >> MPDDRC_CR_NC_Pos) + 8;
    112          	nr = ((MPDDRC->MPDDRC_CR & MPDDRC_CR_NR_Msk) >> MPDDRC_CR_NR_Pos) + 11;
    113          	interleaved = false;
    114          	dbw16 = (MPDDRC->MPDDRC_CR & MPDDRC_CR_DBW) != 0;
    115          #else
    116          	nc = ((MPDDRC->MPDDRC_CR & MPDDRC_CR_NC_Msk) >> MPDDRC_CR_NC_Pos) + 9;
   \                     _compute_ba_offset:
   \        0x0   0xE3E0'20F7        MVN      R2,#+247
   \        0x4   0xE3C2'2D5C        BIC      R2,R2,#0x1700
   \        0x8   0xE592'0000        LDR      R0,[R2, #+0]
   \        0xC   0xE210'0003        ANDS     R0,R0,#0x3
   \       0x10   0xE290'0009        ADDS     R0,R0,#+9
    117          	nr = ((MPDDRC->MPDDRC_CR & MPDDRC_CR_NR_Msk) >> MPDDRC_CR_NR_Pos) + 11;
   \       0x14   0xE592'1000        LDR      R1,[R2, #+0]
   \       0x18   0xE1B0'1121        LSRS     R1,R1,#+2
   \       0x1C   0xE211'1003        ANDS     R1,R1,#0x3
   \       0x20   0xE291'100B        ADDS     R1,R1,#+11
    118          	interleaved = (MPDDRC->MPDDRC_CR & MPDDRC_CR_DECOD_INTERLEAVED) != 0;
   \       0x24   0xE592'2000        LDR      R2,[R2, #+0]
   \       0x28   0xE212'2840        ANDS     R2,R2,#0x400000
   \       0x2C   0xE1B0'3B22        LSRS     R3,R2,#+22
    119          	dbw16 = (MPDDRC->MPDDRC_MD & MPDDRC_MD_DBW) != 0;
   \       0x30   0xE3E0'20DF        MVN      R2,#+223
   \       0x34   0xE3C2'2D5C        BIC      R2,R2,#0x1700
   \       0x38   0xE592'2000        LDR      R2,[R2, #+0]
   \       0x3C   0xE212'2010        ANDS     R2,R2,#0x10
   \       0x40   0xE1B0'2222        LSRS     R2,R2,#+4
    120          #endif
    121          
    122          	return nc + (interleaved ? 0 : nr) + (dbw16 ? 1 : 2);
   \       0x44   0xE213'30FF        ANDS     R3,R3,#0xFF      ;; Zero extend
   \       0x48   0xE353'0000        CMP      R3,#+0
   \       0x4C   0x0A00'0001        BEQ      ??_compute_ba_offset_0
   \       0x50   0xE3A0'1000        MOV      R1,#+0
   \       0x54   0xEA00'0000        B        ??_compute_ba_offset_1
   \                     ??_compute_ba_offset_0:
   \       0x58   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \                     ??_compute_ba_offset_1:
   \       0x5C   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x60   0xE352'0000        CMP      R2,#+0
   \       0x64   0x0A00'0001        BEQ      ??_compute_ba_offset_2
   \       0x68   0xE3A0'2001        MOV      R2,#+1
   \       0x6C   0xEA00'0000        B        ??_compute_ba_offset_3
   \                     ??_compute_ba_offset_2:
   \       0x70   0xE3A0'2002        MOV      R2,#+2
   \                     ??_compute_ba_offset_3:
   \       0x74   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x78   0xE091'0000        ADDS     R0,R1,R0
   \       0x7C   0xE092'0000        ADDS     R0,R2,R0
   \       0x80   0xE12F'FF1E        BX       LR               ;; return
    123          }
    124          

   \                                 In section SOFTPACK, align 4, keep-with-next
    125          static void _send_ddr_cmd(uint32_t cmd)
    126          {
   \                     _send_ddr_cmd:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    127          	MPDDRC->MPDDRC_MR = cmd & MPDDRC_MR_MODE_Msk;
   \        0x8   0xE3E0'00FF        MVN      R0,#+255
   \        0xC   0xE3C0'0D5C        BIC      R0,R0,#0x1700
   \       0x10   0xE214'1007        ANDS     R1,R4,#0x7
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
    128          	MPDDRC->MPDDRC_MR;
   \       0x18   0xE590'0000        LDR      R0,[R0, #+0]
    129          	dmb();
   \       0x1C   0x....'....        BL       `dmb`
    130          
    131          	/* Perform a write to DDR to acknowledge the command */
    132          	*((uint32_t*)DDR_CS_ADDR) = 0;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE3A0'1580        MOV      R1,#+536870912
   \       0x28   0xE581'0000        STR      R0,[R1, #+0]
    133          }
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
    134          

   \                                 In section SOFTPACK, align 4, keep-with-next
    135          static void _send_ext_lmr_cmd(uint32_t opcode, uint32_t ba_offset)
    136          {
   \                     _send_ext_lmr_cmd:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    137          	MPDDRC->MPDDRC_MR = MPDDRC_MR_MODE_EXT_LMR_CMD;
   \        0xC   0xE3E0'00FF        MVN      R0,#+255
   \       0x10   0xE3C0'0D5C        BIC      R0,R0,#0x1700
   \       0x14   0xE3A0'1005        MOV      R1,#+5
   \       0x18   0xE580'1000        STR      R1,[R0, #+0]
    138          	MPDDRC->MPDDRC_MR;
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
    139          	dmb();
   \       0x20   0x....'....        BL       `dmb`
    140          
    141          	/* Perform a write to DDR to acknowledge the command */
    142          	*((uint32_t*)(DDR_CS_ADDR + (opcode << ba_offset))) = 0u;
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0xE3A0'1580        MOV      R1,#+536870912
   \       0x2C   0xE091'1514        ADDS     R1,R1,R4, LSL R5
   \       0x30   0xE581'0000        STR      R0,[R1, #+0]
    143          }
   \       0x34   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    144          
    145          #if defined(CONFIG_HAVE_MPDDRC_LPDDR2) || defined(CONFIG_HAVE_MPDDRC_LPDDR3)
    146          
    147          static void _send_lpddr2_cmd(uint32_t mrs)
    148          {
    149          	MPDDRC->MPDDRC_MR = MPDDRC_MR_MODE_LPDDR2_CMD | MPDDRC_MR_MRS(mrs);
    150          	MPDDRC->MPDDRC_MR;
    151          	dmb();
    152          
    153          	/* Perform a write to DDR to acknowledge the command */
    154          	*((uint32_t*)DDR_CS_ADDR) = 0;
    155          }
    156          
    157          #endif /* CONFIG_HAVE_MPDDRC_LPDDR2 || CONFIG_HAVE_MPDDRC_LPDDR3 */
    158          
    159          #ifdef CONFIG_HAVE_MPDDRC_DDR3
    160          
    161          /* Configure DDR3 */
    162          static void _configure_ddr3(struct _mpddrc_desc* desc)
    163          {
    164          	uint32_t ba_offset = _compute_ba_offset();
    165          
    166          	/* Timings */
    167          	_set_ddr_timings(desc);
    168          
    169          #ifdef CONFIG_HAVE_SFRBU
    170          	/* Only initialize DDR chip when needed */
    171          	if (sfrbu_is_ddr_backup_enabled())
    172          		return;
    173          #endif
    174          
    175          	/* Step 3: Issue a NOP command. */
    176          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    177          
    178          	/* Step 4: Pause for at least 500μs. */
    179          	usleep(500);
    180          
    181          	/* Step 5: Issue a NOP command. */
    182          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    183          
    184          	/* Step 6: Issue Extended Mode Register Set 2 (EMRS2) cycle to choose
    185          	 * between commercial or high temperature operations. */
    186          	_send_ext_lmr_cmd(0x2, ba_offset);
    187          
    188          	/* Step 7: Issue Extended Mode Register Set 3 (EMRS3) cycle to set the
    189          	 * Extended Mode Register to 0. */
    190          	_send_ext_lmr_cmd(0x3, ba_offset);
    191          
    192          	/* Step 8: Issue Extended Mode Register Set 1 (EMRS1) cycle to disable
    193          	 * and to program O.D.S. (Output Driver Strength). */
    194          	_send_ext_lmr_cmd(0x1, ba_offset);
    195          
    196          	/* Step 9: Write a one to the DLL bit (enable DLL reset) in the MPDDRC
    197          	 * Configuration Register (MPDDRC_CR). */
    198          	MPDDRC->MPDDRC_CR |= MPDDRC_CR_DLL_RESET_ENABLED;
    199          
    200          	/* Step 10: Issue a Mode Register Set (MRS) cycle to reset DLL. */
    201          	_send_ddr_cmd(MPDDRC_MR_MODE_LMR_CMD);
    202          
    203          	/* Step 11: Issue a Calibration command (MRS) cycle to calibrate RTT
    204          	 * and RON values for the Process Voltage Temperature (PVT). */
    205          	_send_ddr_cmd(MPDDRC_MR_MODE_CALIB_CMD);
    206          
    207          	/* Step 12: A Normal Mode command is provided.  Program the Normal mode
    208          	 * in the MPDDRC_MR and perform a write access to any DDR3-SDRAM
    209          	 * address to acknowledge this command. */
    210          	_send_ddr_cmd(MPDDRC_MR_MODE_NORMAL_CMD);
    211          }
    212          
    213          #endif /* CONFIG_HAVE_MPDDRC_DDR3 */
    214          
    215          #ifdef CONFIG_HAVE_MPDDRC_DDR2
    216          
    217          /* Configure DDR2 */

   \                                 In section SOFTPACK, align 4, keep-with-next
    218          static void _configure_ddr2(struct _mpddrc_desc* desc)
    219          {
   \                     _configure_ddr2:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    220          	uint32_t ba_offset = _compute_ba_offset();
   \        0x8   0x....'....        BL       _compute_ba_offset
   \        0xC   0xE1B0'5000        MOVS     R5,R0
    221          
    222          	/* Timings */
    223          	_set_ddr_timings(desc);
   \       0x10   0xE1B0'0004        MOVS     R0,R4
   \       0x14   0x....'....        BL       _set_ddr_timings
    224          
    225          	/* Step 3: Issue a NOP command. */
    226          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
   \       0x18   0xE3A0'0001        MOV      R0,#+1
   \       0x1C   0x....'....        BL       _send_ddr_cmd
    227          
    228          	/* Step 4: Pause for at least 200μs. */
    229          	usleep(200);
   \       0x20   0xE3A0'00C8        MOV      R0,#+200
   \       0x24   0x....'....        BL       usleep
    230          
    231          	/* Step 5: Issue a NOP command. */
    232          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
   \       0x28   0xE3A0'0001        MOV      R0,#+1
   \       0x2C   0x....'....        BL       _send_ddr_cmd
    233          
    234          	/* Step 6: Issue all banks precharge command. */
    235          	_send_ddr_cmd(MPDDRC_MR_MODE_PRCGALL_CMD);
   \       0x30   0xE3A0'0002        MOV      R0,#+2
   \       0x34   0x....'....        BL       _send_ddr_cmd
    236          
    237          	/* Step 7: Issue an Extended Mode Register Set (EMRS2) cycle to chose
    238          	 * between commercial or high  temperature operations. */
    239          	_send_ext_lmr_cmd(0x2, ba_offset);
   \       0x38   0xE1B0'1005        MOVS     R1,R5
   \       0x3C   0xE3A0'0002        MOV      R0,#+2
   \       0x40   0x....'....        BL       _send_ext_lmr_cmd
    240          
    241          	/* Step 8: Issue an Extended Mode Register Set (EMRS3) cycle to set all
    242          	 * registers to 0. */
    243          	_send_ext_lmr_cmd(0x3, ba_offset);
   \       0x44   0xE1B0'1005        MOVS     R1,R5
   \       0x48   0xE3A0'0003        MOV      R0,#+3
   \       0x4C   0x....'....        BL       _send_ext_lmr_cmd
    244          
    245          	/* Step 9: Issue an Extended Mode Register Set (EMRS1) cycle to enable
    246          	 * DLL. */
    247          	_send_ext_lmr_cmd(0x1, ba_offset);
   \       0x50   0xE1B0'1005        MOVS     R1,R5
   \       0x54   0xE3A0'0001        MOV      R0,#+1
   \       0x58   0x....'....        BL       _send_ext_lmr_cmd
    248          
    249          	/* Step 10: An additional 200 cycles of clock are required for locking
    250          	 * DLL (2μs should be enough). */
    251          	usleep(2);
   \       0x5C   0xE3A0'0002        MOV      R0,#+2
   \       0x60   0x....'....        BL       usleep
    252          
    253          	/* Step 11: Program DLL field into the Configuration Register. */
    254          	MPDDRC->MPDDRC_CR |= MPDDRC_CR_DLL_RESET_ENABLED;
   \       0x64   0xE3E0'60F7        MVN      R6,#+247
   \       0x68   0xE3C6'6D5C        BIC      R6,R6,#0x1700
   \       0x6C   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x70   0xE390'0080        ORRS     R0,R0,#0x80
   \       0x74   0xE586'0000        STR      R0,[R6, #+0]
    255          
    256          	/* Step 12: A Mode Register set (MRS) cycle is issued to reset DLL. */
    257          	_send_ddr_cmd(MPDDRC_MR_MODE_LMR_CMD);
   \       0x78   0xE3A0'0003        MOV      R0,#+3
   \       0x7C   0x....'....        BL       _send_ddr_cmd
    258          
    259          	/* Step 13: Issue all banks precharge command. */
    260          	_send_ddr_cmd(MPDDRC_MR_MODE_PRCGALL_CMD);
   \       0x80   0xE3A0'0002        MOV      R0,#+2
   \       0x84   0x....'....        BL       _send_ddr_cmd
    261          
    262          	/* Step 14: Two auto-refresh (CBR) cycles are provided. Program the
    263          	 * auto refresh command (CBR) into the Mode Register. */
    264          	_send_ddr_cmd(MPDDRC_MR_MODE_RFSH_CMD);
   \       0x88   0xE3A0'0004        MOV      R0,#+4
   \       0x8C   0x....'....        BL       _send_ddr_cmd
    265          	_send_ddr_cmd(MPDDRC_MR_MODE_RFSH_CMD);
   \       0x90   0xE3A0'0004        MOV      R0,#+4
   \       0x94   0x....'....        BL       _send_ddr_cmd
    266          
    267          	/* Step 15: Program DLL field into the Configuration Register to low
    268          	 * (Disable DLL reset). */
    269          	MPDDRC->MPDDRC_CR &= ~MPDDRC_CR_DLL_RESET_ENABLED;
   \       0x98   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x9C   0xE3D0'0080        BICS     R0,R0,#0x80
   \       0xA0   0xE586'0000        STR      R0,[R6, #+0]
    270          
    271          	/* Step 16: Issue a Mode Register Set (MRS) cycle to program the
    272          	 * parameters device. */
    273          	_send_ddr_cmd(MPDDRC_MR_MODE_LMR_CMD);
   \       0xA4   0xE3A0'0003        MOV      R0,#+3
   \       0xA8   0x....'....        BL       _send_ddr_cmd
    274          
    275          	/* Step 17: Program OCD field into the Configuration Register to high
    276          	 * (OCD calibration default). */
    277          	MPDDRC->MPDDRC_CR |= MPDDRC_CR_OCD_DDR2_DEFAULT_CALIB;
   \       0xAC   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xB0   0xE390'0C70        ORRS     R0,R0,#0x7000
   \       0xB4   0xE586'0000        STR      R0,[R6, #+0]
    278          
    279          	/* Step 18: An Extended Mode Register Set (EMRS1) cycle is issued to
    280          	 * OCD default value. */
    281          	_send_ext_lmr_cmd(0x1, ba_offset);
   \       0xB8   0xE1B0'1005        MOVS     R1,R5
   \       0xBC   0xE3A0'0001        MOV      R0,#+1
   \       0xC0   0x....'....        BL       _send_ext_lmr_cmd
    282          
    283          	/* Step 19: Program OCD field into the Configuration Register to high
    284          	 * (OCD calibration default). */
    285          	MPDDRC->MPDDRC_CR &= ~MPDDRC_CR_OCD_Msk;
   \       0xC4   0xE596'0000        LDR      R0,[R6, #+0]
   \       0xC8   0xE3D0'0C70        BICS     R0,R0,#0x7000
   \       0xCC   0xE586'0000        STR      R0,[R6, #+0]
    286          
    287          	/* Step 20: An Extended Mode Register Set (EMRS1) cycle is issued to
    288          	 * enable OCD exit. */
    289          	_send_ext_lmr_cmd(0x1, ba_offset);
   \       0xD0   0xE1B0'1005        MOVS     R1,R5
   \       0xD4   0xE3A0'0001        MOV      R0,#+1
   \       0xD8   0x....'....        BL       _send_ext_lmr_cmd
    290          
    291          	/* Step 21: A mode Normal command is provided. Program the Normal mode
    292          	 * into Mode Register. */
    293          	_send_ddr_cmd(MPDDRC_MR_MODE_NORMAL_CMD);
   \       0xDC   0xE3A0'0000        MOV      R0,#+0
   \       0xE0   0x....'....        BL       _send_ddr_cmd
    294          }
   \       0xE4   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    295          
    296          #endif /* CONFIG_HAVE_MPDDRC_DDR2 */
    297          
    298          #if defined(CONFIG_HAVE_MPDDRC_LPDDR2) || defined(CONFIG_HAVE_MPDDRC_LPDDR3)
    299          
    300          /* Configure LPDDR2 / LPDDR3 */
    301          static void _configure_lpddr2(struct _mpddrc_desc* desc)
    302          {
    303          	/* Timings */
    304          	_set_ddr_timings(desc);
    305          
    306          	/* Step 3: Issue a NOP command. */
    307          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    308          
    309          	/* Step 4: Pause for at least 100ns (use 1μs instead). */
    310          	usleep(1);
    311          
    312          	/* Step 5: Issue a NOP command. */
    313          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    314          
    315          	/* Step 6: A pause of at least 200μs must be observed before issuing a
    316          	 * Reset command. */
    317          	usleep(200);
    318          
    319          	/* Step 7. A Reset command is issued. */
    320          	_send_lpddr2_cmd(0x3f);
    321          
    322          	/* Step 8. A pause of at least tINIT5 must be observed before issuing
    323          	 * any commands.*/
    324          	usleep(500);
    325          
    326          	/* Step 9. Issued a calibration command by issuing mode register write
    327          	 * command */
    328          	_send_lpddr2_cmd(0xa);
    329          
    330          	/* Step 10: Perform a write access by issuing mode register write
    331          	 * command */
    332          	_send_lpddr2_cmd(0x1);
    333          
    334          	/* Step 11: Program CAS Latency by issuing mode register write
    335          	 * command. */
    336          	_send_lpddr2_cmd(0x2);
    337          
    338          	/* Step 12: Program Drive Strength and Slew Rate by issuing mode
    339          	 * register write command. */
    340          	_send_lpddr2_cmd(0x3);
    341          
    342          	/* Step 13: Program Partial Array Self Refresh (PASR) by issuing mode
    343          	 * register write command. */
    344          	_send_lpddr2_cmd(0x10);
    345          
    346          #ifdef CONFIG_SOC_SAMA5D2
    347          	/* Step 14: In the DDR Configuration Register (SFR_DDRCFG), the
    348          	 * application must write a 1 to fields 17 and 16 to open the input
    349          	 * buffers (See section “Special Function Registers (SFR)”). */
    350          	SFR->SFR_DDRCFG |= SFR_DDRCFG_FDQIEN | SFR_DDRCFG_FDQSIEN;
    351          #endif
    352          
    353          	/* Step 15: Issue a NOP command. */
    354          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    355          
    356          	/* Step 16: Read command cycle by issuing Mode register read
    357          	 * command. */
    358          	_send_lpddr2_cmd(0x5);
    359          
    360          	/* Step 17: Read revision by issuing Mode register read command. */
    361          	_send_lpddr2_cmd(0x6);
    362          
    363          	/* Step 18: Read memory organization by issuing Mode register read
    364          	 * command. */
    365          	_send_lpddr2_cmd(0x8);
    366          
    367          	/* Step 19: Read device information by issuing Mode register read
    368          	 * command. */
    369          	_send_lpddr2_cmd(0x0);
    370          
    371          	/* Step 20: Issue a Normal mode command. */
    372          	_send_ddr_cmd(MPDDRC_MR_MODE_NORMAL_CMD);
    373          
    374          #ifdef CONFIG_SOC_SAMA5D2
    375          	/* Step 21: In the DDR configuration Register (SFR_DDRCCFG), the
    376          	 * application must write a 0 to fields 17 and 16 to close the input
    377          	 * buffers. The buffers are then driven by the MPDDRC controller. */
    378          	SFR->SFR_DDRCFG &= ~(SFR_DDRCFG_FDQIEN | SFR_DDRCFG_FDQSIEN);
    379          #endif
    380          }
    381          
    382          #endif /* CONFIG_HAVE_MPDDRC_LPDDR2 */
    383          
    384          #ifdef CONFIG_HAVE_MPDDRC_SDRAM
    385          
    386          /* Configure SDRAM */
    387          static void _configure_sdram(struct _mpddrc_desc* desc)
    388          {
    389          	uint32_t ba_offset = _compute_ba_offset();
    390          	volatile uint32_t i;
    391          
    392          	/* Timings */
    393          	_set_ddr_timings(desc);
    394          
    395          	/* Step 4: A pause of at least 200μs must be observed before issuing a
    396          	 * Reset command. */
    397          	usleep(200);
    398          
    399          	/* Step 5: Issue a NOP command. */
    400          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    401          
    402          	/* Step 6: Issue all banks precharge command. */
    403          	_send_ddr_cmd(MPDDRC_MR_MODE_PRCGALL_CMD);
    404          
    405          	/* Step 7: Issue auto-refresh (CBR) cycles command for eight times */
    406          	for (i = 0; i < 8; i++)
    407          		_send_ddr_cmd(MPDDRC_MR_MODE_RFSH_CMD);
    408          
    409          	/* Step 8: Issue an Extended Mode Register Set (EMRS3) cycle to set all
    410          	 * registers to 0. */
    411          	_send_ddr_cmd(MPDDRC_MR_MODE_LMR_CMD);
    412          
    413          	/* Step 9: For mobile SDRAM , Issue Extended Mode Register Set 2 (EMR)
    414          		cycle to choose between commercial or high temperature operations.*/
    415          #ifdef CONFIG_HAVE_MPDDRC_SDRAM_ONLY
    416          	if (desc->mode & MPDDRC_MD_MD_LPSDRAM)
    417          #else
    418          	if (desc->mode & MPDDRC_MD_MD_LPSDR_SDRAM)
    419          #endif
    420          		_send_ext_lmr_cmd(0x1, ba_offset);
    421          
    422          	/* Step 10: A mode Normal command is provided. Program the Normal mode
    423          	 * into Mode Register. */
    424          	_send_ddr_cmd(MPDDRC_MR_MODE_NORMAL_CMD);
    425          }
    426          
    427          #endif /* CONFIG_HAVE_MPDDRC_SDRAM */
    428          
    429          #ifdef CONFIG_HAVE_MPDDRC_LPDDR
    430          
    431          /* Configure LPDDR */
    432          static void _configure_lpddr(struct _mpddrc_desc *desc)
    433          {
    434          	uint32_t ba_offset = _compute_ba_offset();
    435          
    436          	/* Timings */
    437          	_set_ddr_timings(desc);
    438          
    439          	/*
    440          	 * Step 4: Program Temperature Compensated Self-refresh (TCR), Partial
    441          	 * Array Self-refresh (PASR) and Drive Strength (DS) parameters in the
    442          	 * Low-power register (MPDDRC_LPR).
    443          	 */
    444          
    445          	/* Assign one-quarter output buffer drive strength to external EMR.DS */
    446          	uint32_t value = MPDDRC->MPDDRC_LPR & ~MPDDRC_LPR_DS_Msk;
    447          	MPDDRC->MPDDRC_LPR = value | MPDDRC_LPR_DS(0x2);
    448          
    449          	/* Step 5: Issue a NOP command. */
    450          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    451          
    452          	/* Step 6: Pause for at least 200μs. */
    453          	usleep(200);
    454          
    455          	/* Step 7: Issue a NOP command. */
    456          	_send_ddr_cmd(MPDDRC_MR_MODE_NOP_CMD);
    457          
    458          	/* Step 8: Issue a All Banks Precharge command. */
    459          	_send_ddr_cmd(MPDDRC_MR_MODE_PRCGALL_CMD);
    460          
    461          	/* Step 9: Issue 2 autorefresh commands. */
    462          	_send_ddr_cmd(MPDDRC_MR_MODE_RFSH_CMD);
    463          	_send_ddr_cmd(MPDDRC_MR_MODE_RFSH_CMD);
    464          
    465          	/*
    466          	 * Step 10: An Extended Mode Register Set (EMRS) cycle is issued to
    467          	 * program the low-power DDR1-SDRAM parameters (TCSR, PASR, DS).
    468          	 * [...]
    469          	 * The write address must be chosen so that signal BA[1] is set to 1
    470          	 * and BA[0] is set to 0.
    471          	 */
    472          	_send_ext_lmr_cmd(0x2, ba_offset);
    473          
    474          	/* Step 11: Issue a Mode Register Set command. */
    475          	_send_ddr_cmd(MPDDRC_MR_MODE_LMR_CMD);
    476          
    477          	/* Step 12 Issue a Normal mode command. */
    478          	_send_ddr_cmd(MPDDRC_MR_MODE_NORMAL_CMD);
    479          }
    480          
    481          #endif /* CONFIG_HAVE_MPDDRC_LPDDR */
    482          

   \                                 In section SOFTPACK, align 4, keep-with-next
    483          extern void mpddrc_configure(struct _mpddrc_desc* desc)
    484          {
   \                     mpddrc_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    485          #ifdef MPDDRC_HS_DIS_ANTICIP_READ
    486          	/* Disable anticipated read */
    487          	MPDDRC->MPDDRC_HS = MPDDRC_HS_DIS_ANTICIP_READ;
    488          #endif
    489          
    490          	/* controller and DDR clock */
    491          #ifdef ID_MPDDRC
    492          	pmc_configure_peripheral(ID_MPDDRC, NULL, true);
   \        0x8   0xE3A0'2001        MOV      R2,#+1
   \        0xC   0xE3A0'1000        MOV      R1,#+0
   \       0x10   0xE3A0'0031        MOV      R0,#+49
   \       0x14   0x....'....        BL       pmc_configure_peripheral
    493          #endif
    494          	pmc_enable_system_clock(PMC_SYSTEM_CLOCK_DDR);
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0x....'....        BL       pmc_enable_system_clock
    495          
    496          	/* Step1: Program memory device type */
    497          	MPDDRC->MPDDRC_MD = desc->mode;
   \       0x20   0xE594'000C        LDR      R0,[R4, #+12]
   \       0x24   0xE3E0'10DF        MVN      R1,#+223
   \       0x28   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0x2C   0xE581'0000        STR      R0,[R1, #+0]
    498          
    499          #ifdef CONFIG_HAVE_MPDDRC_IO_CALIBRATION
    500          	/* set driver impedance */
    501          	uint32_t value = MPDDRC->MPDDRC_IO_CALIBR;
   \       0x30   0xE3E0'10CB        MVN      R1,#+203
   \       0x34   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0x38   0xE591'0000        LDR      R0,[R1, #+0]
    502          #ifdef MPDDRC_IO_CALIBR_RDIV_Msk
    503          	value &= ~MPDDRC_IO_CALIBR_RDIV_Msk;
    504          #endif
    505          #ifdef MPDDRC_IO_CALIBR_CK_F_RANGE_Msk
    506          	value &= ~MPDDRC_IO_CALIBR_CK_F_RANGE_Msk;
   \       0x3C   0xE3D0'0007        BICS     R0,R0,#0x7
    507          #endif
    508          #ifdef MPDDRC_IO_CALIBR_EN_CALIB
    509          	value &= ~MPDDRC_IO_CALIBR_EN_CALIB;
    510          #endif
    511          	value &= ~MPDDRC_IO_CALIBR_TZQIO_Msk;
   \       0x40   0xE3D0'0C7F        BICS     R0,R0,#0x7F00
    512          	value &= ~MPDDRC_IO_CALIBR_CALCODEP_Msk;
   \       0x44   0xE3D0'0AF0        BICS     R0,R0,#0xF0000
    513          	value &= ~MPDDRC_IO_CALIBR_CALCODEN_Msk;
   \       0x48   0xE3D0'08F0        BICS     R0,R0,#0xF00000
    514          
    515          	value |= desc->io_calibr;
   \       0x4C   0xE594'2004        LDR      R2,[R4, #+4]
   \       0x50   0xE192'5000        ORRS     R5,R2,R0
    516          	MPDDRC->MPDDRC_IO_CALIBR = value;
   \       0x54   0xE581'5000        STR      R5,[R1, #+0]
    517          #endif
    518          
    519          #ifdef CONFIG_HAVE_MPDDRC_DATA_PATH
    520          	MPDDRC->MPDDRC_RD_DATA_PATH = desc->data_path;
   \       0x58   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x5C   0xE3E0'10A3        MVN      R1,#+163
   \       0x60   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0x64   0xE581'0000        STR      R0,[R1, #+0]
    521          #endif
    522          
    523          	/* Step 2: Program features of the DDR3-SDRAM device in the
    524          	 * configuration register and timing parameter registers (TPR0
    525          	 * ans TPR1) */
    526          
    527          	/* Configurations */
    528          	MPDDRC->MPDDRC_CR = desc->control;
   \       0x68   0xE594'0010        LDR      R0,[R4, #+16]
   \       0x6C   0xE3E0'10F7        MVN      R1,#+247
   \       0x70   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0x74   0xE581'0000        STR      R0,[R1, #+0]
    529          
    530          	uint32_t lpr_prv = MPDDRC->MPDDRC_LPR, lpr = lpr_prv;
   \       0x78   0xE3E0'10E3        MVN      R1,#+227
   \       0x7C   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0x80   0xE591'6000        LDR      R6,[R1, #+0]
   \       0x84   0xE1B0'0006        MOVS     R0,R6
    531          #ifdef MPDDRC_LPR_APDE
    532          	lpr = (lpr & ~MPDDRC_LPR_APDE) | MPDDRC_LPR_APDE_DDR2_FAST_EXIT;
   \       0x88   0xE3D0'7B40        BICS     R7,R0,#0x10000
    533          #endif
    534          #ifdef CONFIG_HAVE_SFRBU
    535          	if (sfrbu_is_ddr_backup_enabled())
    536          		/* The memory is in self-refresh mode; restore MPDDRC_LPR */
    537          		lpr = (lpr & ~MPDDRC_LPR_LPCB_Msk) | MPDDRC_LPR_LPCB_SELFREFRESH;
    538          #endif
    539          	if (lpr != lpr_prv)
   \       0x8C   0xE157'0006        CMP      R7,R6
   \       0x90   0x0A00'0000        BEQ      ??mpddrc_configure_0
    540          		MPDDRC->MPDDRC_LPR = lpr;
   \       0x94   0xE581'7000        STR      R7,[R1, #+0]
    541          
    542          	switch(desc->type) {
   \                     ??mpddrc_configure_0:
   \       0x98   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \       0x9C   0xE350'0000        CMP      R0,#+0
   \       0xA0   0x1A00'0002        BNE      ??mpddrc_configure_1
    543          #ifdef CONFIG_HAVE_MPDDRC_SDRAM
    544          	case MPDDRC_TYPE_SDRAM:
    545          		_configure_sdram(desc);
    546          		break;
    547          #endif
    548          #ifdef CONFIG_HAVE_MPDDRC_DDR2
    549          	case MPDDRC_TYPE_DDR2:
    550          		_configure_ddr2(desc);
   \       0xA4   0xE1B0'0004        MOVS     R0,R4
   \       0xA8   0x....'....        BL       _configure_ddr2
    551          		break;
   \       0xAC   0xEA00'0006        B        ??mpddrc_configure_2
    552          #endif
    553          #ifdef CONFIG_HAVE_MPDDRC_DDR3
    554          	case MPDDRC_TYPE_DDR3:
    555          		_configure_ddr3(desc);
    556          		break;
    557          #endif
    558          #ifdef CONFIG_HAVE_MPDDRC_LPDDR
    559          	case MPDDRC_TYPE_LPDDR:
    560          		_configure_lpddr(desc);
    561          		break;
    562          #endif
    563          #ifdef CONFIG_HAVE_MPDDRC_LPDDR2
    564          	case MPDDRC_TYPE_LPDDR2:
    565          		_configure_lpddr2(desc);
    566          		break;
    567          #endif
    568          #ifdef CONFIG_HAVE_MPDDRC_LPDDR3
    569          	case MPDDRC_TYPE_LPDDR3:
    570          		_configure_lpddr2(desc);
    571          		break;
    572          #endif
    573          	default:
    574          		trace_error("DDRAM type not handled\r\n");
   \                     ??mpddrc_configure_1:
   \       0xB0   0x....'....        LDR      R0,??DataTable1
   \       0xB4   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xB8   0xE350'0002        CMP      R0,#+2
   \       0xBC   0x3A00'0001        BCC      ??mpddrc_configure_3
   \       0xC0   0x....'....        LDR      R0,??DataTable1_1
   \       0xC4   0x....'....        BL       printf
    575          		abort();
   \                     ??mpddrc_configure_3:
   \       0xC8   0x....'....        BL       abort
    576          	}
    577          
    578          	/* Last step: Write the refresh rate */
    579          	/* Refresh Timer is (refresh_window / refresh_cycles) * master_clock */
    580          	uint32_t master_clock = pmc_get_master_clock() / 1000;
   \                     ??mpddrc_configure_2:
   \       0xCC   0x....'....        BL       pmc_get_master_clock
   \       0xD0   0xE3A0'1FFA        MOV      R1,#+1000
   \       0xD4   0x....'....        BL       __aeabi_uidiv
   \       0xD8   0xE1B0'8000        MOVS     R8,R0
    581          	MPDDRC->MPDDRC_RTR = MPDDRC_RTR_COUNT(desc->refresh_window * master_clock / desc->refresh_cycles);
   \       0xDC   0xE594'0028        LDR      R0,[R4, #+40]
   \       0xE0   0xE010'0098        MULS     R0,R8,R0
   \       0xE4   0xE594'102C        LDR      R1,[R4, #+44]
   \       0xE8   0x....'....        BL       __aeabi_uidiv
   \       0xEC   0xE1B0'0A00        LSLS     R0,R0,#+20
   \       0xF0   0xE1B0'0A20        LSRS     R0,R0,#+20
   \       0xF4   0xE3E0'10FB        MVN      R1,#+251
   \       0xF8   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \       0xFC   0xE581'0000        STR      R0,[R1, #+0]
    582          
    583          #ifdef CONFIG_HAVE_SFRBU
    584          	if (sfrbu_is_ddr_backup_enabled()) {
    585          		MPDDRC->MPDDRC_MR = MPDDRC_MR_MODE_NORMAL_CMD;
    586          		sfrbu_disable_ddr_backup();
    587          		mpddrc_issue_low_power_command(MPDDRC_LPR_LPCB_DISABLED);
    588          	}
    589          #endif
    590          }
   \      0x100   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    591          

   \                                 In section SOFTPACK, align 4, keep-with-next
    592          RAMCODE void mpddrc_issue_low_power_command(uint32_t cmd)
    593          {
    594          	uint32_t value;
    595          	value = MPDDRC->MPDDRC_LPR & ~MPDDRC_LPR_LPCB_Msk;
   \                     mpddrc_issue_low_power_command:
   \        0x0   0xE3E0'10E3        MVN      R1,#+227
   \        0x4   0xE3C1'1D5C        BIC      R1,R1,#0x1700
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
   \        0xC   0xE3D2'2003        BICS     R2,R2,#0x3
    596          	MPDDRC->MPDDRC_LPR = value | (cmd & MPDDRC_LPR_LPCB_Msk);
   \       0x10   0xE210'3003        ANDS     R3,R0,#0x3
   \       0x14   0xE193'3002        ORRS     R3,R3,R2
   \       0x18   0xE581'3000        STR      R3,[R1, #+0]
    597          
    598          #ifdef MPDDRC_LPR_SELF_DONE
    599          	if (cmd == MPDDRC_LPR_LPCB_SELFREFRESH)
   \       0x1C   0xE350'0001        CMP      R0,#+1
   \       0x20   0x1A00'0002        BNE      ??mpddrc_issue_low_power_command_0
    600          		/* Wait for the memory to enter self-refresh mode */
    601          		while (!((MPDDRC->MPDDRC_LPR) & MPDDRC_LPR_SELF_DONE)) ;
   \                     ??mpddrc_issue_low_power_command_1:
   \       0x24   0xE591'3000        LDR      R3,[R1, #+0]
   \       0x28   0xE313'0780        TST      R3,#0x2000000
   \       0x2C   0x0AFF'FFFC        BEQ      ??mpddrc_issue_low_power_command_1
    602          #endif
    603          }
   \                     ??mpddrc_issue_low_power_command_0:
   \       0x30   0xE12F'FF1E        BX       LR               ;; return
    604          

   \                                 In section SOFTPACK, align 4, keep-with-next
    605          RAMCODE void ddr_self_refresh(void)
    606          {
   \                     ddr_self_refresh:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    607          	mpddrc_issue_low_power_command(MPDDRC_LPR_LPCB_SELFREFRESH);
   \        0x4   0xE3A0'0001        MOV      R0,#+1
   \        0x8   0x....'....        BL       mpddrc_issue_low_power_command
    608          
    609          #ifdef CONFIG_HAVE_SFRBU
    610          	if (!sfrbu_is_ddr_backup_enabled()) {
    611          		/* Disable the DDR Controller clock signal at PMC level*/
    612          		pmc_disable_peripheral(ID_MPDDRC);
    613          		/* Disable ddrclk */
    614          		pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    615          
    616          		sfrbu_enable_ddr_backup();
    617          	}
    618          #endif
    619          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
    620          

   \                                 In section SOFTPACK, align 4, keep-with-next
    621          RAMCODE void check_ddr_ready(void)
    622          {
   \                     check_ddr_ready:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    623          #ifdef CONFIG_HAVE_SFRBU
    624          	if (sfrbu_is_ddr_backup_enabled()) {
    625          		/* Enable the DDR Controller clock signal at PMC level */
    626          		pmc_configure_peripheral(ID_MPDDRC, NULL, true);
    627          		/* Enable ddrclk */
    628          		pmc_enable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    629          		/* Disable DDR Backup mode */
    630          		sfrbu_disable_ddr_backup();
    631          	}
    632          #endif
    633          
    634          	mpddrc_issue_low_power_command(MPDDRC_LPR_LPCB_DISABLED);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        BL       mpddrc_issue_low_power_command
    635          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
    636          

   \                                 In section .bss, align 4
    637          RAMDATA struct pck_mck_cfg clock_setting_backup = {0};
   \                     clock_setting_backup:
   \        0x0                      DS8 40

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x45          DC8 "-E- DDRAM type not handled\015\012"

   \              0x2D 0x20    

   \              0x44 0x44    

   \              0x52 0x41    

   \              0x4D 0x20    

   \              0x74 0x79    

   \              0x70 0x65    

   \              0x20 0x6E    

   \              0x6F 0x74    

   \              0x20 0x68    

   \              0x61 0x6E    

   \              0x64 0x6C    

   \              0x65 0x64    

   \              0x0D 0x0A    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00
    638          #ifdef CONFIG_RAMCODE
    639          RAMDATA volatile int _ddr_active_needed = 0;
    640          
    641          RAMCODE void ddram_active(void) {
    642          	/* Restore default PCK and MCK */
    643          	while ((PMC->PMC_SR & PMC_SR_MCKRDY) == 0);
    644          	pmc_set_custom_pck_mck(&clock_setting_backup);
    645          	check_ddr_ready();
    646          	_ddr_active_needed = 0;
    647          }
    648          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _compute_ba_offset
      16   _configure_ddr2
        16   -> _compute_ba_offset
        16   -> _send_ddr_cmd
        16   -> _send_ext_lmr_cmd
        16   -> _set_ddr_timings
        16   -> usleep
       8   _send_ddr_cmd
         8   -> dmb
      16   _send_ext_lmr_cmd
        16   -> dmb
       0   _set_ddr_timings
       8   check_ddr_ready
         8   -> mpddrc_issue_low_power_command
       8   ddr_self_refresh
         8   -> mpddrc_issue_low_power_command
       0   dmb
      24   mpddrc_configure
        24   -> _configure_ddr2
        24   -> abort
        24   -> pmc_configure_peripheral
        24   -> pmc_enable_system_clock
        24   -> pmc_get_master_clock
        24   -> printf
        24 __aeabi_uidiv
       0   mpddrc_issue_low_power_command


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      32  ?_0
     132  _compute_ba_offset
     232  _configure_ddr2
      48  _send_ddr_cmd
      56  _send_ext_lmr_cmd
     264  _set_ddr_timings
      16  check_ddr_ready
      40  clock_setting_backup
      16  ddr_self_refresh
       4  dmb
     260  mpddrc_configure
      52  mpddrc_issue_low_power_command

 
    40 bytes in section .bss
    32 bytes in section .rodata
 1'088 bytes in section SOFTPACK
 
 1'088 bytes of CODE  memory
    32 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none
