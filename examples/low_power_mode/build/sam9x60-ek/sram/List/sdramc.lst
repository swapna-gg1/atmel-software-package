###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         05/Jan/2021  12:18:34
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\sdramc.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWA695.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\sdramc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\List\sdramc.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\low_power_mode\build\sam9x60-ek\sram\Obj\sdramc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\extram\sdramc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2018, Microchip Technology
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*------------------------------------------------------------------------------
     31           *        Header
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include "chip.h"
     35          #include "barriers.h"

   \                                 In section SOFTPACK, align 4, keep-with-next
   \   static __interwork __softfp void dmb(void)
   \                     `dmb`:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
     36          #include "timer.h"
     37          #include "trace.h"
     38          
     39          #include "extram/sdram.h"
     40          #include "peripherals/pmc.h"
     41          
     42          #include <string.h>
     43          
     44          /*------------------------------------------------------------------------------
     45           *        Macro
     46           *----------------------------------------------------------------------------*/
     47          
     48          #ifndef MAX
     49          #define MAX(x, y) (((x) > (y)) ? (x) : (y))
     50          #endif
     51          
     52          /*---------------------------------------------------------------------------
     53           *      Local functions
     54           *---------------------------------------------------------------------------*/
     55          

   \                                 In section SOFTPACK, align 4, keep-with-next
     56          static uint32_t _compute_ba_offset(const struct _sdramc_desc *desc)
     57          {
     58          	return desc->nb_rows + desc->nb_columns +
     59          		(desc->data_bus_width == 16 ? 1 : 2);
   \                     _compute_ba_offset:
   \        0x0   0xE5D0'1004        LDRB     R1,[R0, #+4]
   \        0x4   0xE351'0010        CMP      R1,#+16
   \        0x8   0x1A00'0001        BNE      ??_compute_ba_offset_0
   \        0xC   0xE3A0'1001        MOV      R1,#+1
   \       0x10   0xEA00'0000        B        ??_compute_ba_offset_1
   \                     ??_compute_ba_offset_0:
   \       0x14   0xE3A0'1002        MOV      R1,#+2
   \                     ??_compute_ba_offset_1:
   \       0x18   0xE5D0'2002        LDRB     R2,[R0, #+2]
   \       0x1C   0xE5D0'0001        LDRB     R0,[R0, #+1]
   \       0x20   0xE090'0002        ADDS     R0,R0,R2
   \       0x24   0xE091'0000        ADDS     R0,R1,R0
   \       0x28   0xE12F'FF1E        BX       LR               ;; return
     60          }
     61          

   \                                 In section SOFTPACK, align 4, keep-with-next
     62          static void _send_sdram_cmd(uint32_t cmd)
     63          {
   \                     _send_sdram_cmd:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
     64          	SDRAMC->SDRAMC_MR = cmd & SDRAMC_MR_MODE_Msk;
   \        0x8   0xE3E0'00FF        MVN      R0,#+255
   \        0xC   0xE3C0'0D4C        BIC      R0,R0,#0x1300
   \       0x10   0xE214'1007        ANDS     R1,R4,#0x7
   \       0x14   0xE580'1000        STR      R1,[R0, #+0]
     65          	SDRAMC->SDRAMC_MR;
   \       0x18   0xE590'0000        LDR      R0,[R0, #+0]
     66          	dmb();
   \       0x1C   0x....'....        BL       `dmb`
     67          
     68          	/* Perform a write to SDRAM to acknowledge the command */
     69          	*((uint32_t *)DDR_CS_ADDR) = 0;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE3A0'1580        MOV      R1,#+536870912
   \       0x28   0xE581'0000        STR      R0,[R1, #+0]
     70          }
   \       0x2C   0xE8BD'8010        POP      {R4,PC}          ;; return
     71          

   \                                 In section SOFTPACK, align 4, keep-with-next
     72          static void _send_ext_lmr_cmd(uint32_t opcode, uint32_t ba_offset)
     73          {
   \                     _send_ext_lmr_cmd:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     74          	SDRAMC->SDRAMC_MR = SDRAMC_MR_MODE_EXT_LOAD_MODEREG;
   \        0xC   0xE3E0'00FF        MVN      R0,#+255
   \       0x10   0xE3C0'0D4C        BIC      R0,R0,#0x1300
   \       0x14   0xE3A0'1005        MOV      R1,#+5
   \       0x18   0xE580'1000        STR      R1,[R0, #+0]
     75          	SDRAMC->SDRAMC_MR;
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
     76          	dmb();
   \       0x20   0x....'....        BL       `dmb`
     77          
     78          	/* Perform a write to the SDRAM to acknowledge the command */
     79          	*((uint32_t *)(DDR_CS_ADDR + (opcode << ba_offset))) = 0u;
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0xE3A0'1580        MOV      R1,#+536870912
   \       0x2C   0xE091'1514        ADDS     R1,R1,R4, LSL R5
   \       0x30   0xE581'0000        STR      R0,[R1, #+0]
     80          }
   \       0x34   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
     81          
     82          /*------------------------------------------------------------------------------
     83           *        Exported Functions
     84           *----------------------------------------------------------------------------*/
     85          

   \                                 In section SOFTPACK, align 4, keep-with-next
     86          void sdramc_configure(const struct _sdramc_desc *desc)
     87          {
   \                     sdramc_configure:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
     88          	uint32_t master_clock_khz = pmc_get_master_clock() / 1000;
   \        0x8   0x....'....        BL       pmc_get_master_clock
   \        0xC   0xE3A0'1FFA        MOV      R1,#+1000
   \       0x10   0x....'....        BL       __aeabi_uidiv
   \       0x14   0xE1B0'5000        MOVS     R5,R0
     89          	uint32_t ba_offset = _compute_ba_offset(desc);
   \       0x18   0xE1B0'0004        MOVS     R0,R4
   \       0x1C   0x....'....        BL       _compute_ba_offset
   \       0x20   0xE1B0'6000        MOVS     R6,R0
     90          	uint8_t trc_trfc = MAX(desc->timings.trc, desc->timings.trfc);
   \       0x24   0xE5D4'000A        LDRB     R0,[R4, #+10]
   \       0x28   0xE5D4'1009        LDRB     R1,[R4, #+9]
   \       0x2C   0xE150'0001        CMP      R0,R1
   \       0x30   0x2A00'0001        BCS      ??sdramc_configure_1
   \       0x34   0xE5D4'7009        LDRB     R7,[R4, #+9]
   \       0x38   0xEA00'0000        B        ??sdramc_configure_2
   \                     ??sdramc_configure_1:
   \       0x3C   0xE5D4'700A        LDRB     R7,[R4, #+10]
     91          	uint32_t cr, cfr1, mdr;
     92          	int i;
     93          
     94          	/* Enable the controller clock */
     95          #ifdef ID_SDRAMC
     96          	pmc_configure_peripheral(ID_SDRAMC, NULL, true);
     97          #endif
     98          	pmc_enable_system_clock(PMC_SYSTEM_CLOCK_DDR);
   \                     ??sdramc_configure_2:
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \       0x44   0x....'....        BL       pmc_enable_system_clock
     99          
    100          	/*
    101          	 * Step 1: Set the SDRAM features in tht SDRAMC_CR: asynchronous
    102          	 * timings (TRC, TRAS, etc.), number of columns, number of rows, CAS
    103          	 * latency and data bus width. Set UNAL bit in SDRAMC_CFR1.
    104          	 */
    105          	cr = SDRAMC_CR_TWR(desc->timings.twr) |
    106          	     SDRAMC_CR_TRC_TRFC(trc_trfc) |
    107          	     SDRAMC_CR_TRP(desc->timings.trp) |
    108          	     SDRAMC_CR_TRCD(desc->timings.trcd) |
    109          	     SDRAMC_CR_TRAS(desc->timings.tras) |
    110          	     SDRAMC_CR_TXSR(desc->timings.txsr);
   \       0x48   0xE5D4'0008        LDRB     R0,[R4, #+8]
   \       0x4C   0xE3A0'1EF0        MOV      R1,#+3840
   \       0x50   0xE011'0400        ANDS     R0,R1,R0, LSL #+8
   \       0x54   0xE1B0'1007        MOVS     R1,R7
   \       0x58   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x5C   0xE3A0'2CF0        MOV      R2,#+61440
   \       0x60   0xE012'1601        ANDS     R1,R2,R1, LSL #+12
   \       0x64   0xE191'0000        ORRS     R0,R1,R0
   \       0x68   0xE5D4'100B        LDRB     R1,[R4, #+11]
   \       0x6C   0xE3A0'2AF0        MOV      R2,#+983040
   \       0x70   0xE012'1801        ANDS     R1,R2,R1, LSL #+16
   \       0x74   0xE191'0000        ORRS     R0,R1,R0
   \       0x78   0xE5D4'100C        LDRB     R1,[R4, #+12]
   \       0x7C   0xE3A0'28F0        MOV      R2,#+15728640
   \       0x80   0xE012'1A01        ANDS     R1,R2,R1, LSL #+20
   \       0x84   0xE191'0000        ORRS     R0,R1,R0
   \       0x88   0xE5D4'100D        LDRB     R1,[R4, #+13]
   \       0x8C   0xE3A0'26F0        MOV      R2,#+251658240
   \       0x90   0xE012'1C01        ANDS     R1,R2,R1, LSL #+24
   \       0x94   0xE191'0000        ORRS     R0,R1,R0
   \       0x98   0xE5D4'100E        LDRB     R1,[R4, #+14]
   \       0x9C   0xE190'8E01        ORRS     R8,R0,R1, LSL #+28
    111          
    112          	switch (desc->nb_columns) {
   \       0xA0   0xE5D4'0001        LDRB     R0,[R4, #+1]
   \       0xA4   0xE240'0008        SUB      R0,R0,#+8
   \       0xA8   0xE350'0003        CMP      R0,#+3
   \       0xAC   0x8A00'0009        BHI      ??sdramc_configure_3
   \       0xB0   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0xB4   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??sdramc_configure_0:
   \       0xB8   0x00 0x01          DC8      0x0,0x1,0x3,0x5

   \              0x03 0x05
    113          	case 8:
    114          		cr |= SDRAMC_CR_NC_COL8;
    115          		break;
   \                     ??sdramc_configure_4:
   \       0xBC   0xEA00'000C        B        ??sdramc_configure_5
    116          	case 9:
    117          		cr |= SDRAMC_CR_NC_COL9;
   \                     ??sdramc_configure_6:
   \       0xC0   0xE398'8001        ORRS     R8,R8,#0x1
    118          		break;
   \       0xC4   0xEA00'000A        B        ??sdramc_configure_5
    119          	case 10:
    120          		cr |= SDRAMC_CR_NC_COL10;
   \                     ??sdramc_configure_7:
   \       0xC8   0xE398'8002        ORRS     R8,R8,#0x2
    121          		break;
   \       0xCC   0xEA00'0008        B        ??sdramc_configure_5
    122          	case 11:
    123          		cr |= SDRAMC_CR_NC_COL11;
   \                     ??sdramc_configure_8:
   \       0xD0   0xE398'8003        ORRS     R8,R8,#0x3
    124          		break;
   \       0xD4   0xEA00'0006        B        ??sdramc_configure_5
    125          	default:
    126          		trace_fatal("Unsupported number of columns\r\n");
   \                     ??sdramc_configure_3:
   \       0xD8   0x....'....        LDR      R0,??DataTable1
   \       0xDC   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xE0   0xE350'0000        CMP      R0,#+0
   \       0xE4   0x0A00'0001        BEQ      ??sdramc_configure_9
   \       0xE8   0x....'....        LDR      R0,??DataTable1_1
   \       0xEC   0x....'....        BL       printf
   \                     ??sdramc_configure_9:
   \       0xF0   0xEAFF'FFFE        B        ??sdramc_configure_9
    127          		break;
    128          	}
    129          
    130          	switch (desc->nb_rows) {
   \                     ??sdramc_configure_5:
   \       0xF4   0xE5D4'0002        LDRB     R0,[R4, #+2]
   \       0xF8   0xE350'000B        CMP      R0,#+11
   \       0xFC   0x0A00'0004        BEQ      ??sdramc_configure_10
   \      0x100   0x3A00'0008        BCC      ??sdramc_configure_11
   \      0x104   0xE350'000D        CMP      R0,#+13
   \      0x108   0x0A00'0004        BEQ      ??sdramc_configure_12
   \      0x10C   0x3A00'0001        BCC      ??sdramc_configure_13
   \      0x110   0xEA00'0004        B        ??sdramc_configure_11
    131          	case 11:
    132          		cr |= SDRAMC_CR_NR_ROW11;
    133          		break;
   \                     ??sdramc_configure_10:
   \      0x114   0xEA00'000A        B        ??sdramc_configure_14
    134          	case 12:
    135          		cr |= SDRAMC_CR_NR_ROW12;
   \                     ??sdramc_configure_13:
   \      0x118   0xE398'8004        ORRS     R8,R8,#0x4
    136          		break;
   \      0x11C   0xEA00'0008        B        ??sdramc_configure_14
    137          	case 13:
    138          		cr |= SDRAMC_CR_NR_ROW13;
   \                     ??sdramc_configure_12:
   \      0x120   0xE398'8008        ORRS     R8,R8,#0x8
    139          		break;
   \      0x124   0xEA00'0006        B        ??sdramc_configure_14
    140          	default:
    141          		trace_fatal("Unsupported number of rows\r\n");
   \                     ??sdramc_configure_11:
   \      0x128   0x....'....        LDR      R0,??DataTable1
   \      0x12C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x130   0xE350'0000        CMP      R0,#+0
   \      0x134   0x0A00'0001        BEQ      ??sdramc_configure_15
   \      0x138   0x....'....        LDR      R0,??DataTable1_2
   \      0x13C   0x....'....        BL       printf
   \                     ??sdramc_configure_15:
   \      0x140   0xEAFF'FFFE        B        ??sdramc_configure_15
    142          		break;
    143          	}
    144          
    145          	switch (desc->nb_banks) {
   \                     ??sdramc_configure_14:
   \      0x144   0xE5D4'0003        LDRB     R0,[R4, #+3]
   \      0x148   0xE350'0002        CMP      R0,#+2
   \      0x14C   0x0A00'0002        BEQ      ??sdramc_configure_16
   \      0x150   0xE350'0004        CMP      R0,#+4
   \      0x154   0x0A00'0001        BEQ      ??sdramc_configure_17
   \      0x158   0xEA00'0002        B        ??sdramc_configure_18
    146          	case 2:
    147          		cr |= SDRAMC_CR_NB_BANK2;
    148          		break;
   \                     ??sdramc_configure_16:
   \      0x15C   0xEA00'0008        B        ??sdramc_configure_19
    149          	case 4:
    150          		cr |= SDRAMC_CR_NB_BANK4;
   \                     ??sdramc_configure_17:
   \      0x160   0xE398'8010        ORRS     R8,R8,#0x10
    151          		break;
   \      0x164   0xEA00'0006        B        ??sdramc_configure_19
    152          	default:
    153          		trace_fatal("Unsupported number of banks\r\n");
   \                     ??sdramc_configure_18:
   \      0x168   0x....'....        LDR      R0,??DataTable1
   \      0x16C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x170   0xE350'0000        CMP      R0,#+0
   \      0x174   0x0A00'0001        BEQ      ??sdramc_configure_20
   \      0x178   0x....'....        LDR      R0,??DataTable1_3
   \      0x17C   0x....'....        BL       printf
   \                     ??sdramc_configure_20:
   \      0x180   0xEAFF'FFFE        B        ??sdramc_configure_20
    154          		break;
    155          	}
    156          
    157          	switch (desc->cas_latency) {
   \                     ??sdramc_configure_19:
   \      0x184   0xE5D4'0005        LDRB     R0,[R4, #+5]
   \      0x188   0xE350'0002        CMP      R0,#+2
   \      0x18C   0x0A00'0002        BEQ      ??sdramc_configure_21
   \      0x190   0xE350'0003        CMP      R0,#+3
   \      0x194   0x0A00'0002        BEQ      ??sdramc_configure_22
   \      0x198   0xEA00'0003        B        ??sdramc_configure_23
    158          	case 2:
    159          		cr |= SDRAMC_CR_CAS_LATENCY2;
   \                     ??sdramc_configure_21:
   \      0x19C   0xE398'8040        ORRS     R8,R8,#0x40
    160          		break;
   \      0x1A0   0xEA00'0008        B        ??sdramc_configure_24
    161          	case 3:
    162          		cr |= SDRAMC_CR_CAS_LATENCY3;
   \                     ??sdramc_configure_22:
   \      0x1A4   0xE398'8060        ORRS     R8,R8,#0x60
    163          		break;
   \      0x1A8   0xEA00'0006        B        ??sdramc_configure_24
    164          	default:
    165          		trace_fatal("Unsupported CAS latency\r\n");
   \                     ??sdramc_configure_23:
   \      0x1AC   0x....'....        LDR      R0,??DataTable1
   \      0x1B0   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x1B4   0xE350'0000        CMP      R0,#+0
   \      0x1B8   0x0A00'0001        BEQ      ??sdramc_configure_25
   \      0x1BC   0x....'....        LDR      R0,??DataTable1_4
   \      0x1C0   0x....'....        BL       printf
   \                     ??sdramc_configure_25:
   \      0x1C4   0xEAFF'FFFE        B        ??sdramc_configure_25
    166          		break;
    167          	}
    168          
    169          	switch (desc->data_bus_width) {
   \                     ??sdramc_configure_24:
   \      0x1C8   0xE5D4'0004        LDRB     R0,[R4, #+4]
   \      0x1CC   0xE350'0010        CMP      R0,#+16
   \      0x1D0   0x0A00'0002        BEQ      ??sdramc_configure_26
   \      0x1D4   0xE350'0020        CMP      R0,#+32
   \      0x1D8   0x0A00'0002        BEQ      ??sdramc_configure_27
   \      0x1DC   0xEA00'0002        B        ??sdramc_configure_28
    170          	case 16:
    171          		cr |= SDRAMC_CR_DBW;
   \                     ??sdramc_configure_26:
   \      0x1E0   0xE398'8080        ORRS     R8,R8,#0x80
    172          		break;
   \      0x1E4   0xEA00'0007        B        ??sdramc_configure_29
    173          	case 32:
    174          		break;
   \                     ??sdramc_configure_27:
   \      0x1E8   0xEA00'0006        B        ??sdramc_configure_29
    175          	default:
    176          		trace_fatal("Unsupported data width\r\n");
   \                     ??sdramc_configure_28:
   \      0x1EC   0x....'....        LDR      R0,??DataTable1
   \      0x1F0   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x1F4   0xE350'0000        CMP      R0,#+0
   \      0x1F8   0x0A00'0001        BEQ      ??sdramc_configure_30
   \      0x1FC   0x....'....        LDR      R0,??DataTable1_5
   \      0x200   0x....'....        BL       printf
   \                     ??sdramc_configure_30:
   \      0x204   0xEAFF'FFFE        B        ??sdramc_configure_30
    177          		break;
    178          	}
    179          
    180          	SDRAMC->SDRAMC_CR = cr;
   \                     ??sdramc_configure_29:
   \      0x208   0xE3E0'00F7        MVN      R0,#+247
   \      0x20C   0xE3C0'0D4C        BIC      R0,R0,#0x1300
   \      0x210   0xE580'8000        STR      R8,[R0, #+0]
    181          
    182          	cfr1 = SDRAMC_CFR1_TMRD(desc->timings.tmrd) |
    183          	       SDRAMC_CFR1_UNAL;
   \      0x214   0xE5D4'0007        LDRB     R0,[R4, #+7]
   \      0x218   0xE210'000F        ANDS     R0,R0,#0xF
   \      0x21C   0xE390'9F40        ORRS     R9,R0,#0x100
    184          	SDRAMC->SDRAMC_CFR1 = cfr1;
   \      0x220   0xE3E0'00D7        MVN      R0,#+215
   \      0x224   0xE3C0'0D4C        BIC      R0,R0,#0x1300
   \      0x228   0xE580'9000        STR      R9,[R0, #+0]
    185          
    186          	/*
    187          	 * Step 2: For mobile SDRAM, configure temperature-compensated
    188          	 * self-refresh (TCSR), drive strength (DS) and partial array
    189          	 * self-refresh (PASR) in the Low Power register (SDRAMC_LPR).
    190          	 */
    191          	if (desc->is_lpsdr) {
   \      0x22C   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x230   0xE350'0000        CMP      R0,#+0
   \      0x234   0x0A00'0004        BEQ      ??sdramc_configure_31
    192          		SDRAMC->SDRAMC_LPR = SDRAMC_LPR_LPCB_SELF_REFRESH |
    193          		                     SDRAMC_LPR_PASR(0) | /* Full array */
    194          		                     SDRAMC_LPR_TCSR(0) |
    195          		                     SDRAMC_LPR_DS(2) | /* Quarter */
    196          		                     SDRAMC_LPR_TIMEOUT_LP_LAST_XFER_128;
   \      0x238   0xE3A0'0001        MOV      R0,#+1
   \      0x23C   0xE380'0DA0        ORR      R0,R0,#0x2800
   \      0x240   0xE3E0'10EF        MVN      R1,#+239
   \      0x244   0xE3C1'1D4C        BIC      R1,R1,#0x1300
   \      0x248   0xE581'0000        STR      R0,[R1, #+0]
    197          	}
    198          
    199          	/*
    200          	 * Step 3: Select the SDRAM memory device type and the shift sampling
    201          	 * value int he Memory Device register (SDRAMC_MDR).
    202          	 */
    203          	mdr = desc->is_lpsdr ? SDRAMC_MDR_MD_LPSDRAM : SDRAMC_MDR_MD_SDRAM;
   \                     ??sdramc_configure_31:
   \      0x24C   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x250   0xE350'0000        CMP      R0,#+0
   \      0x254   0x0A00'0001        BEQ      ??sdramc_configure_32
   \      0x258   0xE3A0'A001        MOV      R10,#+1
   \      0x25C   0xEA00'0000        B        ??sdramc_configure_33
   \                     ??sdramc_configure_32:
   \      0x260   0xE3A0'A000        MOV      R10,#+0
    204          	switch (desc->shift_sampling) {
   \                     ??sdramc_configure_33:
   \      0x264   0xE5D4'0006        LDRB     R0,[R4, #+6]
   \      0x268   0xE350'0001        CMP      R0,#+1
   \      0x26C   0x0A00'0003        BEQ      ??sdramc_configure_34
   \      0x270   0x3A00'0011        BCC      ??sdramc_configure_35
   \      0x274   0xE350'0003        CMP      R0,#+3
   \      0x278   0x0A00'0000        BEQ      ??sdramc_configure_34
   \      0x27C   0x2A00'000E        BCS      ??sdramc_configure_35
    205          	case 1:
    206          	case 2:
    207          	case 3:
    208          		mdr |= SDRAMC_MDR_SHIFT_SAMPLING(desc->shift_sampling);
   \                     ??sdramc_configure_34:
   \      0x280   0xE5D4'0006        LDRB     R0,[R4, #+6]
   \      0x284   0xE3A0'1030        MOV      R1,#+48
   \      0x288   0xE011'0200        ANDS     R0,R1,R0, LSL #+4
   \      0x28C   0xE190'A00A        ORRS     R10,R0,R10
    209          		break;
    210          	default:
    211          		trace_fatal("Unsupported shift sampling\r\n");
    212          		break;
    213          	}
    214          
    215          	SDRAMC->SDRAMC_MDR = mdr;
   \      0x290   0xE3E0'00DB        MVN      R0,#+219
   \      0x294   0xE3C0'0D4C        BIC      R0,R0,#0x1300
   \      0x298   0xE580'A000        STR      R10,[R0, #+0]
    216          
    217          	/*
    218          	 * Step 4: A pause of at least 200 us must be observed before a signal
    219          	 * toggle.
    220          	 */
    221          	usleep(200);
   \      0x29C   0xE3A0'00C8        MOV      R0,#+200
   \      0x2A0   0x....'....        BL       usleep
    222          
    223          	/* Step 5: A NOP command is issued to the SDRAM devices. */
    224          	_send_sdram_cmd(SDRAMC_MR_MODE_NOP);
   \      0x2A4   0xE3A0'0001        MOV      R0,#+1
   \      0x2A8   0x....'....        BL       _send_sdram_cmd
    225          
    226          	/* Step 6: An All Banks Precharge command is issued to the SDRAM. */
    227          	_send_sdram_cmd(SDRAMC_MR_MODE_ALLBANKS_PRECHARGE);
   \      0x2AC   0xE3A0'0002        MOV      R0,#+2
   \      0x2B0   0x....'....        BL       _send_sdram_cmd
    228          
    229          	/* Step 7: Eight autorefresh (CBR) cycles are provided. */
    230          	for (i = 0; i < 8; i++)
   \      0x2B4   0xE3A0'B000        MOV      R11,#+0
   \      0x2B8   0xEA00'0006        B        ??sdramc_configure_36
   \                     ??sdramc_configure_35:
   \      0x2BC   0x....'....        LDR      R0,??DataTable1
   \      0x2C0   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x2C4   0xE350'0000        CMP      R0,#+0
   \      0x2C8   0x0A00'0001        BEQ      ??sdramc_configure_37
   \      0x2CC   0x....'....        LDR      R0,??DataTable1_6
   \      0x2D0   0x....'....        BL       printf
   \                     ??sdramc_configure_37:
   \      0x2D4   0xEAFF'FFFE        B        ??sdramc_configure_37
   \                     ??sdramc_configure_36:
   \      0x2D8   0xE35B'0008        CMP      R11,#+8
   \      0x2DC   0xAA00'0003        BGE      ??sdramc_configure_38
    231          		_send_sdram_cmd(SDRAMC_MR_MODE_AUTO_REFRESH);
   \      0x2E0   0xE3A0'0004        MOV      R0,#+4
   \      0x2E4   0x....'....        BL       _send_sdram_cmd
   \      0x2E8   0xE29B'B001        ADDS     R11,R11,#+1
   \      0x2EC   0xEAFF'FFF9        B        ??sdramc_configure_36
    232          
    233          	/*
    234          	 * Step 8: A Mode Register set (MRS) cycle is issued to program the
    235          	 * parameters of the SDRAM, in particular CAS latency and burst length.
    236          	 * The application must write a 3 to the MODE field in the SDRAMC_MR.
    237          	 * Read the SDRAMC_MR and add a memory barrier assembler instruction
    238          	 * just after the read. Perform a write access to the SDRAM. The write
    239          	 * address must be chosen so that BA[1:0] are set to 0.
    240          	 */
    241          	_send_sdram_cmd(SDRAMC_MR_MODE_LOAD_MODEREG);
   \                     ??sdramc_configure_38:
   \      0x2F0   0xE3A0'0003        MOV      R0,#+3
   \      0x2F4   0x....'....        BL       _send_sdram_cmd
    242          
    243          	/*
    244          	 * Step 9: For mobile SDRAM initialization, an Extended Mode Register
    245          	 * set (EMRS) cycle is issued to program the SDRAM parametres (TCSR,
    246          	 * PASR, DS). The application must set the MODE field to 5 in the
    247          	 * SDRAMC_MR. Read the SDRAMC_MR and add a memory barrier assembler
    248          	 * instruction just after the read. Perform a write access to the SDRAM.
    249          	 * The write address must be chosen so that BA[1] or BA[0] are set to 1.
    250          	 */
    251          	if (desc->is_lpsdr)
   \      0x2F8   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \      0x2FC   0xE350'0000        CMP      R0,#+0
   \      0x300   0x0A00'0002        BEQ      ??sdramc_configure_39
    252          		_send_ext_lmr_cmd(2, ba_offset);
   \      0x304   0xE1B0'1006        MOVS     R1,R6
   \      0x308   0xE3A0'0002        MOV      R0,#+2
   \      0x30C   0x....'....        BL       _send_ext_lmr_cmd
    253          
    254          	/* Step 10: The application must go into Normal mode. */
    255          	_send_sdram_cmd(SDRAMC_MR_MODE_NORMAL);
   \                     ??sdramc_configure_39:
   \      0x310   0xE3A0'0000        MOV      R0,#+0
   \      0x314   0x....'....        BL       _send_sdram_cmd
    256          
    257          	/*
    258          	 * Step 11: Write the refresh rate into the COUNT field in the Refresh
    259          	 * Timer register (SDRAMC_TR). (Refresh rate = delay between refresh
    260          	 * cycles.)
    261          	 * Refresh Timer is (refresh window / refresh_cycles) * master_clock_khz
    262          	 */
    263          	SDRAMC->SDRAMC_TR = SDRAMC_TR_COUNT(desc->refresh_window * master_clock_khz / desc->refresh_cycles);
   \      0x318   0xE594'0010        LDR      R0,[R4, #+16]
   \      0x31C   0xE010'0095        MULS     R0,R5,R0
   \      0x320   0xE594'1014        LDR      R1,[R4, #+20]
   \      0x324   0x....'....        BL       __aeabi_uidiv
   \      0x328   0xE1B0'0A00        LSLS     R0,R0,#+20
   \      0x32C   0xE1B0'0A20        LSRS     R0,R0,#+20
   \      0x330   0xE3E0'10FB        MVN      R1,#+251
   \      0x334   0xE3C1'1D4C        BIC      R1,R1,#0x1300
   \      0x338   0xE581'0000        STR      R0,[R1, #+0]
    264          }
   \      0x33C   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported number of columns\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x6E 0x75    

   \              0x6D 0x62    

   \              0x65 0x72    

   \              0x20 0x6F    

   \              0x66 0x20    

   \              0x63 0x6F    

   \              0x6C 0x75    

   \              0x6D 0x6E    

   \              0x73 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported number of rows\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x6E 0x75    

   \              0x6D 0x62    

   \              0x65 0x72    

   \              0x20 0x6F    

   \              0x66 0x20    

   \              0x72 0x6F    

   \              0x77 0x73    

   \              0x0D 0x0A    

   \              0x00
   \       0x21   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported number of banks\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x6E 0x75    

   \              0x6D 0x62    

   \              0x65 0x72    

   \              0x20 0x6F    

   \              0x66 0x20    

   \              0x62 0x61    

   \              0x6E 0x6B    

   \              0x73 0x0D    

   \              0x0A 0x00
   \       0x22   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported CAS latency\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x43 0x41    

   \              0x53 0x20    

   \              0x6C 0x61    

   \              0x74 0x65    

   \              0x6E 0x63    

   \              0x79 0x0D    

   \              0x0A 0x00
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported data width\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x64 0x61    

   \              0x74 0x61    

   \              0x20 0x77    

   \              0x69 0x64    

   \              0x74 0x68    

   \              0x0D 0x0A    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x2D 0x46          DC8 "-F- Unsupported shift sampling\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x73 0x75    

   \              0x70 0x70    

   \              0x6F 0x72    

   \              0x74 0x65    

   \              0x64 0x20    

   \              0x73 0x68    

   \              0x69 0x66    

   \              0x74 0x20    

   \              0x73 0x61    

   \              0x6D 0x70    

   \              0x6C 0x69    

   \              0x6E 0x67    

   \              0x0D 0x0A    

   \              0x00
   \       0x21   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _compute_ba_offset
      16   _send_ext_lmr_cmd
        16   -> dmb
       8   _send_sdram_cmd
         8   -> dmb
       0   dmb
      40   sdramc_configure
        40   -> _compute_ba_offset
        40   -> _send_ext_lmr_cmd
        40   -> _send_sdram_cmd
        40   -> pmc_enable_system_clock
        40   -> pmc_get_master_clock
        40   -> printf
        40   -> usleep
        40 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      36  ?_0
      36  ?_1
      36  ?_2
      32  ?_3
      32  ?_4
      36  ?_5
      44  _compute_ba_offset
      56  _send_ext_lmr_cmd
      48  _send_sdram_cmd
       4  dmb
     832  sdramc_configure

 
   208 bytes in section .rodata
 1'012 bytes in section SOFTPACK
 
 1'012 bytes of CODE  memory
   208 bytes of CONST memory

Errors: none
Warnings: none
