###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         20/Jan/2021  09:41:41
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\display\lcdc.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWD662.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\display\lcdc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_LCD -D CONFIG_HAVE_LCDC -D CONFIG_HAVE_LCDC_OVR1 -D
#        CONFIG_HAVE_LCDC_OVR2 -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_DDR2_W972GG6KB -D CONFIG_HAVE_RSTC_EXTERNAL_RESET -D
#        CONFIG_HAVE_RSTC_INDEPENDENT_RESET -D CONFIG_HAVE_RTT -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\sram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\sram\List\lcdc.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\sram\Obj\lcdc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\display\lcdc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2019, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file */
     31          
     32          /*----------------------------------------------------------------------------
     33           *        Headers
     34           *----------------------------------------------------------------------------*/
     35          
     36          #include <math.h>
     37          #include <string.h>
     38          #include <stdio.h>
     39          
     40          #include "chip.h"
     41          #include "compiler.h"
     42          #include "display/lcdc.h"
     43          #include "gpio/pio.h"
     44          #include "mm/cache.h"
     45          #include "peripherals/pmc.h"
     46          #include "trace.h"
     47          
     48          /** \addtogroup lcdc_base
     49           * Implementation of LCD driver, Include LCD initialization,
     50           * LCD on/off and LCD backlight control.
     51           */
     52          
     53          /**@{*/
     54          
     55          /*----------------------------------------------------------------------------
     56           *        Local types
     57           *----------------------------------------------------------------------------*/
     58          
     59          /** Hardware info about the layers */
     60          struct _layer_info {
     61          	struct _layer_data* data;
     62          	bool                stride_supported;
     63          	volatile uint32_t  *reg_enable;     /**< regs: _ER, _DR, _SR, _IER, _IDR, _IMR, _ISR */
     64          	volatile uint32_t  *reg_blender;    /**< regs: blender */
     65          	volatile uint32_t  *reg_dma_head;   /**< regs: _HEAD, _ADDRESS, _CONTROL, _NEXT */
     66          	volatile uint32_t  *reg_dma_u_head; /**< regs: _HEAD, _ADDRESS, _CONTROL, _NEXT */
     67          	volatile uint32_t  *reg_dma_v_head; /**< regs: _HEAD, _ADDRESS, _CONTROL, _NEXT */
     68          	volatile uint32_t  *reg_cfg;        /**< regs: _CFG0, _CFG1 (RGB mode ...) */
     69          	volatile uint32_t  *reg_win;        /**< regs: X Y register, W H register */
     70          	volatile uint32_t  *reg_stride;     /**< regs: stride */
     71          	volatile uint32_t  *reg_color;      /**< regs: RGB Default, RGB Key, RGB Mask */
     72          	volatile uint32_t  *reg_scale;      /**< regs: scale */
     73          	volatile uint32_t  *reg_clut;       /**< regs: CLUT */
     74          };
     75          
     76          /** DMA descriptor for LCDC */
     77          struct _lcdc_dma_desc {
     78          	uint32_t addr;
     79          	uint32_t ctrl;
     80          	uint32_t next;
     81          	uint32_t for_alignment_only;
     82          };
     83          
     84          /** Variable layer data */
     85          struct _layer_data {
     86          	struct _lcdc_dma_desc *dma_desc;
     87          	struct _lcdc_dma_desc *dma_u_desc;
     88          	struct _lcdc_dma_desc *dma_v_desc;
     89          	void                  *buffer;
     90          	uint8_t                bpp;
     91          };
     92          
     93          /*----------------------------------------------------------------------------
     94           *        Local variables
     95           *----------------------------------------------------------------------------*/
     96          

   \                                 In section .bss, align 4
     97          static struct _lcdc_desc lcdc_config;         /**< Current LCD configuration */
   \                     lcdc_config:
   \        0x0                      DS8 12
     98          

   \                                 In section .bss, align 4
     99          static struct _lcdc_layer lcdc_canvas;        /**< Current selected canvas */
   \                     lcdc_canvas:
   \        0x0                      DS8 12
    100          
    101          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    102          static struct _lcdc_dma_desc base_dma_desc;  /**< DMA desc. for Base Layer */
   \                     base_dma_desc:
   \        0x0                      DS8 16
    103          

   \                                 In section .bss, align 4
    104          static struct _layer_data lcdc_base;         /**< Base Layer */
   \                     lcdc_base:
   \        0x0                      DS8 20
    105          
    106          #ifdef CONFIG_HAVE_LCDC_OVR1
    107          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    108          static struct _lcdc_dma_desc ovr1_dma_desc;  /**< DMA desc. for OVR1 Layer */
   \                     ovr1_dma_desc:
   \        0x0                      DS8 16
    109          

   \                                 In section .bss, align 4
    110          static struct _layer_data lcdc_ovr1;         /**< OVR1 Layer */
   \                     lcdc_ovr1:
   \        0x0                      DS8 20
    111          #endif
    112          
    113          #ifdef CONFIG_HAVE_LCDC_OVR2
    114          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    115          static struct _lcdc_dma_desc ovr2_dma_desc;  /**< DMA desc. for OVR2 Layer */
   \                     ovr2_dma_desc:
   \        0x0                      DS8 16
    116          

   \                                 In section .bss, align 4
    117          static struct _layer_data lcdc_ovr2;         /**< OVR2 Layer */
   \                     lcdc_ovr2:
   \        0x0                      DS8 20
    118          #endif
    119          
    120          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    121          static struct _lcdc_dma_desc heo_dma_desc;   /**< DMA desc. for HEO Layer */
   \                     heo_dma_desc:
   \        0x0                      DS8 16
    122          
    123          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    124          static struct _lcdc_dma_desc heo_dma_u_desc; /**< DMA desc. for HEO U-UV Layer */
   \                     heo_dma_u_desc:
   \        0x0                      DS8 16
    125          
    126          CACHE_ALIGNED_DDR

   \                                 In section .region_ddr_cache_aligned, align 8
    127          static struct _lcdc_dma_desc heo_dma_v_desc; /**< DMA desc. for HEO V Layer */
   \                     heo_dma_v_desc:
   \        0x0                      DS8 16
    128          

   \                                 In section .bss, align 4
    129          static struct _layer_data lcdc_heo;          /**< HEO Layer */
   \                     lcdc_heo:
   \        0x0                      DS8 20
    130          
    131          #ifdef CONFIG_HAVE_LCDC_PP
    132          CACHE_ALIGNED_DDR
    133          static struct _lcdc_dma_desc pp_dma_desc;    /**< DMA desc. for PP Layer */
    134          
    135          static struct _layer_data lcdc_pp;           /**< PP Layer */
    136          #endif
    137          
    138          /*----------------------------------------------------------------------------
    139           *        Local constants
    140           *----------------------------------------------------------------------------*/
    141          
    142          /** Information about layers, order must match value of LCDC_XXX constants in
    143           * ldcd.h */

   \                                 In section .rodata, align 4
    144          static const struct _layer_info lcdc_layers[] = {
   \                     lcdc_layers:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x25   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \       0x34   0x....'....        DC32 lcdc_base
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0xF803'8060        DC32 0xf803'8060, 0xf803'809c, 0xf803'807c, 0x0, 0x0, 0xf803'808c, 0x0

   \              0xF803'809C  

   \              0xF803'807C  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0xF803'808C  

   \              0x0000'0000
   \       0x58   0xF803'8094        DC32 0xf803'8094, 0xf803'8098, 0x0, 0xf803'8600, lcdc_ovr1

   \              0xF803'8098  

   \              0x0000'0000  

   \              0xF803'8600  

   \              0x....'....
   \       0x6C   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x70   0xF803'8160        DC32 0xf803'8160, 0xf803'81b0, 0xf803'817c, 0x0, 0x0, 0xf803'818c

   \              0xF803'81B0  

   \              0xF803'817C  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0xF803'818C
   \       0x88   0xF803'8194        DC32 0xf803'8194, 0xf803'819c, 0xf803'81a4, 0x0, 0xf803'8a00, lcdc_heo

   \              0xF803'819C  

   \              0xF803'81A4  

   \              0x0000'0000  

   \              0xF803'8A00  

   \              0x....'....
   \       0xA0   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0xA4   0xF803'8360        DC32 0xf803'8360, 0xf803'83dc, 0xf803'837c, 0xf803'838c, 0xf803'839c

   \              0xF803'83DC  

   \              0xF803'837C  

   \              0xF803'838C  

   \              0xF803'839C
   \       0xB8   0xF803'83AC        DC32 0xf803'83ac, 0xf803'83b4, 0xf803'83c0, 0xf803'83d0, 0xf803'83e0

   \              0xF803'83B4  

   \              0xF803'83C0  

   \              0xF803'83D0  

   \              0xF803'83E0
   \       0xCC   0xF803'9200        DC32 0xf803'9200, lcdc_ovr2

   \              0x....'....
   \       0xD4   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0xD8   0xF803'8260        DC32 0xf803'8260, 0xf803'82b0, 0xf803'827c, 0x0, 0x0, 0xf803'828c

   \              0xF803'82B0  

   \              0xF803'827C  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0xF803'828C
   \       0xF0   0xF803'8294        DC32 0xf803'8294, 0xf803'829c, 0xf803'82a4, 0x0, 0xf803'8e00, 0x0

   \              0xF803'829C  

   \              0xF803'82A4  

   \              0x0000'0000  

   \              0xF803'8E00  

   \              0x0000'0000
   \      0x108   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x118   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x128   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
    145          	/* 0: LCDC_CONTROLLER */
    146          	{
    147          		.stride_supported = false,
    148          	},
    149          	/* 1: LCDC_BASE */
    150          	{
    151          		.data = &lcdc_base,
    152          		.stride_supported = false,
    153          		.reg_enable = &LCDC->LCDC_BASECHER,
    154          		.reg_blender = &LCDC->LCDC_BASECFG4,
    155          		.reg_dma_head = &LCDC->LCDC_BASEHEAD,
    156          		.reg_cfg = &LCDC->LCDC_BASECFG0,
    157          		.reg_stride = &LCDC->LCDC_BASECFG2,
    158          		.reg_color = &LCDC->LCDC_BASECFG3,
    159          		.reg_clut = &LCDC->LCDC_BASECLUT[0]
    160          	},
    161          #ifdef CONFIG_HAVE_LCDC_OVR1
    162          	/* 2: LCDC_OVR1 */
    163          	{
    164          		.data = &lcdc_ovr1,
    165          		.stride_supported = true,
    166          		.reg_enable = &LCDC->LCDC_OVR1CHER,
    167          		.reg_blender = &LCDC->LCDC_OVR1CFG9,
    168          		.reg_dma_head = &LCDC->LCDC_OVR1HEAD,
    169          		.reg_cfg = &LCDC->LCDC_OVR1CFG0,
    170          		.reg_win = &LCDC->LCDC_OVR1CFG2,
    171          		.reg_stride = &LCDC->LCDC_OVR1CFG4,
    172          		.reg_color = &LCDC->LCDC_OVR1CFG6,
    173          		.reg_clut = &LCDC->LCDC_OVR1CLUT[0],
    174          	},
    175          #else
    176          	/* 2: N/A */
    177          	{
    178          		.data = NULL,
    179          	},
    180          #endif
    181          	/* 3: LCDC_HEO */
    182          	{
    183          		.data = &lcdc_heo,
    184          		.stride_supported = true,
    185          		.reg_enable = &LCDC->LCDC_HEOCHER,
    186          		.reg_blender = &LCDC->LCDC_HEOCFG12,
    187          		.reg_dma_head = &LCDC->LCDC_HEOHEAD,
    188          		.reg_dma_u_head = &LCDC->LCDC_HEOUHEAD,
    189          		.reg_dma_v_head = &LCDC->LCDC_HEOVHEAD,
    190          		.reg_cfg = &LCDC->LCDC_HEOCFG0,
    191          		.reg_win = &LCDC->LCDC_HEOCFG2,
    192          		.reg_stride = &LCDC->LCDC_HEOCFG5,
    193          		.reg_color = &LCDC->LCDC_HEOCFG9,
    194          		.reg_scale = &LCDC->LCDC_HEOCFG13,
    195          		.reg_clut = &LCDC->LCDC_HEOCLUT[0],
    196          	},
    197          #ifdef CONFIG_HAVE_LCDC_OVR2
    198          	/* 4: LCDC_OVR2 */
    199          	{
    200          		.data = &lcdc_ovr2,
    201          		.stride_supported = true,
    202          		.reg_enable = &LCDC->LCDC_OVR2CHER,
    203          		.reg_blender = &LCDC->LCDC_OVR2CFG9,
    204          		.reg_dma_head = &LCDC->LCDC_OVR2HEAD,
    205          		.reg_cfg = &LCDC->LCDC_OVR2CFG0,
    206          		.reg_win = &LCDC->LCDC_OVR2CFG2,
    207          		.reg_stride = &LCDC->LCDC_OVR2CFG4,
    208          		.reg_color = &LCDC->LCDC_OVR2CFG6,
    209          		.reg_clut = &LCDC->LCDC_OVR2CLUT[0],
    210          	},
    211          #else
    212          	/* 4: N/A */
    213          	{
    214          		.data = NULL,
    215          	},
    216          #endif
    217          #ifdef CONFIG_HAVE_LCDC_PP
    218          
    219          	{
    220          		.data = &lcdc_pp,
    221          		.stride_supported = true,
    222          		.reg_enable = &LCDC->LCDC_PPCHER,
    223          		.reg_dma_head = &LCDC->LCDC_PPHEAD,
    224          		.reg_cfg = &LCDC->LCDC_PPCFG0,
    225          		.reg_stride = &LCDC->LCDC_PPCFG2,
    226          	},
    227          #else
    228          	/* 5: N/A */
    229          	{
    230          		.data = NULL,
    231          	},
    232          #endif
    233          };
    234          
    235          /*----------------------------------------------------------------------------
    236           *        Local functions
    237           *----------------------------------------------------------------------------*/
    238          
    239          /**
    240           * Wait for clock domain synchronization to be complete.
    241           * While synchronization is in progress, access to registers
    242           * LCDC_LCDCCFG[0..6], LCDC_LCDEN and LCDC_LCDDIS has no effect.
    243           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    244          static void _wait_for_clock_domain_sync(void)
    245          {
    246          	while ((LCDC->LCDC_LCDSR & LCDC_LCDSR_SIPSTS));
   \                     _wait_for_clock_domain_sync:
   \                     ??_wait_for_clock_domain_sync_0:
   \        0x0   0x....'....        LDR      R0,??DataTable20  ;; 0xf8038028
   \        0x4   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x8   0xE310'0010        TST      R0,#0x10
   \        0xC   0x1AFF'FFFB        BNE      ??_wait_for_clock_domain_sync_0
    247          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    248          
    249          /**
    250           * Return bits per pixel from RGB mode settings.
    251           * (Note the bits is bits occupied in memory, including reserved)
    252           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    253          static uint32_t _get_bits_per_pixel(uint32_t mode_reg)
    254          {
   \                     _get_bits_per_pixel:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    255          	switch (mode_reg) {
   \        0x4   0xE1B0'0001        MOVS     R0,R1
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x0A00'004A        BEQ      ??_get_bits_per_pixel_0
   \       0x10   0xE350'0001        CMP      R0,#+1
   \       0x14   0x0A00'004E        BEQ      ??_get_bits_per_pixel_1
   \       0x18   0xE350'0002        CMP      R0,#+2
   \       0x1C   0x0A00'0054        BEQ      ??_get_bits_per_pixel_2
   \       0x20   0xE350'0010        CMP      R0,#+16
   \       0x24   0x0A00'0044        BEQ      ??_get_bits_per_pixel_0
   \       0x28   0xE350'0020        CMP      R0,#+32
   \       0x2C   0x0A00'0042        BEQ      ??_get_bits_per_pixel_0
   \       0x30   0xE350'0030        CMP      R0,#+48
   \       0x34   0x0A00'0040        BEQ      ??_get_bits_per_pixel_0
   \       0x38   0xE350'0040        CMP      R0,#+64
   \       0x3C   0x0A00'003E        BEQ      ??_get_bits_per_pixel_0
   \       0x40   0xE350'0050        CMP      R0,#+80
   \       0x44   0x0A00'0040        BEQ      ??_get_bits_per_pixel_3
   \       0x48   0xE350'0060        CMP      R0,#+96
   \       0x4C   0x0A00'003C        BEQ      ??_get_bits_per_pixel_4
   \       0x50   0xE350'0070        CMP      R0,#+112
   \       0x54   0x0A00'003C        BEQ      ??_get_bits_per_pixel_3
   \       0x58   0xE350'0080        CMP      R0,#+128
   \       0x5C   0x0A00'0038        BEQ      ??_get_bits_per_pixel_4
   \       0x60   0xE350'0090        CMP      R0,#+144
   \       0x64   0x0A00'0038        BEQ      ??_get_bits_per_pixel_3
   \       0x68   0xE350'00A0        CMP      R0,#+160
   \       0x6C   0x0A00'0034        BEQ      ??_get_bits_per_pixel_4
   \       0x70   0xE350'00B0        CMP      R0,#+176
   \       0x74   0x0A00'0034        BEQ      ??_get_bits_per_pixel_3
   \       0x78   0xE350'00C0        CMP      R0,#+192
   \       0x7C   0x0A00'0032        BEQ      ??_get_bits_per_pixel_3
   \       0x80   0xE350'00D0        CMP      R0,#+208
   \       0x84   0x0A00'0030        BEQ      ??_get_bits_per_pixel_3
   \       0x88   0xE3A0'2001        MOV      R2,#+1
   \       0x8C   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x90   0xE150'0002        CMP      R0,R2
   \       0x94   0x0A00'0030        BEQ      ??_get_bits_per_pixel_5
   \       0x98   0xE3A0'2001        MOV      R2,#+1
   \       0x9C   0xE382'2F80        ORR      R2,R2,#0x200
   \       0xA0   0xE150'0002        CMP      R0,R2
   \       0xA4   0x0A00'002E        BEQ      ??_get_bits_per_pixel_6
   \       0xA8   0xE3A0'2001        MOV      R2,#+1
   \       0xAC   0xE382'2FC0        ORR      R2,R2,#0x300
   \       0xB0   0xE150'0002        CMP      R0,R2
   \       0xB4   0x0A00'002C        BEQ      ??_get_bits_per_pixel_7
   \       0xB8   0xE3A0'2002        MOV      R2,#+2
   \       0xBC   0xE382'2D40        ORR      R2,R2,#0x1000
   \       0xC0   0xE150'0002        CMP      R0,R2
   \       0xC4   0x0A00'002C        BEQ      ??_get_bits_per_pixel_8
   \       0xC8   0xE3A0'2002        MOV      R2,#+2
   \       0xCC   0xE382'2D80        ORR      R2,R2,#0x2000
   \       0xD0   0xE150'0002        CMP      R0,R2
   \       0xD4   0x0A00'0028        BEQ      ??_get_bits_per_pixel_8
   \       0xD8   0xE3A0'2002        MOV      R2,#+2
   \       0xDC   0xE382'2DC0        ORR      R2,R2,#0x3000
   \       0xE0   0xE150'0002        CMP      R0,R2
   \       0xE4   0x0A00'0024        BEQ      ??_get_bits_per_pixel_8
   \       0xE8   0xE3A0'2002        MOV      R2,#+2
   \       0xEC   0xE382'2C40        ORR      R2,R2,#0x4000
   \       0xF0   0xE150'0002        CMP      R0,R2
   \       0xF4   0x0A00'0020        BEQ      ??_get_bits_per_pixel_8
   \       0xF8   0xE3A0'2002        MOV      R2,#+2
   \       0xFC   0xE382'2C50        ORR      R2,R2,#0x5000
   \      0x100   0xE150'0002        CMP      R0,R2
   \      0x104   0x0A00'001C        BEQ      ??_get_bits_per_pixel_8
   \      0x108   0xE3A0'2002        MOV      R2,#+2
   \      0x10C   0xE382'2C60        ORR      R2,R2,#0x6000
   \      0x110   0xE150'0002        CMP      R0,R2
   \      0x114   0x0A00'0018        BEQ      ??_get_bits_per_pixel_8
   \      0x118   0xE3A0'2002        MOV      R2,#+2
   \      0x11C   0xE382'2C70        ORR      R2,R2,#0x7000
   \      0x120   0xE150'0002        CMP      R0,R2
   \      0x124   0x0A00'0014        BEQ      ??_get_bits_per_pixel_8
   \      0x128   0xE3A0'2002        MOV      R2,#+2
   \      0x12C   0xE382'2C80        ORR      R2,R2,#0x8000
   \      0x130   0xE150'0002        CMP      R0,R2
   \      0x134   0x0A00'0010        BEQ      ??_get_bits_per_pixel_8
   \      0x138   0xEA00'0011        B        ??_get_bits_per_pixel_9
    256          
    257          	/* RGB modes */
    258          
    259          	case LCDC_HEOCFG1_RGBMODE_12BPP_RGB_444:
    260          	case LCDC_HEOCFG1_RGBMODE_16BPP_ARGB_4444:
    261          	case LCDC_HEOCFG1_RGBMODE_16BPP_RGBA_4444:
    262          	case LCDC_HEOCFG1_RGBMODE_16BPP_RGB_565:
    263          	case LCDC_HEOCFG1_RGBMODE_16BPP_TRGB_1555:
    264          		return 2 * 8;
   \                     ??_get_bits_per_pixel_0:
   \      0x13C   0xE3A0'0010        MOV      R0,#+16
   \      0x140   0xEA00'0010        B        ??_get_bits_per_pixel_10
    265          
    266          	case LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666_PACKED:
    267          	case LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_PACKED:
    268          	case LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED:
    269          		return 3 * 8;
   \                     ??_get_bits_per_pixel_4:
   \      0x144   0xE3A0'0018        MOV      R0,#+24
   \      0x148   0xEA00'000E        B        ??_get_bits_per_pixel_10
    270          
    271          	case LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666:
    272          	case LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_1666:
    273          	case LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888:
    274          	case LCDC_HEOCFG1_RGBMODE_25BPP_TRGB_1888:
    275          	case LCDC_HEOCFG1_RGBMODE_32BPP_ARGB_8888:
    276          	case LCDC_HEOCFG1_RGBMODE_32BPP_RGBA_8888:
    277          		return 3 * 8;
   \                     ??_get_bits_per_pixel_3:
   \      0x14C   0xE3A0'0018        MOV      R0,#+24
   \      0x150   0xEA00'000C        B        ??_get_bits_per_pixel_10
    278          
    279          	/* CLUT modes */
    280          
    281          	case LCDC_HEOCFG1_CLUTMODE_1BPP | LCDC_HEOCFG1_CLUTEN:
    282          		return 1;
   \                     ??_get_bits_per_pixel_1:
   \      0x154   0xE3A0'0001        MOV      R0,#+1
   \      0x158   0xEA00'000A        B        ??_get_bits_per_pixel_10
    283          	case LCDC_HEOCFG1_CLUTMODE_2BPP | LCDC_HEOCFG1_CLUTEN:
    284          		return 2;
   \                     ??_get_bits_per_pixel_5:
   \      0x15C   0xE3A0'0002        MOV      R0,#+2
   \      0x160   0xEA00'0008        B        ??_get_bits_per_pixel_10
    285          	case LCDC_HEOCFG1_CLUTMODE_4BPP | LCDC_HEOCFG1_CLUTEN:
    286          		return 4;
   \                     ??_get_bits_per_pixel_6:
   \      0x164   0xE3A0'0004        MOV      R0,#+4
   \      0x168   0xEA00'0006        B        ??_get_bits_per_pixel_10
    287          	case LCDC_HEOCFG1_CLUTMODE_8BPP | LCDC_HEOCFG1_CLUTEN:
    288          		return 8;
   \                     ??_get_bits_per_pixel_7:
   \      0x16C   0xE3A0'0008        MOV      R0,#+8
   \      0x170   0xEA00'0004        B        ??_get_bits_per_pixel_10
    289          
    290          #ifdef LCDC_HEOCFG1_YUVEN
    291          	/* YUV modes */
    292          
    293          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_32BPP_AYCBCR:
    294          		return 32;
   \                     ??_get_bits_per_pixel_2:
   \      0x174   0xE3A0'0020        MOV      R0,#+32
   \      0x178   0xEA00'0002        B        ??_get_bits_per_pixel_10
    295          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE0:
    296          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE1:
    297          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE2:
    298          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE3:
    299          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_SEMIPLANAR:
    300          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_PLANAR:
    301          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_SEMIPLANAR:
    302          	case LCDC_HEOCFG1_YUVEN | LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_PLANAR:
    303          		return 16;
   \                     ??_get_bits_per_pixel_8:
   \      0x17C   0xE3A0'0010        MOV      R0,#+16
   \      0x180   0xEA00'0000        B        ??_get_bits_per_pixel_10
    304          #endif /* LCDC_HEOCFG1_YUVEN */
    305          	}
    306          	return 0;
   \                     ??_get_bits_per_pixel_9:
   \      0x184   0xE3A0'0000        MOV      R0,#+0
   \                     ??_get_bits_per_pixel_10:
   \      0x188   0xE12F'FF1E        BX       LR               ;; return
    307          }
    308          
    309          /**
    310           * Enable a LCDC DMA channel
    311           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    312          static void _set_dma_desc(void *buffer, struct _lcdc_dma_desc *desc,
    313          		volatile uint32_t *dma_head_reg)
    314          {
    315          	/* Modify descriptor */
    316          	desc->addr = (uint32_t)buffer;
   \                     _set_dma_desc:
   \        0x0   0xE581'0000        STR      R0,[R1, #+0]
    317          	desc->ctrl = LCDC_BASECTRL_DFETCH;
   \        0x4   0xE3A0'3001        MOV      R3,#+1
   \        0x8   0xE581'3004        STR      R3,[R1, #+4]
    318          	desc->next = (uint32_t)desc;
   \        0xC   0xE581'1008        STR      R1,[R1, #+8]
    319          	//cache_clean_region(desc, sizeof(struct _lcdc_dma_desc));
    320          	/* Modify registers */
    321          	dma_head_reg[1] = (uint32_t)buffer;
   \       0x10   0xE582'0004        STR      R0,[R2, #+4]
    322          	dma_head_reg[2] = LCDC_BASECTRL_DFETCH;
   \       0x14   0xE582'3008        STR      R3,[R2, #+8]
    323          	dma_head_reg[3] = (uint32_t)desc;
   \       0x18   0xE582'100C        STR      R1,[R2, #+12]
    324          }
   \       0x1C   0xE12F'FF1E        BX       LR               ;; return
    325          
    326          /**
    327           * Disable a LCDC DMA channel
    328           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    329          static void _clear_dma_desc(struct _lcdc_dma_desc *desc,
    330          		volatile uint32_t *dma_head_reg)
    331          {
   \                     _clear_dma_desc:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    332          	/* Modify descriptor */
    333          	if (desc) {
   \        0xC   0xE354'0000        CMP      R4,#+0
   \       0x10   0x0A00'0006        BEQ      ??_clear_dma_desc_0
    334          		desc->ctrl &= ~LCDC_BASECTRL_DFETCH;
   \       0x14   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x18   0xE3D0'0001        BICS     R0,R0,#0x1
   \       0x1C   0xE584'0004        STR      R0,[R4, #+4]
    335          		desc->next = (uint32_t)desc;
   \       0x20   0xE584'4008        STR      R4,[R4, #+8]
    336          		cache_clean_region(desc, sizeof(struct _lcdc_dma_desc));
   \       0x24   0xE3A0'1010        MOV      R1,#+16
   \       0x28   0xE1B0'0004        MOVS     R0,R4
   \       0x2C   0x....'....        BL       cache_clean_region
    337          	}
    338          
    339          	/* Modify registers */
    340          	dma_head_reg[2] &= ~LCDC_BASECTRL_DFETCH;
   \                     ??_clear_dma_desc_0:
   \       0x30   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x34   0xE3D0'0001        BICS     R0,R0,#0x1
   \       0x38   0xE585'0008        STR      R0,[R5, #+8]
    341          	dma_head_reg[3] = (uint32_t)desc;
   \       0x3C   0xE585'400C        STR      R4,[R5, #+12]
    342          }
   \       0x40   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    343          
    344          /**
    345           * Compute scaling factors
    346           */
    347          static void _compute_scaling_factors(const struct _layer_info *layer,
                             ^
Warning[Pe177]: function "_compute_scaling_factors" was declared but never
          referenced
    348          		uint16_t* xfactor, uint16_t* yfactor)
    349          {
    350          	uint16_t xmemsize, ymemsize;
    351          	uint16_t xsize, ysize;
    352          #ifdef LCDC_HEOCFG41_XPHIDEF
    353          	uint16_t xfactor_1st, yfactor_1st;
    354          #endif
    355          
    356          	xmemsize = (layer->reg_win[2] & LCDC_HEOCFG4_XMEMSIZE_Msk) >> LCDC_HEOCFG4_XMEMSIZE_Pos;
    357          	ymemsize = (layer->reg_win[2] & LCDC_HEOCFG4_YMEMSIZE_Msk) >> LCDC_HEOCFG4_YMEMSIZE_Pos;
    358          	xsize = (layer->reg_win[1] & LCDC_HEOCFG3_XSIZE_Msk) >> LCDC_HEOCFG3_XSIZE_Pos;
    359          	ysize = (layer->reg_win[1] & LCDC_HEOCFG3_YSIZE_Msk) >> LCDC_HEOCFG3_YSIZE_Pos;
    360          
    361          #ifdef LCDC_HEOCFG41_XPHIDEF
    362          	/* we assume that XPHIDEF & YPHIDEF are 0 */
    363          	xfactor_1st = (2048 * xmemsize / xsize) + 1;
    364          	yfactor_1st = (2048 * ymemsize / ysize) + 1;
    365          
    366          	if ((xfactor_1st * xsize / 2048) > xmemsize)
    367          		*xfactor = xfactor_1st - 1;
    368          	else
    369          		*xfactor = xfactor_1st;
    370          
    371          	if ((yfactor_1st * ysize / 2048) > ymemsize)
    372          		*yfactor = yfactor_1st - 1;
    373          	else
    374          		*yfactor = yfactor_1st;
    375          #else
    376          	*xfactor = 1024 * (xmemsize + 1) / (xsize + 1);
    377          	*yfactor = 1024 * (ymemsize + 1) / (ysize + 1);
    378          #endif
    379          }
    380          
    381          /**
    382           * Build 8-bit color palette (actually true color)
    383           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    384          static void _build_color_lut8(volatile uint32_t *clut)
    385          {
    386          	uint32_t r, g, b;
    387          	/* 3:3:2 */
    388          	for (r = 0; r < 8; r++) {
   \                     _build_color_lut8:
   \        0x0   0xE3A0'1000        MOV      R1,#+0
   \                     ??_build_color_lut8_0:
   \        0x4   0xE351'0008        CMP      R1,#+8
   \        0x8   0x2A00'0012        BCS      ??_build_color_lut8_1
    389          		for (g = 0; g < 8; g++) {
   \        0xC   0xE3A0'C000        MOV      R12,#+0
   \       0x10   0xE1B0'200C        MOVS     R2,R12
   \                     ??_build_color_lut8_2:
   \       0x14   0xE352'0008        CMP      R2,#+8
   \       0x18   0x2A00'000C        BCS      ??_build_color_lut8_3
    390          			for (b = 0; b < 4; b++) {
   \       0x1C   0xE3A0'C000        MOV      R12,#+0
   \       0x20   0xE1B0'300C        MOVS     R3,R12
   \                     ??_build_color_lut8_4:
   \       0x24   0xE353'0004        CMP      R3,#+4
   \       0x28   0x2A00'0006        BCS      ??_build_color_lut8_5
    391          				*clut++ = (r << (16 + 5))
    392          					+ (g << (8 + 5))
    393          					+ (b << (0 + 6));
   \       0x2C   0xE1B0'C682        LSLS     R12,R2,#+13
   \       0x30   0xE09C'CA81        ADDS     R12,R12,R1, LSL #+21
   \       0x34   0xE09C'C303        ADDS     R12,R12,R3, LSL #+6
   \       0x38   0xE580'C000        STR      R12,[R0, #+0]
   \       0x3C   0xE290'0004        ADDS     R0,R0,#+4
    394          			}
   \       0x40   0xE293'3001        ADDS     R3,R3,#+1
   \       0x44   0xEAFF'FFF6        B        ??_build_color_lut8_4
    395          		}
   \                     ??_build_color_lut8_5:
   \       0x48   0xE292'2001        ADDS     R2,R2,#+1
   \       0x4C   0xEAFF'FFF0        B        ??_build_color_lut8_2
    396          	}
   \                     ??_build_color_lut8_3:
   \       0x50   0xE291'1001        ADDS     R1,R1,#+1
   \       0x54   0xEAFF'FFEA        B        ??_build_color_lut8_0
    397          }
   \                     ??_build_color_lut8_1:
   \       0x58   0xE12F'FF1E        BX       LR               ;; return
    398          
    399          /**
    400           * Build 4-bit color palette (16 color)
    401           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    402          static void _build_color_lut4(volatile uint32_t *clut)
    403          {
    404          	uint32_t r, g, b;
    405          	for (r = 0; r < 4; r++) {
   \                     _build_color_lut4:
   \        0x0   0xE3A0'1000        MOV      R1,#+0
   \                     ??_build_color_lut4_0:
   \        0x4   0xE351'0004        CMP      R1,#+4
   \        0x8   0x2A00'0012        BCS      ??_build_color_lut4_1
    406          		for (g = 0; g < 2; g++) {
   \        0xC   0xE3A0'C000        MOV      R12,#+0
   \       0x10   0xE1B0'200C        MOVS     R2,R12
   \                     ??_build_color_lut4_2:
   \       0x14   0xE352'0002        CMP      R2,#+2
   \       0x18   0x2A00'000C        BCS      ??_build_color_lut4_3
    407          			for (b = 0; b < 2; b++) {
   \       0x1C   0xE3A0'C000        MOV      R12,#+0
   \       0x20   0xE1B0'300C        MOVS     R3,R12
   \                     ??_build_color_lut4_4:
   \       0x24   0xE353'0002        CMP      R3,#+2
   \       0x28   0x2A00'0006        BCS      ??_build_color_lut4_5
    408          				*clut++ = (r << (16 + 6))
    409          					+ (g << (8 + 7))
    410          					+ (b << (0 + 7));
   \       0x2C   0xE1B0'C782        LSLS     R12,R2,#+15
   \       0x30   0xE09C'CB01        ADDS     R12,R12,R1, LSL #+22
   \       0x34   0xE09C'C383        ADDS     R12,R12,R3, LSL #+7
   \       0x38   0xE580'C000        STR      R12,[R0, #+0]
   \       0x3C   0xE290'0004        ADDS     R0,R0,#+4
    411          			}
   \       0x40   0xE293'3001        ADDS     R3,R3,#+1
   \       0x44   0xEAFF'FFF6        B        ??_build_color_lut4_4
    412          		}
   \                     ??_build_color_lut4_5:
   \       0x48   0xE292'2001        ADDS     R2,R2,#+1
   \       0x4C   0xEAFF'FFF0        B        ??_build_color_lut4_2
    413          	}
   \                     ??_build_color_lut4_3:
   \       0x50   0xE291'1001        ADDS     R1,R1,#+1
   \       0x54   0xEAFF'FFEA        B        ??_build_color_lut4_0
    414          }
   \                     ??_build_color_lut4_1:
   \       0x58   0xE12F'FF1E        BX       LR               ;; return
    415          
    416          /**
    417           * Build 2-bit color palette (4 gray)
    418           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    419          static void _build_color_lut2(volatile uint32_t *clut)
    420          {
    421          	clut[0] = 0x000000;
   \                     _build_color_lut2:
   \        0x0   0xE3A0'1000        MOV      R1,#+0
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    422          	clut[1] = 0x505050;
   \        0x8   0x....'....        LDR      R1,??DataTable20_1  ;; 0x505050
   \        0xC   0xE580'1004        STR      R1,[R0, #+4]
    423          	clut[2] = 0xA0A0A0;
   \       0x10   0x....'....        LDR      R1,??DataTable21  ;; 0xa0a0a0
   \       0x14   0xE580'1008        STR      R1,[R0, #+8]
    424          	clut[3] = 0xFFFFFF;
   \       0x18   0xE3E0'14FF        MVN      R1,#-16777216
   \       0x1C   0xE580'100C        STR      R1,[R0, #+12]
    425          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
    426          
    427          /**
    428           * Build 1-bit color palette (black & white)
    429           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    430          static void _build_color_lut1(volatile uint32_t *clut)
    431          {
    432          	clut[0] = 0x000000;
   \                     _build_color_lut1:
   \        0x0   0xE3A0'1000        MOV      R1,#+0
   \        0x4   0xE580'1000        STR      R1,[R0, #+0]
    433          	clut[1] = 0xFFFFFF;
   \        0x8   0xE3E0'14FF        MVN      R1,#-16777216
   \        0xC   0xE580'1004        STR      R1,[R0, #+4]
    434          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    435          
    436          /*----------------------------------------------------------------------------
    437           *        Exported functions
    438           *----------------------------------------------------------------------------*/
    439          /**
    440           * \brief Initializes the LCD controller.
    441           * Configure SMC to access LCD controller at 64MHz MCK.
    442           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    443          void lcdc_configure(const struct _lcdc_desc *desc)
    444          {
   \                     lcdc_configure:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    445          	lcdc_config = *desc;
   \        0x8   0x....'....        LDR      R0,??DataTable21_1
   \        0xC   0xE1B0'1004        MOVS     R1,R4
   \       0x10   0xE3A0'200C        MOV      R2,#+12
   \       0x14   0x....'....        BL       __aeabi_memcpy
    446          
    447          	/* Reset layer information */
    448          	lcdc_base.bpp = 0;
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0x....'....        LDR      R1,??DataTable24
   \       0x20   0xE5C1'0010        STRB     R0,[R1, #+16]
    449          	lcdc_base.buffer = NULL;
   \       0x24   0xE581'000C        STR      R0,[R1, #+12]
    450          	lcdc_base.dma_desc = &base_dma_desc;
   \       0x28   0x....'....        LDR      R2,??DataTable21_2
   \       0x2C   0xE581'2000        STR      R2,[R1, #+0]
    451          #ifdef CONFIG_HAVE_LCDC_OVR1
    452          	lcdc_ovr1.bpp = 0;
   \       0x30   0x....'....        LDR      R1,??DataTable24_1
   \       0x34   0xE5C1'0010        STRB     R0,[R1, #+16]
    453          	lcdc_ovr1.buffer = NULL;
   \       0x38   0xE581'000C        STR      R0,[R1, #+12]
    454          	lcdc_ovr1.dma_desc = &ovr1_dma_desc;
   \       0x3C   0x....'....        LDR      R2,??DataTable21_3
   \       0x40   0xE581'2000        STR      R2,[R1, #+0]
    455          #endif
    456          #ifdef CONFIG_HAVE_LCDC_OVR2
    457          	lcdc_ovr2.bpp = 0;
   \       0x44   0x....'....        LDR      R1,??DataTable24_2
   \       0x48   0xE5C1'0010        STRB     R0,[R1, #+16]
    458          	lcdc_ovr2.buffer = NULL;
   \       0x4C   0xE581'000C        STR      R0,[R1, #+12]
    459          	lcdc_ovr2.dma_desc = &ovr2_dma_desc;
   \       0x50   0x....'....        LDR      R2,??DataTable21_4
   \       0x54   0xE581'2000        STR      R2,[R1, #+0]
    460          #endif
    461          	lcdc_heo.bpp = 0;
   \       0x58   0x....'....        LDR      R1,??DataTable22
   \       0x5C   0xE5C1'0010        STRB     R0,[R1, #+16]
    462          	lcdc_heo.buffer = NULL;
   \       0x60   0xE581'000C        STR      R0,[R1, #+12]
    463          	lcdc_heo.dma_desc = &heo_dma_desc;
   \       0x64   0x....'....        LDR      R2,??DataTable21_5
   \       0x68   0xE581'2000        STR      R2,[R1, #+0]
    464          	lcdc_heo.dma_u_desc = &heo_dma_u_desc;
   \       0x6C   0x....'....        LDR      R2,??DataTable21_6
   \       0x70   0xE581'2004        STR      R2,[R1, #+4]
    465          	lcdc_heo.dma_v_desc = &heo_dma_v_desc;
   \       0x74   0x....'....        LDR      R2,??DataTable21_7
   \       0x78   0xE581'2008        STR      R2,[R1, #+8]
    466          #ifdef CONFIG_HAVE_LCDC_PP
    467          	/* Reset layer information */
    468          	lcdc_pp.bpp = 0;
    469          	lcdc_pp.buffer = NULL;
    470          	lcdc_pp.dma_desc = &pp_dma_desc;
    471          #endif
    472          	/* No canvas selected */
    473          	lcdc_canvas.buffer = NULL;
   \       0x7C   0x....'....        LDR      R1,??DataTable21_8
   \       0x80   0xE581'0000        STR      R0,[R1, #+0]
    474          
    475          	/* Disable LCD controller */
    476          	lcdc_off();
   \       0x84   0x....'....        BL       lcdc_off
    477          
    478          	/* Enable peripheral clock */
    479          	pmc_configure_peripheral(ID_LCDC, NULL, true);
   \       0x88   0xE3A0'2001        MOV      R2,#+1
   \       0x8C   0xE3A0'1000        MOV      R1,#+0
   \       0x90   0xE3A0'0019        MOV      R0,#+25
   \       0x94   0x....'....        BL       pmc_configure_peripheral
    480          	if (pmc_has_system_clock(PMC_SYSTEM_CLOCK_LCD))
   \       0x98   0xE3A0'0001        MOV      R0,#+1
   \       0x9C   0x....'....        BL       pmc_has_system_clock
   \       0xA0   0xE350'0000        CMP      R0,#+0
   \       0xA4   0x0A00'0001        BEQ      ??lcdc_configure_0
    481          		pmc_enable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0xA8   0xE3A0'0001        MOV      R0,#+1
   \       0xAC   0x....'....        BL       pmc_enable_system_clock
    482          
    483          	/* Timing Engine Configuration */
    484          
    485          	/* Disable interrupt */
    486          	LCDC->LCDC_LCDIDR = 0xFFFFFFFF;
   \                     ??lcdc_configure_0:
   \       0xB0   0xE3E0'0000        MVN      R0,#+0
   \       0xB4   0x....'....        LDR      R1,??DataTable21_9  ;; 0xf8038030
   \       0xB8   0xE581'0000        STR      R0,[R1, #+0]
    487          
    488          	/* Configure channels */
    489          
    490          	/* Base */
    491          	LCDC->LCDC_BASECFG0 = LCDC_BASECFG0_DLBO |
    492          	                      LCDC_BASECFG0_BLEN_AHB_INCR16;
   \       0xBC   0xE3A0'0F4C        MOV      R0,#+304
   \       0xC0   0x....'....        LDR      R1,??DataTable21_10  ;; 0xf803808c
   \       0xC4   0xE581'0000        STR      R0,[R1, #+0]
    493          	LCDC->LCDC_BASECFG1 = LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED;
   \       0xC8   0xE3A0'00A0        MOV      R0,#+160
   \       0xCC   0x....'....        LDR      R1,??DataTable21_11  ;; 0xf8038090
   \       0xD0   0xE581'0000        STR      R0,[R1, #+0]
    494          
    495          #ifdef CONFIG_HAVE_LCDC_OVR1
    496          	/* Overlay 1, GA 0xFF */
    497          	LCDC->LCDC_OVR1CFG0 = LCDC_OVR1CFG0_DLBO |
    498          	                      LCDC_OVR1CFG0_BLEN_AHB_INCR16 |
    499          	                      LCDC_OVR1CFG0_ROTDIS;
   \       0xD4   0xE3A0'1030        MOV      R1,#+48
   \       0xD8   0xE381'1D44        ORR      R1,R1,#0x1100
   \       0xDC   0x....'....        LDR      R2,??DataTable21_12  ;; 0xf803818c
   \       0xE0   0xE582'1000        STR      R1,[R2, #+0]
    500          	LCDC->LCDC_OVR1CFG1 = LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888_PACKED;
   \       0xE4   0x....'....        LDR      R2,??DataTable21_13  ;; 0xf8038190
   \       0xE8   0xE582'0000        STR      R0,[R2, #+0]
    501          	LCDC->LCDC_OVR1CFG9 = LCDC_OVR1CFG9_GA(0xFF) |
    502          	                      LCDC_OVR1CFG9_GAEN;
   \       0xEC   0xE3A0'2020        MOV      R2,#+32
   \       0xF0   0xE382'28FF        ORR      R2,R2,#0xFF0000
   \       0xF4   0x....'....        LDR      R3,??DataTable21_14  ;; 0xf80381b0
   \       0xF8   0xE583'2000        STR      R2,[R3, #+0]
    503          #endif
    504          
    505          #ifdef CONFIG_HAVE_LCDC_OVR2
    506          	/* Overlay 2, GA 0xFF */
    507          	LCDC->LCDC_OVR2CFG0 = LCDC_OVR2CFG0_DLBO |
    508          	                      LCDC_OVR2CFG0_BLEN_AHB_INCR16 |
    509          	                      LCDC_OVR2CFG0_ROTDIS;
   \       0xFC   0x....'....        LDR      R3,??DataTable21_15  ;; 0xf803828c
   \      0x100   0xE583'1000        STR      R1,[R3, #+0]
    510          	LCDC->LCDC_OVR2CFG1 = LCDC_OVR2CFG1_RGBMODE_24BPP_RGB_888_PACKED;
   \      0x104   0x....'....        LDR      R3,??DataTable21_16  ;; 0xf8038290
   \      0x108   0xE583'0000        STR      R0,[R3, #+0]
    511          	LCDC->LCDC_OVR2CFG9 = LCDC_OVR2CFG9_GA(0xFF) |
    512          	                      LCDC_OVR2CFG9_GAEN;
   \      0x10C   0x....'....        LDR      R3,??DataTable21_17  ;; 0xf80382b0
   \      0x110   0xE583'2000        STR      R2,[R3, #+0]
    513          #endif
    514          
    515          	/* High End Overlay, GA 0xFF */
    516          	LCDC->LCDC_HEOCFG0 = LCDC_HEOCFG0_DLBO |
    517          	                     LCDC_HEOCFG0_BLEN_AHB_INCR16 |
    518          	                     LCDC_HEOCFG0_ROTDIS;
   \      0x114   0x....'....        LDR      R3,??DataTable21_18  ;; 0xf80383ac
   \      0x118   0xE583'1000        STR      R1,[R3, #+0]
    519          	LCDC->LCDC_HEOCFG1 = LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED;
   \      0x11C   0x....'....        LDR      R1,??DataTable21_19  ;; 0xf80383b0
   \      0x120   0xE581'0000        STR      R0,[R1, #+0]
    520          	LCDC->LCDC_HEOCFG12 = LCDC_HEOCFG12_GA(0xFF) |
    521          	                      LCDC_HEOCFG12_GAEN;
   \      0x124   0x....'....        LDR      R0,??DataTable21_20  ;; 0xf80383dc
   \      0x128   0xE580'2000        STR      R2,[R0, #+0]
    522          
    523          	LCDC->LCDC_HEOCFG14 = LCDC_HEOCFG14_CSCRY(0x94) |
    524          	                      LCDC_HEOCFG14_CSCRU(0xCC) |
    525          	                      LCDC_HEOCFG14_CSCRV(0) |
    526          	                      LCDC_HEOCFG14_CSCYOFF;
   \      0x12C   0x....'....        LDR      R0,??DataTable21_21  ;; 0x40033094
   \      0x130   0x....'....        LDR      R1,??DataTable21_22  ;; 0xf80383e4
   \      0x134   0xE581'0000        STR      R0,[R1, #+0]
    527          	LCDC->LCDC_HEOCFG15 = LCDC_HEOCFG15_CSCGY(0x94) |
    528          	                      LCDC_HEOCFG15_CSCGU(0x387) |
    529          	                      LCDC_HEOCFG15_CSCGV(0x3CD) |
    530          	                      LCDC_HEOCFG15_CSCUOFF;
   \      0x138   0x....'....        LDR      R0,??DataTable21_23  ;; 0x7cde1c94
   \      0x13C   0x....'....        LDR      R1,??DataTable22_1  ;; 0xf80383e8
   \      0x140   0xE581'0000        STR      R0,[R1, #+0]
    531          	LCDC->LCDC_HEOCFG16 = LCDC_HEOCFG16_CSCBY(0x94)|
    532          	                      LCDC_HEOCFG16_CSCBU(0) |
    533          	                      LCDC_HEOCFG16_CSCBV(0x102) |
    534          	                      LCDC_HEOCFG16_CSCVOFF;
   \      0x144   0x....'....        LDR      R0,??DataTable22_2  ;; 0x50200094
   \      0x148   0x....'....        LDR      R1,??DataTable25  ;; 0xf80383ec
   \      0x14C   0xE581'0000        STR      R0,[R1, #+0]
    535          
    536          	lcdc_on();
   \      0x150   0x....'....        BL       lcdc_on
    537          }
   \      0x154   0xE8BD'8010        POP      {R4,PC}          ;; return
    538          
    539          /**
    540           * Check if specified layer is working.
    541           * \param layer Layer ID.
    542           * \return 1 if layer is on.
    543           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    544          uint8_t lcdc_is_layer_on(uint8_t layer_id)
    545          {
   \                     lcdc_is_layer_on:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    546          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R0,??DataTable25_1
   \        0x8   0xE1B0'2001        MOVS     R2,R1
   \        0xC   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x10   0xE3A0'3034        MOV      R3,#+52
   \       0x14   0xE012'0293        MULS     R2,R3,R2
   \       0x18   0xE090'2002        ADDS     R2,R0,R2
    547          
    548          	if (!layer->reg_enable)
   \       0x1C   0xE592'0008        LDR      R0,[R2, #+8]
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0001        BNE      ??lcdc_is_layer_on_0
    549          		return 0;
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0xEA00'0002        B        ??lcdc_is_layer_on_1
    550          
    551          	return ((layer->reg_enable[2] & LCDC_BASECHSR_CHSR) > 0);
   \                     ??lcdc_is_layer_on_0:
   \       0x30   0xE592'0008        LDR      R0,[R2, #+8]
   \       0x34   0xE590'0008        LDR      R0,[R0, #+8]
   \       0x38   0xE210'0001        ANDS     R0,R0,#0x1
   \                     ??lcdc_is_layer_on_1:
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
    552          }
    553          
    554          /**
    555           * Enable(turn on)/Disable(hide) specified layer.
    556           * \param layer_id Layer ID.
    557           * \param bEnDis Enable/Disable.
    558           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    559          void lcdc_enable_layer(uint8_t layer_id, bool enable)
    560          {
    561          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \                     lcdc_enable_layer:
   \        0x0   0x....'....        LDR      R2,??DataTable25_1
   \        0x4   0xE1B0'3000        MOVS     R3,R0
   \        0x8   0xE213'30FF        ANDS     R3,R3,#0xFF      ;; Zero extend
   \        0xC   0xE3A0'C034        MOV      R12,#+52
   \       0x10   0xE013'039C        MULS     R3,R12,R3
   \       0x14   0xE092'2003        ADDS     R2,R2,R3
    562          #ifdef CONFIG_HAVE_LCDC_PP
    563          	if (layer_id == LCDC_PP) {
    564          		if (enable) {
    565          			/* Disable the display by setting LCDC_LCDDIS.SYNCDIS bit */
    566          			LCDC->LCDC_LCDDIS = LCDC_LCDDIS_SYNCDIS;
    567          			/* select the PP layer */
    568          			LCDC->LCDC_LCDCFG5 |= LCDC_LCDCFG5_PP;
    569          			LCDC->LCDC_PPCHER = LCDC_PPCHER_CHEN | LCDC_PPCHER_UPDATEEN;
    570          			while(LCDC->LCDC_PPCHSR & LCDC_PPCHSR_CHSR != LCDC_PPCHSR_CHSR);
    571          			LCDC->LCDC_LCDEN = LCDC_LCDEN_SYNCEN;
    572          		} else {
    573          			LCDC->LCDC_LCDDIS = LCDC_LCDDIS_SYNCDIS;
    574          			LCDC->LCDC_LCDCFG5 = 0;
    575          			LCDC->LCDC_PPCHDR = LCDC_PPCHDR_CHDIS;
    576          			LCDC->LCDC_LCDEN = LCDC_LCDEN_SYNCEN;
    577          		}
    578          	} else
    579          #endif
    580          	{
    581          		if (!layer->reg_enable || !layer->reg_blender)
   \       0x18   0xE592'3008        LDR      R3,[R2, #+8]
   \       0x1C   0xE353'0000        CMP      R3,#+0
   \       0x20   0x0A00'0002        BEQ      ??lcdc_enable_layer_0
   \       0x24   0xE592'300C        LDR      R3,[R2, #+12]
   \       0x28   0xE353'0000        CMP      R3,#+0
   \       0x2C   0x1A00'0000        BNE      ??lcdc_enable_layer_1
    582          			return;
   \                     ??lcdc_enable_layer_0:
   \       0x30   0xEA00'0014        B        ??lcdc_enable_layer_2
    583          
    584          		if (enable) {
   \                     ??lcdc_enable_layer_1:
   \       0x34   0xE1B0'3001        MOVS     R3,R1
   \       0x38   0xE213'30FF        ANDS     R3,R3,#0xFF      ;; Zero extend
   \       0x3C   0xE353'0000        CMP      R3,#+0
   \       0x40   0x0A00'0008        BEQ      ??lcdc_enable_layer_3
    585          			layer->reg_enable[0] = LCDC_BASECHER_CHEN | LCDC_BASECHER_UPDATEEN;
   \       0x44   0xE3A0'3003        MOV      R3,#+3
   \       0x48   0xE592'C008        LDR      R12,[R2, #+8]
   \       0x4C   0xE58C'3000        STR      R3,[R12, #+0]
    586          			layer->reg_blender[0] |= LCDC_HEOCFG12_DMA | LCDC_HEOCFG12_OVR;
   \       0x50   0xE592'300C        LDR      R3,[R2, #+12]
   \       0x54   0xE593'3000        LDR      R3,[R3, #+0]
   \       0x58   0xE393'3F60        ORRS     R3,R3,#0x180
   \       0x5C   0xE592'C00C        LDR      R12,[R2, #+12]
   \       0x60   0xE58C'3000        STR      R3,[R12, #+0]
   \       0x64   0xEA00'0007        B        ??lcdc_enable_layer_4
    587          		} else {
    588          			layer->reg_enable[1] = LCDC_BASECHDR_CHDIS;
   \                     ??lcdc_enable_layer_3:
   \       0x68   0xE3A0'3001        MOV      R3,#+1
   \       0x6C   0xE592'C008        LDR      R12,[R2, #+8]
   \       0x70   0xE58C'3004        STR      R3,[R12, #+4]
    589          			layer->reg_blender[0] &= ~(LCDC_HEOCFG12_DMA | LCDC_HEOCFG12_OVR);
   \       0x74   0xE592'300C        LDR      R3,[R2, #+12]
   \       0x78   0xE593'3000        LDR      R3,[R3, #+0]
   \       0x7C   0xE3D3'3F60        BICS     R3,R3,#0x180
   \       0x80   0xE592'C00C        LDR      R12,[R2, #+12]
   \       0x84   0xE58C'3000        STR      R3,[R12, #+0]
    590          		}
    591          	}
    592          }
   \                     ??lcdc_enable_layer_4:
   \                     ??lcdc_enable_layer_2:
   \       0x88   0xE12F'FF1E        BX       LR               ;; return
    593          
    594          /**
    595           * Refresh layer
    596           * \param layer_id Layer ID.
    597           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    598          void lcdc_refresh(uint8_t layer_id)
    599          {
    600          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \                     lcdc_refresh:
   \        0x0   0x....'....        LDR      R1,??DataTable25_1
   \        0x4   0xE1B0'2000        MOVS     R2,R0
   \        0x8   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0xC   0xE3A0'3034        MOV      R3,#+52
   \       0x10   0xE012'0293        MULS     R2,R3,R2
   \       0x14   0xE091'1002        ADDS     R1,R1,R2
    601          
    602          	if (!layer->reg_enable || !layer->reg_blender)
   \       0x18   0xE591'2008        LDR      R2,[R1, #+8]
   \       0x1C   0xE352'0000        CMP      R2,#+0
   \       0x20   0x0A00'0002        BEQ      ??lcdc_refresh_0
   \       0x24   0xE591'200C        LDR      R2,[R1, #+12]
   \       0x28   0xE352'0000        CMP      R2,#+0
   \       0x2C   0x1A00'0000        BNE      ??lcdc_refresh_1
    603          		return;
   \                     ??lcdc_refresh_0:
   \       0x30   0xEA00'000B        B        ??lcdc_refresh_2
    604          
    605          	if (layer->reg_enable[2] & LCDC_HEOCHSR_CHSR) {
   \                     ??lcdc_refresh_1:
   \       0x34   0xE591'2008        LDR      R2,[R1, #+8]
   \       0x38   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x3C   0xE312'0001        TST      R2,#0x1
   \       0x40   0x0A00'0007        BEQ      ??lcdc_refresh_3
    606          		layer->reg_blender[0] |= LCDC_HEOCFG12_DMA;
   \       0x44   0xE591'200C        LDR      R2,[R1, #+12]
   \       0x48   0xE592'2000        LDR      R2,[R2, #+0]
   \       0x4C   0xE392'2F40        ORRS     R2,R2,#0x100
   \       0x50   0xE591'300C        LDR      R3,[R1, #+12]
   \       0x54   0xE583'2000        STR      R2,[R3, #+0]
    607          		layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0x58   0xE3A0'2002        MOV      R2,#+2
   \       0x5C   0xE591'3008        LDR      R3,[R1, #+8]
   \       0x60   0xE583'2000        STR      R2,[R3, #+0]
    608          	}
    609          }
   \                     ??lcdc_refresh_3:
   \                     ??lcdc_refresh_2:
   \       0x64   0xE12F'FF1E        BX       LR               ;; return
    610          
    611          /**
    612           * Set display window position.
    613           * \param layer_id Layer ID.
    614           * \param x X position.
    615           * \param y Y position.
    616           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    617          void lcdc_set_position(uint8_t layer_id, uint32_t x, uint32_t y)
    618          {
   \                     lcdc_set_position:
   \        0x0   0xE92D'40F0        PUSH     {R4-R7,LR}
    619          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R3,??DataTable25_1
   \        0x8   0xE1B0'C000        MOVS     R12,R0
   \        0xC   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \       0x10   0xE3A0'E034        MOV      LR,#+52
   \       0x14   0xE01C'0C9E        MULS     R12,LR,R12
   \       0x18   0xE093'300C        ADDS     R3,R3,R12
    620          	uint32_t w, h;
    621          
    622          	if (!layer->reg_enable || !layer->reg_win)
   \       0x1C   0xE593'C008        LDR      R12,[R3, #+8]
   \       0x20   0xE35C'0000        CMP      R12,#+0
   \       0x24   0x0A00'0002        BEQ      ??lcdc_set_position_0
   \       0x28   0xE593'C020        LDR      R12,[R3, #+32]
   \       0x2C   0xE35C'0000        CMP      R12,#+0
   \       0x30   0x1A00'0000        BNE      ??lcdc_set_position_1
    623          		return;
   \                     ??lcdc_set_position_0:
   \       0x34   0xEA00'0024        B        ??lcdc_set_position_2
    624          
    625          	w = (layer->reg_win[1] & LCDC_HEOCFG3_XSIZE_Msk) >> LCDC_HEOCFG3_XSIZE_Pos;
   \                     ??lcdc_set_position_1:
   \       0x38   0xE3A0'C0FF        MOV      R12,#+255
   \       0x3C   0xE38C'CE70        ORR      R12,R12,#0x700
   \       0x40   0xE593'E020        LDR      LR,[R3, #+32]
   \       0x44   0xE59E'E004        LDR      LR,[LR, #+4]
   \       0x48   0xE01C'E00E        ANDS     LR,R12,LR
    626          	h = (layer->reg_win[1] & LCDC_HEOCFG3_YSIZE_Msk) >> LCDC_HEOCFG3_YSIZE_Pos;
   \       0x4C   0xE593'4020        LDR      R4,[R3, #+32]
   \       0x50   0xE594'4004        LDR      R4,[R4, #+4]
   \       0x54   0xE01C'4824        ANDS     R4,R12,R4, LSR #+16
    627          
    628          	if (x + w >= lcdc_config.width)
   \       0x58   0x....'....        LDR      R5,??DataTable21_1
   \       0x5C   0xE09E'6001        ADDS     R6,LR,R1
   \       0x60   0xE1D5'70B0        LDRH     R7,[R5, #+0]
   \       0x64   0xE156'0007        CMP      R6,R7
   \       0x68   0x3A00'0002        BCC      ??lcdc_set_position_3
    629          		x = lcdc_config.width - w;
   \       0x6C   0xE1D5'60B0        LDRH     R6,[R5, #+0]
   \       0x70   0xE056'600E        SUBS     R6,R6,LR
   \       0x74   0xE1B0'1006        MOVS     R1,R6
    630          	if (y + h >= lcdc_config.height)
   \                     ??lcdc_set_position_3:
   \       0x78   0xE094'6002        ADDS     R6,R4,R2
   \       0x7C   0xE1D5'70B2        LDRH     R7,[R5, #+2]
   \       0x80   0xE156'0007        CMP      R6,R7
   \       0x84   0x3A00'0002        BCC      ??lcdc_set_position_4
    631          		y = lcdc_config.height - h;
   \       0x88   0xE1D5'50B2        LDRH     R5,[R5, #+2]
   \       0x8C   0xE055'5004        SUBS     R5,R5,R4
   \       0x90   0xE1B0'2005        MOVS     R2,R5
    632          
    633          	layer->reg_win[0] = LCDC_HEOCFG2_XPOS(x) | LCDC_HEOCFG2_YPOS(y);
   \                     ??lcdc_set_position_4:
   \       0x94   0xE01C'C001        ANDS     R12,R12,R1
   \       0x98   0xE3A0'5670        MOV      R5,#+117440512
   \       0x9C   0xE385'58FF        ORR      R5,R5,#0xFF0000
   \       0xA0   0xE015'5802        ANDS     R5,R5,R2, LSL #+16
   \       0xA4   0xE195'C00C        ORRS     R12,R5,R12
   \       0xA8   0xE593'5020        LDR      R5,[R3, #+32]
   \       0xAC   0xE585'C000        STR      R12,[R5, #+0]
    634          	if (layer->reg_enable[2] & LCDC_HEOCHSR_CHSR)
   \       0xB0   0xE593'C008        LDR      R12,[R3, #+8]
   \       0xB4   0xE59C'C008        LDR      R12,[R12, #+8]
   \       0xB8   0xE31C'0001        TST      R12,#0x1
   \       0xBC   0x0A00'0002        BEQ      ??lcdc_set_position_5
    635          		layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0xC0   0xE3A0'C002        MOV      R12,#+2
   \       0xC4   0xE593'5008        LDR      R5,[R3, #+8]
   \       0xC8   0xE585'C000        STR      R12,[R5, #+0]
    636          }
   \                     ??lcdc_set_position_5:
   \                     ??lcdc_set_position_2:
   \       0xCC   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return
    637          
    638          /**
    639           * Set Priority of layer (only for HEO now).
    640           * \param layer_id Layer ID
    641           * \param priority Priority value.
    642           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    643          void lcdc_set_priority(uint8_t layer_id, uint8_t priority)
    644          {
    645          #ifdef LCDC_HEOCFG12_VIDPRI
    646          	if (layer_id != LCDC_HEO)
   \                     lcdc_set_priority:
   \        0x0   0xE1B0'2000        MOVS     R2,R0
   \        0x4   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0x8   0xE352'0003        CMP      R2,#+3
   \        0xC   0x1A00'000F        BNE      ??lcdc_set_priority_0
    647          		return;
    648          
    649          	if (priority)
   \                     ??lcdc_set_priority_1:
   \       0x10   0xE1B0'2001        MOVS     R2,R1
   \       0x14   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x18   0xE352'0000        CMP      R2,#+0
   \       0x1C   0x0A00'0004        BEQ      ??lcdc_set_priority_2
    650          		LCDC->LCDC_HEOCFG12 |= LCDC_HEOCFG12_VIDPRI;
   \       0x20   0x....'....        LDR      R2,??DataTable21_20  ;; 0xf80383dc
   \       0x24   0xE592'3000        LDR      R3,[R2, #+0]
   \       0x28   0xE393'3D40        ORRS     R3,R3,#0x1000
   \       0x2C   0xE582'3000        STR      R3,[R2, #+0]
   \       0x30   0xEA00'0003        B        ??lcdc_set_priority_3
    651          	else
    652          		LCDC->LCDC_HEOCFG12 &= ~LCDC_HEOCFG12_VIDPRI;
   \                     ??lcdc_set_priority_2:
   \       0x34   0x....'....        LDR      R2,??DataTable21_20  ;; 0xf80383dc
   \       0x38   0xE592'3000        LDR      R3,[R2, #+0]
   \       0x3C   0xE3D3'3D40        BICS     R3,R3,#0x1000
   \       0x40   0xE582'3000        STR      R3,[R2, #+0]
    653          	LCDC->LCDC_HEOCHER = LCDC_HEOCHER_UPDATEEN;
   \                     ??lcdc_set_priority_3:
   \       0x44   0xE3A0'2002        MOV      R2,#+2
   \       0x48   0x....'....        LDR      R3,??DataTable26  ;; 0xf8038360
   \       0x4C   0xE583'2000        STR      R2,[R3, #+0]
    654          #endif /* LCDC_HEOCFG12_VIDPRI */
    655          }
   \                     ??lcdc_set_priority_0:
   \       0x50   0xE12F'FF1E        BX       LR               ;; return
    656          
    657          /**
    658           * Return Priority of layer (only for HEO now).
    659           * \param layer_id Layer ID.
    660           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    661          uint8_t lcdc_get_priority(uint8_t layer_id)
    662          {
   \                     lcdc_get_priority:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    663          #ifdef LCDC_HEOCFG12_VIDPRI
    664          	if (layer_id != LCDC_HEO)
   \        0x4   0xE1B0'0001        MOVS     R0,R1
   \        0x8   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \        0xC   0xE350'0003        CMP      R0,#+3
   \       0x10   0x0A00'0001        BEQ      ??lcdc_get_priority_0
    665          		return 0;
   \       0x14   0xE3A0'0000        MOV      R0,#+0
   \       0x18   0xEA00'0003        B        ??lcdc_get_priority_1
    666          
    667          	return (LCDC->LCDC_HEOCFG12 & LCDC_HEOCFG12_VIDPRI) > 0;
   \                     ??lcdc_get_priority_0:
   \       0x1C   0x....'....        LDR      R0,??DataTable21_20  ;; 0xf80383dc
   \       0x20   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x24   0xE1B0'0620        LSRS     R0,R0,#+12
   \       0x28   0xE210'0001        ANDS     R0,R0,#0x1
   \                     ??lcdc_get_priority_1:
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    668          #else
    669          	return 0;
    670          #endif /* LCDC_HEOCFG12_VIDPRI */
    671          }
    672          
    673          /**
    674           * Global & Local Alpha Enable/Disable
    675           * \param layer_id   Layer ID.
    676           * \param bEnDisLA Enable/Disable local  alpha.
    677           * \param bEnDisGA Enable/Disable global alpha.
    678           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    679          void lcdc_enable_alpha(uint8_t layer_id, bool enable_local, bool enable_global)
    680          {
   \                     lcdc_enable_alpha:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    681          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R3,??DataTable25_1
   \        0x8   0xE1B0'C000        MOVS     R12,R0
   \        0xC   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \       0x10   0xE3A0'E034        MOV      LR,#+52
   \       0x14   0xE01C'0C9E        MULS     R12,LR,R12
   \       0x18   0xE093'300C        ADDS     R3,R3,R12
    682          	uint32_t cfg;
    683          
    684          	if (!layer->reg_enable || !layer->reg_blender)
   \       0x1C   0xE593'C008        LDR      R12,[R3, #+8]
   \       0x20   0xE35C'0000        CMP      R12,#+0
   \       0x24   0x0A00'0002        BEQ      ??lcdc_enable_alpha_0
   \       0x28   0xE593'C00C        LDR      R12,[R3, #+12]
   \       0x2C   0xE35C'0000        CMP      R12,#+0
   \       0x30   0x1A00'0000        BNE      ??lcdc_enable_alpha_1
    685          		return;
   \                     ??lcdc_enable_alpha_0:
   \       0x34   0xEA00'0011        B        ??lcdc_enable_alpha_2
    686          
    687          	cfg = layer->reg_blender[0] & ~(LCDC_HEOCFG12_LAEN | LCDC_HEOCFG12_GAEN);
   \                     ??lcdc_enable_alpha_1:
   \       0x38   0xE593'C00C        LDR      R12,[R3, #+12]
   \       0x3C   0xE59C'C000        LDR      R12,[R12, #+0]
   \       0x40   0xE3DC'C060        BICS     R12,R12,#0x60
    688          	if (enable_global)
   \       0x44   0xE1B0'E002        MOVS     LR,R2
   \       0x48   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x4C   0xE35E'0000        CMP      LR,#+0
   \       0x50   0x0A00'0000        BEQ      ??lcdc_enable_alpha_3
    689          		cfg |= LCDC_HEOCFG12_GAEN;
   \       0x54   0xE39C'C020        ORRS     R12,R12,#0x20
    690          	if (enable_local)
   \                     ??lcdc_enable_alpha_3:
   \       0x58   0xE1B0'E001        MOVS     LR,R1
   \       0x5C   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x60   0xE35E'0000        CMP      LR,#+0
   \       0x64   0x0A00'0000        BEQ      ??lcdc_enable_alpha_4
    691          		cfg |= LCDC_HEOCFG12_LAEN;
   \       0x68   0xE39C'C040        ORRS     R12,R12,#0x40
    692          	layer->reg_blender[0] = cfg;
   \                     ??lcdc_enable_alpha_4:
   \       0x6C   0xE593'E00C        LDR      LR,[R3, #+12]
   \       0x70   0xE58E'C000        STR      R12,[LR, #+0]
    693          	layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0x74   0xE3A0'E002        MOV      LR,#+2
   \       0x78   0xE593'4008        LDR      R4,[R3, #+8]
   \       0x7C   0xE584'E000        STR      LR,[R4, #+0]
    694          }
   \                     ??lcdc_enable_alpha_2:
   \       0x80   0xE8BD'8010        POP      {R4,PC}          ;; return
    695          
    696          /**
    697           * Set alpha value
    698           * \param layer_id Layer ID (OVR1 or HEOR).
    699           * \param bReverse Reverse alpha (alpha -> 1 - alpha).
    700           * \param bAlpha   Global alpha value.
    701           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    702          void lcdc_set_alpha(uint8_t layer_id, bool reverse, uint8_t alpha)
    703          {
   \                     lcdc_set_alpha:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    704          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R3,??DataTable25_1
   \        0x8   0xE1B0'C000        MOVS     R12,R0
   \        0xC   0xE21C'C0FF        ANDS     R12,R12,#0xFF    ;; Zero extend
   \       0x10   0xE3A0'E034        MOV      LR,#+52
   \       0x14   0xE01C'0C9E        MULS     R12,LR,R12
   \       0x18   0xE093'300C        ADDS     R3,R3,R12
    705          	uint32_t cfg;
    706          
    707          	if (!layer->reg_enable || !layer->reg_blender)
   \       0x1C   0xE593'C008        LDR      R12,[R3, #+8]
   \       0x20   0xE35C'0000        CMP      R12,#+0
   \       0x24   0x0A00'0002        BEQ      ??lcdc_set_alpha_0
   \       0x28   0xE593'C00C        LDR      R12,[R3, #+12]
   \       0x2C   0xE35C'0000        CMP      R12,#+0
   \       0x30   0x1A00'0000        BNE      ??lcdc_set_alpha_1
    708          		return;
   \                     ??lcdc_set_alpha_0:
   \       0x34   0xEA00'0011        B        ??lcdc_set_alpha_2
    709          
    710          	cfg = layer->reg_blender[0] & ~(LCDC_HEOCFG12_REVALPHA | LCDC_HEOCFG12_GA_Msk);
   \                     ??lcdc_set_alpha_1:
   \       0x38   0xE593'C00C        LDR      R12,[R3, #+12]
   \       0x3C   0xE59C'C000        LDR      R12,[R12, #+0]
   \       0x40   0xE3E0'E010        MVN      LR,#+16
   \       0x44   0xE3CE'E8FF        BIC      LR,LR,#0xFF0000
   \       0x48   0xE01E'C00C        ANDS     R12,LR,R12
    711          	if (reverse)
   \       0x4C   0xE1B0'E001        MOVS     LR,R1
   \       0x50   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x54   0xE35E'0000        CMP      LR,#+0
   \       0x58   0x0A00'0000        BEQ      ??lcdc_set_alpha_3
    712          		cfg |= LCDC_HEOCFG12_REVALPHA;
   \       0x5C   0xE39C'C010        ORRS     R12,R12,#0x10
    713          	layer->reg_blender[0] = cfg | LCDC_HEOCFG12_GA(alpha);
   \                     ??lcdc_set_alpha_3:
   \       0x60   0xE1B0'E002        MOVS     LR,R2
   \       0x64   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x68   0xE19C'E80E        ORRS     LR,R12,LR, LSL #+16
   \       0x6C   0xE593'400C        LDR      R4,[R3, #+12]
   \       0x70   0xE584'E000        STR      LR,[R4, #+0]
    714          	layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0x74   0xE3A0'E002        MOV      LR,#+2
   \       0x78   0xE593'4008        LDR      R4,[R3, #+8]
   \       0x7C   0xE584'E000        STR      LR,[R4, #+0]
    715          }
   \                     ??lcdc_set_alpha_2:
   \       0x80   0xE8BD'8010        POP      {R4,PC}          ;; return
    716          
    717          /**
    718           * Get alpha value
    719           * \param layer_id Layer ID (OVR1 or HEO).
    720           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    721          uint8_t lcdc_get_alpha(uint8_t layer_id)
    722          {
   \                     lcdc_get_alpha:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
    723          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R0,??DataTable25_1
   \        0x8   0xE1B0'2001        MOVS     R2,R1
   \        0xC   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x10   0xE3A0'3034        MOV      R3,#+52
   \       0x14   0xE012'0293        MULS     R2,R3,R2
   \       0x18   0xE090'2002        ADDS     R2,R0,R2
    724          
    725          	if (!layer->reg_blender)
   \       0x1C   0xE592'000C        LDR      R0,[R2, #+12]
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0001        BNE      ??lcdc_get_alpha_0
    726          		return 0;
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0xEA00'0003        B        ??lcdc_get_alpha_1
    727          
    728          	return (layer->reg_blender[0] & LCDC_HEOCFG12_GA_Msk) >> LCDC_HEOCFG12_GA_Pos;
   \                     ??lcdc_get_alpha_0:
   \       0x30   0xE592'000C        LDR      R0,[R2, #+12]
   \       0x34   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x38   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0x3C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \                     ??lcdc_get_alpha_1:
   \       0x40   0xE12F'FF1E        BX       LR               ;; return
    729          }
    730          
    731          /**
    732           * Enable and Set Color Keying
    733           * \param layer_id  Layer ID (OVR1 or HEO).
    734           * \param dest_keying Destination/Source keying.
    735           * \param color Color to matching.
    736           * \param mask  Color bit mask.
    737           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    738          void lcdc_set_color_keying(uint8_t layer_id, bool dest_keying,
    739          			   uint32_t color, uint32_t mask)
    740          {
   \                     lcdc_set_color_keying:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    741          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R12,??DataTable25_1
   \        0x8   0xE1B0'E000        MOVS     LR,R0
   \        0xC   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x10   0xE3A0'4034        MOV      R4,#+52
   \       0x14   0xE01E'0E94        MULS     LR,R4,LR
   \       0x18   0xE09C'C00E        ADDS     R12,R12,LR
    742          
    743          	if (!layer->reg_enable || !layer->reg_blender || !layer->reg_color)
   \       0x1C   0xE59C'E008        LDR      LR,[R12, #+8]
   \       0x20   0xE35E'0000        CMP      LR,#+0
   \       0x24   0x0A00'0005        BEQ      ??lcdc_set_color_keying_0
   \       0x28   0xE59C'E00C        LDR      LR,[R12, #+12]
   \       0x2C   0xE35E'0000        CMP      LR,#+0
   \       0x30   0x0A00'0002        BEQ      ??lcdc_set_color_keying_0
   \       0x34   0xE59C'E028        LDR      LR,[R12, #+40]
   \       0x38   0xE35E'0000        CMP      LR,#+0
   \       0x3C   0x1A00'0000        BNE      ??lcdc_set_color_keying_1
    744          		return;
   \                     ??lcdc_set_color_keying_0:
   \       0x40   0xEA00'001A        B        ??lcdc_set_color_keying_2
    745          
    746          	/* Dest/Source Keying */
    747          	if (dest_keying)
   \                     ??lcdc_set_color_keying_1:
   \       0x44   0xE1B0'E001        MOVS     LR,R1
   \       0x48   0xE21E'E0FF        ANDS     LR,LR,#0xFF      ;; Zero extend
   \       0x4C   0xE35E'0000        CMP      LR,#+0
   \       0x50   0x0A00'0005        BEQ      ??lcdc_set_color_keying_3
    748          		layer->reg_blender[0] |= LCDC_HEOCFG12_DSTKEY;
   \       0x54   0xE59C'E00C        LDR      LR,[R12, #+12]
   \       0x58   0xE59E'E000        LDR      LR,[LR, #+0]
   \       0x5C   0xE39E'EE40        ORRS     LR,LR,#0x400
   \       0x60   0xE59C'400C        LDR      R4,[R12, #+12]
   \       0x64   0xE584'E000        STR      LR,[R4, #+0]
   \       0x68   0xEA00'0004        B        ??lcdc_set_color_keying_4
    749          	else
    750          		layer->reg_blender[0] &= ~LCDC_HEOCFG12_DSTKEY;
   \                     ??lcdc_set_color_keying_3:
   \       0x6C   0xE59C'E00C        LDR      LR,[R12, #+12]
   \       0x70   0xE59E'E000        LDR      LR,[LR, #+0]
   \       0x74   0xE3DE'EE40        BICS     LR,LR,#0x400
   \       0x78   0xE59C'400C        LDR      R4,[R12, #+12]
   \       0x7C   0xE584'E000        STR      LR,[R4, #+0]
    751          
    752          	/* Activate Color Keying */
    753          	layer->reg_blender[0] |= LCDC_HEOCFG12_CRKEY;
   \                     ??lcdc_set_color_keying_4:
   \       0x80   0xE59C'E00C        LDR      LR,[R12, #+12]
   \       0x84   0xE59E'E000        LDR      LR,[LR, #+0]
   \       0x88   0xE39E'E001        ORRS     LR,LR,#0x1
   \       0x8C   0xE59C'400C        LDR      R4,[R12, #+12]
   \       0x90   0xE584'E000        STR      LR,[R4, #+0]
    754          
    755          	/* Program Color Keying */
    756          	layer->reg_color[1] = color;
   \       0x94   0xE59C'E028        LDR      LR,[R12, #+40]
   \       0x98   0xE58E'2004        STR      R2,[LR, #+4]
    757          	layer->reg_color[2] = mask;
   \       0x9C   0xE59C'E028        LDR      LR,[R12, #+40]
   \       0xA0   0xE58E'3008        STR      R3,[LR, #+8]
    758          
    759          	/* Update */
    760          	layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0xA4   0xE3A0'E002        MOV      LR,#+2
   \       0xA8   0xE59C'4008        LDR      R4,[R12, #+8]
   \       0xAC   0xE584'E000        STR      LR,[R4, #+0]
    761          }
   \                     ??lcdc_set_color_keying_2:
   \       0xB0   0xE8BD'8010        POP      {R4,PC}          ;; return
    762          
    763          /**
    764           * Disable Color Keying
    765           * \param layer_id  Layer ID (OVR1 or HEO).
    766           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    767          void lcdc_disable_color_keying(uint8_t layer_id)
    768          {
    769          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \                     lcdc_disable_color_keying:
   \        0x0   0x....'....        LDR      R1,??DataTable25_1
   \        0x4   0xE1B0'2000        MOVS     R2,R0
   \        0x8   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \        0xC   0xE3A0'3034        MOV      R3,#+52
   \       0x10   0xE012'0293        MULS     R2,R3,R2
   \       0x14   0xE091'1002        ADDS     R1,R1,R2
    770          
    771          	if (!layer->reg_enable || !layer->reg_blender || !layer->reg_color)
   \       0x18   0xE591'2008        LDR      R2,[R1, #+8]
   \       0x1C   0xE352'0000        CMP      R2,#+0
   \       0x20   0x0A00'0005        BEQ      ??lcdc_disable_color_keying_0
   \       0x24   0xE591'200C        LDR      R2,[R1, #+12]
   \       0x28   0xE352'0000        CMP      R2,#+0
   \       0x2C   0x0A00'0002        BEQ      ??lcdc_disable_color_keying_0
   \       0x30   0xE591'2028        LDR      R2,[R1, #+40]
   \       0x34   0xE352'0000        CMP      R2,#+0
   \       0x38   0x1A00'0000        BNE      ??lcdc_disable_color_keying_1
    772          		return;
   \                     ??lcdc_disable_color_keying_0:
   \       0x3C   0xEA00'000A        B        ??lcdc_disable_color_keying_2
    773          
    774          	layer->reg_blender[0] &= ~LCDC_HEOCFG12_CRKEY;
   \                     ??lcdc_disable_color_keying_1:
   \       0x40   0xE591'200C        LDR      R2,[R1, #+12]
   \       0x44   0xE592'2000        LDR      R2,[R2, #+0]
   \       0x48   0xE3D2'2001        BICS     R2,R2,#0x1
   \       0x4C   0xE591'300C        LDR      R3,[R1, #+12]
   \       0x50   0xE583'2000        STR      R2,[R3, #+0]
    775          	layer->reg_color[2] = 0;
   \       0x54   0xE3A0'2000        MOV      R2,#+0
   \       0x58   0xE591'3028        LDR      R3,[R1, #+40]
   \       0x5C   0xE583'2008        STR      R2,[R3, #+8]
    776          
    777          	/* Update */
    778          	layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN;
   \       0x60   0xE3A0'2002        MOV      R2,#+2
   \       0x64   0xE591'3008        LDR      R3,[R1, #+8]
   \       0x68   0xE583'2000        STR      R2,[R3, #+0]
    779          }
   \                     ??lcdc_disable_color_keying_2:
   \       0x6C   0xE12F'FF1E        BX       LR               ;; return
    780          
    781          /**
    782           * Set Color Lookup Table
    783           * \param layer_id   Layer ID (OVR1 or HEO).
    784           * \param pCLUT    Pointer to color lookup table.
    785           * \param bpp      Bits Per Pixel (1, 2, 4, 8).
    786           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    787          void lcdc_set_color_lut(uint8_t layer_id, uint32_t *clut, uint8_t bpp)
    788          {
   \                     lcdc_set_color_lut:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    789          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \       0x10   0x....'....        LDR      R0,??DataTable25_1
   \       0x14   0xE1B0'1004        MOVS     R1,R4
   \       0x18   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x1C   0xE3A0'2034        MOV      R2,#+52
   \       0x20   0xE011'0192        MULS     R1,R2,R1
   \       0x24   0xE090'7001        ADDS     R7,R0,R1
    790          	struct _layer_data *data = layer->data;
   \       0x28   0xE597'8000        LDR      R8,[R7, #+0]
    791          
    792          	if (!layer->reg_clut || !data)
   \       0x2C   0xE597'0030        LDR      R0,[R7, #+48]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0A00'0001        BEQ      ??lcdc_set_color_lut_1
   \       0x38   0xE358'0000        CMP      R8,#+0
   \       0x3C   0x1A00'0000        BNE      ??lcdc_set_color_lut_2
    793          		return;
   \                     ??lcdc_set_color_lut_1:
   \       0x40   0xEA00'0021        B        ??lcdc_set_color_lut_3
    794          
    795          	data->bpp = bpp;
   \                     ??lcdc_set_color_lut_2:
   \       0x44   0xE5C8'6010        STRB     R6,[R8, #+16]
    796          
    797          	/* Customize CLUT */
    798          	if (clut) {
   \       0x48   0xE355'0000        CMP      R5,#+0
   \       0x4C   0x0A00'000A        BEQ      ??lcdc_set_color_lut_4
    799          		uint32_t i;
    800          		for (i = 0; i < (1 << bpp); i++)
   \       0x50   0xE3A0'0000        MOV      R0,#+0
   \                     ??lcdc_set_color_lut_5:
   \       0x54   0xE3A0'1001        MOV      R1,#+1
   \       0x58   0xE150'0611        CMP      R0,R1, LSL R6
   \       0x5C   0x2A00'001A        BCS      ??lcdc_set_color_lut_6
    801          			layer->reg_clut[i] = clut[i];
   \       0x60   0xE1B0'1100        LSLS     R1,R0,#+2
   \       0x64   0xE795'1001        LDR      R1,[R5, +R1]
   \       0x68   0xE597'2030        LDR      R2,[R7, #+48]
   \       0x6C   0xE1B0'3100        LSLS     R3,R0,#+2
   \       0x70   0xE782'1003        STR      R1,[R2, +R3]
   \       0x74   0xE290'0001        ADDS     R0,R0,#+1
   \       0x78   0xEAFF'FFF5        B        ??lcdc_set_color_lut_5
    802          	}
    803          	/* Build CLUT */
    804          	else {
    805          		switch (bpp) {
   \                     ??lcdc_set_color_lut_4:
   \       0x7C   0xE1B0'0006        MOVS     R0,R6
   \       0x80   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x84   0xE240'0001        SUB      R0,R0,#+1
   \       0x88   0xE350'0007        CMP      R0,#+7
   \       0x8C   0x8A00'000E        BHI      ??lcdc_set_color_lut_6
   \       0x90   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x94   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??lcdc_set_color_lut_0:
   \       0x98   0x01 0x04          DC8      0x1,0x4,0xC,0x7

   \              0x0C 0x07
   \       0x9C   0x0C 0x0C          DC8      0xC,0xC,0xC,0xA

   \              0x0C 0x0A
    806          		case 1:
    807          			_build_color_lut1(layer->reg_clut);
   \                     ??lcdc_set_color_lut_7:
   \       0xA0   0xE597'0030        LDR      R0,[R7, #+48]
   \       0xA4   0x....'....        BL       _build_color_lut1
    808          			break;
   \       0xA8   0xEA00'0007        B        ??lcdc_set_color_lut_6
    809          		case 2:
    810          			_build_color_lut2(layer->reg_clut);
   \                     ??lcdc_set_color_lut_8:
   \       0xAC   0xE597'0030        LDR      R0,[R7, #+48]
   \       0xB0   0x....'....        BL       _build_color_lut2
    811          			break;
   \       0xB4   0xEA00'0004        B        ??lcdc_set_color_lut_6
    812          		case 4:
    813          			_build_color_lut4(layer->reg_clut);
   \                     ??lcdc_set_color_lut_9:
   \       0xB8   0xE597'0030        LDR      R0,[R7, #+48]
   \       0xBC   0x....'....        BL       _build_color_lut4
    814          			break;
   \       0xC0   0xEA00'0001        B        ??lcdc_set_color_lut_6
    815          		case 8:
    816          			_build_color_lut8(layer->reg_clut);
   \                     ??lcdc_set_color_lut_10:
   \       0xC4   0xE597'0030        LDR      R0,[R7, #+48]
   \       0xC8   0x....'....        BL       _build_color_lut8
    817          			break;
    818          		}
    819          	}
    820          }
   \                     ??lcdc_set_color_lut_6:
   \                     ??lcdc_set_color_lut_3:
   \       0xCC   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    821          //swap
    822          #if 1

   \                                 In section SOFTPACK, align 4, keep-with-next
    823          void * lcdc_put_image_rotated(uint8_t layer_id,
    824          			     void *buffer, uint8_t bpp,
    825          			     uint32_t x, uint32_t y,
    826          			     int32_t w, int32_t h,
    827          			     uint32_t img_w, uint32_t img_h, int16_t rotation)
    828          {
   \                     lcdc_put_image_rotated:
   \        0x0   0xE92D'47F0        PUSH     {R4-R10,LR}
   \        0x4   0xE1B0'7000        MOVS     R7,R0
   \        0x8   0xE1B0'4001        MOVS     R4,R1
   \        0xC   0xE1B0'5002        MOVS     R5,R2
   \       0x10   0xE1B0'6003        MOVS     R6,R3
    829          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \       0x14   0x....'....        LDR      R0,??DataTable25_1
   \       0x18   0xE1B0'1007        MOVS     R1,R7
   \       0x1C   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x20   0xE3A0'2034        MOV      R2,#+52
   \       0x24   0xE011'0192        MULS     R1,R2,R1
   \       0x28   0xE090'8001        ADDS     R8,R0,R1
    830          	struct _layer_data *data = layer->data;
   \       0x2C   0xE598'9000        LDR      R9,[R8, #+0]
    831          
    832          	void *old_buffer = data->buffer;
   \       0x30   0xE599'A00C        LDR      R10,[R9, #+12]
    833          	//layer->reg_cfg[1] = LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED;
    834                  //layer->reg_cfg[1] = LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888;
    835                  data->buffer = buffer;
   \       0x34   0xE589'400C        STR      R4,[R9, #+12]
    836          	/* No rotation optimization */
    837          //	layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
    838          //	layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0);	
    839          	
    840          	_set_dma_desc(buffer, data->dma_desc, layer->reg_dma_head);
   \       0x38   0xE598'2010        LDR      R2,[R8, #+16]
   \       0x3C   0xE599'1000        LDR      R1,[R9, #+0]
   \       0x40   0xE1B0'0004        MOVS     R0,R4
   \       0x44   0x....'....        BL       _set_dma_desc
    841          	
    842          	
    843          	layer->reg_blender[0] |= LCDC_BASECFG4_DMA;
   \       0x48   0xE598'000C        LDR      R0,[R8, #+12]
   \       0x4C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x50   0xE390'0F40        ORRS     R0,R0,#0x100
   \       0x54   0xE598'100C        LDR      R1,[R8, #+12]
   \       0x58   0xE581'0000        STR      R0,[R1, #+0]
    844          	
    845          	/* Enable & Update */
    846          	/* 5. Enable the relevant channel by writing one to the CHEN field of the
    847          	   CHXCHER register. */
    848          	layer->reg_enable[0] |= LCDC_BASECHER_UPDATEEN | LCDC_BASECHER_CHEN;
   \       0x5C   0xE598'0008        LDR      R0,[R8, #+8]
   \       0x60   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x64   0xE390'0003        ORRS     R0,R0,#0x3
   \       0x68   0xE598'1008        LDR      R1,[R8, #+8]
   \       0x6C   0xE581'0000        STR      R0,[R1, #+0]
    849                  //layer->reg_enable[0] =3;
    850          	/* 6. An interrupt may be raised if unmasked when the descriptor has been
    851          	   loaded.  */
    852          
    853          	return old_buffer;
   \       0x70   0xE1B0'000A        MOVS     R0,R10
   \       0x74   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    854          }
    855          #endif 
    856          #if 0
    857          /**
    858           * Display an image on specified layer.
    859           * (Image scan origion: Left -> Right, Top -> Bottom.)
    860           * \note w & h should be the rotated result.
    861           * \note for LCDC_BASE: x, y don't care. w always > 0.
    862           * \note for LCDC_HEO:imgW & imgH is used.
    863           * \param layer_id  Layer ID (OVR1 or HEO).
    864           * \param buffer Pointer to image data.
    865           * \param bpp     Bits Per Pixel.
    866           *                - 16: TRGB 1555
    867           *                - 24:  RGB  888  packed
    868           *                - 32: ARGB 8888
    869           * \param x       X position.
    870           * \param y       Y position.
    871           * \param w       Width  (<0 means Right  -> Left data).
    872           * \param h       Height (<0 means Bottom -> Top data).
    873           * \param imgW    Source image width.
    874           * \param imgH    Source image height.
    875           * \param wRotate Rotation (clockwise, 0, 90, 180, 270 accepted).
    876           */
    877          void * lcdc_put_image_rotated(uint8_t layer_id,
    878          			     void *buffer, uint8_t bpp,
    879          			     uint32_t x, uint32_t y,
    880          			     int32_t w, int32_t h,
    881          			     uint32_t img_w, uint32_t img_h, int16_t rotation)
    882          {
    883          	const struct _layer_info *layer = &lcdc_layers[layer_id];
    884          	struct _layer_data *data = layer->data;
    885          
    886          	uint8_t bottom_up = (h < 0);
    887          	uint8_t right_left = (w < 0);
    888          	uint32_t padding = 0;
    889          	int32_t src_w, src_h;
    890          	uint32_t bits_per_row, bytes_per_row;
    891          	uint32_t bytes_per_pixel = bpp >> 3;
    892          
    893          	void *old_buffer = data->buffer;
    894          
    895          	if (!layer->reg_cfg)
    896          		return old_buffer;
    897          
    898          	//printf("Show %x @ %d: (%d,%d)+(%d,%d) img %d x %d * %d\n\r", buffer, layer_id, x, y, w, h, img_w, img_h, bpp);
    899          
    900          	switch (bpp) {
    901          	/*  RGB 565 */
    902          	case 16:
    903          #ifdef LCDC_HEOCFG1_YUVEN
    904          		if ((layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) == LCDC_HEOCFG1_YUVEN) {
    905          			layer->reg_cfg[1] = layer->reg_cfg[1] & (~LCDC_HEOCFG1_YUVMODE_Msk) | LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE0;
    906          		} else
    907          #endif
    908          		{
    909          			layer->reg_cfg[1] = LCDC_HEOCFG1_RGBMODE_16BPP_RGB_565;
    910          		}
    911          		break;
    912          	/*  RGB  888 packed */
    913          	case 24:
    914          		layer->reg_cfg[1] = LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED;
    915          		break;
    916          	/* ARGB 8888 */
    917          	case 32:
    918          		layer->reg_cfg[1] = LCDC_HEOCFG1_RGBMODE_32BPP_ARGB_8888;
    919          		break;
    920          	default:
    921          		return old_buffer;
    922          	}
    923          
    924          	/* Windows position & size check */
    925          	if (h < 0)
    926          		h = -h;
    927          	if (w < 0)
    928          		w = -w;
    929          	if (x + w > lcdc_config.width) {
    930          		//printf("! w %d -> %d\n\r", w, lcdc_config.width-x);
    931          		w = lcdc_config.width - x;
    932          	}
    933          	if (y + h > lcdc_config.height) {
    934          		//printf("! h %d -> %d\n\r", h, lcdc_config.height-y);
    935          		h = lcdc_config.height - y;
    936          	}
    937          	if (w == 0)
    938          		w++;
    939          	if (h == 0)
    940          		h++;
    941          	if (img_w == 0)
    942          		img_w++;
    943          	if (img_h == 0)
    944          		img_h++;
    945          
    946          	/* Only 0,(-)90,(-)180,(-)270 accepted */
    947          	switch (rotation) {
    948          	case 0:
    949          	case 90:
    950          	case 180:
    951          	case 270:
    952          		break;
    953          	case -90:
    954          	case -180:
    955          	case -270:
    956          		rotation += 360;
    957          		break;
    958          	default:
    959          		return NULL;
    960          	}
    961          
    962          	/* Setup display buffer & window */
    963          	if (buffer)
    964          		data->buffer = buffer;
    965          	else
    966          		buffer = data->buffer;
    967          
    968          	/* Set display buffer & mode */
    969          	bits_per_row = img_w * bpp;
    970          	bytes_per_row = bits_per_row >> 3;
    971          	if (bits_per_row & 0x7)
    972          		bytes_per_row++;
    973          	if (bytes_per_row & 0x3)
    974          		padding = 4 - (bytes_per_row & 0x3);
    975          
    976          	/* No X mirror supported layer, no Right->Left scan */
    977          	if (!layer->stride_supported)
    978          		right_left = 0;
    979          
    980          	/* --------- Mirror & then rotate --------- */
    981          	/* Normal direction: Left,Top -> Right,Down */
    982          	if ((!right_left && !bottom_up && rotation == 0)
    983          	    || (right_left && bottom_up && rotation == 180)) {
    984          #ifdef LCDC_HEOCFG1_YUVEN
    985          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
    986          			/* No rotation optimization */
    987          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
    988          			layer->reg_cfg[1] &= ~LCDC_HEOCFG1_YUV422ROT;
    989          			/* X0 ++ */
    990          			if (layer->stride_supported)
    991          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0);
    992          			/* Y0 ++ */
    993          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0);
    994          			/* Pointer to Left,Top (x0,y0) */
    995          		} else
    996          #endif
    997          		{
    998          			/* No rotation optimization */
    999          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1000          			/* X0 ++ */
   1001          			if (layer->stride_supported)
   1002          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0);
   1003          			/* Y0 ++ */
   1004          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(padding);
   1005          			/* Pointer to Left,Top (x0,y0) */
   1006          		}
   1007          	}
   1008          	/* X mirror: Right,Top -> Left,Down */
   1009          	else if ((right_left && !bottom_up && rotation == 0)
   1010          		 || (!right_left && bottom_up && rotation == 180)) {
   1011          #ifdef LCDC_HEOCFG1_YUVEN
   1012          		if ((layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) == LCDC_HEOCFG1_YUVEN) {
   1013          			/* No rotation optimization */
   1014          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1015          			layer->reg_cfg[1] &= ~LCDC_HEOCFG1_YUV422ROT;
   1016          			/* X0 ++ */
   1017          			if (layer->stride_supported)
   1018          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - 2 * bytes_per_pixel - 4);
   1019          			/* Y0 ++ */
   1020          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(bytes_per_row * 2 - 2 * bytes_per_pixel - 4);
   1021          			/* Pointer to Right,Top (x1,y0) */
   1022          			buffer = (void *)((uint32_t) buffer + bytes_per_row - 4);
   1023          		} else
   1024          #endif
   1025          		{
   1026          			/* No rotation optimization */
   1027          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1028          			/* X1 -- */
   1029          			if (layer->stride_supported)
   1030          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - 2 * bytes_per_pixel);
   1031          			/* Y0 ++ */
   1032          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(bytes_per_row * 2 + padding - 2 * bytes_per_pixel);
   1033          			/* Pointer to Right,Top (x1,y0) */
   1034          			buffer = (void *)((uint32_t) buffer + bytes_per_pixel * (img_w - 1));
   1035          		}
   1036          	}
   1037          	/* Y mirror: Left,Down -> Right,Top */
   1038          	else if ((!right_left && bottom_up && rotation == 0)
   1039          		 || (right_left && !bottom_up && rotation == 180)) {
   1040          #ifdef LCDC_HEOCFG1_YUVEN
   1041          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1042          			/* No rotation optimization */
   1043          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1044          			layer->reg_cfg[1] &= ~LCDC_HEOCFG1_YUV422ROT;
   1045          			/* X0 ++ */
   1046          			if (layer->stride_supported)
   1047          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0);
   1048          			/* Y0 ++ */
   1049          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - bytes_per_row * 2);
   1050          			/* Pointer to Right,Top (x1,y0) */
   1051          			buffer = (void *)((uint32_t) buffer + bytes_per_row * (img_h - 1));
   1052          		} else
   1053          #endif
   1054          		{
   1055          			/* No rotation optimization */
   1056          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1057          			/* X0 ++ */
   1058          			if (layer->stride_supported)
   1059          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0);
   1060          			/* Y1 -- */
   1061          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - (bytes_per_row * 2 + padding));
   1062          			/* Pointer to Left,Down (x0,y1) */
   1063          			buffer = (void *)((uint32_t) buffer + (bytes_per_row + padding) * (img_h - 1));
   1064          		}
   1065          	}
   1066          	/* X,Y mirror: Right,Top -> Left,Down */
   1067          	else if ((right_left && bottom_up && rotation == 0)
   1068          		 || (!right_left && !bottom_up && rotation == 180)) {
   1069          #ifdef LCDC_HEOCFG1_YUVEN
   1070          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1071          			/* No rotation optimization */
   1072          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1073          			layer->reg_cfg[1] &= ~LCDC_HEOCFG1_YUV422ROT;
   1074          			/* X0 ++ */
   1075          			if (layer->stride_supported)
   1076          				  layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0);
   1077          			/* Y0 ++ */
   1078          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - bytes_per_row * 2);
   1079          			/* Pointer to Right,Top (x1,y0) */
   1080          			buffer = (void *)((uint32_t) buffer + bytes_per_row * (img_h-1));
   1081          		} else
   1082          #endif
   1083          		{
   1084          			/* No rotation optimization */
   1085          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1086          			/* X1 -- */
   1087          			if (layer->stride_supported)
   1088          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - 2 * bytes_per_pixel);
   1089          			/* Y1 -- */
   1090          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - (bytes_per_pixel * 2 + padding));
   1091          			/* Pointer to Left,Down (x1,y1) */
   1092          			buffer = (void *)((uint32_t) buffer + (bytes_per_row + padding) * (img_h - 1) + (bytes_per_pixel) * (img_w - 1));
   1093          		}
   1094          	}
   1095          	/* Rotate  90: Down,Left -> Top,Right (with w,h swap) */
   1096          	else if ((!right_left && !bottom_up && rotation == 90)
   1097          		 || (right_left && bottom_up && rotation == 270)) {
   1098          #ifdef LCDC_HEOCFG1_YUVEN
   1099          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1100          			/* No rotation optimization */
   1101          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1102          			layer->reg_cfg[1] |= LCDC_HEOCFG1_YUV422ROT;
   1103          			/* X0 ++ */
   1104          			if (layer->stride_supported)
   1105          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - bytes_per_row - 4);
   1106          			/* Y0 ++ */
   1107          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(bytes_per_row * (img_h-1));
   1108          			/* Pointer to Right,Top (x1,y0) */
   1109          			buffer = (void *)((uint32_t) buffer + bytes_per_row * (img_h - 1));
   1110          		} else
   1111          #endif
   1112          		{
   1113          			/* No rotation optimization */
   1114          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1115          			/* Y -- as pixels in row */
   1116          			if (layer->stride_supported)
   1117          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - (bytes_per_pixel + bytes_per_row + padding));
   1118          			/* X ++ as rows */
   1119          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE((bytes_per_row + padding) * (img_h - 1));
   1120          			/* Pointer to Bottom,Left */
   1121          			buffer = (void *)((uint32_t) buffer + (bytes_per_row + padding) * (img_h - 1));
   1122          		}
   1123          	}
   1124          	/* Rotate 270: Top,Right -> Down,Left (with w,h swap) */
   1125          	else if ((!right_left && !bottom_up && rotation == 270)
   1126          		 || (right_left && bottom_up && rotation == 90)) {
   1127          #ifdef LCDC_HEOCFG1_YUVEN
   1128          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1129          			/* No rotation optimization */
   1130          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1131          			layer->reg_cfg[1] |= LCDC_HEOCFG1_YUV422ROT;
   1132          			/* X0 ++ */
   1133          			if (layer->stride_supported)
   1134          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(bytes_per_row - 4);
   1135          			/* Y0 ++ */
   1136          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE((bytes_per_row * (1 - img_h) - 4 - 4));
   1137          			/* Pointer to Right,Top (x1,y0) */
   1138          			buffer = (void *)((uint32_t) buffer + bytes_per_row - 4);
   1139          		} else
   1140          #endif
   1141          		{
   1142          			/* No rotation optimization */
   1143          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1144          			/* Y ++ as pixels in row */
   1145          			if (layer->stride_supported)
   1146          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(bytes_per_row + padding - bytes_per_pixel);
   1147          			/* X -- as rows */
   1148          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - 2 * bytes_per_pixel - (bytes_per_row + padding) * (img_h - 1));
   1149          			/* Pointer to top right */
   1150          			buffer = (void *)((uint32_t) buffer + bytes_per_pixel * (img_w - 1));
   1151          		}
   1152          	}
   1153          	/* Mirror X then Rotate 90: Down,Right -> Top,Left */
   1154          	else if ((right_left && !bottom_up && rotation == 90)
   1155          		 || (!right_left && bottom_up && rotation == 270)) {
   1156          #ifdef LCDC_HEOCFG1_YUVEN
   1157          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1158          			/* No rotation optimization */
   1159          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1160          			layer->reg_cfg[1] |= LCDC_HEOCFG1_YUV422ROT;
   1161          			/* X0 ++ */
   1162          			if (layer->stride_supported)
   1163          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - bytes_per_row - 4);
   1164          			/* Y0 ++ */
   1165          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(bytes_per_row * (img_h - 1) - 2 * bytes_per_pixel - 4);
   1166          			/* Pointer to Right,Top (x1,y0) */
   1167          			buffer = (void *)((uint32_t) buffer + bytes_per_row * img_h - 4);
   1168          		} else
   1169          #endif
   1170          		{
   1171          			/* No rotation optimization */
   1172          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1173          			/* Y -- as pixels in row */
   1174          			if (layer->stride_supported)
   1175          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(0 - (bytes_per_pixel + bytes_per_row + padding));
   1176          			/* X -- as rows */
   1177          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - 2 * bytes_per_pixel + (bytes_per_row + padding) * (img_h - 1));
   1178          			/* Pointer to down right (x1,y1) */
   1179          			buffer = (void *)((uint32_t) buffer + (bytes_per_row + padding) * (img_h - 1) + (bytes_per_pixel) * (img_w - 1));
   1180          		}
   1181          	}
   1182          	/* Mirror Y then Rotate 90: Top,Left -> Down,Right */
   1183          	else if ((!right_left && bottom_up && rotation == 90)
   1184          		 || (right_left && !bottom_up && rotation == 270)) {
   1185          #ifdef LCDC_HEOCFG1_YUVEN
   1186          		if(layer->reg_cfg[1] & LCDC_HEOCFG1_YUVEN) {
   1187          			/* No rotation optimization */
   1188          			layer->reg_cfg[0] = LCDC_HEOCFG0_BLEN(0x2) | LCDC_HEOCFG0_ROTDIS;
   1189          			layer->reg_cfg[1] |= LCDC_HEOCFG1_YUV422ROT;
   1190          			/* X0 ++ */
   1191          			if (layer->stride_supported)
   1192          					layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(bytes_per_row - 4);
   1193          			/* Y0 ++ */
   1194          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - (bytes_per_row * (img_h - 1)));
   1195          			/* Pointer to Right,Top (x1,y0) */
   1196          		} else
   1197          #endif
   1198          		{
   1199          			/* No rotation optimization */
   1200          			layer->reg_cfg[0] |= LCDC_HEOCFG0_ROTDIS;
   1201          			/* Y ++ as pixels in row */
   1202          			if (layer->stride_supported)
   1203          				layer->reg_stride[1] = LCDC_HEOCFG6_PSTRIDE(bytes_per_row + padding - bytes_per_pixel);
   1204          			/* X ++ as rows */
   1205          			layer->reg_stride[0] = LCDC_HEOCFG5_XSTRIDE(0 - (bytes_per_row + padding) * (img_h - 1));
   1206          			/* Pointer to top left (x0,y0) */
   1207          		}
   1208          	}
   1209          
   1210          	/** DMA is running, just add new descriptor to queue */
   1211          	if (layer->reg_blender[0] & LCDC_HEOCFG12_DMA) {
   1212          		data->dma_desc->addr = (uint32_t)buffer;
   1213          		data->dma_desc->ctrl = LCDC_HEOCTRL_DFETCH;
   1214          		data->dma_desc->next = (uint32_t)data->dma_desc;
   1215          		cache_clean_region(data->dma_desc, sizeof(*(data->dma_desc)));
   1216          		layer->reg_dma_head[0] = (uint32_t)data->dma_desc;
   1217          		layer->reg_enable[0] = LCDC_HEOCHER_A2QEN;
   1218          	} else {
   1219          		/* 2. Write the channel descriptor (DSCR) structure in the system memory by
   1220          		   writing DSCR.CHXADDR Frame base address, DSCR.CHXCTRL channel control
   1221          		   and DSCR.CHXNEXT next descriptor location.
   1222          		   3. If more than one descriptor is expected, the DFETCH field of
   1223          		   DSCR.CHXCTRL is set to one to enable the descriptor fetch operation.
   1224          		   4. Write the DSCR.CHXNEXT register with the address location of the
   1225          		   descriptor structure and set DFETCH field of the DSCR.CHXCTRL register
   1226          		   to one. */
   1227          		_set_dma_desc(buffer, data->dma_desc, layer->reg_dma_head);
   1228          	}
   1229          
   1230          	/* Set window & position */
   1231          	if (layer->reg_win) {
   1232          		layer->reg_win[0] = LCDC_HEOCFG2_XPOS(x) | LCDC_HEOCFG2_YPOS(y);
   1233          		layer->reg_win[1] = LCDC_HEOCFG3_XSIZE(w - 1) | LCDC_HEOCFG3_YSIZE(h - 1);
   1234          	}
   1235          
   1236          	/* Scaling setup */
   1237          	if (layer->reg_win && layer->reg_scale) {
   1238          		/* Image size only used in scaling */
   1239          		/* Scaling target */
   1240          		if (rotation == 90 || rotation == 270) {
   1241          			src_w = img_h;
   1242          			src_h = img_w;
   1243          		} else {
   1244          			src_w = img_w;
   1245          			src_h = img_h;
   1246          		}
   1247          		layer->reg_win[2] = LCDC_HEOCFG4_XMEMSIZE(src_w - 1)
   1248          			| LCDC_HEOCFG4_YMEMSIZE(src_h - 1);
   1249          		/* Scaled */
   1250          		if (w != src_w || h != src_h) {
   1251          			uint16_t scale_w, scale_h;
   1252          			_compute_scaling_factors(layer, &scale_w, &scale_h);
   1253          			layer->reg_scale[0] = LCDC_HEOCFG13_YFACTOR(scale_h)
   1254          				| LCDC_HEOCFG13_XFACTOR(scale_w)
   1255          				| LCDC_HEOCFG13_SCALEN;
   1256          		}
   1257          		/* Disable scaling */
   1258          		else {
   1259          			layer->reg_scale[0] = 0;
   1260          		}
   1261          	}
   1262          	/* Enable DMA */
   1263          	if (buffer) {
   1264          		//layer->reg_blender[0] |= LCDC_HEOCFG12_DMA | LCDC_HEOCFG12_OVR;
   1265                          layer->reg_blender[0] |= LCDC_BASECFG4_DMA;
   1266          	}
   1267          	/* Enable & Update */
   1268          	/* 5. Enable the relevant channel by writing one to the CHEN field of the
   1269          	   CHXCHER register. */
   1270          	layer->reg_enable[0] = LCDC_HEOCHER_UPDATEEN | LCDC_HEOCHER_CHEN;
   1271          
   1272          	/* 6. An interrupt may be raised if unmasked when the descriptor has been
   1273          	   loaded.  */
   1274          
   1275          	return old_buffer;
   1276          }
   1277          
   1278          
   1279          #endif
   1280          /**
   1281           * Display an image on specified layer.
   1282           * (Image scan: Left -> Right, Top -> Bottom.)
   1283           * \param layer_id  Layer ID (OVR1 or HEO).
   1284           * \param buffer Pointer to image data.
   1285           * \param bpp     Bits Per Pixel.
   1286           *                - 16: TRGB 1555
   1287           *                - 24:  RGB  888  packed
   1288           *                - 32: ARGB 8888
   1289           * \param x       X position.
   1290           * \param y       Y position.
   1291           * \param w       Width  (<0 means Right  -> Left data).
   1292           * \param h       Height (<0 means Bottom -> Top data).
   1293           * \param imgW    Source image width.
   1294           * \param imgH    Source image height.
   1295           * \return Pointer to old display image data.
   1296           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1297          void * lcdc_put_image_scaled(uint8_t layer_id, void *buffer, uint8_t bpp,
   1298          		uint32_t x, uint32_t y, int32_t w, int32_t h,
   1299          		uint32_t img_w, uint32_t img_h)
   1300          {
   \                     lcdc_put_image_scaled:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
   1301          	return lcdc_put_image_rotated(layer_id, buffer, bpp, x, y, w, h, img_w,
   1302          			img_h, 0);
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0xE58D'0014        STR      R0,[SP, #+20]
   \       0x20   0xE59D'0040        LDR      R0,[SP, #+64]
   \       0x24   0xE58D'0010        STR      R0,[SP, #+16]
   \       0x28   0xE59D'003C        LDR      R0,[SP, #+60]
   \       0x2C   0xE58D'000C        STR      R0,[SP, #+12]
   \       0x30   0xE59D'0038        LDR      R0,[SP, #+56]
   \       0x34   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x38   0xE59D'0034        LDR      R0,[SP, #+52]
   \       0x3C   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x40   0xE59D'0030        LDR      R0,[SP, #+48]
   \       0x44   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x48   0xE1B0'3007        MOVS     R3,R7
   \       0x4C   0xE1B0'2006        MOVS     R2,R6
   \       0x50   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x54   0xE1B0'1005        MOVS     R1,R5
   \       0x58   0xE1B0'0004        MOVS     R0,R4
   \       0x5C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x60   0x....'....        BL       lcdc_put_image_rotated
   \       0x64   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x68   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return
   1303          }
   1304          
   1305          /**
   1306           * Display an image on specified layer.
   1307           * (Image scan: Left -> Right, Top -> Bottom.)
   1308           * \param layer_id  Layer ID (OVR1 or HEO).
   1309           * \param buffer Pointer to image data.
   1310           * \param bpp     Bits Per Pixel.
   1311           *                - 16: TRGB 1555
   1312           *                - 24:  RGB  888  packed
   1313           *                - 32: ARGB 8888
   1314           * \param x       X position.
   1315           * \param y       Y position.
   1316           * \param w       Width
   1317           * \param h       Height (<0 means Bottom -> Top data).
   1318           * \return Pointer to old display image data.
   1319           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1320          void * lcdc_put_image(uint8_t layer_id, void *buffer, uint8_t bpp,
   1321          		uint32_t x, uint32_t y, int32_t w, int32_t h)
   1322          {
   \                     lcdc_put_image:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
   \       0x18   0xE59D'803C        LDR      R8,[SP, #+60]
   \       0x1C   0xE59D'9040        LDR      R9,[SP, #+64]
   1323          	return lcdc_put_image_rotated(layer_id, buffer, bpp, x, y, w, h, w,
   1324          			h < 0 ? -h : h, 0);
   \       0x20   0xE359'0000        CMP      R9,#+0
   \       0x24   0x5A00'0001        BPL      ??lcdc_put_image_0
   \       0x28   0xE279'0000        RSBS     R0,R9,#+0
   \       0x2C   0xEA00'0000        B        ??lcdc_put_image_1
   \                     ??lcdc_put_image_0:
   \       0x30   0xE1B0'0009        MOVS     R0,R9
   \                     ??lcdc_put_image_1:
   \       0x34   0xE3A0'1000        MOV      R1,#+0
   \       0x38   0xE58D'1014        STR      R1,[SP, #+20]
   \       0x3C   0xE58D'0010        STR      R0,[SP, #+16]
   \       0x40   0xE58D'800C        STR      R8,[SP, #+12]
   \       0x44   0xE58D'9008        STR      R9,[SP, #+8]
   \       0x48   0xE58D'8004        STR      R8,[SP, #+4]
   \       0x4C   0xE59D'0038        LDR      R0,[SP, #+56]
   \       0x50   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x54   0xE1B0'3007        MOVS     R3,R7
   \       0x58   0xE1B0'2006        MOVS     R2,R6
   \       0x5C   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x60   0xE1B0'1005        MOVS     R1,R5
   \       0x64   0xE1B0'0004        MOVS     R0,R4
   \       0x68   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x6C   0x....'....        BL       lcdc_put_image_rotated
   \       0x70   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x74   0xE8BD'83F0        POP      {R4-R9,PC}       ;; return
   1325          }
   1326          
   1327          /**
   1328           * Start display on base layer
   1329           * \param buffer   Pointer to image data.
   1330           * \param bpp       Bits Per Pixel.
   1331           * \param bBottomUp Scan from bottom to top.
   1332           * \return Pointer to old display image data.
   1333           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1334          void * lcdc_show_base(void *buffer, uint8_t bpp, bool bottom_up)
   1335          {
   \                     lcdc_show_base:
   \        0x0   0xE92D'407F        PUSH     {R0-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   1336            //int32_t width = 80; int32_t height=48;
   1337            //return lcdc_put_image(LCDC_BASE, buffer, bpp, 0, 0, width,
   1338          			//height);
   1339          	return lcdc_put_image(LCDC_BASE, buffer, bpp, 0, 0, lcdc_config.width,
   1340          			bottom_up ? -lcdc_config.height : lcdc_config.height);
   \       0x10   0xE1B0'0006        MOVS     R0,R6
   \       0x14   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0003        BEQ      ??lcdc_show_base_0
   \       0x20   0x....'....        LDR      R0,??DataTable30
   \       0x24   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \       0x28   0xE270'0000        RSBS     R0,R0,#+0
   \       0x2C   0xEA00'0001        B        ??lcdc_show_base_1
   \                     ??lcdc_show_base_0:
   \       0x30   0x....'....        LDR      R0,??DataTable30
   \       0x34   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \                     ??lcdc_show_base_1:
   \       0x38   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x3C   0x....'....        LDR      R0,??DataTable30
   \       0x40   0xE1D0'00B0        LDRH     R0,[R0, #+0]
   \       0x44   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x48   0xE3A0'0000        MOV      R0,#+0
   \       0x4C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x50   0xE3A0'3000        MOV      R3,#+0
   \       0x54   0xE1B0'2005        MOVS     R2,R5
   \       0x58   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x5C   0xE1B0'1004        MOVS     R1,R4
   \       0x60   0xE3A0'0001        MOV      R0,#+1
   \       0x64   0x....'....        BL       lcdc_put_image
   \       0x68   0xE28D'D010        ADD      SP,SP,#+16
   \       0x6C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1341          }
   1342          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1343          void lcdc_base_auto_loop(void *buffer, uint32_t size, uint32_t slides)
   1344          {
   \                     lcdc_base_auto_loop:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   1345          	uint32_t i;
   1346          	ALIGNED(16) static struct _lcdc_dma_desc dma_desc[40];
   1347          	if (ARRAY_SIZE(dma_desc) < slides * 10) {
   \       0x10   0xE086'0106        ADD      R0,R6,R6, LSL #+2
   \       0x14   0xE1B0'0080        LSLS     R0,R0,#+1
   \       0x18   0xE350'0029        CMP      R0,#+41
   \       0x1C   0x3A00'0006        BCC      ??lcdc_base_auto_loop_0
   1348          		trace_warning("The DMA link size is not suitable for showing the loop effects on the base layer!");
   \       0x20   0x....'....        LDR      R0,??DataTable29
   \       0x24   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x28   0xE350'0003        CMP      R0,#+3
   \       0x2C   0x3A00'0001        BCC      ??lcdc_base_auto_loop_1
   \       0x30   0x....'....        LDR      R0,??DataTable30_1
   \       0x34   0x....'....        BL       printf
   1349          		return;
   \                     ??lcdc_base_auto_loop_1:
   \       0x38   0xEA00'0026        B        ??lcdc_base_auto_loop_2
   1350          	}
   1351          	for (i = 0; i < ARRAY_SIZE(dma_desc); i++) {
   \                     ??lcdc_base_auto_loop_0:
   \       0x3C   0xE3A0'7000        MOV      R7,#+0
   \                     ??lcdc_base_auto_loop_3:
   \       0x40   0xE357'0028        CMP      R7,#+40
   \       0x44   0x2A00'0016        BCS      ??lcdc_base_auto_loop_4
   1352          		dma_desc[i].addr = (uint32_t)buffer + (i / 10) * (size / slides);
   \       0x48   0x....'....        LDR      R8,??DataTable30_2
   \       0x4C   0xE1B0'0007        MOVS     R0,R7
   \       0x50   0xE3A0'100A        MOV      R1,#+10
   \       0x54   0x....'....        BL       __aeabi_uidiv
   \       0x58   0xE1B0'9000        MOVS     R9,R0
   \       0x5C   0xE1B0'0005        MOVS     R0,R5
   \       0x60   0xE1B0'1006        MOVS     R1,R6
   \       0x64   0x....'....        BL       __aeabi_uidiv
   \       0x68   0xE021'4990        MLA      R1,R0,R9,R4
   \       0x6C   0xE1B0'0207        LSLS     R0,R7,#+4
   \       0x70   0xE788'1000        STR      R1,[R8, +R0]
   1353          		dma_desc[i].ctrl = LCDC_HEOCTRL_DFETCH;
   \       0x74   0xE3A0'0001        MOV      R0,#+1
   \       0x78   0xE1B0'1207        LSLS     R1,R7,#+4
   \       0x7C   0xE098'1001        ADDS     R1,R8,R1
   \       0x80   0xE581'0004        STR      R0,[R1, #+4]
   1354          		dma_desc[i].next = (uint32_t)&dma_desc[i+1];
   \       0x84   0xE1B0'0207        LSLS     R0,R7,#+4
   \       0x88   0xE098'0000        ADDS     R0,R8,R0
   \       0x8C   0xE290'0010        ADDS     R0,R0,#+16
   \       0x90   0xE1B0'1207        LSLS     R1,R7,#+4
   \       0x94   0xE098'1001        ADDS     R1,R8,R1
   \       0x98   0xE581'0008        STR      R0,[R1, #+8]
   1355          	}
   \       0x9C   0xE297'7001        ADDS     R7,R7,#+1
   \       0xA0   0xEAFF'FFE6        B        ??lcdc_base_auto_loop_3
   1356          	dma_desc[i-1].next = (uint32_t)&dma_desc[0];
   \                     ??lcdc_base_auto_loop_4:
   \       0xA4   0x....'....        LDR      R8,??DataTable30_2
   \       0xA8   0xE1B0'0207        LSLS     R0,R7,#+4
   \       0xAC   0xE098'0000        ADDS     R0,R8,R0
   \       0xB0   0xE500'8008        STR      R8,[R0, #-8]
   1357          	cache_clean_region(dma_desc, sizeof(dma_desc));
   \       0xB4   0xE3A0'1FA0        MOV      R1,#+640
   \       0xB8   0xE1B0'0008        MOVS     R0,R8
   \       0xBC   0x....'....        BL       cache_clean_region
   1358          	lcdc_layers[LCDC_BASE].reg_dma_head[0] = (uint32_t)dma_desc;
   \       0xC0   0x....'....        LDR      R0,??DataTable30_3
   \       0xC4   0xE590'1044        LDR      R1,[R0, #+68]
   \       0xC8   0xE581'8000        STR      R8,[R1, #+0]
   1359          	lcdc_layers[LCDC_BASE].reg_enable[0] = LCDC_HEOCHER_A2QEN;
   \       0xCC   0xE3A0'1004        MOV      R1,#+4
   \       0xD0   0xE590'003C        LDR      R0,[R0, #+60]
   \       0xD4   0xE580'1000        STR      R1,[R0, #+0]
   1360          }
   \                     ??lcdc_base_auto_loop_2:
   \       0xD8   0xE8BD'83F1        POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 16
   \                     `lcdc_base_auto_loop::dma_desc`:
   \        0x0                      DS8 640
   1361          
   1362          /**
   1363           * Stop display on base layer
   1364           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1365          void lcdc_stop_base(void)
   1366          {
   \                     lcdc_stop_base:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1367          	if (!(LCDC->LCDC_BASECHSR & LCDC_BASECHSR_CHSR))
   \        0x4   0x....'....        LDR      R4,??DataTable30_4  ;; 0xf8038068
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0xE310'0001        TST      R0,#0x1
   \       0x10   0x0A00'0009        BEQ      ??lcdc_stop_base_0
   1368          		return;
   1369          
   1370          	/* 1. Clear the DFETCH bit in the DSCR.CHXCTRL field of the DSCR structure
   1371          	   will disable the channel at the end of the frame. */
   1372          	/* 2. Set the DSCR.CHXNEXT field of the DSCR structure will disable the
   1373          	   channel at the end of the frame. */
   1374          	_clear_dma_desc(lcdc_base.dma_desc, &LCDC->LCDC_BASEHEAD);
   \                     ??lcdc_stop_base_1:
   \       0x14   0x....'....        LDR      R1,??DataTable30_5  ;; 0xf803807c
   \       0x18   0x....'....        LDR      R0,??DataTable24
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0x....'....        BL       _clear_dma_desc
   1375          
   1376          	/* 3. Writing one to the CHDIS field of the CHXCHDR register will disable
   1377          	   the channel at the end of the frame. */
   1378          	LCDC->LCDC_BASECHDR = LCDC_BASECHDR_CHDIS;
   \       0x24   0xE3A0'0001        MOV      R0,#+1
   \       0x28   0x....'....        LDR      R1,??DataTable30_6  ;; 0xf8038064
   \       0x2C   0xE581'0000        STR      R0,[R1, #+0]
   1379          
   1380          	/* 4. Writing one to the CHRST field of the CHXCHDR register will disable
   1381          	   the channel immediately. This may occur in the middle of the image. */
   1382          
   1383          	/* 5. Poll CHSR field in the CHXCHSR register until the channel is
   1384          	   successfully disabled. */
   1385          	while (LCDC->LCDC_BASECHSR & LCDC_BASECHSR_CHSR);
   \                     ??lcdc_stop_base_2:
   \       0x30   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x34   0xE310'0001        TST      R0,#0x1
   \       0x38   0x1AFF'FFFC        BNE      ??lcdc_stop_base_2
   1386          }
   \                     ??lcdc_stop_base_0:
   \       0x3C   0xE8BD'8010        POP      {R4,PC}          ;; return
   1387          
   1388          #ifdef CONFIG_HAVE_LCDC_OVR1
   1389          /**
   1390           * Start display on overlay 1 layer
   1391           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1392          void *lcdc_show_ovr1(void *buffer, uint8_t bpp, uint32_t x, uint32_t y,
   1393          		int32_t w, int32_t h)
   1394          {
   \                     lcdc_show_ovr1:
   \        0x0   0xE92D'40FE        PUSH     {R1-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
   \       0x10   0xE1B0'7003        MOVS     R7,R3
   1395          	return lcdc_put_image(LCDC_OVR1, buffer, bpp, x, y, w, h);
   \       0x14   0xE59D'0024        LDR      R0,[SP, #+36]
   \       0x18   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x1C   0xE59D'0020        LDR      R0,[SP, #+32]
   \       0x20   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x24   0xE58D'7000        STR      R7,[SP, #+0]
   \       0x28   0xE1B0'3006        MOVS     R3,R6
   \       0x2C   0xE1B0'2005        MOVS     R2,R5
   \       0x30   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x34   0xE1B0'1004        MOVS     R1,R4
   \       0x38   0xE3A0'0002        MOV      R0,#+2
   \       0x3C   0x....'....        BL       lcdc_put_image
   \       0x40   0xE8BD'80FE        POP      {R1-R7,PC}       ;; return
   1396          }
   1397          
   1398          /**
   1399           * Stop display on overlay 1 layer
   1400           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1401          void lcdc_stop_ovr1(void)
   1402          {
   \                     lcdc_stop_ovr1:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1403          	if (!(LCDC->LCDC_OVR1CHSR & LCDC_OVR1CHSR_CHSR))
   \        0x4   0x....'....        LDR      R4,??DataTable30_7  ;; 0xf8038168
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0xE310'0001        TST      R0,#0x1
   \       0x10   0x0A00'0009        BEQ      ??lcdc_stop_ovr1_0
   1404          		return;
   1405          
   1406          	/* 1. Clear the DFETCH bit in the DSCR.CHXCTRL field of the DSCR structure
   1407          	   will disable the channel at the end of the frame. */
   1408          	/* 2. Set the DSCR.CHXNEXT field of the DSCR structure will disable the
   1409          	   channel at the end of the frame. */
   1410          	_clear_dma_desc(lcdc_ovr1.dma_desc, &LCDC->LCDC_OVR1HEAD);
   \                     ??lcdc_stop_ovr1_1:
   \       0x14   0x....'....        LDR      R1,??DataTable30_8  ;; 0xf803817c
   \       0x18   0x....'....        LDR      R0,??DataTable24_1
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0x....'....        BL       _clear_dma_desc
   1411          
   1412          	/* 3. Writing one to the CHDIS field of the CHXCHDR register will disable
   1413          	   the channel at the end of the frame. */
   1414          	LCDC->LCDC_OVR1CHDR = LCDC_OVR1CHDR_CHDIS;
   \       0x24   0xE3A0'0001        MOV      R0,#+1
   \       0x28   0x....'....        LDR      R1,??DataTable30_9  ;; 0xf8038164
   \       0x2C   0xE581'0000        STR      R0,[R1, #+0]
   1415          
   1416          	/* 4. Writing one to the CHRST field of the CHXCHDR register will disable
   1417          	   the channel immediately. This may occur in the middle of the image. */
   1418          
   1419          	/* 5. Poll CHSR field in the CHXCHSR register until the channel is
   1420          	   successfully disabled. */
   1421          	while (LCDC->LCDC_OVR1CHSR & LCDC_OVR1CHSR_CHSR);
   \                     ??lcdc_stop_ovr1_2:
   \       0x30   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x34   0xE310'0001        TST      R0,#0x1
   \       0x38   0x1AFF'FFFC        BNE      ??lcdc_stop_ovr1_2
   1422          }
   \                     ??lcdc_stop_ovr1_0:
   \       0x3C   0xE8BD'8010        POP      {R4,PC}          ;; return
   1423          #endif /* CONFIG_HAVE_LCDC_OVR1 */
   1424          
   1425          /**
   1426           * Start display on High End Overlay layer
   1427           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1428          void *lcdc_show_heo(void *buffer, uint8_t bpp, uint32_t x, uint32_t y,
   1429          		int32_t w, int32_t h, uint32_t img_w, uint32_t img_h)
   1430          {
   \                     lcdc_show_heo:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   \        0xC   0xE1B0'5001        MOVS     R5,R1
   \       0x10   0xE1B0'6002        MOVS     R6,R2
   \       0x14   0xE1B0'7003        MOVS     R7,R3
   1431          	return lcdc_put_image_rotated(LCDC_HEO, buffer, bpp, x, y, w, h,
   1432          			img_w, img_h, 0);
   \       0x18   0xE3A0'0000        MOV      R0,#+0
   \       0x1C   0xE58D'0014        STR      R0,[SP, #+20]
   \       0x20   0xE59D'003C        LDR      R0,[SP, #+60]
   \       0x24   0xE58D'0010        STR      R0,[SP, #+16]
   \       0x28   0xE59D'0038        LDR      R0,[SP, #+56]
   \       0x2C   0xE58D'000C        STR      R0,[SP, #+12]
   \       0x30   0xE59D'0034        LDR      R0,[SP, #+52]
   \       0x34   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x38   0xE59D'0030        LDR      R0,[SP, #+48]
   \       0x3C   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x40   0xE58D'7000        STR      R7,[SP, #+0]
   \       0x44   0xE1B0'3006        MOVS     R3,R6
   \       0x48   0xE1B0'2005        MOVS     R2,R5
   \       0x4C   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x50   0xE1B0'1004        MOVS     R1,R4
   \       0x54   0xE3A0'0003        MOV      R0,#+3
   \       0x58   0x....'....        BL       lcdc_put_image_rotated
   \       0x5C   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x60   0xE8BD'80F0        POP      {R4-R7,PC}       ;; return
   1433          }
   1434          
   1435          /**
   1436           * Stop display on High End Overlay layer
   1437           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1438          void lcdc_stop_heo(void)
   1439          {
   \                     lcdc_stop_heo:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   1440          	if (!(LCDC->LCDC_HEOCHSR & LCDC_HEOCHSR_CHSR))
   \        0x4   0x....'....        LDR      R4,??DataTable30_10  ;; 0xf8038368
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0xE310'0001        TST      R0,#0x1
   \       0x10   0x0A00'000F        BEQ      ??lcdc_stop_heo_0
   1441          		return;
   1442          
   1443          	/* 1. Clear the DFETCH bit in the DSCR.CHXCTRL field of the DSCR structure
   1444          	   will disable the channel at the end of the frame. */
   1445          	/* 2. Set the DSCR.CHXNEXT field of the DSCR structure will disable the
   1446          	   channel at the end of the frame. */
   1447          	_clear_dma_desc(lcdc_heo.dma_desc, &LCDC->LCDC_HEOHEAD);
   \                     ??lcdc_stop_heo_1:
   \       0x14   0x....'....        LDR      R5,??DataTable22
   \       0x18   0x....'....        LDR      R1,??DataTable30_11  ;; 0xf803837c
   \       0x1C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x20   0x....'....        BL       _clear_dma_desc
   1448          	_clear_dma_desc(lcdc_heo.dma_u_desc, &LCDC->LCDC_HEOUHEAD);
   \       0x24   0x....'....        LDR      R1,??DataTable30_12  ;; 0xf803838c
   \       0x28   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x2C   0x....'....        BL       _clear_dma_desc
   1449          	_clear_dma_desc(lcdc_heo.dma_v_desc, &LCDC->LCDC_HEOVHEAD);
   \       0x30   0x....'....        LDR      R1,??DataTable30_13  ;; 0xf803839c
   \       0x34   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x38   0x....'....        BL       _clear_dma_desc
   1450          
   1451          	/* 3. Writing one to the CHDIS field of the CHXCHDR register will disable
   1452          	   the channel at the end of the frame. */
   1453          	LCDC->LCDC_HEOCHDR = LCDC_HEOCHDR_CHDIS;
   \       0x3C   0xE3A0'0001        MOV      R0,#+1
   \       0x40   0x....'....        LDR      R1,??DataTable30_14  ;; 0xf8038364
   \       0x44   0xE581'0000        STR      R0,[R1, #+0]
   1454          
   1455          	/* 4. Writing one to the CHRST field of the CHXCHDR register will disable
   1456          	   the channel immediately. This may occur in the middle of the image. */
   1457          
   1458          	/* 5. Poll CHSR field in the CHXCHSR register until the channel is
   1459          	   successfully disabled. */
   1460          	while (LCDC->LCDC_HEOCHSR & LCDC_HEOCHSR_CHSR);
   \                     ??lcdc_stop_heo_2:
   \       0x48   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x4C   0xE310'0001        TST      R0,#0x1
   \       0x50   0x1AFF'FFFC        BNE      ??lcdc_stop_heo_2
   1461          }
   \                     ??lcdc_stop_heo_0:
   \       0x54   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
   1462          
   1463          /**
   1464           * \brief Turn on the LCD.
   1465           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1466          void lcdc_on(void)
   1467          {
   \                     lcdc_on:
   \        0x0   0xE92D'43FE        PUSH     {R1-R9,LR}
   1468          	uint32_t cfg0;
   1469          	uint32_t pixel_clock = lcdc_config.framerate;
   \        0x4   0x....'....        LDR      R6,??DataTable21_1
   \        0x8   0xE5D6'0004        LDRB     R0,[R6, #+4]
   1470          	uint32_t lcd_clock;
   1471          	pixel_clock *= lcdc_config.timing_hpw + lcdc_config.timing_hbp +
   1472          		lcdc_config.width + lcdc_config.timing_hfp;
   \        0xC   0xE5D6'100A        LDRB     R1,[R6, #+10]
   \       0x10   0xE5D6'2009        LDRB     R2,[R6, #+9]
   \       0x14   0xE092'1001        ADDS     R1,R2,R1
   \       0x18   0xE1D6'20B0        LDRH     R2,[R6, #+0]
   \       0x1C   0xE092'1001        ADDS     R1,R2,R1
   \       0x20   0xE5D6'2008        LDRB     R2,[R6, #+8]
   \       0x24   0xE092'1001        ADDS     R1,R2,R1
   \       0x28   0xE010'0091        MULS     R0,R1,R0
   1473          	pixel_clock *= lcdc_config.timing_vpw + lcdc_config.timing_vbp +
   1474          		lcdc_config.height + lcdc_config.timing_vfp;
   \       0x2C   0xE5D6'1007        LDRB     R1,[R6, #+7]
   \       0x30   0xE5D6'2006        LDRB     R2,[R6, #+6]
   \       0x34   0xE092'1001        ADDS     R1,R2,R1
   \       0x38   0xE1D6'20B2        LDRH     R2,[R6, #+2]
   \       0x3C   0xE092'1001        ADDS     R1,R2,R1
   \       0x40   0xE5D6'2005        LDRB     R2,[R6, #+5]
   \       0x44   0xE092'1001        ADDS     R1,R2,R1
   \       0x48   0xE014'0091        MULS     R4,R1,R0
   1475          
   1476          	/* Enable peripheral clock and LCD system clock */
   1477          	if (pmc_has_system_clock(PMC_SYSTEM_CLOCK_LCD)) {
   \       0x4C   0xE3A0'0001        MOV      R0,#+1
   \       0x50   0x....'....        BL       pmc_has_system_clock
   \       0x54   0xE350'0000        CMP      R0,#+0
   \       0x58   0x0A00'0008        BEQ      ??lcdc_on_0
   1478          		pmc_configure_peripheral(ID_LCDC, NULL, true);
   \       0x5C   0xE3A0'2001        MOV      R2,#+1
   \       0x60   0xE3A0'1000        MOV      R1,#+0
   \       0x64   0xE3A0'0019        MOV      R0,#+25
   \       0x68   0x....'....        BL       pmc_configure_peripheral
   1479          		pmc_enable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0x6C   0xE3A0'0001        MOV      R0,#+1
   \       0x70   0x....'....        BL       pmc_enable_system_clock
   1480          		lcd_clock = pmc_get_master_clock();
   \       0x74   0x....'....        BL       pmc_get_master_clock
   \       0x78   0xE1B0'5000        MOVS     R5,R0
   \       0x7C   0xEA00'000A        B        ??lcdc_on_1
   1481          	} else {
   1482          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1483          		struct _pmc_periph_cfg cfg = {
   1484          			.gck = {
   1485          				.css = PMC_PCR_GCKCSS_MCK_CLK,
   1486          				.div = 2,
   1487          			},
   1488          		};
   \                     ??lcdc_on_0:
   \       0x80   0x....'....        LDR      R0,??DataTable30_15
   \       0x84   0xE890'000C        LDM      R0,{R2,R3}
   \       0x88   0xE1B0'000D        MOVS     R0,SP
   \       0x8C   0xE880'000C        STM      R0,{R2,R3}
   1489          		pmc_configure_peripheral(ID_LCDC, &cfg, true);
   \       0x90   0xE3A0'2001        MOV      R2,#+1
   \       0x94   0xE1B0'100D        MOVS     R1,SP
   \       0x98   0xE3A0'0019        MOV      R0,#+25
   \       0x9C   0x....'....        BL       pmc_configure_peripheral
   1490          		lcd_clock = pmc_get_gck_clock(ID_LCDC);
   \       0xA0   0xE3A0'0019        MOV      R0,#+25
   \       0xA4   0x....'....        BL       pmc_get_gck_clock
   \       0xA8   0xE1B0'5000        MOVS     R5,R0
   1491          #else
   1492          		lcd_clock = pmc_get_master_clock();
   1493          #endif
   1494          	}
   1495          	/* 1. Configure LCD timing parameters, signal polarity and clock period. */
   1496          #ifdef LCDC_LCDCFG0_CLKSEL
   1497          	cfg0 = LCDC_LCDCFG0_CLKDIV((lcd_clock * 2) / pixel_clock - 2) |
   1498          	       LCDC_LCDCFG0_CGDISBASE |
   1499          	       LCDC_LCDCFG0_CGDISHEO |
   1500          	       LCDC_LCDCFG0_CLKPWMSEL |
   1501          	       LCDC_LCDCFG0_CLKSEL;
   1502          #else
   1503          	cfg0 = LCDC_LCDCFG0_CLKDIV(lcd_clock / pixel_clock - 2) |
   1504          	       LCDC_LCDCFG0_CGDISBASE |
   1505          	       LCDC_LCDCFG0_CGDISHEO |
   1506          	       LCDC_LCDCFG0_CLKPWMSEL;
   \                     ??lcdc_on_1:
   \       0xAC   0xE1B0'0005        MOVS     R0,R5
   \       0xB0   0xE1B0'1004        MOVS     R1,R4
   \       0xB4   0x....'....        BL       __aeabi_uidiv
   \       0xB8   0xE250'0002        SUBS     R0,R0,#+2
   \       0xBC   0xE3A0'18FF        MOV      R1,#+16711680
   \       0xC0   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \       0xC4   0xE390'0F42        ORRS     R0,R0,#0x108
   \       0xC8   0xE390'0E80        ORRS     R0,R0,#0x800
   1507          #endif
   1508          
   1509          #ifdef LCDC_LCDCFG0_CGDISOVR1
   1510          	cfg0 |= LCDC_LCDCFG0_CGDISOVR1;
   \       0xCC   0xE390'0F80        ORRS     R0,R0,#0x200
   1511          #endif
   1512          #ifdef LCDC_LCDCFG0_CGDISOVR2
   1513          	cfg0 |= LCDC_LCDCFG0_CGDISOVR2;
   \       0xD0   0xE390'7E40        ORRS     R7,R0,#0x400
   1514          #endif
   1515          #ifdef LCDC_LCDCFG0_CGDISHCR
   1516          	cfg0 |= LCDC_LCDCFG0_CGDISHCR;
   1517          #endif
   1518          #ifdef LCDC_LCDCFG0_CGDISPP
   1519          	cfg0 |= LCDC_LCDCFG0_CGDISPP;
   1520          #endif
   1521          	_wait_for_clock_domain_sync();
   \       0xD4   0x....'....        BL       _wait_for_clock_domain_sync
   1522          	LCDC->LCDC_LCDCFG0 = cfg0;
   \       0xD8   0xE3A0'04F8        MOV      R0,#-134217728
   \       0xDC   0xE380'0BE0        ORR      R0,R0,#0x38000
   \       0xE0   0xE580'7000        STR      R7,[R0, #+0]
   1523          
   1524          	_wait_for_clock_domain_sync();
   \       0xE4   0x....'....        BL       _wait_for_clock_domain_sync
   1525          	LCDC->LCDC_LCDCFG1 = LCDC_LCDCFG1_VSPW(lcdc_config.timing_vpw - 1) |
   1526          	                     LCDC_LCDCFG1_HSPW(lcdc_config.timing_hpw - 1);
   \       0xE8   0xE3A0'80FF        MOV      R8,#+255
   \       0xEC   0xE388'8FC0        ORR      R8,R8,#0x300
   \       0xF0   0xE3A0'97C0        MOV      R9,#+50331648
   \       0xF4   0xE389'98FF        ORR      R9,R9,#0xFF0000
   \       0xF8   0xE5D6'0007        LDRB     R0,[R6, #+7]
   \       0xFC   0xE250'0001        SUBS     R0,R0,#+1
   \      0x100   0xE019'0800        ANDS     R0,R9,R0, LSL #+16
   \      0x104   0xE5D6'100A        LDRB     R1,[R6, #+10]
   \      0x108   0xE251'1001        SUBS     R1,R1,#+1
   \      0x10C   0xE018'1001        ANDS     R1,R8,R1
   \      0x110   0xE191'0000        ORRS     R0,R1,R0
   \      0x114   0x....'....        LDR      R1,??DataTable30_16  ;; 0xf8038004
   \      0x118   0xE581'0000        STR      R0,[R1, #+0]
   1527          
   1528          	_wait_for_clock_domain_sync();
   \      0x11C   0x....'....        BL       _wait_for_clock_domain_sync
   1529          	LCDC->LCDC_LCDCFG2 = LCDC_LCDCFG2_VBPW(lcdc_config.timing_vbp) |
   1530          	                     LCDC_LCDCFG2_VFPW(lcdc_config.timing_vfp - 1);
   \      0x120   0xE5D6'0006        LDRB     R0,[R6, #+6]
   \      0x124   0xE5D6'1005        LDRB     R1,[R6, #+5]
   \      0x128   0xE251'1001        SUBS     R1,R1,#+1
   \      0x12C   0xE018'1001        ANDS     R1,R8,R1
   \      0x130   0xE191'0800        ORRS     R0,R1,R0, LSL #+16
   \      0x134   0x....'....        LDR      R1,??DataTable30_17  ;; 0xf8038008
   \      0x138   0xE581'0000        STR      R0,[R1, #+0]
   1531          
   1532          	_wait_for_clock_domain_sync();
   \      0x13C   0x....'....        BL       _wait_for_clock_domain_sync
   1533          	LCDC->LCDC_LCDCFG3 = LCDC_LCDCFG3_HBPW(lcdc_config.timing_hbp - 1) |
   1534          	                     LCDC_LCDCFG3_HFPW(lcdc_config.timing_hfp - 1);
   \      0x140   0xE5D6'0009        LDRB     R0,[R6, #+9]
   \      0x144   0xE250'0001        SUBS     R0,R0,#+1
   \      0x148   0xE019'0800        ANDS     R0,R9,R0, LSL #+16
   \      0x14C   0xE5D6'1008        LDRB     R1,[R6, #+8]
   \      0x150   0xE251'1001        SUBS     R1,R1,#+1
   \      0x154   0xE018'1001        ANDS     R1,R8,R1
   \      0x158   0xE191'0000        ORRS     R0,R1,R0
   \      0x15C   0x....'....        LDR      R1,??DataTable30_18  ;; 0xf803800c
   \      0x160   0xE581'0000        STR      R0,[R1, #+0]
   1535          
   1536          	_wait_for_clock_domain_sync();
   \      0x164   0x....'....        BL       _wait_for_clock_domain_sync
   1537          	LCDC->LCDC_LCDCFG4 = LCDC_LCDCFG4_RPF(lcdc_config.height - 1) |
   1538          	                     LCDC_LCDCFG4_PPL(lcdc_config.width - 1);
   \      0x168   0xE1D6'00B2        LDRH     R0,[R6, #+2]
   \      0x16C   0xE250'0001        SUBS     R0,R0,#+1
   \      0x170   0xE3A0'1670        MOV      R1,#+117440512
   \      0x174   0xE381'18FF        ORR      R1,R1,#0xFF0000
   \      0x178   0xE011'0800        ANDS     R0,R1,R0, LSL #+16
   \      0x17C   0xE1D6'10B0        LDRH     R1,[R6, #+0]
   \      0x180   0xE251'1001        SUBS     R1,R1,#+1
   \      0x184   0xE1B0'1A81        LSLS     R1,R1,#+21
   \      0x188   0xE190'0AA1        ORRS     R0,R0,R1, LSR #+21
   \      0x18C   0x....'....        LDR      R1,??DataTable30_19  ;; 0xf8038010
   \      0x190   0xE581'0000        STR      R0,[R1, #+0]
   1539          
   1540          	_wait_for_clock_domain_sync();
   \      0x194   0x....'....        BL       _wait_for_clock_domain_sync
   1541          	LCDC->LCDC_LCDCFG5 = LCDC_LCDCFG5_GUARDTIME(30) |
   1542          	                     LCDC_LCDCFG5_MODE_OUTPUT_24BPP |
   1543          	                     LCDC_LCDCFG5_DISPDLY |
   1544          	                     LCDC_LCDCFG5_VSPDLYS |
   1545          	                     LCDC_LCDCFG5_VSPOL |
   1546          	                     LCDC_LCDCFG5_HSPOL;
   \      0x198   0x....'....        LDR      R0,??DataTable30_20  ;; 0x1e0387
   \      0x19C   0x....'....        LDR      R1,??DataTable30_21  ;; 0xf8038014
   \      0x1A0   0xE581'0000        STR      R0,[R1, #+0]
   1547          
   1548          	_wait_for_clock_domain_sync();
   \      0x1A4   0x....'....        BL       _wait_for_clock_domain_sync
   1549          	LCDC->LCDC_LCDCFG6 = LCDC_LCDCFG6_PWMCVAL(0xF0) |
   1550          	                     LCDC_LCDCFG6_PWMPOL |
   1551          	                     LCDC_LCDCFG6_PWMPS(5);
   \      0x1A8   0xE3A0'0015        MOV      R0,#+21
   \      0x1AC   0xE380'0CF0        ORR      R0,R0,#0xF000
   \      0x1B0   0x....'....        LDR      R1,??DataTable30_22  ;; 0xf8038018
   \      0x1B4   0xE581'0000        STR      R0,[R1, #+0]
   1552          
   1553          	/* 2. Enable the Pixel Clock by writing one to the CLKEN field of the
   1554          	   LCDC_LCDEN register. */
   1555          	_wait_for_clock_domain_sync();
   \      0x1B8   0x....'....        BL       _wait_for_clock_domain_sync
   1556          	LCDC->LCDC_LCDEN = LCDC_LCDEN_CLKEN;
   \      0x1BC   0x....'....        LDR      R6,??DataTable30_23  ;; 0xf8038020
   \      0x1C0   0xE3A0'0001        MOV      R0,#+1
   \      0x1C4   0xE586'0000        STR      R0,[R6, #+0]
   1557          
   1558          	/* 3. Poll CLKSTS field of the LCDC_LCDSR register to check that the clock
   1559          	   is running. */
   1560          	while (!(LCDC->LCDC_LCDSR & LCDC_LCDSR_CLKSTS));
   \                     ??lcdc_on_2:
   \      0x1C8   0x....'....        LDR      R8,??DataTable30_24  ;; 0xf8038028
   \      0x1CC   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x1D0   0xE310'0001        TST      R0,#0x1
   \      0x1D4   0x0AFF'FFFB        BEQ      ??lcdc_on_2
   1561          
   1562          	/* 4. Enable Horizontal and Vertical Synchronization by writing one to the
   1563          	   SYNCEN field of the LCDC_LCDEN register. */
   1564          	_wait_for_clock_domain_sync();
   \      0x1D8   0x....'....        BL       _wait_for_clock_domain_sync
   1565          	LCDC->LCDC_LCDEN = LCDC_LCDEN_SYNCEN;
   \      0x1DC   0xE3A0'0002        MOV      R0,#+2
   \      0x1E0   0xE586'0000        STR      R0,[R6, #+0]
   1566          
   1567          	/* 5. Poll LCDSTS field of the LCDC_LCDSR register to check that the
   1568          	   synchronization is up. */
   1569          	while (!(LCDC->LCDC_LCDSR & LCDC_LCDSR_LCDSTS));
   \                     ??lcdc_on_3:
   \      0x1E4   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x1E8   0xE310'0002        TST      R0,#0x2
   \      0x1EC   0x0AFF'FFFC        BEQ      ??lcdc_on_3
   1570          
   1571          	/* 6. Enable the display power signal writing one to the DISPEN field of the
   1572          	   LCDC_LCDEN register. */
   1573          	_wait_for_clock_domain_sync();
   \      0x1F0   0x....'....        BL       _wait_for_clock_domain_sync
   1574          	LCDC->LCDC_LCDEN = LCDC_LCDEN_DISPEN;
   \      0x1F4   0xE3A0'0004        MOV      R0,#+4
   \      0x1F8   0xE586'0000        STR      R0,[R6, #+0]
   1575          
   1576          	/* 7. Poll DISPSTS field of the LCDC_LCDSR register to check that the power
   1577          	   signal is activated. */
   1578          	while (!(LCDC->LCDC_LCDSR & LCDC_LCDSR_DISPSTS));
   \                     ??lcdc_on_4:
   \      0x1FC   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x200   0xE310'0004        TST      R0,#0x4
   \      0x204   0x0AFF'FFFC        BEQ      ??lcdc_on_4
   1579          
   1580          	/* 8. Enable backlight */
   1581          	_wait_for_clock_domain_sync();
   \      0x208   0x....'....        BL       _wait_for_clock_domain_sync
   1582          	LCDC->LCDC_LCDEN = LCDC_LCDEN_PWMEN;
   \      0x20C   0xE3A0'0008        MOV      R0,#+8
   \      0x210   0xE586'0000        STR      R0,[R6, #+0]
   1583          }
   \      0x214   0xE8BD'83F7        POP      {R0-R2,R4-R9,PC}  ;; return

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000'0300        DC32 768, 2

   \              0x0000'0002
   1584          
   1585          /**
   1586           * \brief Turn off the LCD.
   1587           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1588          void lcdc_off(void)
   1589          {
   \                     lcdc_off:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1590          	/* 1. Clear the DFETCH bit in the DSCR.CHXCTRL field of the DSCR structure
   1591          	   will disable the channel at the end of the frame. */
   1592          
   1593          	/* 2. Set the DSCR.CHXNEXT field of the DSCR structure will disable the
   1594          	   channel at the end of the frame. */
   1595          
   1596          	/* Disable all DMA channel descriptors */
   1597          	_clear_dma_desc(lcdc_base.dma_desc, &LCDC->LCDC_BASEHEAD);
   \        0x4   0x....'....        LDR      R1,??DataTable30_5  ;; 0xf803807c
   \        0x8   0x....'....        LDR      R0,??DataTable24
   \        0xC   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x10   0x....'....        BL       _clear_dma_desc
   1598          #ifdef CONFIG_HAVE_LCDC_OVR1
   1599          	_clear_dma_desc(lcdc_ovr1.dma_desc, &LCDC->LCDC_OVR1HEAD);
   \       0x14   0x....'....        LDR      R1,??DataTable30_8  ;; 0xf803817c
   \       0x18   0x....'....        LDR      R0,??DataTable24_1
   \       0x1C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x20   0x....'....        BL       _clear_dma_desc
   1600          #endif
   1601          #ifdef CONFIG_HAVE_LCDC_OVR2
   1602          	_clear_dma_desc(lcdc_ovr2.dma_desc, &LCDC->LCDC_OVR2HEAD);
   \       0x24   0x....'....        LDR      R1,??DataTable30_25  ;; 0xf803827c
   \       0x28   0x....'....        LDR      R0,??DataTable24_2
   \       0x2C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x30   0x....'....        BL       _clear_dma_desc
   1603          #endif
   1604          	_clear_dma_desc(lcdc_heo.dma_desc, &LCDC->LCDC_HEOHEAD);
   \       0x34   0x....'....        LDR      R4,??DataTable22
   \       0x38   0x....'....        LDR      R1,??DataTable30_11  ;; 0xf803837c
   \       0x3C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x40   0x....'....        BL       _clear_dma_desc
   1605          	_clear_dma_desc(lcdc_heo.dma_u_desc, &LCDC->LCDC_HEOUHEAD);
   \       0x44   0x....'....        LDR      R1,??DataTable30_12  ;; 0xf803838c
   \       0x48   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x4C   0x....'....        BL       _clear_dma_desc
   1606          	_clear_dma_desc(lcdc_heo.dma_v_desc, &LCDC->LCDC_HEOVHEAD);
   \       0x50   0x....'....        LDR      R1,??DataTable30_13  ;; 0xf803839c
   \       0x54   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x58   0x....'....        BL       _clear_dma_desc
   1607          
   1608          	/* 3. Writing one to the CHDIS field of the CHXCHDR register will disable
   1609          	   the channel at the end of the frame. */
   1610          
   1611          	/* Disable DMA channels */
   1612          	LCDC->LCDC_BASECHDR = LCDC_BASECHDR_CHDIS;
   \       0x5C   0xE3A0'0001        MOV      R0,#+1
   \       0x60   0x....'....        LDR      R1,??DataTable30_6  ;; 0xf8038064
   \       0x64   0xE581'0000        STR      R0,[R1, #+0]
   1613          #ifdef CONFIG_HAVE_LCDC_OVR1
   1614          	LCDC->LCDC_OVR1CHDR = LCDC_OVR1CHDR_CHDIS;
   \       0x68   0x....'....        LDR      R1,??DataTable30_9  ;; 0xf8038164
   \       0x6C   0xE581'0000        STR      R0,[R1, #+0]
   1615          #endif
   1616          #ifdef CONFIG_HAVE_LCDC_OVR2
   1617          	LCDC->LCDC_OVR2CHDR = LCDC_OVR2CHDR_CHDIS;
   \       0x70   0x....'....        LDR      R1,??DataTable30_26  ;; 0xf8038264
   \       0x74   0xE581'0000        STR      R0,[R1, #+0]
   1618          #endif
   1619          	LCDC->LCDC_HEOCHDR = LCDC_HEOCHDR_CHDIS;
   \       0x78   0x....'....        LDR      R1,??DataTable30_14  ;; 0xf8038364
   \       0x7C   0xE581'0000        STR      R0,[R1, #+0]
   1620          	LCDC->LCDC_BASECFG4 = 0;
   \       0x80   0xE3A0'1000        MOV      R1,#+0
   \       0x84   0x....'....        LDR      R2,??DataTable30_27  ;; 0xf803809c
   \       0x88   0xE582'1000        STR      R1,[R2, #+0]
   1621          
   1622          	/* 4. Writing one to the CHRST field of the CHXCHDR register will disable
   1623          	   the channel immediately. This may occur in the middle of the image. */
   1624          
   1625          	/* 5. Poll CHSR field in the CHXCHSR register until the channel is
   1626          	   successfully disabled. */
   1627          	while (LCDC->LCDC_BASECHSR & LCDC_BASECHSR_CHSR);
   \                     ??lcdc_off_0:
   \       0x8C   0x....'....        LDR      R1,??DataTable30_4  ;; 0xf8038068
   \       0x90   0xE591'1000        LDR      R1,[R1, #+0]
   \       0x94   0xE311'0001        TST      R1,#0x1
   \       0x98   0x1AFF'FFFB        BNE      ??lcdc_off_0
   1628          #ifdef CONFIG_HAVE_LCDC_OVR1
   1629          	while (LCDC->LCDC_OVR1CHSR & LCDC_OVR1CHSR_CHSR);
   \                     ??lcdc_off_1:
   \       0x9C   0x....'....        LDR      R1,??DataTable30_7  ;; 0xf8038168
   \       0xA0   0xE591'1000        LDR      R1,[R1, #+0]
   \       0xA4   0xE311'0001        TST      R1,#0x1
   \       0xA8   0x1AFF'FFFB        BNE      ??lcdc_off_1
   1630          #endif
   1631          #ifdef CONFIG_HAVE_LCDC_OVR2
   1632          	while (LCDC->LCDC_OVR2CHSR & LCDC_OVR1CHSR_CHSR);
   \                     ??lcdc_off_2:
   \       0xAC   0x....'....        LDR      R1,??DataTable30_28  ;; 0xf8038268
   \       0xB0   0xE591'1000        LDR      R1,[R1, #+0]
   \       0xB4   0xE311'0001        TST      R1,#0x1
   \       0xB8   0x1AFF'FFFB        BNE      ??lcdc_off_2
   1633          #endif
   1634          	while (LCDC->LCDC_HEOCHSR & LCDC_HEOCHSR_CHSR);
   \                     ??lcdc_off_3:
   \       0xBC   0x....'....        LDR      R1,??DataTable30_10  ;; 0xf8038368
   \       0xC0   0xE591'1000        LDR      R1,[R1, #+0]
   \       0xC4   0xE311'0001        TST      R1,#0x1
   \       0xC8   0x1AFF'FFFB        BNE      ??lcdc_off_3
   1635          
   1636          	/* Timing Engine Power Down Software Operation */
   1637          
   1638          	/* Disable backlight */
   1639          	LCDC->LCDC_LCDDIS = LCDC_LCDDIS_PWMDIS;
   \       0xCC   0x....'....        LDR      R1,??DataTable30_29  ;; 0xf8038024
   \       0xD0   0xE3A0'2008        MOV      R2,#+8
   \       0xD4   0xE581'2000        STR      R2,[R1, #+0]
   1640          	while (LCDC->LCDC_LCDSR & LCDC_LCDSR_PWMSTS);
   \                     ??lcdc_off_4:
   \       0xD8   0x....'....        LDR      R2,??DataTable30_24  ;; 0xf8038028
   \       0xDC   0xE592'3000        LDR      R3,[R2, #+0]
   \       0xE0   0xE313'0008        TST      R3,#0x8
   \       0xE4   0x1AFF'FFFB        BNE      ??lcdc_off_4
   1641          
   1642          	/* 1. Disable the DISP signal writing DISPDIS field of the LCDC_LCDDIS
   1643          	   register. */
   1644          	LCDC->LCDC_LCDDIS = LCDC_LCDDIS_DISPDIS;
   \       0xE8   0xE3A0'3004        MOV      R3,#+4
   \       0xEC   0xE581'3000        STR      R3,[R1, #+0]
   1645          
   1646          	/* 2. Poll DISPSTS field of the LCDC_LCDSR register to verify that the DISP
   1647          	   is no longer activated. */
   1648          	while (LCDC->LCDC_LCDSR & LCDC_LCDSR_DISPSTS);
   \                     ??lcdc_off_5:
   \       0xF0   0xE592'3000        LDR      R3,[R2, #+0]
   \       0xF4   0xE313'0004        TST      R3,#0x4
   \       0xF8   0x1AFF'FFFC        BNE      ??lcdc_off_5
   1649          
   1650          	/* 3. Disable the hsync and vsync signals by writing one to SYNCDIS field of
   1651          	   the LCDC_LCDDIS register. */
   1652          	LCDC->LCDC_LCDDIS = LCDC_LCDDIS_SYNCDIS;
   \       0xFC   0xE3A0'3002        MOV      R3,#+2
   \      0x100   0xE581'3000        STR      R3,[R1, #+0]
   1653          
   1654          	/* 4. Poll LCDSTS field of the LCDC_LCDSR register to check that the
   1655          	   synchronization is off. */
   1656          	while (LCDC->LCDC_LCDSR & LCDC_LCDSR_LCDSTS);
   \                     ??lcdc_off_6:
   \      0x104   0xE592'3000        LDR      R3,[R2, #+0]
   \      0x108   0xE313'0002        TST      R3,#0x2
   \      0x10C   0x1AFF'FFFC        BNE      ??lcdc_off_6
   1657          
   1658          	/* 5. Disable the Pixel clock by writing one in the CLKDIS field of the
   1659          	   LCDC_LCDDIS register. */
   1660          	LCDC->LCDC_LCDDIS = LCDC_LCDDIS_CLKDIS;
   \      0x110   0xE581'0000        STR      R0,[R1, #+0]
   1661          
   1662          	/* 6. Poll CLKSTS field of the LCDC_LCDSR register to check that Pixel Clock
   1663          	   is disabled. */
   1664          	while (LCDC->LCDC_LCDSR & LCDC_LCDSR_CLKSTS);
   \                     ??lcdc_off_7:
   \      0x114   0xE592'0000        LDR      R0,[R2, #+0]
   \      0x118   0xE310'0001        TST      R0,#0x1
   \      0x11C   0x1AFF'FFFC        BNE      ??lcdc_off_7
   1665          
   1666          	/* Disable peripheral clock and ISC system clock */
   1667          	pmc_disable_peripheral(ID_LCDC);
   \      0x120   0xE3A0'0019        MOV      R0,#+25
   \      0x124   0x....'....        BL       pmc_disable_peripheral
   1668          	if (pmc_has_system_clock(PMC_SYSTEM_CLOCK_LCD))
   \      0x128   0xE3A0'0001        MOV      R0,#+1
   \      0x12C   0x....'....        BL       pmc_has_system_clock
   \      0x130   0xE350'0000        CMP      R0,#+0
   \      0x134   0x0A00'0001        BEQ      ??lcdc_off_8
   1669          		pmc_disable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \      0x138   0xE3A0'0001        MOV      R0,#+1
   \      0x13C   0x....'....        BL       pmc_disable_system_clock
   1670          }
   \                     ??lcdc_off_8:
   \      0x140   0xE8BD'8010        POP      {R4,PC}          ;; return
   1671          
   1672          /**
   1673           * \brief Set the backlight of the LCD.
   1674           *
   1675           * \param level   Backlight brightness level [1..255],
   1676           *                255 means maximum brightness.
   1677           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1678          void lcdc_set_backlight(uint32_t level)
   1679          {
   1680          	uint32_t cfg = LCDC->LCDC_LCDCFG6 & ~LCDC_LCDCFG6_PWMCVAL_Msk;
   \                     lcdc_set_backlight:
   \        0x0   0x....'....        LDR      R2,??DataTable30_22  ;; 0xf8038018
   \        0x4   0xE592'1000        LDR      R1,[R2, #+0]
   \        0x8   0xE3D1'1CFF        BICS     R1,R1,#0xFF00
   1681          	LCDC->LCDC_LCDCFG6 = cfg | LCDC_LCDCFG6_PWMCVAL(level);
   \        0xC   0xE3A0'3CFF        MOV      R3,#+65280
   \       0x10   0xE013'3400        ANDS     R3,R3,R0, LSL #+8
   \       0x14   0xE193'3001        ORRS     R3,R3,R1
   \       0x18   0xE582'3000        STR      R3,[R2, #+0]
   1682          }
   \       0x1C   0xE12F'FF1E        BX       LR               ;; return
   1683          
   1684          /**
   1685           * Get canvas layer for LCDC_Draw*
   1686           * \return Layer information pointer.
   1687           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1688          struct _lcdc_layer *lcdc_get_canvas(void)
   1689          {
   1690          	return &lcdc_canvas;
   \                     lcdc_get_canvas:
   \        0x0   0x....'....        LDR      R0,??DataTable30_30
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
   1691          }
   1692          
   1693          /**
   1694           * Flush the current canvas layer*
   1695           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1696          void lcdc_flush_canvas(void)
   1697          {
   \                     lcdc_flush_canvas:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1698          	struct _lcdc_layer *layer;
   1699          
   1700          	layer = lcdc_get_canvas();
   \        0x4   0x....'....        BL       lcdc_get_canvas
   \        0x8   0xE1B0'4000        MOVS     R4,R0
   1701          	cache_clean_region(layer->buffer, layer->height * layer->width * 4);
   \        0xC   0xE1D4'00B6        LDRH     R0,[R4, #+6]
   \       0x10   0xE1D4'10B4        LDRH     R1,[R4, #+4]
   \       0x14   0xE010'0091        MULS     R0,R1,R0
   \       0x18   0xE1B0'1100        LSLS     R1,R0,#+2
   \       0x1C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x20   0x....'....        BL       cache_clean_region
   1702          }
   \       0x24   0xE8BD'8010        POP      {R4,PC}          ;; return
   1703          
   1704          /**
   1705           * Select an LCD layer as canvas layer.
   1706           * Then all drawing operations will apply to current display buffer
   1707           * of selected layer.
   1708           * \note If there is no display buffer for the layer (not running)
   1709           *       selection fails.
   1710           * \param layer_id Layer ID.
   1711           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1712          uint8_t lcdc_select_canvas(uint8_t layer_id)
   1713          {
   \                     lcdc_select_canvas:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   1714          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x8   0x....'....        LDR      R0,??DataTable25_1
   \        0xC   0xE1B0'1004        MOVS     R1,R4
   \       0x10   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x14   0xE3A0'2034        MOV      R2,#+52
   \       0x18   0xE011'0192        MULS     R1,R2,R1
   \       0x1C   0xE090'5001        ADDS     R5,R0,R1
   1715          
   1716          	if (!layer->reg_cfg || !layer->data)
   \       0x20   0xE595'001C        LDR      R0,[R5, #+28]
   \       0x24   0xE350'0000        CMP      R0,#+0
   \       0x28   0x0A00'0002        BEQ      ??lcdc_select_canvas_0
   \       0x2C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x1A00'0001        BNE      ??lcdc_select_canvas_1
   1717          		return 0;
   \                     ??lcdc_select_canvas_0:
   \       0x38   0xE3A0'0000        MOV      R0,#+0
   \       0x3C   0xEA00'001E        B        ??lcdc_select_canvas_2
   1718          
   1719          	lcdc_canvas.buffer = (void *)layer->data->buffer;
   \                     ??lcdc_select_canvas_1:
   \       0x40   0x....'....        LDR      R6,??DataTable30_30
   \       0x44   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x48   0xE590'000C        LDR      R0,[R0, #+12]
   \       0x4C   0xE586'0000        STR      R0,[R6, #+0]
   1720          	if (layer->reg_win) {
   \       0x50   0xE595'0020        LDR      R0,[R5, #+32]
   \       0x54   0xE350'0000        CMP      R0,#+0
   \       0x58   0x0A00'000B        BEQ      ??lcdc_select_canvas_3
   1721          		lcdc_canvas.width = (layer->reg_win[1] & LCDC_HEOCFG3_XSIZE_Msk) >> LCDC_HEOCFG3_XSIZE_Pos;
   \       0x5C   0xE3A0'00FF        MOV      R0,#+255
   \       0x60   0xE380'0E70        ORR      R0,R0,#0x700
   \       0x64   0xE595'1020        LDR      R1,[R5, #+32]
   \       0x68   0xE591'1004        LDR      R1,[R1, #+4]
   \       0x6C   0xE010'1001        ANDS     R1,R0,R1
   \       0x70   0xE1C6'10B4        STRH     R1,[R6, #+4]
   1722          		lcdc_canvas.height = (layer->reg_win[1] & LCDC_HEOCFG3_YSIZE_Msk) >> LCDC_HEOCFG3_YSIZE_Pos;
   \       0x74   0xE595'1020        LDR      R1,[R5, #+32]
   \       0x78   0xE591'1004        LDR      R1,[R1, #+4]
   \       0x7C   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x80   0xE010'0001        ANDS     R0,R0,R1
   \       0x84   0xE1C6'00B6        STRH     R0,[R6, #+6]
   \       0x88   0xEA00'0004        B        ??lcdc_select_canvas_4
   1723          	} else {
   1724          		lcdc_canvas.width = lcdc_config.width;
   \                     ??lcdc_select_canvas_3:
   \       0x8C   0x....'....        LDR      R0,??DataTable30
   \       0x90   0xE1D0'10B0        LDRH     R1,[R0, #+0]
   \       0x94   0xE1C6'10B4        STRH     R1,[R6, #+4]
   1725          		lcdc_canvas.height = lcdc_config.height;
   \       0x98   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \       0x9C   0xE1C6'00B6        STRH     R0,[R6, #+6]
   1726          	}
   1727          	lcdc_canvas.bpp = _get_bits_per_pixel(layer->reg_cfg[1] & LCDC_HEOCFG1_RGBMODE_Msk);
   \                     ??lcdc_select_canvas_4:
   \       0xA0   0xE595'001C        LDR      R0,[R5, #+28]
   \       0xA4   0xE590'0004        LDR      R0,[R0, #+4]
   \       0xA8   0xE210'00F0        ANDS     R0,R0,#0xF0
   \       0xAC   0x....'....        BL       _get_bits_per_pixel
   \       0xB0   0xE5C6'0008        STRB     R0,[R6, #+8]
   1728          	lcdc_canvas.layer_id = layer_id;
   \       0xB4   0xE5C6'4009        STRB     R4,[R6, #+9]
   1729          
   1730          	return 1;
   \       0xB8   0xE3A0'0001        MOV      R0,#+1
   \                     ??lcdc_select_canvas_2:
   \       0xBC   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1731          }
   1732          
   1733          /**
   1734           * Create a blank canvas on a display layer for further operations.
   1735           * \param layer_id Layer ID.
   1736           * \param buffer   Pointer to canvas display buffer.
   1737           * \param bpp      Bits Per Pixel.
   1738           * \param x        Canvas X coordinate on base.
   1739           * \param y        Canvas Y coordinate on base.
   1740           * \param w        Canvas width.
   1741           * \param h        Canvas height.
   1742           * \note The content in buffer is destroied.
   1743           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1744          void * lcdc_create_canvas(uint8_t layer_id, void *buffer, uint8_t bpp,
   1745          			  uint16_t x, uint16_t y, uint16_t w, uint16_t h)
   1746          {
   \                     lcdc_create_canvas:
   \        0x0   0xE92D'4FF7        PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xE24D'D020        SUB      SP,SP,#+32
   \        0x8   0xE1B0'4003        MOVS     R4,R3
   \        0xC   0xE1DD'55B0        LDRH     R5,[SP, #+80]
   \       0x10   0xE1DD'65B4        LDRH     R6,[SP, #+84]
   \       0x14   0xE1DD'75B8        LDRH     R7,[SP, #+88]
   1747          	uint32_t max_w = lcdc_config.width;
   \       0x18   0x....'....        LDR      R0,??DataTable30
   \       0x1C   0xE1D0'80B0        LDRH     R8,[R0, #+0]
   1748          	uint32_t max_h = lcdc_config.height;
   \       0x20   0xE1D0'10B2        LDRH     R1,[R0, #+2]
   \       0x24   0xE58D'101C        STR      R1,[SP, #+28]
   1749          	uint32_t bits_per_row, bytes_per_row;
   1750          	void *old_buffer;
   1751          
   1752          	switch (layer_id) {
   \       0x28   0xE5DD'1020        LDRB     R1,[SP, #+32]
   \       0x2C   0xE241'1001        SUB      R1,R1,#+1
   \       0x30   0xE351'0003        CMP      R1,#+3
   \       0x34   0x8A00'001D        BHI      ??lcdc_create_canvas_1
   \       0x38   0xE7DF'2001        LDRB     R2,[PC, R1]
   \       0x3C   0xE08F'F102        ADD      PC,PC,R2, LSL #+2
   \                     ??lcdc_create_canvas_0:
   \       0x40   0x00 0x05          DC8      0x0,0x5,0x5,0x5

   \              0x05 0x05
   1753          	case LCDC_BASE:
   1754          		x = 0;
   \                     ??lcdc_create_canvas_2:
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0xE1B0'1000        MOVS     R1,R0
   \       0x4C   0xE1B0'4001        MOVS     R4,R1
   1755          		y = 0;
   \       0x50   0xE1B0'5000        MOVS     R5,R0
   1756          		break;
   \       0x54   0xEA00'0015        B        ??lcdc_create_canvas_1
   1757          #ifdef CONFIG_HAVE_LCDC_OVR1
   1758          	case LCDC_OVR1:
   1759          #endif
   1760          #ifdef CONFIG_HAVE_LCDC_OVR2
   1761          	case LCDC_OVR2:
   1762          #endif
   1763          	case LCDC_HEO:
   1764          		/* Size check */
   1765          		if (x + w > lcdc_config.width || y + h > lcdc_config.height)
   \                     ??lcdc_create_canvas_3:
   \       0x58   0xE1D0'10B0        LDRH     R1,[R0, #+0]
   \       0x5C   0xE1B0'2004        MOVS     R2,R4
   \       0x60   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x64   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0x68   0xE1B0'3006        MOVS     R3,R6
   \       0x6C   0xE1A0'3803        LSL      R3,R3,#+16
   \       0x70   0xE1B0'3823        LSRS     R3,R3,#+16
   \       0x74   0xE093'2002        ADDS     R2,R3,R2
   \       0x78   0xE151'0002        CMP      R1,R2
   \       0x7C   0xBA00'0009        BLT      ??lcdc_create_canvas_4
   \       0x80   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \       0x84   0xE1B0'1005        MOVS     R1,R5
   \       0x88   0xE1A0'1801        LSL      R1,R1,#+16
   \       0x8C   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x90   0xE1B0'2007        MOVS     R2,R7
   \       0x94   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x98   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0x9C   0xE092'1001        ADDS     R1,R2,R1
   \       0xA0   0xE150'0001        CMP      R0,R1
   \       0xA4   0xAA00'0001        BGE      ??lcdc_create_canvas_5
   1766          			return NULL;
   \                     ??lcdc_create_canvas_4:
   \       0xA8   0xE3A0'0000        MOV      R0,#+0
   \       0xAC   0xEA00'004D        B        ??lcdc_create_canvas_6
   1767          		break;
   1768          	}
   1769          	if (w == 0)
   \                     ??lcdc_create_canvas_5:
   \                     ??lcdc_create_canvas_1:
   \       0xB0   0xE1B0'0006        MOVS     R0,R6
   \       0xB4   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xB8   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xBC   0xE350'0000        CMP      R0,#+0
   \       0xC0   0x1A00'0002        BNE      ??lcdc_create_canvas_7
   1770          		w = max_w - x;
   \       0xC4   0xE1B0'0008        MOVS     R0,R8
   \       0xC8   0xE050'0004        SUBS     R0,R0,R4
   \       0xCC   0xE1B0'6000        MOVS     R6,R0
   1771          	if (h == 0)
   \                     ??lcdc_create_canvas_7:
   \       0xD0   0xE1B0'0007        MOVS     R0,R7
   \       0xD4   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xD8   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xDC   0xE350'0000        CMP      R0,#+0
   \       0xE0   0x1A00'0002        BNE      ??lcdc_create_canvas_8
   1772          		h = max_h - y;
   \       0xE4   0xE59D'001C        LDR      R0,[SP, #+28]
   \       0xE8   0xE050'0005        SUBS     R0,R0,R5
   \       0xEC   0xE1B0'7000        MOVS     R7,R0
   1773          
   1774          	/* Clear buffer */
   1775          	bits_per_row = w * bpp;
   \                     ??lcdc_create_canvas_8:
   \       0xF0   0xE1B0'0006        MOVS     R0,R6
   \       0xF4   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xF8   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xFC   0xE5DD'1028        LDRB     R1,[SP, #+40]
   \      0x100   0xE019'0091        MULS     R9,R1,R0
   1776          	bytes_per_row = (bits_per_row & 0x7) ? (bits_per_row / 8 + 1) : (bits_per_row / 8);
   \      0x104   0xE319'0007        TST      R9,#0x7
   \      0x108   0x0A00'0002        BEQ      ??lcdc_create_canvas_9
   \      0x10C   0xE3A0'0001        MOV      R0,#+1
   \      0x110   0xE090'A1A9        ADDS     R10,R0,R9, LSR #+3
   \      0x114   0xEA00'0000        B        ??lcdc_create_canvas_10
   \                     ??lcdc_create_canvas_9:
   \      0x118   0xE1B0'A1A9        LSRS     R10,R9,#+3
   1777          	memset(buffer, 0, bytes_per_row * h);
   \                     ??lcdc_create_canvas_10:
   \      0x11C   0xE1B0'0007        MOVS     R0,R7
   \      0x120   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x124   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x128   0xE011'0A90        MULS     R1,R0,R10
   \      0x12C   0xE58D'1018        STR      R1,[SP, #+24]
   \      0x130   0xE3A0'B000        MOV      R11,#+0
   \      0x134   0xE59D'0024        LDR      R0,[SP, #+36]
   \      0x138   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x13C   0xE1B0'200B        MOVS     R2,R11
   \      0x140   0xE59D'1018        LDR      R1,[SP, #+24]
   \      0x144   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x148   0x....'....        BL       __aeabi_memset
   \      0x14C   0xE59D'0000        LDR      R0,[SP, #+0]
   1778          
   1779          	old_buffer = lcdc_put_image_rotated(layer_id, buffer, bpp,
   1780          			x, y, w, h, w, h, 0);
   \      0x150   0xE3A0'0000        MOV      R0,#+0
   \      0x154   0xE58D'0014        STR      R0,[SP, #+20]
   \      0x158   0xE1B0'0007        MOVS     R0,R7
   \      0x15C   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x160   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x164   0xE58D'0010        STR      R0,[SP, #+16]
   \      0x168   0xE1B0'0006        MOVS     R0,R6
   \      0x16C   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x170   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x174   0xE58D'000C        STR      R0,[SP, #+12]
   \      0x178   0xE1B0'0007        MOVS     R0,R7
   \      0x17C   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x180   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x184   0xE58D'0008        STR      R0,[SP, #+8]
   \      0x188   0xE1B0'0006        MOVS     R0,R6
   \      0x18C   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x190   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x194   0xE58D'0004        STR      R0,[SP, #+4]
   \      0x198   0xE1B0'0005        MOVS     R0,R5
   \      0x19C   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x1A0   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x1A4   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x1A8   0xE1B0'3004        MOVS     R3,R4
   \      0x1AC   0xE1A0'3803        LSL      R3,R3,#+16
   \      0x1B0   0xE1B0'3823        LSRS     R3,R3,#+16
   \      0x1B4   0xE5DD'2028        LDRB     R2,[SP, #+40]
   \      0x1B8   0xE59D'1024        LDR      R1,[SP, #+36]
   \      0x1BC   0xE5DD'0020        LDRB     R0,[SP, #+32]
   \      0x1C0   0x....'....        BL       lcdc_put_image_rotated
   1781          
   1782          	lcdc_canvas.layer_id = layer_id;
   \      0x1C4   0x....'....        LDR      R1,??DataTable30_30
   \      0x1C8   0xE5DD'2020        LDRB     R2,[SP, #+32]
   \      0x1CC   0xE5C1'2009        STRB     R2,[R1, #+9]
   1783          	lcdc_canvas.bpp = bpp;
   \      0x1D0   0xE5DD'2028        LDRB     R2,[SP, #+40]
   \      0x1D4   0xE5C1'2008        STRB     R2,[R1, #+8]
   1784          	lcdc_canvas.buffer = buffer;
   \      0x1D8   0xE59D'2024        LDR      R2,[SP, #+36]
   \      0x1DC   0xE581'2000        STR      R2,[R1, #+0]
   1785          	lcdc_canvas.width = w;
   \      0x1E0   0xE1C1'60B4        STRH     R6,[R1, #+4]
   1786          	lcdc_canvas.height = h;
   \      0x1E4   0xE1C1'70B6        STRH     R7,[R1, #+6]
   1787          
   1788          	return old_buffer;
   \                     ??lcdc_create_canvas_6:
   \      0x1E8   0xE28D'D02C        ADD      SP,SP,#+44
   \      0x1EC   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
   1789          }
   1790          
   1791          /**
   1792           * Create a blank canvas on a display layer for YUV422/420 planar.
   1793           * \param layer_id Layer ID.
   1794           * \param buffer   Pointer to buffer of Y.
   1795           * \param buffer_u Pointer to buffer of U.
   1796           * \param buffer_v Pointer to buffer of V.
   1797           * \param bpp      Bits Per Pixel.
   1798           * \param x        Canvas X coordinate on base.
   1799           * \param y        Canvas Y coordinate on base.
   1800           * \param w        Canvas width.
   1801           * \param h        Canvas height.
   1802           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1803          void *lcdc_create_canvas_yuv_planar(uint8_t layer_id,
   1804          		void *buffer_y, void *buffer_u, void *buffer_v, uint8_t bpp,
   1805          		uint16_t x, uint16_t y, uint16_t w, uint16_t h)
   1806          {
   \                     lcdc_create_canvas_yuv_planar:
   \        0x0   0xE92D'4FFF        PUSH     {R0-R11,LR}
   \        0x4   0xE24D'D014        SUB      SP,SP,#+20
   \        0x8   0xE1DD'44BC        LDRH     R4,[SP, #+76]
   \        0xC   0xE1DD'55B0        LDRH     R5,[SP, #+80]
   \       0x10   0xE1DD'65B4        LDRH     R6,[SP, #+84]
   \       0x14   0xE1DD'75B8        LDRH     R7,[SP, #+88]
   1807          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \       0x18   0x....'....        LDR      R0,??DataTable30_3
   \       0x1C   0xE5DD'1014        LDRB     R1,[SP, #+20]
   \       0x20   0xE3A0'2034        MOV      R2,#+52
   \       0x24   0xE011'0192        MULS     R1,R2,R1
   \       0x28   0xE090'8001        ADDS     R8,R0,R1
   1808          
   1809          	uint32_t max_w = lcdc_config.width;
   \       0x2C   0x....'....        LDR      R0,??DataTable30
   \       0x30   0xE1D0'90B0        LDRH     R9,[R0, #+0]
   1810          	uint32_t max_h = lcdc_config.height;
   \       0x34   0xE1D0'10B2        LDRH     R1,[R0, #+2]
   \       0x38   0xE58D'100C        STR      R1,[SP, #+12]
   1811          	uint32_t bits_per_row, bytes_per_row;
   1812          
   1813          	if (!layer->reg_dma_u_head || !layer->reg_dma_v_head)
   \       0x3C   0xE598'1014        LDR      R1,[R8, #+20]
   \       0x40   0xE351'0000        CMP      R1,#+0
   \       0x44   0x0A00'0002        BEQ      ??lcdc_create_canvas_yuv_planar_0
   \       0x48   0xE598'1018        LDR      R1,[R8, #+24]
   \       0x4C   0xE351'0000        CMP      R1,#+0
   \       0x50   0x1A00'0001        BNE      ??lcdc_create_canvas_yuv_planar_1
   1814          		return NULL;
   \                     ??lcdc_create_canvas_yuv_planar_0:
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0xEA00'007D        B        ??lcdc_create_canvas_yuv_planar_2
   1815          
   1816          	/* Size check */
   1817          	if (x + w > lcdc_config.width || y + h > lcdc_config.height)
   \                     ??lcdc_create_canvas_yuv_planar_1:
   \       0x5C   0xE1D0'10B0        LDRH     R1,[R0, #+0]
   \       0x60   0xE1B0'2004        MOVS     R2,R4
   \       0x64   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x68   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0x6C   0xE1B0'3006        MOVS     R3,R6
   \       0x70   0xE1A0'3803        LSL      R3,R3,#+16
   \       0x74   0xE1B0'3823        LSRS     R3,R3,#+16
   \       0x78   0xE093'2002        ADDS     R2,R3,R2
   \       0x7C   0xE151'0002        CMP      R1,R2
   \       0x80   0xBA00'0009        BLT      ??lcdc_create_canvas_yuv_planar_3
   \       0x84   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \       0x88   0xE1B0'1005        MOVS     R1,R5
   \       0x8C   0xE1A0'1801        LSL      R1,R1,#+16
   \       0x90   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x94   0xE1B0'2007        MOVS     R2,R7
   \       0x98   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x9C   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0xA0   0xE092'1001        ADDS     R1,R2,R1
   \       0xA4   0xE150'0001        CMP      R0,R1
   \       0xA8   0xAA00'0001        BGE      ??lcdc_create_canvas_yuv_planar_4
   1818          		return NULL;
   \                     ??lcdc_create_canvas_yuv_planar_3:
   \       0xAC   0xE3A0'0000        MOV      R0,#+0
   \       0xB0   0xEA00'0067        B        ??lcdc_create_canvas_yuv_planar_2
   1819          	if (w == 0)
   \                     ??lcdc_create_canvas_yuv_planar_4:
   \       0xB4   0xE1B0'0006        MOVS     R0,R6
   \       0xB8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xBC   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xC0   0xE350'0000        CMP      R0,#+0
   \       0xC4   0x1A00'0002        BNE      ??lcdc_create_canvas_yuv_planar_5
   1820          		w = max_w - x;
   \       0xC8   0xE1B0'0009        MOVS     R0,R9
   \       0xCC   0xE050'0004        SUBS     R0,R0,R4
   \       0xD0   0xE1B0'6000        MOVS     R6,R0
   1821          	if (h == 0)
   \                     ??lcdc_create_canvas_yuv_planar_5:
   \       0xD4   0xE1B0'0007        MOVS     R0,R7
   \       0xD8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xDC   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xE0   0xE350'0000        CMP      R0,#+0
   \       0xE4   0x1A00'0002        BNE      ??lcdc_create_canvas_yuv_planar_6
   1822          		h = max_h - y;
   \       0xE8   0xE59D'000C        LDR      R0,[SP, #+12]
   \       0xEC   0xE050'0005        SUBS     R0,R0,R5
   \       0xF0   0xE1B0'7000        MOVS     R7,R0
   1823          
   1824          	/* Clear buffer */
   1825          	bits_per_row = w * bpp;
   \                     ??lcdc_create_canvas_yuv_planar_6:
   \       0xF4   0xE1B0'0006        MOVS     R0,R6
   \       0xF8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xFC   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x100   0xE5DD'1048        LDRB     R1,[SP, #+72]
   \      0x104   0xE010'0091        MULS     R0,R1,R0
   \      0x108   0xE58D'0000        STR      R0,[SP, #+0]
   1826          	bytes_per_row = (bits_per_row & 0x7) ? (bits_per_row / 8 + 1) : (bits_per_row / 8);
   \      0x10C   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x110   0xE310'0007        TST      R0,#0x7
   \      0x114   0x0A00'0003        BEQ      ??lcdc_create_canvas_yuv_planar_7
   \      0x118   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x11C   0xE3A0'1001        MOV      R1,#+1
   \      0x120   0xE091'A1A0        ADDS     R10,R1,R0, LSR #+3
   \      0x124   0xEA00'0001        B        ??lcdc_create_canvas_yuv_planar_8
   \                     ??lcdc_create_canvas_yuv_planar_7:
   \      0x128   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x12C   0xE1B0'A1A0        LSRS     R10,R0,#+3
   1827          	memset(buffer_y, 0xFF, bytes_per_row * h);
   \                     ??lcdc_create_canvas_yuv_planar_8:
   \      0x130   0xE1B0'0007        MOVS     R0,R7
   \      0x134   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x138   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x13C   0xE011'0A90        MULS     R1,R0,R10
   \      0x140   0xE58D'1008        STR      R1,[SP, #+8]
   \      0x144   0xE3A0'B0FF        MOV      R11,#+255
   \      0x148   0xE59D'0018        LDR      R0,[SP, #+24]
   \      0x14C   0xE58D'0004        STR      R0,[SP, #+4]
   \      0x150   0xE1B0'200B        MOVS     R2,R11
   \      0x154   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x158   0xE59D'0004        LDR      R0,[SP, #+4]
   \      0x15C   0x....'....        BL       __aeabi_memset
   \      0x160   0xE59D'0004        LDR      R0,[SP, #+4]
   1828          
   1829          	/* Setup window */
   1830          	if (layer->reg_win) {
   \      0x164   0xE598'0020        LDR      R0,[R8, #+32]
   \      0x168   0xE350'0000        CMP      R0,#+0
   \      0x16C   0x0A00'0028        BEQ      ??lcdc_create_canvas_yuv_planar_9
   1831          		layer->reg_win[0] = LCDC_HEOCFG2_XPOS(x) | LCDC_HEOCFG2_YPOS(y);
   \      0x170   0xE3A0'0670        MOV      R0,#+117440512
   \      0x174   0xE380'08FF        ORR      R0,R0,#0xFF0000
   \      0x178   0xE3A0'10FF        MOV      R1,#+255
   \      0x17C   0xE381'1E70        ORR      R1,R1,#0x700
   \      0x180   0xE1B0'2004        MOVS     R2,R4
   \      0x184   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x188   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x18C   0xE011'2002        ANDS     R2,R1,R2
   \      0x190   0xE1B0'3005        MOVS     R3,R5
   \      0x194   0xE1A0'3803        LSL      R3,R3,#+16
   \      0x198   0xE1B0'3823        LSRS     R3,R3,#+16
   \      0x19C   0xE010'3803        ANDS     R3,R0,R3, LSL #+16
   \      0x1A0   0xE193'2002        ORRS     R2,R3,R2
   \      0x1A4   0xE598'3020        LDR      R3,[R8, #+32]
   \      0x1A8   0xE583'2000        STR      R2,[R3, #+0]
   1832          		layer->reg_win[1] = LCDC_HEOCFG3_XSIZE(w - 1) | LCDC_HEOCFG3_YSIZE(h - 1);
   \      0x1AC   0xE1B0'2006        MOVS     R2,R6
   \      0x1B0   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1B4   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x1B8   0xE252'2001        SUBS     R2,R2,#+1
   \      0x1BC   0xE011'2002        ANDS     R2,R1,R2
   \      0x1C0   0xE1B0'3007        MOVS     R3,R7
   \      0x1C4   0xE1A0'3803        LSL      R3,R3,#+16
   \      0x1C8   0xE1B0'3823        LSRS     R3,R3,#+16
   \      0x1CC   0xE253'3001        SUBS     R3,R3,#+1
   \      0x1D0   0xE010'3803        ANDS     R3,R0,R3, LSL #+16
   \      0x1D4   0xE193'2002        ORRS     R2,R3,R2
   \      0x1D8   0xE598'3020        LDR      R3,[R8, #+32]
   \      0x1DC   0xE583'2004        STR      R2,[R3, #+4]
   1833          		layer->reg_win[2] = LCDC_HEOCFG4_XMEMSIZE(w - 1) | LCDC_HEOCFG4_YMEMSIZE(h - 1);
   \      0x1E0   0xE1B0'2006        MOVS     R2,R6
   \      0x1E4   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1E8   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x1EC   0xE252'2001        SUBS     R2,R2,#+1
   \      0x1F0   0xE011'1002        ANDS     R1,R1,R2
   \      0x1F4   0xE1B0'2007        MOVS     R2,R7
   \      0x1F8   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1FC   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x200   0xE252'2001        SUBS     R2,R2,#+1
   \      0x204   0xE010'0802        ANDS     R0,R0,R2, LSL #+16
   \      0x208   0xE190'0001        ORRS     R0,R0,R1
   \      0x20C   0xE598'1020        LDR      R1,[R8, #+32]
   \      0x210   0xE581'0008        STR      R0,[R1, #+8]
   1834          	}
   1835          
   1836          	_set_dma_desc(buffer_y, layer->data->dma_desc, layer->reg_dma_head);
   \                     ??lcdc_create_canvas_yuv_planar_9:
   \      0x214   0xE598'2010        LDR      R2,[R8, #+16]
   \      0x218   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x21C   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x220   0xE59D'0018        LDR      R0,[SP, #+24]
   \      0x224   0x....'....        BL       _set_dma_desc
   1837          	_set_dma_desc(buffer_u, layer->data->dma_u_desc, layer->reg_dma_u_head);
   \      0x228   0xE598'2014        LDR      R2,[R8, #+20]
   \      0x22C   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x230   0xE590'1004        LDR      R1,[R0, #+4]
   \      0x234   0xE59D'001C        LDR      R0,[SP, #+28]
   \      0x238   0x....'....        BL       _set_dma_desc
   1838          	_set_dma_desc(buffer_v, layer->data->dma_v_desc, layer->reg_dma_v_head);
   \      0x23C   0xE598'2018        LDR      R2,[R8, #+24]
   \      0x240   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x244   0xE590'1008        LDR      R1,[R0, #+8]
   \      0x248   0xE59D'0020        LDR      R0,[SP, #+32]
   \      0x24C   0x....'....        BL       _set_dma_desc
   1839          
   1840          	return 0;
   \      0x250   0xE3A0'0000        MOV      R0,#+0
   \                     ??lcdc_create_canvas_yuv_planar_2:
   \      0x254   0xE28D'D024        ADD      SP,SP,#+36
   \      0x258   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
   1841          }
   1842          
   1843          /**
   1844           * Create a blank canvas on a display layer for YUV422/420 semiplanar.
   1845           * \param layer_id  Layer ID.
   1846           * \param buffer    Pointer to buffer of Y.
   1847           * \param buffer_uv Pointer to buffer of UV.
   1848           * \param bpp       Bits Per Pixel.
   1849           * \param x         Canvas X coordinate on base.
   1850           * \param y         Canvas Y coordinate on base.
   1851           * \param w         Canvas width.
   1852           * \param h         Canvas height.
   1853           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1854          void *lcdc_create_canvas_yuv_semiplanar(uint8_t layer_id,
   1855          		void *buffer_y, void *buffer_uv, uint8_t bpp,
   1856          		uint16_t x, uint16_t y, uint16_t w, uint16_t h)
   1857          {
   \                     lcdc_create_canvas_yuv_semiplanar:
   \        0x0   0xE92D'4FFF        PUSH     {R0-R11,LR}
   \        0x4   0xE24D'D014        SUB      SP,SP,#+20
   \        0x8   0xE1DD'44B8        LDRH     R4,[SP, #+72]
   \        0xC   0xE1DD'54BC        LDRH     R5,[SP, #+76]
   \       0x10   0xE1DD'65B0        LDRH     R6,[SP, #+80]
   \       0x14   0xE1DD'75B4        LDRH     R7,[SP, #+84]
   1858          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \       0x18   0x....'....        LDR      R0,??DataTable30_3
   \       0x1C   0xE5DD'1014        LDRB     R1,[SP, #+20]
   \       0x20   0xE3A0'2034        MOV      R2,#+52
   \       0x24   0xE011'0192        MULS     R1,R2,R1
   \       0x28   0xE090'8001        ADDS     R8,R0,R1
   1859          
   1860          	uint32_t max_w = lcdc_config.width;
   \       0x2C   0x....'....        LDR      R0,??DataTable30
   \       0x30   0xE1D0'90B0        LDRH     R9,[R0, #+0]
   1861          	uint32_t max_h = lcdc_config.height;
   \       0x34   0xE1D0'10B2        LDRH     R1,[R0, #+2]
   \       0x38   0xE58D'100C        STR      R1,[SP, #+12]
   1862          	uint32_t bits_per_row, bytes_per_row;
   1863          
   1864          	if (!layer->reg_dma_u_head || !layer->reg_dma_v_head)
   \       0x3C   0xE598'1014        LDR      R1,[R8, #+20]
   \       0x40   0xE351'0000        CMP      R1,#+0
   \       0x44   0x0A00'0002        BEQ      ??lcdc_create_canvas_yuv_semiplanar_0
   \       0x48   0xE598'1018        LDR      R1,[R8, #+24]
   \       0x4C   0xE351'0000        CMP      R1,#+0
   \       0x50   0x1A00'0001        BNE      ??lcdc_create_canvas_yuv_semiplanar_1
   1865          		return NULL;
   \                     ??lcdc_create_canvas_yuv_semiplanar_0:
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0xEA00'0078        B        ??lcdc_create_canvas_yuv_semiplanar_2
   1866          
   1867          	/* Size check */
   1868          	if (x + w > lcdc_config.width || y + h > lcdc_config.height)
   \                     ??lcdc_create_canvas_yuv_semiplanar_1:
   \       0x5C   0xE1D0'10B0        LDRH     R1,[R0, #+0]
   \       0x60   0xE1B0'2004        MOVS     R2,R4
   \       0x64   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x68   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0x6C   0xE1B0'3006        MOVS     R3,R6
   \       0x70   0xE1A0'3803        LSL      R3,R3,#+16
   \       0x74   0xE1B0'3823        LSRS     R3,R3,#+16
   \       0x78   0xE093'2002        ADDS     R2,R3,R2
   \       0x7C   0xE151'0002        CMP      R1,R2
   \       0x80   0xBA00'0009        BLT      ??lcdc_create_canvas_yuv_semiplanar_3
   \       0x84   0xE1D0'00B2        LDRH     R0,[R0, #+2]
   \       0x88   0xE1B0'1005        MOVS     R1,R5
   \       0x8C   0xE1A0'1801        LSL      R1,R1,#+16
   \       0x90   0xE1B0'1821        LSRS     R1,R1,#+16
   \       0x94   0xE1B0'2007        MOVS     R2,R7
   \       0x98   0xE1A0'2802        LSL      R2,R2,#+16
   \       0x9C   0xE1B0'2822        LSRS     R2,R2,#+16
   \       0xA0   0xE092'1001        ADDS     R1,R2,R1
   \       0xA4   0xE150'0001        CMP      R0,R1
   \       0xA8   0xAA00'0001        BGE      ??lcdc_create_canvas_yuv_semiplanar_4
   1869          		return NULL;
   \                     ??lcdc_create_canvas_yuv_semiplanar_3:
   \       0xAC   0xE3A0'0000        MOV      R0,#+0
   \       0xB0   0xEA00'0062        B        ??lcdc_create_canvas_yuv_semiplanar_2
   1870          	if (w == 0)
   \                     ??lcdc_create_canvas_yuv_semiplanar_4:
   \       0xB4   0xE1B0'0006        MOVS     R0,R6
   \       0xB8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xBC   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xC0   0xE350'0000        CMP      R0,#+0
   \       0xC4   0x1A00'0002        BNE      ??lcdc_create_canvas_yuv_semiplanar_5
   1871          		w = max_w - x;
   \       0xC8   0xE1B0'0009        MOVS     R0,R9
   \       0xCC   0xE050'0004        SUBS     R0,R0,R4
   \       0xD0   0xE1B0'6000        MOVS     R6,R0
   1872          	if (h == 0)
   \                     ??lcdc_create_canvas_yuv_semiplanar_5:
   \       0xD4   0xE1B0'0007        MOVS     R0,R7
   \       0xD8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xDC   0xE1B0'0820        LSRS     R0,R0,#+16
   \       0xE0   0xE350'0000        CMP      R0,#+0
   \       0xE4   0x1A00'0002        BNE      ??lcdc_create_canvas_yuv_semiplanar_6
   1873          		h = max_h - y;
   \       0xE8   0xE59D'000C        LDR      R0,[SP, #+12]
   \       0xEC   0xE050'0005        SUBS     R0,R0,R5
   \       0xF0   0xE1B0'7000        MOVS     R7,R0
   1874          
   1875          	/* Clear buffer */
   1876          	bits_per_row = w * bpp;
   \                     ??lcdc_create_canvas_yuv_semiplanar_6:
   \       0xF4   0xE1B0'0006        MOVS     R0,R6
   \       0xF8   0xE1A0'0800        LSL      R0,R0,#+16
   \       0xFC   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x100   0xE5DD'1020        LDRB     R1,[SP, #+32]
   \      0x104   0xE010'0091        MULS     R0,R1,R0
   \      0x108   0xE58D'0000        STR      R0,[SP, #+0]
   1877          	bytes_per_row = (bits_per_row & 0x7) ? (bits_per_row / 8 + 1) : (bits_per_row / 8);
   \      0x10C   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x110   0xE310'0007        TST      R0,#0x7
   \      0x114   0x0A00'0003        BEQ      ??lcdc_create_canvas_yuv_semiplanar_7
   \      0x118   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x11C   0xE3A0'1001        MOV      R1,#+1
   \      0x120   0xE091'A1A0        ADDS     R10,R1,R0, LSR #+3
   \      0x124   0xEA00'0001        B        ??lcdc_create_canvas_yuv_semiplanar_8
   \                     ??lcdc_create_canvas_yuv_semiplanar_7:
   \      0x128   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x12C   0xE1B0'A1A0        LSRS     R10,R0,#+3
   1878          	memset(buffer_y, 0xFF, bytes_per_row * h);
   \                     ??lcdc_create_canvas_yuv_semiplanar_8:
   \      0x130   0xE1B0'0007        MOVS     R0,R7
   \      0x134   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x138   0xE1B0'0820        LSRS     R0,R0,#+16
   \      0x13C   0xE011'0A90        MULS     R1,R0,R10
   \      0x140   0xE58D'1008        STR      R1,[SP, #+8]
   \      0x144   0xE3A0'B0FF        MOV      R11,#+255
   \      0x148   0xE59D'0018        LDR      R0,[SP, #+24]
   \      0x14C   0xE58D'0004        STR      R0,[SP, #+4]
   \      0x150   0xE1B0'200B        MOVS     R2,R11
   \      0x154   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x158   0xE59D'0004        LDR      R0,[SP, #+4]
   \      0x15C   0x....'....        BL       __aeabi_memset
   \      0x160   0xE59D'0004        LDR      R0,[SP, #+4]
   1879          
   1880          	if (layer->reg_win) {
   \      0x164   0xE598'0020        LDR      R0,[R8, #+32]
   \      0x168   0xE350'0000        CMP      R0,#+0
   \      0x16C   0x0A00'0028        BEQ      ??lcdc_create_canvas_yuv_semiplanar_9
   1881          		layer->reg_win[0] = LCDC_HEOCFG2_XPOS(x) | LCDC_HEOCFG2_YPOS(y);
   \      0x170   0xE3A0'0670        MOV      R0,#+117440512
   \      0x174   0xE380'08FF        ORR      R0,R0,#0xFF0000
   \      0x178   0xE3A0'10FF        MOV      R1,#+255
   \      0x17C   0xE381'1E70        ORR      R1,R1,#0x700
   \      0x180   0xE1B0'2004        MOVS     R2,R4
   \      0x184   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x188   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x18C   0xE011'2002        ANDS     R2,R1,R2
   \      0x190   0xE1B0'3005        MOVS     R3,R5
   \      0x194   0xE1A0'3803        LSL      R3,R3,#+16
   \      0x198   0xE1B0'3823        LSRS     R3,R3,#+16
   \      0x19C   0xE010'3803        ANDS     R3,R0,R3, LSL #+16
   \      0x1A0   0xE193'2002        ORRS     R2,R3,R2
   \      0x1A4   0xE598'3020        LDR      R3,[R8, #+32]
   \      0x1A8   0xE583'2000        STR      R2,[R3, #+0]
   1882          		layer->reg_win[1] = LCDC_HEOCFG3_XSIZE(w - 1) | LCDC_HEOCFG3_YSIZE(h - 1);
   \      0x1AC   0xE1B0'2006        MOVS     R2,R6
   \      0x1B0   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1B4   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x1B8   0xE252'2001        SUBS     R2,R2,#+1
   \      0x1BC   0xE011'2002        ANDS     R2,R1,R2
   \      0x1C0   0xE1B0'3007        MOVS     R3,R7
   \      0x1C4   0xE1A0'3803        LSL      R3,R3,#+16
   \      0x1C8   0xE1B0'3823        LSRS     R3,R3,#+16
   \      0x1CC   0xE253'3001        SUBS     R3,R3,#+1
   \      0x1D0   0xE010'3803        ANDS     R3,R0,R3, LSL #+16
   \      0x1D4   0xE193'2002        ORRS     R2,R3,R2
   \      0x1D8   0xE598'3020        LDR      R3,[R8, #+32]
   \      0x1DC   0xE583'2004        STR      R2,[R3, #+4]
   1883          		layer->reg_win[2] = LCDC_HEOCFG4_XMEMSIZE(w - 1) | LCDC_HEOCFG4_YMEMSIZE(h - 1);
   \      0x1E0   0xE1B0'2006        MOVS     R2,R6
   \      0x1E4   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1E8   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x1EC   0xE252'2001        SUBS     R2,R2,#+1
   \      0x1F0   0xE011'1002        ANDS     R1,R1,R2
   \      0x1F4   0xE1B0'2007        MOVS     R2,R7
   \      0x1F8   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x1FC   0xE1B0'2822        LSRS     R2,R2,#+16
   \      0x200   0xE252'2001        SUBS     R2,R2,#+1
   \      0x204   0xE010'0802        ANDS     R0,R0,R2, LSL #+16
   \      0x208   0xE190'0001        ORRS     R0,R0,R1
   \      0x20C   0xE598'1020        LDR      R1,[R8, #+32]
   \      0x210   0xE581'0008        STR      R0,[R1, #+8]
   1884          	}
   1885          
   1886          	_set_dma_desc(buffer_y, layer->data->dma_desc, layer->reg_dma_head);
   \                     ??lcdc_create_canvas_yuv_semiplanar_9:
   \      0x214   0xE598'2010        LDR      R2,[R8, #+16]
   \      0x218   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x21C   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x220   0xE59D'0018        LDR      R0,[SP, #+24]
   \      0x224   0x....'....        BL       _set_dma_desc
   1887          	_set_dma_desc(buffer_uv, layer->data->dma_u_desc, layer->reg_dma_u_head);
   \      0x228   0xE598'2014        LDR      R2,[R8, #+20]
   \      0x22C   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x230   0xE590'1004        LDR      R1,[R0, #+4]
   \      0x234   0xE59D'001C        LDR      R0,[SP, #+28]
   \      0x238   0x....'....        BL       _set_dma_desc
   1888          
   1889          	return 0;
   \      0x23C   0xE3A0'0000        MOV      R0,#+0
   \                     ??lcdc_create_canvas_yuv_semiplanar_2:
   \      0x240   0xE28D'D024        ADD      SP,SP,#+36
   \      0x244   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
   1890          }
   1891          
   1892          #ifdef CONFIG_HAVE_LCDC_PP
   1893          /**
   1894           * Connfigure PPC with DMA enabled.
   1895           * \param buffer       Pointer to buffer.
   1896           * \param output_mode  Post Processing output format selection.
   1897           */
   1898          void lcdc_configure_pp(void *buffer, uint32_t output_mode)
   1899          {
   1900          	const struct _layer_info *layer = &lcdc_layers[LCDC_PP];
   1901          
   1902          	_set_dma_desc(buffer, layer->data->dma_desc, layer->reg_dma_head);
   1903          	layer->reg_dma_head[0] = (uint32_t)layer->data->dma_desc;
   1904          	LCDC->LCDC_PPCFG1 = output_mode;
   1905          }
   1906          #endif
   1907          
   1908          /**
   1909           * \brief Change RGB Input Mode Selection for given layer.
   1910           * \param layer_id   Layer ID.
   1911           * \param input_mode RGB Input Mode Selection.
   1912           */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1913          void lcdc_configure_input_mode(uint8_t layer_id, uint32_t input_mode)
   1914          {
   1915          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \                     lcdc_configure_input_mode:
   \        0x0   0x....'....        LDR      R2,??DataTable30_3
   \        0x4   0xE1B0'3000        MOVS     R3,R0
   \        0x8   0xE213'30FF        ANDS     R3,R3,#0xFF      ;; Zero extend
   \        0xC   0xE3A0'C034        MOV      R12,#+52
   \       0x10   0xE013'039C        MULS     R3,R12,R3
   \       0x14   0xE092'2003        ADDS     R2,R2,R3
   1916          	layer->reg_cfg[1] = input_mode;
   \       0x18   0xE592'301C        LDR      R3,[R2, #+28]
   \       0x1C   0xE583'1004        STR      R1,[R3, #+4]
   1917          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
   1918          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1919          uint32_t lcdc_configure_get_mode(uint8_t layer_id)
   1920          {
   \                     lcdc_configure_get_mode:
   \        0x0   0xE1B0'1000        MOVS     R1,R0
   1921          	const struct _layer_info *layer = &lcdc_layers[layer_id];
   \        0x4   0x....'....        LDR      R0,??DataTable30_3
   \        0x8   0xE1B0'2001        MOVS     R2,R1
   \        0xC   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x10   0xE3A0'3034        MOV      R3,#+52
   \       0x14   0xE012'0293        MULS     R2,R3,R2
   \       0x18   0xE090'0002        ADDS     R0,R0,R2
   1922          	return layer->reg_cfg[1];
   \       0x1C   0xE590'001C        LDR      R0,[R0, #+28]
   \       0x20   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
   1923          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0xF803'8028        DC32     0xf8038028

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x0050'5050        DC32     0x505050

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x00A0'A0A0        DC32     0xa0a0a0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     lcdc_config

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0x....'....        DC32     base_dma_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_3:
   \        0x0   0x....'....        DC32     ovr1_dma_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_4:
   \        0x0   0x....'....        DC32     ovr2_dma_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_5:
   \        0x0   0x....'....        DC32     heo_dma_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_6:
   \        0x0   0x....'....        DC32     heo_dma_u_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_7:
   \        0x0   0x....'....        DC32     heo_dma_v_desc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_8:
   \        0x0   0x....'....        DC32     lcdc_canvas

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_9:
   \        0x0   0xF803'8030        DC32     0xf8038030

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_10:
   \        0x0   0xF803'808C        DC32     0xf803808c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_11:
   \        0x0   0xF803'8090        DC32     0xf8038090

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_12:
   \        0x0   0xF803'818C        DC32     0xf803818c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_13:
   \        0x0   0xF803'8190        DC32     0xf8038190

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_14:
   \        0x0   0xF803'81B0        DC32     0xf80381b0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_15:
   \        0x0   0xF803'828C        DC32     0xf803828c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_16:
   \        0x0   0xF803'8290        DC32     0xf8038290

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_17:
   \        0x0   0xF803'82B0        DC32     0xf80382b0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_18:
   \        0x0   0xF803'83AC        DC32     0xf80383ac

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_19:
   \        0x0   0xF803'83B0        DC32     0xf80383b0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_20:
   \        0x0   0xF803'83DC        DC32     0xf80383dc

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_21:
   \        0x0   0x4003'3094        DC32     0x40033094

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_22:
   \        0x0   0xF803'83E4        DC32     0xf80383e4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable21_23:
   \        0x0   0x7CDE'1C94        DC32     0x7cde1c94

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     lcdc_heo

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xF803'83E8        DC32     0xf80383e8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x5020'0094        DC32     0x50200094

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     lcdc_base

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     lcdc_ovr1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0x....'....        DC32     lcdc_ovr2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0xF803'83EC        DC32     0xf80383ec

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x....'....        DC32     lcdc_layers

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0xF803'8360        DC32     0xf8038360

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0x....'....        DC32     lcdc_config

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_2:
   \        0x0   0x....'....        DC32     `lcdc_base_auto_loop::dma_desc`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_3:
   \        0x0   0x....'....        DC32     lcdc_layers

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_4:
   \        0x0   0xF803'8068        DC32     0xf8038068

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_5:
   \        0x0   0xF803'807C        DC32     0xf803807c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_6:
   \        0x0   0xF803'8064        DC32     0xf8038064

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_7:
   \        0x0   0xF803'8168        DC32     0xf8038168

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_8:
   \        0x0   0xF803'817C        DC32     0xf803817c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_9:
   \        0x0   0xF803'8164        DC32     0xf8038164

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_10:
   \        0x0   0xF803'8368        DC32     0xf8038368

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_11:
   \        0x0   0xF803'837C        DC32     0xf803837c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_12:
   \        0x0   0xF803'838C        DC32     0xf803838c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_13:
   \        0x0   0xF803'839C        DC32     0xf803839c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_14:
   \        0x0   0xF803'8364        DC32     0xf8038364

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_15:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_16:
   \        0x0   0xF803'8004        DC32     0xf8038004

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_17:
   \        0x0   0xF803'8008        DC32     0xf8038008

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_18:
   \        0x0   0xF803'800C        DC32     0xf803800c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_19:
   \        0x0   0xF803'8010        DC32     0xf8038010

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_20:
   \        0x0   0x001E'0387        DC32     0x1e0387

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_21:
   \        0x0   0xF803'8014        DC32     0xf8038014

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_22:
   \        0x0   0xF803'8018        DC32     0xf8038018

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_23:
   \        0x0   0xF803'8020        DC32     0xf8038020

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_24:
   \        0x0   0xF803'8028        DC32     0xf8038028

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_25:
   \        0x0   0xF803'827C        DC32     0xf803827c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_26:
   \        0x0   0xF803'8264        DC32     0xf8038264

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_27:
   \        0x0   0xF803'809C        DC32     0xf803809c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_28:
   \        0x0   0xF803'8268        DC32     0xf8038268

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_29:
   \        0x0   0xF803'8024        DC32     0xf8038024

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable30_30:
   \        0x0   0x....'....        DC32     lcdc_canvas

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x54, 0x68, 0x65, 0x20

   \              0x2D 0x20    

   \              0x54 0x68    

   \              0x65 0x20
   \        0x8   0x44 0x4D          DC8 0x44, 0x4D, 0x41, 0x20, 0x6C, 0x69, 0x6E, 0x6B

   \              0x41 0x20    

   \              0x6C 0x69    

   \              0x6E 0x6B
   \       0x10   0x20 0x73          DC8 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x73

   \              0x69 0x7A    

   \              0x65 0x20    

   \              0x69 0x73
   \       0x18   0x20 0x6E          DC8 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x75, 0x69

   \              0x6F 0x74    

   \              0x20 0x73    

   \              0x75 0x69
   \       0x20   0x74 0x61          DC8 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x6F

   \              0x62 0x6C    

   \              0x65 0x20    

   \              0x66 0x6F
   \       0x28   0x72 0x20          DC8 0x72, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x69, 0x6E

   \              0x73 0x68    

   \              0x6F 0x77    

   \              0x69 0x6E
   \       0x30   0x67 0x20          DC8 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F

   \              0x74 0x68    

   \              0x65 0x20    

   \              0x6C 0x6F
   \       0x38   0x6F 0x70          DC8 0x6F, 0x70, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63

   \              0x20 0x65    

   \              0x66 0x66    

   \              0x65 0x63
   \       0x40   0x74 0x73          DC8 0x74, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68

   \              0x20 0x6F    

   \              0x6E 0x20    

   \              0x74 0x68
   \       0x48   0x65 0x20          DC8 0x65, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x6C

   \              0x62 0x61    

   \              0x73 0x65    

   \              0x20 0x6C
   \       0x50   0x61 0x79          DC8 0x61, 0x79, 0x65, 0x72, 0x21, 0

   \              0x65 0x72    

   \              0x21 0x00
   \       0x56   0x00 0x00          DC8 0, 0
   1924          
   1925          /**@}*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _build_color_lut1
       0   _build_color_lut2
       0   _build_color_lut4
       0   _build_color_lut8
      16   _clear_dma_desc
        16   -> cache_clean_region
       0   _get_bits_per_pixel
       0   _set_dma_desc
       0   _wait_for_clock_domain_sync
      32   lcdc_base_auto_loop
        32   -> cache_clean_region
        32   -> printf
        32 __aeabi_uidiv
       8   lcdc_configure
         8   -> __aeabi_memcpy
         8   -> lcdc_off
         8   -> lcdc_on
         8   -> pmc_configure_peripheral
         8   -> pmc_enable_system_clock
         8   -> pmc_has_system_clock
       0   lcdc_configure_get_mode
       0   lcdc_configure_input_mode
      80   lcdc_create_canvas
        80   -> __aeabi_memset
        80   -> lcdc_put_image_rotated
      72   lcdc_create_canvas_yuv_planar
        72   -> __aeabi_memset
        72   -> _set_dma_desc
      72   lcdc_create_canvas_yuv_semiplanar
        72   -> __aeabi_memset
        72   -> _set_dma_desc
       0   lcdc_disable_color_keying
       8   lcdc_enable_alpha
       0   lcdc_enable_layer
       8   lcdc_flush_canvas
         8   -> cache_clean_region
         8   -> lcdc_get_canvas
       0   lcdc_get_alpha
       0   lcdc_get_canvas
       0   lcdc_get_priority
       0   lcdc_is_layer_on
       8   lcdc_off
         8   -> _clear_dma_desc
         8   -> pmc_disable_peripheral
         8   -> pmc_disable_system_clock
         8   -> pmc_has_system_clock
      40   lcdc_on
        40   -> _wait_for_clock_domain_sync
        40   -> pmc_configure_peripheral
        40   -> pmc_enable_system_clock
        40   -> pmc_get_gck_clock
        40   -> pmc_get_master_clock
        40   -> pmc_has_system_clock
        40 __aeabi_uidiv
      56   lcdc_put_image
        56   -> lcdc_put_image_rotated
      32   lcdc_put_image_rotated
        32   -> _set_dma_desc
      48   lcdc_put_image_scaled
        48   -> lcdc_put_image_rotated
       0   lcdc_refresh
      16   lcdc_select_canvas
        16   -> _get_bits_per_pixel
       8   lcdc_set_alpha
       0   lcdc_set_backlight
       8   lcdc_set_color_keying
      24   lcdc_set_color_lut
        24   -> _build_color_lut1
        24   -> _build_color_lut2
        24   -> _build_color_lut4
        24   -> _build_color_lut8
      20   lcdc_set_position
       0   lcdc_set_priority
      32   lcdc_show_base
        32   -> lcdc_put_image
      48   lcdc_show_heo
        48   -> lcdc_put_image_rotated
      32   lcdc_show_ovr1
        32   -> lcdc_put_image
       8   lcdc_stop_base
         8   -> _clear_dma_desc
      16   lcdc_stop_heo
        16   -> _clear_dma_desc
       8   lcdc_stop_ovr1
         8   -> _clear_dma_desc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable26
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_20
       4  ??DataTable30_21
       4  ??DataTable30_22
       4  ??DataTable30_23
       4  ??DataTable30_24
       4  ??DataTable30_25
       4  ??DataTable30_26
       4  ??DataTable30_27
       4  ??DataTable30_28
       4  ??DataTable30_29
       4  ??DataTable30_3
       4  ??DataTable30_30
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      88  ?_0
       8  ?_1
      20  _build_color_lut1
      36  _build_color_lut2
      92  _build_color_lut4
      92  _build_color_lut8
      68  _clear_dma_desc
     396  _get_bits_per_pixel
      32  _set_dma_desc
      20  _wait_for_clock_domain_sync
      16  base_dma_desc
     640  dma_desc
      16  heo_dma_desc
      16  heo_dma_u_desc
      16  heo_dma_v_desc
      20  lcdc_base
     220  lcdc_base_auto_loop
      12  lcdc_canvas
      12  lcdc_config
     344  lcdc_configure
      40  lcdc_configure_get_mode
      36  lcdc_configure_input_mode
     496  lcdc_create_canvas
     604  lcdc_create_canvas_yuv_planar
     584  lcdc_create_canvas_yuv_semiplanar
     112  lcdc_disable_color_keying
     132  lcdc_enable_alpha
     140  lcdc_enable_layer
      40  lcdc_flush_canvas
      68  lcdc_get_alpha
       8  lcdc_get_canvas
      48  lcdc_get_priority
      20  lcdc_heo
      64  lcdc_is_layer_on
     312  lcdc_layers
     324  lcdc_off
     536  lcdc_on
      20  lcdc_ovr1
      20  lcdc_ovr2
     120  lcdc_put_image
     120  lcdc_put_image_rotated
     108  lcdc_put_image_scaled
     104  lcdc_refresh
     192  lcdc_select_canvas
     132  lcdc_set_alpha
      32  lcdc_set_backlight
     180  lcdc_set_color_keying
     208  lcdc_set_color_lut
     208  lcdc_set_position
      84  lcdc_set_priority
     112  lcdc_show_base
     100  lcdc_show_heo
      68  lcdc_show_ovr1
      64  lcdc_stop_base
      88  lcdc_stop_heo
      64  lcdc_stop_ovr1
      16  ovr1_dma_desc
      16  ovr2_dma_desc

 
   744 bytes in section .bss
    96 bytes in section .region_ddr_cache_aligned
   408 bytes in section .rodata
 6'804 bytes in section SOFTPACK
 
 6'804 bytes of CODE  memory
   408 bytes of CONST memory
   840 bytes of DATA  memory

Errors: none
Warnings: 1
