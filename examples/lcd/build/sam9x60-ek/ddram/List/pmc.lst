###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         15/Jan/2021  07:27:13
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW529B.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_LCD -D CONFIG_HAVE_LCDC -D CONFIG_HAVE_LCDC_OVR1 -D
#        CONFIG_HAVE_LCDC_OVR2 -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_DDR2_W972GG6KB -D CONFIG_HAVE_RSTC_EXTERNAL_RESET -D
#        CONFIG_HAVE_RSTC_INDEPENDENT_RESET -D CONFIG_HAVE_RTT -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List\pmc.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj\pmc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup pmc_module Working with PMC
     31           * \section Purpose
     32           * The PMC driver provides the Interface for configuration the Power Management
     33           *  Controller (PMC).
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li>  Enable & disable peripherals using pmc_enable_peripheral() and
     38           * pmc_enable_all_peripherals() or pmc_disable_peripheral() and
     39           * pmc_disable_all_peripherals().
     40           * <li>  Get & set maximum frequency clock for giving peripheral using
     41           * pmc_get_peri_max_freq() and pmc_set_peri_max_clock().
     42           * <li>  Get Peripheral Status for the given peripheral using pmc_is_periph_enabled()
     43           * <li>  Select clocks's source using pmc_select_external_crystal(),
     44           * pmc_select_internal_crystal(), pmc_select_external_osc() and pmc_select_internal_osc().
     45           * <li>  Switch MCK using pmc_switch_mck_to_pll(), pmc_switch_mck_to_main() and
     46           * pmc_switch_mck_to_slck().
     47           * <li>  Config PLL using pmc_set_pll_a() and pmc_disable_pll_a().
     48           * </li>
     49           * </ul>
     50           * For more accurate information, please look at the PMC section of the
     51           * Datasheet.
     52           *
     53           * Related files :\n
     54           * \ref pmc.c\n
     55           * \ref pmc.h\n
     56          */
     57          /*@{*/
     58          /*@}*/
     59          
     60          /**
     61           * \file
     62           *
     63           * Implementation of PIO (Parallel Input/Output) controller.
     64           *
     65           */
     66          /*----------------------------------------------------------------------------
     67           *        Headers
     68           *----------------------------------------------------------------------------*/
     69          
     70          #include <assert.h>
     71          #include <errno.h>
     72          #include <string.h>
     73          
     74          #include "chip.h"
     75          #include "timer.h"
     76          #include "peripherals/pmc.h"
     77          #include "peripherals/slowclock.h"
     78          #include "trace.h"
     79          #include "barriers.h"
     80          /*----------------------------------------------------------------------------
     81           *        Types
     82           *----------------------------------------------------------------------------*/
     83          
     84          struct _pmc_main_osc {
     85          	uint32_t rc_freq;
     86          	uint32_t crystal_freq;
     87          };
     88          
     89          #define OSC_STARTUP_TIME	0xFFu
     90          #define MAINFRDY_TIMEOUT	32000u
     91          #define MOSCXTS_TIMEOUT		((OSC_STARTUP_TIME * 8) + 8)
     92          #define MOSCSELS_TIMEOUT	32u
     93          
     94          /*----------------------------------------------------------------------------
     95           *        Variables
     96           *----------------------------------------------------------------------------*/
     97          

   \                                 In section .data, align 4
     98          RAMDATA static uint32_t _pmc_mck = 0;
     99          static struct _pmc_main_osc _pmc_main_oscillators = {
   \                     _pmc_main_oscillators:
   \        0x0   0x00B7'1B00        DC32 12'000'000
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x8   0x0000'0000        DC32 0
    100          	.rc_freq = MAIN_CLOCK_INT_OSC,
    101          };
    102          
    103          #ifdef CONFIG_RAMCODE
    104          	#define TRACE_FATAL(...) ((void)0)
    105          	#define _ASSERT(x) ((void)0)
    106          	#define _SLEEP(x) do { for(volatile uint32_t count = 0; count < 100; count++);} while(0)
    107          #else
    108          	#define TRACE_FATAL trace_fatal
    109          	#define _ASSERT assert
    110          	#define _SLEEP(x) do { usleep(x); } while(0)
    111          #endif
    112          
    113          /*----------------------------------------------------------------------------
    114           *        Private functions
    115           *----------------------------------------------------------------------------*/
    116          
    117          static void _pmc_compute_mck(void)
    118          {
    119          	uint32_t clk = 0;
    120          	uint32_t mckr = PMC->PMC_MCKR;
    121          
    122          	uint32_t css = mckr & PMC_MCKR_CSS_Msk;
    123          	switch (css) {
    124          	case PMC_MCKR_CSS_SLOW_CLK:
    125          		clk = pmc_get_slow_clock();
    126          		break;
    127          	case PMC_MCKR_CSS_MAIN_CLK:
    128          		clk = pmc_get_main_clock();
    129          		break;
    130          	case PMC_MCKR_CSS_PLLA_CLK:
    131          		clk = pmc_get_plla_clock();
    132          		break;
    133          	case PMC_MCKR_CSS_UPLL_CLK:
    134          		clk = pmc_get_upll_clock();
    135          		break;
    136          	default:
    137          		/* should never get here... */
    138          		break;
    139          	}
    140          
    141          	uint32_t pres = mckr & PMC_MCKR_PRES_Msk;
    142          	switch (pres) {
    143          	case PMC_MCKR_PRES_CLOCK:
    144          		break;
    145          	case PMC_MCKR_PRES_CLOCK_DIV2:
    146          		clk >>= 1;
    147          		break;
    148          	case PMC_MCKR_PRES_CLOCK_DIV4:
    149          		clk >>= 2;
    150          		break;
    151          	case PMC_MCKR_PRES_CLOCK_DIV8:
    152          		clk >>= 3;
    153          		break;
    154          	case PMC_MCKR_PRES_CLOCK_DIV16:
    155          		clk >>= 4;
    156          		break;
    157          	case PMC_MCKR_PRES_CLOCK_DIV32:
    158          		clk >>= 5;
    159          		break;
    160          	case PMC_MCKR_PRES_CLOCK_DIV64:
    161          		clk >>= 6;
    162          		break;
    163          #ifdef PMC_MCKR_PRES_CLOCK_DIV3
    164          	case PMC_MCKR_PRES_CLOCK_DIV3:
    165          		clk /= 3;
    166          		break;
    167          #endif
    168          	default:
    169          		/* should never get here... */
    170          		break;
    171          	}
    172          
    173          	uint32_t mdiv = mckr & PMC_MCKR_MDIV_Msk;
    174          	switch (mdiv) {
    175          	case PMC_MCKR_MDIV_EQ_PCK:
    176          		break;
    177          	case PMC_MCKR_MDIV_PCK_DIV2:
    178          		clk >>= 1; // divide by 2
    179          		break;
    180          	case PMC_MCKR_MDIV_PCK_DIV4:
    181          		clk >>= 2; // divide by 4
    182          		break;
    183          	case PMC_MCKR_MDIV_PCK_DIV3:
    184          		clk /= 3;  // divide by 3
    185          		break;
    186          	default:
    187          		/* should never get here... */
    188          		break;
    189          	}
    190          
    191          	_pmc_mck = clk;
    192          }
    193          
    194          static uint32_t _pmc_get_pck_clock(uint32_t index)
    195          {
    196          	uint32_t clk = 0;
    197          	uint32_t pck = PMC->PMC_PCK[index];
    198          
    199          	switch (pck & PMC_PCK_CSS_Msk) {
    200          	case PMC_PCK_CSS_SLOW_CLK:
    201          		clk = pmc_get_slow_clock();
    202          		break;
    203          	case PMC_PCK_CSS_MAIN_CLK:
    204          		clk = pmc_get_main_clock();
    205          		break;
    206          	case PMC_PCK_CSS_PLLA_CLK:
    207          		clk = pmc_get_plla_clock();
    208          		break;
    209          	case PMC_PCK_CSS_UPLL_CLK:
    210          		clk = pmc_get_upll_clock();
    211          		break;
    212          	case PMC_PCK_CSS_MCK:
    213          		clk = pmc_get_master_clock();
    214          		break;
    215          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    216          	case PMC_PCK_CSS_AUDIO_CLK:
    217          		clk = pmc_get_audio_pmc_clock();
    218          		break;
    219          #endif
    220          	}
    221          
    222          	uint32_t prescaler = (pck & PMC_PCK_PRES_Msk) >> PMC_PCK_PRES_Pos;
    223          	return clk / (prescaler + 1);
    224          }
    225          

   \                                 In section SOFTPACK, align 4, keep-with-next
    226          RAMCODE static bool _pmc_get_system_clock_bits(enum _pmc_system_clock clock,
    227          	uint32_t *scer, uint32_t* scdr, uint32_t *scsr)
    228          {
   \                     _pmc_get_system_clock_bits:
   \        0x0   0xE92D'4000        PUSH     {LR}
    229          	uint32_t e, d, s;
    230          
    231          	switch (clock)
   \        0x4   0xE350'000D        CMP      R0,#+13
   \        0x8   0x8A00'0016        BHI      ??_pmc_get_system_clock_bits_1
   \        0xC   0xE7DF'C000        LDRB     R12,[PC, R0]
   \       0x10   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??_pmc_get_system_clock_bits_0:
   \       0x14   0x03 0x14          DC8      0x3,0x14,0x14,0x5

   \              0x14 0x05
   \       0x18   0x14 0x07          DC8      0x14,0x7,0x9,0x14

   \              0x09 0x14
   \       0x1C   0x14 0x14          DC8      0x14,0x14,0x14,0x14

   \              0x14 0x14
   \       0x20   0x14 0x0B          DC8      0x14,0xB,0x0,0x0

   \              0x00 0x00
    232          	{
    233          #ifdef PMC_SCER_DDRCK
    234          	case PMC_SYSTEM_CLOCK_DDR:
    235          		e = PMC_SCER_DDRCK;
   \                     ??_pmc_get_system_clock_bits_2:
   \       0x24   0xE3A0'0004        MOV      R0,#+4
    236          		d = PMC_SCDR_DDRCK;
   \       0x28   0xEA00'0006        B        ??_pmc_get_system_clock_bits_3
    237          		s = PMC_SCSR_DDRCK;
    238          		break;
    239          #endif
    240          #ifdef PMC_SCER_LCDCK
    241          	case PMC_SYSTEM_CLOCK_LCD:
    242          		e = PMC_SCER_LCDCK;
    243          		d = PMC_SCDR_LCDCK;
    244          		s = PMC_SCSR_LCDCK;
    245          		break;
    246          #endif
    247          #ifdef PMC_SCER_SMDCK
    248          	case PMC_SYSTEM_CLOCK_SMD:
    249          		e = PMC_SCER_SMDCK;
    250          		d = PMC_SCDR_SMDCK;
    251          		s = PMC_SCSR_SMDCK;
    252          		break;
    253          #endif
    254          #ifdef PMC_SCER_UHP
    255          	case PMC_SYSTEM_CLOCK_UHP:
    256          		e = PMC_SCER_UHP;
   \                     ??_pmc_get_system_clock_bits_4:
   \       0x2C   0xE3A0'0040        MOV      R0,#+64
    257          		d = PMC_SCDR_UHP;
   \       0x30   0xEA00'0004        B        ??_pmc_get_system_clock_bits_3
    258          		s = PMC_SCSR_UHP;
    259          		break;
    260          #endif
    261          #ifdef PMC_SCER_UDP
    262          	case PMC_SYSTEM_CLOCK_UDP:
    263          		e = PMC_SCER_UDP;
    264          		d = PMC_SCDR_UDP;
    265          		s = PMC_SCSR_UDP;
    266          		break;
    267          #endif
    268          #ifdef PMC_SCER_PCK0
    269          	case PMC_SYSTEM_CLOCK_PCK0:
    270          		e = PMC_SCER_PCK0;
   \                     ??_pmc_get_system_clock_bits_5:
   \       0x34   0xE3A0'0F40        MOV      R0,#+256
    271          		d = PMC_SCDR_PCK0;
   \       0x38   0xEA00'0002        B        ??_pmc_get_system_clock_bits_3
    272          		s = PMC_SCSR_PCK0;
    273          		break;
    274          #endif
    275          #ifdef PMC_SCER_PCK1
    276          	case PMC_SYSTEM_CLOCK_PCK1:
    277          		e = PMC_SCER_PCK1;
   \                     ??_pmc_get_system_clock_bits_6:
   \       0x3C   0xE3A0'0F80        MOV      R0,#+512
    278          		d = PMC_SCDR_PCK1;
   \       0x40   0xEA00'0000        B        ??_pmc_get_system_clock_bits_3
    279          		s = PMC_SCSR_PCK1;
    280          		break;
    281          #endif
    282          #ifdef PMC_SCER_PCK2
    283          	case PMC_SYSTEM_CLOCK_PCK2:
    284          		e = PMC_SCER_PCK2;
    285          		d = PMC_SCDR_PCK2;
    286          		s = PMC_SCSR_PCK2;
    287          		break;
    288          #endif
    289          #ifdef PMC_SCER_PCK3
    290          	case PMC_SYSTEM_CLOCK_PCK3:
    291          		e = PMC_SCER_PCK3;
    292          		d = PMC_SCDR_PCK3;
    293          		s = PMC_SCSR_PCK3;
    294          		break;
    295          #endif
    296          #ifdef PMC_SCER_PCK4
    297          	case PMC_SYSTEM_CLOCK_PCK4:
    298          		e = PMC_SCER_PCK4;
    299          		d = PMC_SCDR_PCK4;
    300          		s = PMC_SCSR_PCK4;
    301          		break;
    302          #endif
    303          #ifdef PMC_SCER_PCK5
    304          	case PMC_SYSTEM_CLOCK_PCK5:
    305          		e = PMC_SCER_PCK5;
    306          		d = PMC_SCDR_PCK5;
    307          		s = PMC_SCSR_PCK5;
    308          		break;
    309          #endif
    310          #ifdef PMC_SCER_PCK6
    311          	case PMC_SYSTEM_CLOCK_PCK6:
    312          		e = PMC_SCER_PCK6;
    313          		d = PMC_SCDR_PCK6;
    314          		s = PMC_SCSR_PCK6;
    315          		break;
    316          #endif
    317          #ifdef PMC_SCER_ISCCK
    318          	case PMC_SYSTEM_CLOCK_ISC:
    319          		e = PMC_SCER_ISCCK;
    320          		d = PMC_SCDR_ISCCK;
    321          		s = PMC_SCSR_ISCCK;
    322          		break;
    323          #endif
    324          #ifdef PMC_SCER_QSPICLK
    325          	case PMC_SYSTEM_CLOCK_QSPI:
    326          		e = PMC_SCER_QSPICLK;
   \                     ??_pmc_get_system_clock_bits_7:
   \       0x44   0xE3A0'0A80        MOV      R0,#+524288
    327          		d = PMC_SCDR_QSPICLK;
    328          		s = PMC_SCSR_QSPICLK;
    329          		break;
    330          #endif
    331          	default:
    332          		return false;
    333          	}
    334          
    335          	if (scer) {
   \                     ??_pmc_get_system_clock_bits_3:
   \       0x48   0xE351'0000        CMP      R1,#+0
    336          		if (e)
    337          			*scer = e;
   \       0x4C   0x1581'0000        STRNE    R0,[R1, #+0]
    338          		else
    339          			return false;
    340          	}
    341          
    342          	if (scdr) {
   \       0x50   0xE352'0000        CMP      R2,#+0
    343          		if (d)
    344          			*scdr = d;
   \       0x54   0x1582'0000        STRNE    R0,[R2, #+0]
    345          		else
    346          			return false;
    347          	}
    348          
    349          	if (scsr) {
   \       0x58   0xE353'0000        CMP      R3,#+0
    350          		if (s)
    351          			*scsr = s;
   \       0x5C   0x1583'0000        STRNE    R0,[R3, #+0]
    352          		else
    353          			return false;
    354          	}
    355          
    356          	return true;
   \       0x60   0xE3A0'0001        MOV      R0,#+1
   \       0x64   0xE8BD'8000        POP      {PC}             ;; return
   \                     ??_pmc_get_system_clock_bits_1:
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xE8BD'8000        POP      {PC}
    357          }
    358          
    359          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
    360          static void _pmc_configure_peripheral_div(uint32_t id, uint32_t div)
    361          {
    362          	uint32_t clk_max;
    363          	bool can_divide;
    364          
    365          	can_divide = peripheral_has_clock_div(id);
    366          	clk_max = get_peripheral_clock_max_freq(id);
    367          
    368          	if (div == 0) {
    369          		if (can_divide) {
    370          			for (div = 0; div < ((PMC_PCR_DIV_Msk >> PMC_PCR_DIV_Pos)); div++)
    371          				if ((pmc_get_master_clock() >> div) <= clk_max)
    372          					break;
    373          		}
    374          	} else {
    375          		if (div > 1 && !can_divide)
    376          			TRACE_FATAL("Peripheral does not support divided clock\r\n");
    377          		div--;
    378          	}
    379          
    380          	if ((pmc_get_master_clock() >> div) <= clk_max) {
    381          		PMC->PMC_PCR = PMC_PCR_PID(id);
    382          		volatile uint32_t pcr = PMC->PMC_PCR;
    383          		PMC->PMC_PCR = (pcr & ~PMC_PCR_DIV_Msk) | PMC_PCR_DIV(div) | PMC_PCR_CMD;
    384          	} else {
    385          		TRACE_FATAL("Peripheral clock for periph#%d is too high\r\n", (int)id);
    386          	}
    387          }
    388          #endif
    389          
    390          static uint16_t _pmc_measure_main_osc_freq(bool external_xt)
    391          {
    392          	volatile uint32_t timeout = MAINFRDY_TIMEOUT;
    393          
    394          #ifdef CKGR_MCFR_CCSS
    395          	PMC->CKGR_MCFR = external_xt ? CKGR_MCFR_CCSS : 0;
    396          #endif
    397          
    398          #ifdef CKGR_MCFR_RCMEAS
    399          	PMC->CKGR_MCFR |= CKGR_MCFR_RCMEAS;
    400          #endif
    401          	dsb();
    402          	while (!(PMC->CKGR_MCFR & CKGR_MCFR_MAINFRDY) && (--timeout > 0));
    403          	return (timeout ?
    404          		((PMC->CKGR_MCFR & CKGR_MCFR_MAINF_Msk) >> CKGR_MCFR_MAINF_Pos) :
    405          		0u);
    406          }
    407          
    408          #if defined(PMC_PLL_UPDT_ID)

   \                                 In section SOFTPACK, align 4, keep-with-next
    409          RAMCODE static void _pmc_configure_pll(const struct _pmc_plla_cfg* plla)
    410          {
   \                     _pmc_configure_pll:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    411          	uint32_t reg;
    412          
    413          	if (plla->pll_id == PLL_ID_PLLA) {
   \        0x8   0xE594'100C        LDR      R1,[R4, #+12]
   \        0xC   0xE351'0000        CMP      R1,#+0
   \       0x10   0x0A00'000A        BEQ      ??_pmc_configure_pll_0
    414          	} else if (plla->pll_id == PLL_ID_UPLL){
   \       0x14   0xE351'0001        CMP      R1,#+1
   \       0x18   0x1A00'0061        BNE      ??_pmc_configure_pll_1
    415          		_ASSERT(plla->div == 1);
   \       0x1C   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x20   0xE350'0001        CMP      R0,#+1
   \       0x24   0x0A00'0005        BEQ      ??_pmc_configure_pll_0
   \       0x28   0xE3A0'209F        MOV      R2,#+159
   \       0x2C   0xE382'2F40        ORR      R2,R2,#0x100
   \       0x30   0x....'....        LDR      R1,??DataTable23
   \       0x34   0x....'....        LDR      R0,??DataTable23_1
   \       0x38   0x....'....        BL       __aeabi_assert
   \       0x3C   0x....'....        BL       __iar_EmptyStepPoint
    416          	} else {
    417          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)plla->pll_id);
    418          	}
    419          
    420          	/* Follow the steps below to power-on a PLL: */
    421          	/* 1. Define the ID (ID=n) and startup time by configuring the fields PMC_PLL_UPDT.ID and
    422          	PMC_PLL_UPDT.STUPTIM. Set PMC_PLL_UPDT.UPDATE to '0'. */
    423          	reg = PMC->PMC_PLL_UPDT;
   \                     ??_pmc_configure_pll_0:
   \       0x40   0xE3E0'00F3        MVN      R0,#+243
   \       0x44   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x48   0xE590'0010        LDR      R0,[R0, #+16]
    424          	reg &= ~(PMC_PLL_UPDT_STUPTIM_Msk | PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
    425          	reg |= PMC_PLL_UPDT_STUPTIM(plla->count);
   \       0x4C   0x....'....        LDR      R1,??DataTable23_2  ;; 0xff00fefe
   \       0x50   0xE3A0'28FF        MOV      R2,#+16711680
   \       0x54   0xE001'1000        AND      R1,R1,R0
   \       0x58   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x5C   0xE002'2800        AND      R2,R2,R0, LSL #+16
   \       0x60   0xE182'0001        ORR      R0,R2,R1
    426          	if (plla->pll_id)
   \       0x64   0xE594'100C        LDR      R1,[R4, #+12]
   \       0x68   0xE351'0000        CMP      R1,#+0
    427          		reg |= PMC_PLL_UPDT_ID;
    428          	PMC->PMC_PLL_UPDT = reg;
   \       0x6C   0xE3E0'10F3        MVN      R1,#+243
   \       0x70   0x1380'0001        ORRNE    R0,R0,#0x1
   \       0x74   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x78   0xE581'0010        STR      R0,[R1, #+16]
    429          	
    430          	if ((PMC -> PMC_PLL_ACR & PMC_PLL_ACR_UTMIBG) != PMC_PLL_ACR_UTMIBG) {
   \       0x7C   0xE1A0'0001        MOV      R0,R1
   \       0x80   0xE590'100C        LDR      R1,[R0, #+12]
   \       0x84   0xE311'0D80        TST      R1,#0x2000
   \       0x88   0x1A00'0006        BNE      ??_pmc_configure_pll_2
    431          		/* 2. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    432          		reg = PMC->PMC_PLL_ACR;
   \       0x8C   0xE590'000C        LDR      R0,[R0, #+12]
    433          		reg |= PMC_PLL_ACR_UTMIBG;
    434          		PMC->PMC_PLL_ACR = reg;
   \       0x90   0xE380'1D80        ORR      R1,R0,#0x2000
   \       0x94   0xE3E0'00F3        MVN      R0,#+243
   \       0x98   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x9C   0xE580'100C        STR      R1,[R0, #+12]
    435          		/* 3. Wait 10 us. */
    436          		_SLEEP(10);
   \       0xA0   0xE3A0'000A        MOV      R0,#+10
   \       0xA4   0x....'....        BL       usleep
    437          	}
    438          
    439          	/* 2. Configure PMC_PLL_ACR.LOOP_FILTER. */
    440          	reg = PMC->PMC_PLL_ACR;
   \                     ??_pmc_configure_pll_2:
   \       0xA8   0xE3E0'00F3        MVN      R0,#+243
   \       0xAC   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0xB0   0xE590'000C        LDR      R0,[R0, #+12]
    441          	reg &= ~PMC_PLL_ACR_LOOP_FILTER_Msk;
    442          	reg |= PMC_PLL_ACR_LOOP_FILTER(plla->loop_filter);
    443          	PMC->PMC_PLL_ACR = reg;
   \       0xB4   0xE3A0'25FC        MOV      R2,#+1056964608
   \       0xB8   0xE3C0'15FC        BIC      R1,R0,#0x3F000000
   \       0xBC   0xE594'0014        LDR      R0,[R4, #+20]
   \       0xC0   0xE3E0'30F3        MVN      R3,#+243
   \       0xC4   0xE002'2C00        AND      R2,R2,R0, LSL #+24
   \       0xC8   0xE182'1001        ORR      R1,R2,R1
   \       0xCC   0xE3C3'3FC0        BIC      R3,R3,#0x300
   \       0xD0   0xE583'100C        STR      R1,[R3, #+12]
    444          
    445          	/* 3. Define the MUL and FRACR to be applied to PLL(n) in PMC_PLL_CTRL1. */
    446          	PMC->PMC_PLL_CTRL1 = PMC_PLL_CTRL1_MUL(plla->mul) | PMC_PLL_CTRL1_FRACR(plla->fracr);
   \       0xD4   0xE594'1010        LDR      R1,[R4, #+16]
   \       0xD8   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xDC   0xE1A0'2501        LSL      R2,R1,#+10
   \       0xE0   0xE1A0'2522        LSR      R2,R2,#+10
   \       0xE4   0xE182'0C00        ORR      R0,R2,R0, LSL #+24
   \       0xE8   0xE583'0004        STR      R0,[R3, #+4]
    447          
    448          	/* In case UPLL is being configured, follow Step 4. to Step 7., else jump to Step 8. */
    449          	if (plla->pll_id == PLL_ID_UPLL) {
   \       0xEC   0xE594'000C        LDR      R0,[R4, #+12]
   \       0xF0   0xE350'0001        CMP      R0,#+1
   \       0xF4   0x1A00'000D        BNE      ??_pmc_configure_pll_3
    450          		/* 4. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    451          		reg = PMC->PMC_PLL_ACR;
   \       0xF8   0xE593'000C        LDR      R0,[R3, #+12]
    452          		reg |= PMC_PLL_ACR_UTMIBG;
    453          		PMC->PMC_PLL_ACR = reg;
   \       0xFC   0xE380'0D80        ORR      R0,R0,#0x2000
   \      0x100   0xE583'000C        STR      R0,[R3, #+12]
    454          		/* 5. Wait 10 us. */
    455          		_SLEEP(10);
   \      0x104   0xE3A0'000A        MOV      R0,#+10
   \      0x108   0x....'....        BL       usleep
    456          
    457          		/* 6. Write PMC_PLL_ACR.UTMIVR to '1' to enable the UTMI internal regulator. */
    458          		reg = PMC->PMC_PLL_ACR;
   \      0x10C   0xE3E0'00F3        MVN      R0,#+243
   \      0x110   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x114   0xE590'000C        LDR      R0,[R0, #+12]
    459          		reg |= PMC_PLL_ACR_UTMIVR;
    460          		PMC->PMC_PLL_ACR = reg;
   \      0x118   0xE380'1D40        ORR      R1,R0,#0x1000
   \      0x11C   0xE3E0'00F3        MVN      R0,#+243
   \      0x120   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x124   0xE580'100C        STR      R1,[R0, #+12]
    461          
    462          		/* 7. Wait 10 us. */
    463          		_SLEEP(10);
   \      0x128   0xE3A0'000A        MOV      R0,#+10
   \      0x12C   0x....'....        BL       usleep
    464          	}
    465          
    466          	/* 8. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    467          	1, else the update is cancelled. */
    468          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
   \                     ??_pmc_configure_pll_3:
   \      0x130   0xE3E0'00F3        MVN      R0,#+243
   \      0x134   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x138   0xE590'1010        LDR      R1,[R0, #+16]
   \      0x13C   0xE381'2F40        ORR      R2,R1,#0x100
   \      0x140   0xE580'2010        STR      R2,[R0, #+16]
    469          
    470          	/* 9. In PMC_PLL_CTRL0, write a '1' to ENLOCK and to ENPLL and configure DIVPMC (for PLLA only,
    471          	as UPLL has a fixed divider value) and ENPLLCK. */
    472          	reg = PMC->PMC_PLL_CTRL0 & ~PMC_PLL_CTRL0_DIVPMC_Msk;
   \      0x144   0xE590'1000        LDR      R1,[R0, #+0]
    473          	reg |= PMC_PLL_CTRL0_ENLOCK | PMC_PLL_CTRL0_ENPLL;
    474          	reg |= PMC_PLL_CTRL0_DIVPMC(plla->div) | PMC_PLL_CTRL0_ENPLLCK;
    475          	PMC->PMC_PLL_CTRL0 = reg;
   \      0x148   0xE5D4'2004        LDRB     R2,[R4, #+4]
   \      0x14C   0xE1A0'1421        LSR      R1,R1,#+8
   \      0x150   0xE202'30FF        AND      R3,R2,#0xFF
   \      0x154   0xE183'3401        ORR      R3,R3,R1, LSL #+8
   \      0x158   0xE383'14B0        ORR      R1,R3,#0xB0000000
   \      0x15C   0xE580'1000        STR      R1,[R0, #+0]
    476          
    477          	/* 10. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    478          	1, else the update is cancelled. */
    479          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
   \      0x160   0xE590'2010        LDR      R2,[R0, #+16]
   \      0x164   0xE382'1F40        ORR      R1,R2,#0x100
   \      0x168   0xE580'1010        STR      R1,[R0, #+16]
   \      0x16C   0xE3E0'20F3        MVN      R2,#+243
   \      0x170   0xE594'000C        LDR      R0,[R4, #+12]
   \      0x174   0xE3A0'1001        MOV      R1,#+1
   \      0x178   0xE3C2'2FC0        BIC      R2,R2,#0x300
    480          
    481          	/* 11. Wait for the lock bit to rise by polling the PMC_PLL_ISR0 or by enabling the corresponding interrupt
    482          	in PMC_PLL_IER. */
    483          	while ((PMC->PMC_PLL_ISR0 & (PMC_PLL_ISR0_LOCKA << plla->pll_id)) != (PMC_PLL_ISR0_LOCKA << plla->pll_id));
   \                     ??_pmc_configure_pll_4:
   \      0x17C   0xE592'30E0        LDR      R3,[R2, #+224]
   \      0x180   0xE003'3011        AND      R3,R3,R1, LSL R0
   \      0x184   0xE153'0011        CMP      R3,R1, LSL R0
   \      0x188   0x1AFF'FFFB        BNE      ??_pmc_configure_pll_4
    484          
    485          	/* 12. Disable the interrupt (if enabled) */
    486          
    487          	/* 13. Enable the unlock interrupt to quickly detect a failure on the generation of the clock of the PLL. */
    488          	PMC->PMC_PLL_IER |= (PMC_PLL_IER_UNLOCKA << plla->pll_id);
   \      0x18C   0xE1A0'1002        MOV      R1,R2
   \      0x190   0xE591'20D4        LDR      R2,[R1, #+212]
   \      0x194   0xE3A0'3B40        MOV      R3,#+65536
   \      0x198   0xE182'0013        ORR      R0,R2,R3, LSL R0
   \      0x19C   0xE581'00D4        STR      R0,[R1, #+212]
    489          }
   \      0x1A0   0xE8BD'8010        POP      {R4,PC}          ;; return
   \                     ??_pmc_configure_pll_1:
   \      0x1A4   0x....'....        LDR      R0,??DataTable26
   \      0x1A8   0xE590'2000        LDR      R2,[R0, #+0]
   \      0x1AC   0xE352'0000        CMP      R2,#+0
   \      0x1B0   0x0A00'0001        BEQ      ??_pmc_configure_pll_5
   \      0x1B4   0x....'....        LDR      R0,??DataTable27
   \      0x1B8   0x....'....        BL       printf
   \                     ??_pmc_configure_pll_5:
   \      0x1BC   0xEAFF'FFFE        B        ??_pmc_configure_pll_5
    490          
    491          RAMCODE static void _pmc_disable_pll(uint32_t pll_id)
    492          {
    493          	uint32_t reg;
    494          
    495          	if (pll_id == PLL_ID_PLLA) {
    496          	} else if (pll_id == PLL_ID_UPLL){
    497          	} else {
    498          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
    499          	}
    500          
    501          	/* To power-down a PLL, the following sequence must be applied: */
    502          	/* 1. If the PLL drives a section of the system that is active, modify the source clock of the system. */
    503          
    504          	/* 2. Define the ID (ID=n) of the PLL to be switched off in PMC_UPDT. The bit UPDATE in this register
    505          	must be set at 0 in this step. */
    506          	reg = PMC->PMC_PLL_UPDT;
    507          	reg &= ~(PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
    508          	if (pll_id)
    509          		reg |= PMC_PLL_UPDT_ID;
    510          	PMC->PMC_PLL_UPDT = reg;
    511          
    512          	/* 3. In PMC_PLL_CTRL0, set ENPLLCK to 0 and leave ENPLL at '1'. */
    513          	reg = PMC->PMC_PLL_CTRL0 & (~PMC_PLL_CTRL0_ENPLLCK);
    514          	PMC->PMC_PLL_CTRL0 = reg | PMC_PLL_CTRL0_ENPLL;
    515          
    516          	/* 4. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    517          	2, else the update is cancelled. */
    518          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
    519          
    520          	/* 5. Write a '0' to PMC_PLL_CTRL0.ENPLL. */
    521          	PMC->PMC_PLL_CTRL0 &= ~PMC_PLL_CTRL0_ENPLL;
    522          
    523          	/* 6. In case a UPLL is being powered down, write a '0' to PMC_PLL_ACR.UTMIBG and
    524          	PMC_PLL_ACR.UTMIVR. */
    525          	if (pll_id == PLL_ID_UPLL) {
    526          		reg = PMC->PMC_PLL_ACR;
    527          		reg &= ~(PMC_PLL_ACR_UTMIBG | PMC_PLL_ACR_UTMIVR);
    528          		PMC->PMC_PLL_ACR = reg;
    529          	}
    530          }
    531          
    532          static bool _pmc_pll_enabled(uint32_t pll_id)
    533          {
    534          	return (PMC->PMC_PLL_ISR0 & (1 << (pll_id & 0xf))) != 0;
    535          }
    536          

   \                                 In section SOFTPACK, align 4, keep-with-next
    537          static void _pmc_get_pll_config(uint32_t pll_id, struct _pmc_plla_cfg *plla)
    538          {
   \                     _pmc_get_pll_config:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    539          #ifdef PMC_PLL_UPDT_ID_Msk
    540          	uint32_t pll_updt;
    541          
    542          	pll_updt = PMC->PMC_PLL_UPDT;
    543          	pll_updt = (pll_updt & ~PMC_PLL_UPDT_ID_Msk) | PMC_PLL_UPDT_ID(pll_id);
    544          	PMC->PMC_PLL_UPDT = pll_updt;
    545          #else
    546          	if (pll_id)
   \        0xC   0x0A00'0005        BEQ      ??_pmc_get_pll_config_0
    547          		PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_ID;
   \       0x10   0xE3E0'00F3        MVN      R0,#+243
   \       0x14   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x18   0xE590'1010        LDR      R1,[R0, #+16]
   \       0x1C   0xE381'2001        ORR      R2,R1,#0x1
   \       0x20   0xE580'2010        STR      R2,[R0, #+16]
   \       0x24   0xEA00'0004        B        ??_pmc_get_pll_config_1
    548          	else 
    549          		PMC->PMC_PLL_UPDT &= ~PMC_PLL_UPDT_ID;
   \                     ??_pmc_get_pll_config_0:
   \       0x28   0xE3E0'10F3        MVN      R1,#+243
   \       0x2C   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x30   0xE591'0010        LDR      R0,[R1, #+16]
   \       0x34   0xE3C0'2001        BIC      R2,R0,#0x1
   \       0x38   0xE581'2010        STR      R2,[R1, #+16]
    550          #endif
    551          
    552          	memset(plla, 0, sizeof(*plla));
   \                     ??_pmc_get_pll_config_1:
   \       0x3C   0xE3A0'1018        MOV      R1,#+24
   \       0x40   0xE1A0'0005        MOV      R0,R5
   \       0x44   0x....'....        BL       __aeabi_memclr4
    553          	plla->pll_id = pll_id;
    554          	plla->mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
   \       0x48   0xE3E0'00F3        MVN      R0,#+243
   \       0x4C   0xE585'400C        STR      R4,[R5, #+12]
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'1004        LDR      R1,[R0, #+4]
    555          	plla->fracr = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_FRACR_Msk) >> PMC_PLL_CTRL1_FRACR_Pos;
    556          	plla->div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
    557          
    558          #if defined(CONFIG_SOC_SAM9X60)
    559          	/*
    560          	 * On SAM9X60, the value of DIVPMC in PMC_PLL_CTRL0 is ignored for the
    561          	 * USB PLL as there is a fixed hardware divider of 2. Hence, we should
    562          	 * always consider that DIVPMC is actually read as 1, whatever its real
    563          	 * value.
    564          	 */
    565          	if (pll_id)
   \       0x58   0xE354'0000        CMP      R4,#+0
   \       0x5C   0xE1A0'2C21        LSR      R2,R1,#+24
   \       0x60   0xE585'2000        STR      R2,[R5, #+0]
   \       0x64   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x68   0xE1A0'2501        LSL      R2,R1,#+10
   \       0x6C   0xE1A0'2522        LSR      R2,R2,#+10
   \       0x70   0xE585'2010        STR      R2,[R5, #+16]
   \       0x74   0xE590'1000        LDR      R1,[R0, #+0]
    566          		plla->div = 1;
   \       0x78   0x13A0'0001        MOVNE    R0,#+1
   \       0x7C   0xE201'20FF        AND      R2,R1,#0xFF
   \       0x80   0xE585'2004        STR      R2,[R5, #+4]
   \       0x84   0x1585'0004        STRNE    R0,[R5, #+4]
    567          #endif
    568          }
   \       0x88   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    569          

   \                                 In section SOFTPACK, align 4, keep-with-next
    570          static uint32_t _pmc_get_pll_clock(uint32_t pll_id)
    571          {
   \                     _pmc_get_pll_clock:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'5000        MOVS     R5,R0
    572          	struct _pmc_plla_cfg plla;
    573          	uint32_t f_core, f_ref;
    574          
    575          	if (pll_id == PLL_ID_PLLA) {
   \        0xC   0x1A00'0015        BNE      ??_pmc_get_pll_clock_0
    576          		f_ref = pmc_get_main_clock();
   \       0x10   0xE3E0'10DF        MVN      R1,#+223
   \       0x14   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x18   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x1C   0x....'....        LDR      R0,??DataTable29
   \       0x20   0xE312'0740        TST      R2,#0x1000000
   \       0x24   0x1590'4004        LDRNE    R4,[R0, #+4]
   \       0x28   0x0590'4000        LDREQ    R4,[R0, #+0]
    577          	} else if (pll_id == PLL_ID_UPLL){
    578          		f_ref = pmc_get_main_oscillator_freq();
    579          	} else {
    580          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
    581          	}
    582          
    583          	_pmc_get_pll_config(pll_id, &plla);
   \                     ??_pmc_get_pll_clock_1:
   \       0x2C   0xE1A0'100D        MOV      R1,SP
   \       0x30   0xE1A0'0005        MOV      R0,R5
   \       0x34   0x....'....        BL       _pmc_get_pll_config
    584          
    585          	f_core = f_ref * (plla.mul + 1) + (uint32_t)((((uint64_t)f_ref) * plla.fracr) >> 22);
    586          	return f_core / (plla.div + 1);
   \       0x38   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x3C   0xE59D'C010        LDR      R12,[SP, #+16]
   \       0x40   0xE281'2001        ADD      R2,R1,#+1
   \       0x44   0xE081'0C94        UMULL    R0,R1,R4,R12
   \       0x48   0xE1A0'0B20        LSR      R0,R0,#+22
   \       0x4C   0xE180'0501        ORR      R0,R0,R1, LSL #+10
   \       0x50   0xE020'0492        MLA      R0,R2,R4,R0
   \       0x54   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x58   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x5C   0xE8BD'4030        POP      {R4,R5,LR}
   \       0x60   0xE281'1001        ADD      R1,R1,#+1
   \       0x64   0x....'....        B        __aeabi_uidiv
   \                     ??_pmc_get_pll_clock_0:
   \       0x68   0xE355'0001        CMP      R5,#+1
   \       0x6C   0x1A00'0007        BNE      ??_pmc_get_pll_clock_2
   \       0x70   0x....'....        LDR      R0,??DataTable29
   \       0x74   0xE590'4004        LDR      R4,[R0, #+4]
   \       0x78   0xE354'0000        CMP      R4,#+0
   \       0x7C   0x1AFF'FFEA        BNE      ??_pmc_get_pll_clock_1
   \       0x80   0xE3A0'0000        MOV      R0,#+0
   \       0x84   0x....'....        BL       pmc_set_main_oscillator_freq
   \       0x88   0xE1A0'4000        MOV      R4,R0
   \       0x8C   0xEAFF'FFE6        B        ??_pmc_get_pll_clock_1
   \                     ??_pmc_get_pll_clock_2:
   \       0x90   0x....'....        LDR      R0,??DataTable26
   \       0x94   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x98   0xE351'0000        CMP      R1,#+0
   \       0x9C   0x0A00'0002        BEQ      ??_pmc_get_pll_clock_3
   \       0xA0   0xE1A0'1005        MOV      R1,R5
   \       0xA4   0x....'....        LDR      R0,??DataTable27
   \       0xA8   0x....'....        BL       printf
   \                     ??_pmc_get_pll_clock_3:
   \       0xAC   0xEAFF'FFFE        B        ??_pmc_get_pll_clock_3
    587          }
    588          #endif /* PMC_PLL_UPDT_ID */
    589          
    590          /*----------------------------------------------------------------------------
    591           *        Exported functions (General)
    592           *----------------------------------------------------------------------------*/
    593          

   \                                 In section SOFTPACK, align 4, keep-with-next
    594          uint32_t pmc_set_main_oscillator_freq(uint32_t freq)
    595          {
   \                     pmc_set_main_oscillator_freq:
   \        0x0   0xE92D'45F8        PUSH     {R3-R8,R10,LR}
    596          	uint32_t mor, mckr, mckr_mask;
    597          #ifdef CKGR_PLLAR_MULA_Msk
    598          	uint32_t pllar;
    599          #endif
    600          	uint16_t mainf_rc, mainf_xt = 0;
    601          
    602          	_pmc_main_oscillators.crystal_freq = freq;
   \        0x4   0x....'....        LDR      R4,??DataTable29
   \        0x8   0xE3A0'5000        MOV      R5,#+0
   \        0xC   0xE584'0004        STR      R0,[R4, #+4]
    603          	if (freq > 0)
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0075        BNE      ??pmc_set_main_oscillator_freq_0
    604          		return freq;
    605          
    606          	/*
    607          	 * Save the current value of the CKGR_MCKR register then swith to
    608          	 * the slow clock.
    609          	 */
    610          	mckr = PMC->PMC_MCKR;
   \       0x18   0xE3E0'00DF        MVN      R0,#+223
   \       0x1C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x20   0xE590'6008        LDR      R6,[R0, #+8]
    611          	pmc_switch_mck_to_slck();
   \       0x24   0x....'....        BL       pmc_switch_mck_to_slck
    612          	mckr_mask = PMC_MCKR_MDIV_Msk | PMC_MCKR_PRES_Msk;
    613          	PMC->PMC_MCKR &= ~mckr_mask;
   \       0x28   0xE3E0'00DF        MVN      R0,#+223
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE590'1008        LDR      R1,[R0, #+8]
    614          
    615          	/* Save the current value of the CKGR_MOR register. */
    616          	mor = PMC->CKGR_MOR;
   \       0x34   0xE1A0'7000        MOV      R7,R0
   \       0x38   0xE3C1'2E77        BIC      R2,R1,#0x770
   \       0x3C   0xE580'2008        STR      R2,[R0, #+8]
   \       0x40   0xE597'8000        LDR      R8,[R7, #+0]
    617          
    618          #ifdef CKGR_PLLAR_MULA_Msk
    619          	/*
    620          	 * Save the current value of the CKGR_PLLAR register then stop this
    621          	 * PLL, if needed.
    622          	 */
    623          	pllar = PMC->CKGR_PLLAR;
    624          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk))
    625          		PMC->CKGR_PLLAR &= ~(CKGR_PLLAR_MULA_Msk | CKGR_PLLAR_DIVA_Msk);
    626          #endif
    627          
    628          	/* Switch to internal 12MHz RC, if needed. */
    629          	pmc_select_internal_osc();
   \       0x44   0x....'....        BL       pmc_select_internal_osc
    630          
    631          	/* Measure the 12MHz RC frequency. */
    632          	mainf_rc = _pmc_measure_main_osc_freq(false);
   \       0x48   0xE3A0'0C7D        MOV      R0,#+32000
   \       0x4C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x50   0xE587'5004        STR      R5,[R7, #+4]
   \       0x54   0xE597'1004        LDR      R1,[R7, #+4]
   \       0x58   0xE3A0'0000        MOV      R0,#+0
   \       0x5C   0xE381'2940        ORR      R2,R1,#0x100000
   \       0x60   0xE587'2004        STR      R2,[R7, #+4]
   \       0x64   0xEE07'0F9A        mcr p15, 0, R0, c7, c10, 4
   \                     ??pmc_set_main_oscillator_freq_1:
   \       0x68   0xE597'1004        LDR      R1,[R7, #+4]
   \       0x6C   0xE311'0B40        TST      R1,#0x10000
   \       0x70   0x1A00'0003        BNE      ??pmc_set_main_oscillator_freq_2
   \       0x74   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x78   0xE251'0001        SUBS     R0,R1,#+1
   \       0x7C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x80   0x1AFF'FFF8        BNE      ??pmc_set_main_oscillator_freq_1
   \                     ??pmc_set_main_oscillator_freq_2:
   \       0x84   0xE59D'1000        LDR      R1,[SP, #+0]
    633          
    634          	/* Measure the crystal or by-pass frequency. */
    635          
    636          #ifdef CKGR_MOR_MOSCXTBY
    637          	/* Try by-pass first. */
    638          	if (pmc_select_external_osc(true) == 0)
    639          		mainf_xt = _pmc_measure_main_osc_freq(true);
    640          #endif /* CKGR_MOR_MOSCXTBY */
    641          
    642          	/* Then try external crytal if no by-pass. */
    643          	if (!mainf_xt) {
    644          		if (pmc_select_external_osc(false) == 0)
   \       0x88   0xE3A0'0000        MOV      R0,#+0
   \       0x8C   0xE351'0000        CMP      R1,#+0
   \       0x90   0x1597'A004        LDRNE    R10,[R7, #+4]
   \       0x94   0x03A0'A000        MOVEQ    R10,#+0
   \       0x98   0x....'....        BL       pmc_select_external_osc
   \       0x9C   0xE1A0'A80A        LSL      R10,R10,#+16
   \       0xA0   0xE1A0'A82A        LSR      R10,R10,#+16
   \       0xA4   0xE350'0000        CMP      R0,#+0
   \       0xA8   0x1A00'0014        BNE      ??pmc_set_main_oscillator_freq_3
    645          			mainf_xt = _pmc_measure_main_osc_freq(true);
   \       0xAC   0xE3A0'0C7D        MOV      R0,#+32000
   \       0xB0   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xB4   0xE3A0'2740        MOV      R2,#+16777216
   \       0xB8   0xE587'2004        STR      R2,[R7, #+4]
   \       0xBC   0xE597'1004        LDR      R1,[R7, #+4]
   \       0xC0   0xE3A0'0000        MOV      R0,#+0
   \       0xC4   0xE381'2940        ORR      R2,R1,#0x100000
   \       0xC8   0xE587'2004        STR      R2,[R7, #+4]
   \       0xCC   0xEE07'0F9A        mcr p15, 0, R0, c7, c10, 4
   \                     ??pmc_set_main_oscillator_freq_4:
   \       0xD0   0xE597'1004        LDR      R1,[R7, #+4]
   \       0xD4   0xE311'0B40        TST      R1,#0x10000
   \       0xD8   0x1A00'0003        BNE      ??pmc_set_main_oscillator_freq_5
   \       0xDC   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xE0   0xE251'0001        SUBS     R0,R1,#+1
   \       0xE4   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xE8   0x1AFF'FFF8        BNE      ??pmc_set_main_oscillator_freq_4
   \                     ??pmc_set_main_oscillator_freq_5:
   \       0xEC   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xF0   0xE351'0000        CMP      R1,#+0
   \       0xF4   0x1597'5004        LDRNE    R5,[R7, #+4]
    646          	}
   \       0xF8   0xE1A0'5805        LSL      R5,R5,#+16
   \       0xFC   0xE1A0'5825        LSR      R5,R5,#+16
    647          
    648          	/* Switch back to internal 12MHz RC if it was selected initially */
    649          	if (!(mor & CKGR_MOR_MOSCSEL))
   \                     ??pmc_set_main_oscillator_freq_3:
   \      0x100   0xE318'0740        TST      R8,#0x1000000
   \      0x104   0x1A00'0000        BNE      ??pmc_set_main_oscillator_freq_6
    650          		pmc_select_internal_osc();
   \      0x108   0x....'....        BL       pmc_select_internal_osc
    651          
    652          #ifdef CKGR_MOR_MOSCRCEN
    653          	/* Disable internal oscillator if it wasn't enabled initially */
    654          	if (!(mor & CKGR_MOR_MOSCRCEN))
   \                     ??pmc_set_main_oscillator_freq_6:
   \      0x10C   0xE318'0008        TST      R8,#0x8
   \      0x110   0x1A00'0005        BNE      ??pmc_set_main_oscillator_freq_7
    655          		pmc_disable_internal_osc();
   \      0x114   0xE597'0000        LDR      R0,[R7, #+0]
   \      0x118   0xE3E0'1008        MVN      R1,#+8
   \      0x11C   0xE3C1'18FF        BIC      R1,R1,#0xFF0000
   \      0x120   0xE001'1000        AND      R1,R1,R0
   \      0x124   0xE381'29DC        ORR      R2,R1,#0x370000
   \      0x128   0xE587'2000        STR      R2,[R7, #+0]
    656          #endif
    657          
    658          #ifdef CKGR_PLLAR_MULA_Msk
    659          	/* Restart the PLLA, if needed. */
    660          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk)) {
    661          		PMC->CKGR_PLLAR = pllar;
    662          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
    663          	}
    664          #endif
    665          
    666          	/* Switch back to the former MCK source. */
    667          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~mckr_mask) | (mckr & mckr_mask);
   \                     ??pmc_set_main_oscillator_freq_7:
   \      0x12C   0xE597'1008        LDR      R1,[R7, #+8]
   \      0x130   0xE206'0E77        AND      R0,R6,#0x770
   \      0x134   0xE3C1'2E77        BIC      R2,R1,#0x770
   \      0x138   0xE180'0002        ORR      R0,R0,R2
   \      0x13C   0xE587'0008        STR      R0,[R7, #+8]
    668          	pmc_switch_mck_to_new_source(mckr & PMC_MCKR_CSS_Msk);
   \      0x140   0xE206'0003        AND      R0,R6,#0x3
   \      0x144   0x....'....        BL       pmc_switch_mck_to_new_source
    669          
    670          	/* Guess the external crystal frequency, if available. */
    671          	if (mainf_rc && mainf_xt) {
   \      0x148   0xE35A'0000        CMP      R10,#+0
   \      0x14C   0x0A00'0026        BEQ      ??pmc_set_main_oscillator_freq_8
   \      0x150   0xE355'0000        CMP      R5,#+0
   \      0x154   0x0A00'0024        BEQ      ??pmc_set_main_oscillator_freq_8
    672          		uint32_t ratio = (mainf_xt * 1000) / mainf_rc;
   \      0x158   0xE3A0'1FFA        MOV      R1,#+1000
   \      0x15C   0xE000'0591        MUL      R0,R1,R5
   \      0x160   0xE1A0'100A        MOV      R1,R10
   \      0x164   0x....'....        BL       __aeabi_idiv
    673          
    674          		// Use 10% low and high margins
    675          		if (3600 <= ratio && ratio <= 4400) {
   \      0x168   0xE247'2EA3        SUB      R2,R7,#+2608
   \      0x16C   0xE3A0'3021        MOV      R3,#+33
   \      0x170   0xE082'2000        ADD      R2,R2,R0
   \      0x174   0xE383'3FC0        ORR      R3,R3,#0x300
   \      0x178   0xE152'0003        CMP      R2,R3
    676          			// 48/12 => ratio = 4000
    677          			_pmc_main_oscillators.crystal_freq = 48000000u;
   \      0x17C   0x33A0'07B7        MOVCC    R0,#+47972352
   \      0x180   0x3380'0C6C        ORRCC    R0,R0,#0x6C00
   \      0x184   0x3A00'0017        BCC      ??pmc_set_main_oscillator_freq_9
    678          		} else if (1800 <= ratio && ratio <= 2200) {
   \      0x188   0xE247'1FCA        SUB      R1,R7,#+808
   \      0x18C   0xE081'1000        ADD      R1,R1,R0
   \      0x190   0xE243'2F64        SUB      R2,R3,#+400
   \      0x194   0xE151'0002        CMP      R1,R2
    679          			// 24/12 => ratio = 2000
    680          			_pmc_main_oscillators.crystal_freq = 24000000u;
   \      0x198   0x....'....        LDRCC    R0,??DataTable33  ;; 0x16e3600
   \      0x19C   0x3A00'0011        BCC      ??pmc_set_main_oscillator_freq_9
    681          		} else if (1200 <= ratio && ratio <= 1467) {
   \      0x1A0   0xE247'10D0        SUB      R1,R7,#+208
   \      0x1A4   0xE081'1000        ADD      R1,R1,R0
   \      0x1A8   0xE351'0F43        CMP      R1,#+268
    682          			// 16/12 => ratio = 1333
    683          			_pmc_main_oscillators.crystal_freq = 16000000u;
   \      0x1AC   0x33A0'08F4        MOVCC    R0,#+15990784
   \      0x1B0   0x3380'0D90        ORRCC    R0,R0,#0x2400
   \      0x1B4   0x3A00'000B        BCC      ??pmc_set_main_oscillator_freq_9
    684          		} else if (900 <= ratio && ratio <= 1100) {
   \      0x1B8   0xE387'105C        ORR      R1,R7,#0x5C
   \      0x1BC   0xE081'1000        ADD      R1,R1,R0
   \      0x1C0   0xE351'00C9        CMP      R1,#+201
    685          			// 12/12 => ratio = 1000
    686          			_pmc_main_oscillators.crystal_freq = 12000000u;
   \      0x1C4   0x33A0'08B7        MOVCC    R0,#+11993088
   \      0x1C8   0x3380'0D6C        ORRCC    R0,R0,#0x1B00
   \      0x1CC   0x3A00'0005        BCC      ??pmc_set_main_oscillator_freq_9
    687          		} else if (600 <= ratio && ratio <= 733) {
   \      0x1D0   0xE387'1F62        ORR      R1,R7,#0x188
   \      0x1D4   0xE081'1000        ADD      R1,R1,R0
   \      0x1D8   0xE351'0086        CMP      R1,#+134
   \      0x1DC   0x2A00'0002        BCS      ??pmc_set_main_oscillator_freq_8
    688          			// 8/12 => ratio = 667
    689          			_pmc_main_oscillators.crystal_freq = 8000000u;
   \      0x1E0   0xE3A0'087A        MOV      R0,#+7995392
   \      0x1E4   0xE380'0D48        ORR      R0,R0,#0x1200
   \                     ??pmc_set_main_oscillator_freq_9:
   \      0x1E8   0xE584'0004        STR      R0,[R4, #+4]
    690          		}
    691          	}
    692          
    693          	return _pmc_main_oscillators.crystal_freq;
   \                     ??pmc_set_main_oscillator_freq_8:
   \      0x1EC   0xE594'0004        LDR      R0,[R4, #+4]
   \                     ??pmc_set_main_oscillator_freq_0:
   \      0x1F0   0xE8BD'85F2        POP      {R1,R4-R8,R10,PC}  ;; return
    694          }
    695          

   \                                 In section SOFTPACK, align 4, keep-with-next
    696          uint32_t pmc_get_main_oscillator_freq(void)
    697          {
    698          	if (_pmc_main_oscillators.crystal_freq > 0)
   \                     pmc_get_main_oscillator_freq:
   \        0x0   0x....'....        LDR      R0,??DataTable29
   \        0x4   0xE590'0004        LDR      R0,[R0, #+4]
   \        0x8   0xE350'0000        CMP      R0,#+0
    699          		return _pmc_main_oscillators.crystal_freq;
    700          	else
    701          		return pmc_set_main_oscillator_freq(0);
   \        0xC   0x....'....        BEQ      pmc_set_main_oscillator_freq  ;; tailcall
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    702          }
    703          

   \                                 In section SOFTPACK, align 4, keep-with-next
    704          uint32_t pmc_get_master_clock(void)
    705          {
   \                     pmc_get_master_clock:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    706          	if (!_pmc_mck)
   \        0x4   0x....'....        LDR      R4,??DataTable29
   \        0x8   0xE594'0008        LDR      R0,[R4, #+8]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'003E        BNE      ??pmc_get_master_clock_1
    707          		_pmc_compute_mck();
   \       0x14   0xE3E0'10DF        MVN      R1,#+223
   \       0x18   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x1C   0xE591'5008        LDR      R5,[R1, #+8]
   \       0x20   0xE205'2003        AND      R2,R5,#0x3
   \       0x24   0xE352'0003        CMP      R2,#+3
   \       0x28   0x8A00'000B        BHI      ??pmc_get_master_clock_2
   \       0x2C   0xE7DF'3002        LDRB     R3,[PC, R2]
   \       0x30   0xE08F'F103        ADD      PC,PC,R3, LSL #+2
   \                     ??pmc_get_master_clock_0:
   \       0x34   0x08 0x03          DC8      0x8,0x3,0x1,0x0

   \              0x01 0x00
   \                     ??pmc_get_master_clock_3:
   \       0x38   0xE3A0'0001        MOV      R0,#+1
   \                     ??pmc_get_master_clock_4:
   \       0x3C   0x....'....        BL       _pmc_get_pll_clock
   \       0x40   0xEA00'0005        B        ??pmc_get_master_clock_2
   \                     ??pmc_get_master_clock_5:
   \       0x44   0xE591'1000        LDR      R1,[R1, #+0]
   \       0x48   0xE311'0740        TST      R1,#0x1000000
   \       0x4C   0x1594'0004        LDRNE    R0,[R4, #+4]
   \       0x50   0x0594'0000        LDREQ    R0,[R4, #+0]
   \       0x54   0xEA00'0000        B        ??pmc_get_master_clock_2
   \                     ??pmc_get_master_clock_6:
   \       0x58   0x....'....        BL       slowclock_get_clock
   \                     ??pmc_get_master_clock_2:
   \       0x5C   0xE205'1070        AND      R1,R5,#0x70
   \       0x60   0xE351'0010        CMP      R1,#+16
   \       0x64   0x0A00'0019        BEQ      ??pmc_get_master_clock_7
   \       0x68   0xE351'0020        CMP      R1,#+32
   \       0x6C   0x0A00'0015        BEQ      ??pmc_get_master_clock_8
   \       0x70   0xE351'0030        CMP      R1,#+48
   \       0x74   0x0A00'0011        BEQ      ??pmc_get_master_clock_9
   \       0x78   0xE351'0040        CMP      R1,#+64
   \       0x7C   0x0A00'000D        BEQ      ??pmc_get_master_clock_10
   \       0x80   0xE351'0050        CMP      R1,#+80
   \       0x84   0x0A00'0009        BEQ      ??pmc_get_master_clock_11
   \       0x88   0xE351'0060        CMP      R1,#+96
   \       0x8C   0x0A00'0005        BEQ      ??pmc_get_master_clock_12
   \       0x90   0xE351'0070        CMP      R1,#+112
   \       0x94   0x1A00'000E        BNE      ??pmc_get_master_clock_13
   \       0x98   0x....'....        LDR      R12,??DataTable35  ;; 0xaaaaaaab
   \       0x9C   0xE083'CC90        UMULL    R12,R3,R0,R12
   \       0xA0   0xE1A0'00A3        LSR      R0,R3,#+1
   \       0xA4   0xEA00'000A        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_12:
   \       0xA8   0xE1A0'0320        LSR      R0,R0,#+6
   \       0xAC   0xEA00'0008        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_11:
   \       0xB0   0xE1A0'02A0        LSR      R0,R0,#+5
   \       0xB4   0xEA00'0006        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_10:
   \       0xB8   0xE1A0'0220        LSR      R0,R0,#+4
   \       0xBC   0xEA00'0004        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_9:
   \       0xC0   0xE1A0'01A0        LSR      R0,R0,#+3
   \       0xC4   0xEA00'0002        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_8:
   \       0xC8   0xE1A0'0120        LSR      R0,R0,#+2
   \       0xCC   0xEA00'0000        B        ??pmc_get_master_clock_13
   \                     ??pmc_get_master_clock_7:
   \       0xD0   0xE1A0'00A0        LSR      R0,R0,#+1
   \                     ??pmc_get_master_clock_13:
   \       0xD4   0xE205'1E70        AND      R1,R5,#0x700
   \       0xD8   0xE351'0F40        CMP      R1,#+256
   \       0xDC   0x0A00'0009        BEQ      ??pmc_get_master_clock_14
   \       0xE0   0xE351'0F80        CMP      R1,#+512
   \       0xE4   0x0A00'0005        BEQ      ??pmc_get_master_clock_15
   \       0xE8   0xE351'0FC0        CMP      R1,#+768
   \       0xEC   0x1A00'0006        BNE      ??pmc_get_master_clock_16
   \       0xF0   0x....'....        LDR      R12,??DataTable35  ;; 0xaaaaaaab
   \       0xF4   0xE083'CC90        UMULL    R12,R3,R0,R12
   \       0xF8   0xE1A0'00A3        LSR      R0,R3,#+1
   \       0xFC   0xEA00'0002        B        ??pmc_get_master_clock_16
   \                     ??pmc_get_master_clock_15:
   \      0x100   0xE1A0'0120        LSR      R0,R0,#+2
   \      0x104   0xEA00'0000        B        ??pmc_get_master_clock_16
   \                     ??pmc_get_master_clock_14:
   \      0x108   0xE1A0'00A0        LSR      R0,R0,#+1
   \                     ??pmc_get_master_clock_16:
   \      0x10C   0xE584'0008        STR      R0,[R4, #+8]
    708          	return _pmc_mck;
   \                     ??pmc_get_master_clock_1:
   \      0x110   0xE594'0008        LDR      R0,[R4, #+8]
   \      0x114   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    709          }
    710          

   \                                 In section SOFTPACK, align 4, keep-with-next
    711          uint32_t pmc_get_slow_clock(void)
    712          {
    713          	return slowclock_get_clock(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     pmc_get_slow_clock:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0x....'....        B        slowclock_get_clock  ;; tailcall
    714          }
    715          

   \                                 In section SOFTPACK, align 4, keep-with-next
    716          uint32_t pmc_get_main_clock(void)
    717          {
    718          	if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)
   \                     pmc_get_main_clock:
   \        0x0   0xE3E0'10DF        MVN      R1,#+223
   \        0x4   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
   \        0xC   0x....'....        LDR      R0,??DataTable29
   \       0x10   0xE312'0740        TST      R2,#0x1000000
    719          		return _pmc_main_oscillators.crystal_freq; /* external crystal */
   \       0x14   0x1590'0004        LDRNE    R0,[R0, #+4]
    720          	else
    721          		return _pmc_main_oscillators.rc_freq; /* on-chip main clock RC */
   \       0x18   0x0590'0000        LDREQ    R0,[R0, #+0]
   \       0x1C   0xE12F'FF1E        BX       LR               ;; return
    722          }
    723          

   \                                 In section SOFTPACK, align 4, keep-with-next
    724          uint32_t pmc_get_plla_clock(void)
    725          {
   \                     pmc_get_plla_clock:
   \        0x0   0xE92D'4000        PUSH     {LR}
    726          #if defined(PMC_PLL_UPDT_ID)
    727          	return _pmc_get_pll_clock(PLL_ID_PLLA);
   \        0x4   0xE3E0'10F3        MVN      R1,#+243
   \        0x8   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0xC   0xE591'2014        LDR      R2,[R1, #+20]
   \       0x10   0x....'....        LDR      R0,??DataTable29
   \       0x14   0xE312'0740        TST      R2,#0x1000000
   \       0x18   0x1590'2004        LDRNE    R2,[R0, #+4]
   \       0x1C   0x0590'2000        LDREQ    R2,[R0, #+0]
   \       0x20   0xE3A0'E001        MOV      LR,#+1
   \       0x24   0xE1A0'0001        MOV      R0,R1
   \       0x28   0xE590'1010        LDR      R1,[R0, #+16]
   \       0x2C   0xE3C1'3001        BIC      R3,R1,#0x1
   \       0x30   0xE580'3010        STR      R3,[R0, #+16]
   \       0x34   0xE1A0'1000        MOV      R1,R0
   \       0x38   0xE591'0004        LDR      R0,[R1, #+4]
   \       0x3C   0xE1A0'3001        MOV      R3,R1
   \       0x40   0xE08E'EC20        ADD      LR,LR,R0, LSR #+24
   \       0x44   0xE593'1004        LDR      R1,[R3, #+4]
   \       0x48   0xE593'3000        LDR      R3,[R3, #+0]
   \       0x4C   0xE1A0'1501        LSL      R1,R1,#+10
   \       0x50   0xE1A0'C521        LSR      R12,R1,#+10
   \       0x54   0xE081'0C92        UMULL    R0,R1,R2,R12
   \       0x58   0xE1A0'0B20        LSR      R0,R0,#+22
   \       0x5C   0xE180'0501        ORR      R0,R0,R1, LSL #+10
   \       0x60   0xE020'029E        MLA      R0,LR,R2,R0
   \       0x64   0xE203'20FF        AND      R2,R3,#0xFF
   \       0x68   0xE8BD'4000        POP      {LR}
   \       0x6C   0xE282'1001        ADD      R1,R2,#+1
   \       0x70   0x....'....        B        __aeabi_uidiv
    728          #elif defined(CKGR_PLLAR_DIVA_Pos)
    729          	uint32_t pllaclk, pllar, pllmula, plldiva;
    730          
    731          	pllar = PMC->CKGR_PLLAR;
    732          	pllmula = (pllar & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
    733          	plldiva = (pllar & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
    734          	if (plldiva == 0 || pllmula == 0)
    735          		return 0;
    736          
    737          	pllaclk = pmc_get_main_clock();
    738          	pllaclk = pllaclk * (pllmula + 1) / plldiva;
    739          #ifdef CONFIG_HAVE_PMC_PLLADIV2
    740          	if (PMC->PMC_MCKR & PMC_MCKR_PLLADIV2)
    741          		pllaclk >>= 1;
    742          #endif
    743          	return pllaclk;
    744          #endif
    745          }
    746          

   \                                 In section SOFTPACK, align 4, keep-with-next
    747          uint32_t pmc_get_processor_clock(void)
    748          {
   \                     pmc_get_processor_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    749          	uint32_t procclk, mdiv;
    750          
    751          	procclk = pmc_get_master_clock();
   \        0x4   0x....'....        BL       pmc_get_master_clock
    752          
    753          	mdiv = PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk;
   \        0x8   0xE3E0'10D7        MVN      R1,#+215
   \        0xC   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x10   0xE591'1000        LDR      R1,[R1, #+0]
    754          	switch (mdiv) {
   \       0x14   0xE201'2E70        AND      R2,R1,#0x700
   \       0x18   0xE352'0F40        CMP      R2,#+256
   \       0x1C   0x0A00'0004        BEQ      ??pmc_get_processor_clock_0
   \       0x20   0xE352'0F80        CMP      R2,#+512
   \       0x24   0x0A00'0004        BEQ      ??pmc_get_processor_clock_1
   \       0x28   0xE352'0FC0        CMP      R2,#+768
    755          	case PMC_MCKR_MDIV_EQ_PCK:
    756          		break;
    757          	case PMC_MCKR_MDIV_PCK_DIV2:
    758          		procclk <<= 1; // multiply by 2
    759          		break;
    760          	case PMC_MCKR_MDIV_PCK_DIV3:
    761          		procclk *= 3;  // multiply by 3
   \       0x2C   0x0080'0080        ADDEQ    R0,R0,R0, LSL #+1
   \       0x30   0xE8BD'8002        POP      {R1,PC}
   \                     ??pmc_get_processor_clock_0:
   \       0x34   0xE1A0'0080        LSL      R0,R0,#+1
   \       0x38   0xE8BD'8002        POP      {R1,PC}
    762          		break;
    763          	case PMC_MCKR_MDIV_PCK_DIV4:
    764          		procclk <<= 2; // multiply by 4
   \                     ??pmc_get_processor_clock_1:
   \       0x3C   0xE1A0'0100        LSL      R0,R0,#+2
    765          		break;
    766          	default:
    767          		/* should never get here... */
    768          		break;
    769          	}
    770          
    771          	return procclk;
   \       0x40   0xE8BD'8002        POP      {R1,PC}          ;; return
    772          }
    773          

   \                                 In section SOFTPACK, align 4, keep-with-next
    774          RAMCODE void pmc_select_external_crystal(void)
    775          {
    776          	bool return_to_slck = false;
    777          
    778          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \                     pmc_select_external_crystal:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE92D'4010        PUSH     {R4,LR}
   \        0x8   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x10   0xE3A0'4000        MOV      R4,#+0
   \       0x14   0xE351'0000        CMP      R1,#+0
   \       0x18   0x1A00'0001        BNE      ??pmc_select_external_crystal_0
    779          		pmc_switch_mck_to_main();
   \       0x1C   0x....'....        BL       pmc_switch_mck_to_main
    780          		return_to_slck = true;
   \       0x20   0xE3A0'4001        MOV      R4,#+1
    781          	}
    782          
    783          	slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_external_crystal_0:
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0x....'....        BL       slowclock_select_external
    784          
    785          	/* Switch to slow clock again if needed */
    786          	if (return_to_slck)
   \       0x2C   0x....'....        B        ?Subroutine2
    787          		pmc_switch_mck_to_slck();
    788          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE354'0000        CMP      R4,#+0
   \        0x4   0x18BD'4010        POPNE    {R4,LR}
   \        0x8   0x....'....        BNE      pmc_switch_mck_to_slck  ;; tailcall
   \        0xC   0xE8BD'8010        POP      {R4,PC}          ;; return
    789          

   \                                 In section SOFTPACK, align 4, keep-with-next
    790          RAMCODE void pmc_select_internal_crystal(void)
    791          {
    792          	bool return_to_slck = false;
    793          
    794          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \                     pmc_select_internal_crystal:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE92D'4010        PUSH     {R4,LR}
   \        0x8   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x10   0xE3A0'4000        MOV      R4,#+0
   \       0x14   0xE351'0000        CMP      R1,#+0
   \       0x18   0x1A00'0001        BNE      ??pmc_select_internal_crystal_0
    795          		pmc_switch_mck_to_main();
   \       0x1C   0x....'....        BL       pmc_switch_mck_to_main
    796          		return_to_slck = true;
   \       0x20   0xE3A0'4001        MOV      R4,#+1
    797          	}
    798          
    799          	slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_internal_crystal_0:
   \       0x24   0xE3A0'0000        MOV      R0,#+0
   \       0x28   0x....'....        BL       slowclock_select_internal
    800          
    801          	/* Switch to slow clock again if needed */
    802          	if (return_to_slck)
   \       0x2C                      REQUIRE ?Subroutine2
   \       0x2C                      ;; // Fall through to label ?Subroutine2
    803          		pmc_switch_mck_to_slck();
    804          }
    805          

   \                                 In section SOFTPACK, align 4, keep-with-next
    806          RAMCODE int pmc_select_external_osc(bool bypass)
    807          {
    808          	int err;
    809          	volatile uint32_t timeout;
    810          
    811          	/* Return if external oscillator had been selected */
    812          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \                     pmc_select_external_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE24D'D004        SUB      SP,SP,#+4
   \        0x8   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x10   0xE311'0740        TST      R1,#0x1000000
   \       0x14   0x0A00'0002        BEQ      ??pmc_select_external_osc_0
    813          #ifdef CKGR_MOR_MOSCXTBY
    814          		uint32_t mask = bypass ? CKGR_MOR_MOSCXTBY : CKGR_MOR_MOSCXTEN;
    815          #else
    816          		uint32_t mask = CKGR_MOR_MOSCXTEN;
    817          #endif  /* CKGR_MOR_MOSCXTBY */
    818          		if ((PMC->CKGR_MOR & mask) == mask)
   \       0x18   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x1C   0xE311'0001        TST      R1,#0x1
   \       0x20   0x1A00'0050        BNE      ??pmc_select_external_osc_1
    819          			return 0;
    820          	}
    821          
    822          	/*
    823          	 * When switching the source of the main clock between the RC oscillator and the crystal
    824          	 * oscillator, both oscillators must be enabled. After completion of the switch, the
    825          	 * unused oscillator can be disabled.
    826          	 */
    827          	pmc_enable_internal_osc();
   \                     ??pmc_select_external_osc_0:
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE311'0008        TST      R1,#0x8
   \       0x2C   0x1A00'0007        BNE      ??pmc_select_external_osc_2
   \       0x30   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x34   0xE3C1'28FF        BIC      R2,R1,#0xFF0000
   \       0x38   0xE382'3008        ORR      R3,R2,#0x8
   \       0x3C   0xE383'39DC        ORR      R3,R3,#0x370000
   \       0x40   0xE580'3000        STR      R3,[R0, #+0]
   \                     ??pmc_select_external_osc_3:
   \       0x44   0xE590'2048        LDR      R2,[R0, #+72]
   \       0x48   0xE312'0B80        TST      R2,#0x20000
   \       0x4C   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_3
    828          	err = pmc_enable_external_osc(bypass);
   \                     ??pmc_select_external_osc_2:
   \       0x50   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x54   0xE311'0001        TST      R1,#0x1
   \       0x58   0x1A00'0014        BNE      ??pmc_select_external_osc_4
   \       0x5C   0xE3A0'20FF        MOV      R2,#+255
   \       0x60   0xE382'24FF        ORR      R2,R2,#0xFF000000
   \       0x64   0xE002'1001        AND      R1,R2,R1
   \       0x68   0xE381'1D48        ORR      R1,R1,#0x1200
   \       0x6C   0xE381'19DC        ORR      R1,R1,#0x370000
   \       0x70   0xE580'1000        STR      R1,[R0, #+0]
   \       0x74   0xE381'3001        ORR      R3,R1,#0x1
   \       0x78   0xE580'3000        STR      R3,[R0, #+0]
   \       0x7C   0xE3A0'CE80        MOV      R12,#+2048
   \       0x80   0xE58D'C000        STR      R12,[SP, #+0]
   \                     ??pmc_select_external_osc_5:
   \       0x84   0xE590'1048        LDR      R1,[R0, #+72]
   \       0x88   0xE311'0001        TST      R1,#0x1
   \       0x8C   0x1A00'0003        BNE      ??pmc_select_external_osc_6
   \       0x90   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x94   0xE252'1001        SUBS     R1,R2,#+1
   \       0x98   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x9C   0x1AFF'FFF8        BNE      ??pmc_select_external_osc_5
   \                     ??pmc_select_external_osc_6:
   \       0xA0   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0xA4   0xE352'0000        CMP      R2,#+0
   \       0xA8   0x1A00'0004        BNE      ??pmc_select_external_osc_7
   \       0xAC   0xEA00'001D        B        ??pmc_select_external_osc_8
   \                     ??pmc_select_external_osc_4:
   \       0xB0   0xE590'2048        LDR      R2,[R0, #+72]
   \       0xB4   0xE312'0001        TST      R2,#0x1
   \       0xB8   0x03E0'003C        MVNEQ    R0,#+60
    829          	if (err < 0)
    830          		return err;
   \       0xBC   0x0A00'002A        BEQ      ??pmc_select_external_osc_9
    831          
    832          	/* switch MAIN clock to external oscillator */
    833          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCSEL
    834          	    | CKGR_MOR_KEY_PASSWD;
   \                     ??pmc_select_external_osc_7:
   \       0xC0   0xE590'1000        LDR      R1,[R0, #+0]
   \       0xC4   0xE3C1'28FF        BIC      R2,R1,#0xFF0000
   \       0xC8   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0xCC   0xE383'3740        ORR      R3,R3,#0x1000000
   \       0xD0   0xE580'3000        STR      R3,[R0, #+0]
    835          
    836          	/* wait for the command to be taken into account */
    837          	while ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) != CKGR_MOR_MOSCSEL);
   \                     ??pmc_select_external_osc_10:
   \       0xD4   0xE590'1000        LDR      R1,[R0, #+0]
   \       0xD8   0xE311'0740        TST      R1,#0x1000000
   \       0xDC   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_10
    838          
    839          	/* wait MAIN clock status change for external oscillator selection */
    840          	timeout = MOSCSELS_TIMEOUT;
   \       0xE0   0xE3A0'1020        MOV      R1,#+32
   \       0xE4   0xE58D'1000        STR      R1,[SP, #+0]
    841          	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS) && --timeout > 0);
   \                     ??pmc_select_external_osc_11:
   \       0xE8   0xE590'1048        LDR      R1,[R0, #+72]
   \       0xEC   0xE311'0B40        TST      R1,#0x10000
   \       0xF0   0x1A00'0003        BNE      ??pmc_select_external_osc_12
   \       0xF4   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0xF8   0xE252'1001        SUBS     R1,R2,#+1
   \       0xFC   0xE58D'1000        STR      R1,[SP, #+0]
   \      0x100   0x1AFF'FFF8        BNE      ??pmc_select_external_osc_11
    842          	if (!timeout) {
   \                     ??pmc_select_external_osc_12:
   \      0x104   0xE59D'2000        LDR      R2,[SP, #+0]
   \      0x108   0xE352'0000        CMP      R2,#+0
   \      0x10C   0x1A00'0006        BNE      ??pmc_select_external_osc_13
    843          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk))
    844          			| CKGR_MOR_KEY_PASSWD;
   \      0x110   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x114   0xE3E0'2740        MVN      R2,#+16777216
   \      0x118   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \      0x11C   0xE002'2001        AND      R2,R2,R1
   \      0x120   0xE382'39DC        ORR      R3,R2,#0x370000
   \      0x124   0xE580'3000        STR      R3,[R0, #+0]
    845          		return -ETIMEDOUT;
    846          	}
   \                     ??pmc_select_external_osc_8:
   \      0x128   0x....'....        B        ?Subroutine4
    847          
    848          	/* in case where MCK is running on MAIN CLK */
    849          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \                     ??pmc_select_external_osc_13:
   \      0x12C   0xE590'2008        LDR      R2,[R0, #+8]
   \      0x130   0xE312'0002        TST      R2,#0x2
   \      0x134   0x1A00'0002        BNE      ??pmc_select_external_osc_14
   \      0x138   0xE590'2008        LDR      R2,[R0, #+8]
   \      0x13C   0xE312'0001        TST      R2,#0x1
   \      0x140   0x0A00'0002        BEQ      ??pmc_select_external_osc_15
    850          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_external_osc_14:
   \      0x144   0xE590'2048        LDR      R2,[R0, #+72]
   \      0x148   0xE312'0008        TST      R2,#0x8
   \      0x14C   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_14
    851          
    852          	/* disable internal 12MHz RC to save power */
    853          	pmc_disable_internal_osc();
   \                     ??pmc_select_external_osc_15:
   \      0x150   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x154   0xE3E0'2008        MVN      R2,#+8
   \      0x158   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \      0x15C   0xE002'2001        AND      R2,R2,R1
   \      0x160   0xE382'39DC        ORR      R3,R2,#0x370000
   \      0x164   0xE580'3000        STR      R3,[R0, #+0]
    854          
    855          	return 0;
   \                     ??pmc_select_external_osc_1:
   \      0x168   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_select_external_osc_9:
   \      0x16C   0x....'....        B        ??Subroutine4_0
    856          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine4:
   \        0x0   0xE3E0'004C        MVN      R0,#+76
   \                     ??Subroutine4_0:
   \        0x4   0xE28D'D004        ADD      SP,SP,#+4
   \        0x8   0xE12F'FF1E        BX       LR
    857          

   \                                 In section SOFTPACK, align 4, keep-with-next
    858          RAMCODE int pmc_enable_external_osc(bool bypass)
    859          {
    860          	uint32_t cgmor = PMC->CKGR_MOR;
   \                     pmc_enable_external_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE24D'D004        SUB      SP,SP,#+4
   \        0x8   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
    861          	uint32_t mask = CKGR_MOR_MOSCXTEN;
    862          	volatile uint32_t timeout;
    863          
    864          #ifdef CKGR_MOR_MOSCXTBY
    865          	if (bypass)
    866          		mask = CKGR_MOR_MOSCXTBY;
    867          #else
    868          	(void)bypass;
    869          #endif /* CKGR_MOR_MOSCXTBY */
    870          
    871          	/* Enable Crystal Oscillator if needed */
    872          	if ((cgmor & mask) != mask) {
   \       0x10   0xE311'0001        TST      R1,#0x1
   \       0x14   0x1A00'0016        BNE      ??pmc_enable_external_osc_0
    873          		cgmor &= ~CKGR_MOR_KEY_Msk;
    874          		cgmor |= CKGR_MOR_KEY_PASSWD;
    875          
    876          #ifdef CKGR_MOR_MOSCXTBY
    877          		if (bypass) {
    878          			/* Disable Crystal Oscillator */
    879          			cgmor &= ~CKGR_MOR_MOSCXTEN;
    880          			PMC->CKGR_MOR = cgmor;
    881          
    882          			/* Wait Main Oscillator not ready */
    883          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
    884          
    885          			/* Enable Crystal Oscillator Bypass */
    886          			cgmor |= CKGR_MOR_MOSCXTBY;
    887          			PMC->CKGR_MOR = cgmor;
    888          		} else {
    889          			/* Disable Crystal Oscillator Bypass */
    890          			cgmor &= ~CKGR_MOR_MOSCXTBY;
    891          			PMC->CKGR_MOR = cgmor;
    892          
    893          			/* Wait Main Oscillator not ready */
    894          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
    895          
    896          			/* Set Oscillator Startup Time */
    897          			cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
    898          			cgmor |= CKGR_MOR_MOSCXTST(18);
    899          			PMC->CKGR_MOR = cgmor;
    900          
    901          			/* Enable Crystal Oscillator */
    902          			cgmor |= CKGR_MOR_MOSCXTEN;
    903          			PMC->CKGR_MOR = cgmor;
    904          		}
    905          #else
    906          		/* Set Oscillator Startup Time */
    907          		cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
    908          		cgmor |= CKGR_MOR_MOSCXTST(18);
   \       0x18   0xE3A0'20FF        MOV      R2,#+255
   \       0x1C   0xE382'24FF        ORR      R2,R2,#0xFF000000
   \       0x20   0xE002'1001        AND      R1,R2,R1
   \       0x24   0xE381'1D48        ORR      R1,R1,#0x1200
   \       0x28   0xE381'19DC        ORR      R1,R1,#0x370000
    909          		PMC->CKGR_MOR = cgmor;
   \       0x2C   0xE580'1000        STR      R1,[R0, #+0]
    910          
    911          		/* Enable Crystal Oscillator */
    912          		cgmor |= CKGR_MOR_MOSCXTEN;
    913          		PMC->CKGR_MOR = cgmor;
   \       0x30   0xE381'3001        ORR      R3,R1,#0x1
   \       0x34   0xE580'3000        STR      R3,[R0, #+0]
    914          #endif /* CKGR_MOR_MOSCXTBY */
    915          
    916          		/* Wait Main Oscillator ready */
    917          		timeout = MOSCXTS_TIMEOUT;
   \       0x38   0xE3A0'0E80        MOV      R0,#+2048
   \       0x3C   0xE3E0'20DF        MVN      R2,#+223
   \       0x40   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x44   0xE3C2'2FC0        BIC      R2,R2,#0x300
    918          		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS) && --timeout > 0);
   \                     ??pmc_enable_external_osc_1:
   \       0x48   0xE592'0048        LDR      R0,[R2, #+72]
   \       0x4C   0xE310'0001        TST      R0,#0x1
   \       0x50   0x1A00'0003        BNE      ??pmc_enable_external_osc_2
   \       0x54   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x58   0xE251'0001        SUBS     R0,R1,#+1
   \       0x5C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x60   0x1AFF'FFF8        BNE      ??pmc_enable_external_osc_1
    919          
    920          		/* Return true if oscillator ready before timeout */
    921          		return timeout == 0 ? -ETIMEDOUT : 0;
   \                     ??pmc_enable_external_osc_2:
   \       0x64   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x68   0xE351'0000        CMP      R1,#+0
   \       0x6C   0x1A00'0003        BNE      ??pmc_enable_external_osc_3
   \       0x70   0x....'....        B        ?Subroutine4
    922          	} else {
    923          		/* Crystal Oscillator already selected, just check if ready */
    924          		if (PMC->PMC_SR & PMC_SR_MOSCXTS)
   \                     ??pmc_enable_external_osc_0:
   \       0x74   0xE590'1048        LDR      R1,[R0, #+72]
   \       0x78   0xE311'0001        TST      R1,#0x1
   \       0x7C   0x0A00'0001        BEQ      ??pmc_enable_external_osc_4
    925          			return 0;
   \                     ??pmc_enable_external_osc_3:
   \       0x80   0xE3A0'0000        MOV      R0,#+0
   \       0x84   0x....'....        B        ??Subroutine4_0
    926          		else
    927          			return -ENOTSUP;
   \                     ??pmc_enable_external_osc_4:
   \       0x88   0xE3E0'003C        MVN      R0,#+60
   \       0x8C   0x....'....        B        ??Subroutine4_0
    928          	}
    929          }
    930          

   \                                 In section SOFTPACK, align 4, keep-with-next
    931          RAMCODE void pmc_disable_external_osc(void)
    932          {
    933          #ifdef CKGR_MOR_MOSCXTBY
    934          	uint32_t mask = CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTBY;
    935          #else
    936          	uint32_t mask = CKGR_MOR_MOSCXTEN;
    937          #endif /* CKGR_MOR_MOSCXTBY */
    938          
    939          	/* disable external OSC */
    940          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \                     pmc_disable_external_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3E0'2740        MVN      R2,#+16777216
   \       0x10   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \       0x14   0xE002'2001        AND      R2,R2,R1
   \       0x18   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0x1C   0xE580'3000        STR      R3,[R0, #+0]
    941          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(mask | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \       0x20   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x24   0xE3E0'1001        MVN      R1,#+1
   \       0x28   0xE3C1'18FF        BIC      R1,R1,#0xFF0000
   \       0x2C   0xE001'100C        AND      R1,R1,R12
   \       0x30   0xE381'29DC        ORR      R2,R1,#0x370000
   \       0x34   0xE580'2000        STR      R2,[R0, #+0]
    942          }
   \       0x38   0xE12F'FF1E        BX       LR               ;; return
    943          

   \                                 In section SOFTPACK, align 4, keep-with-next
    944          RAMCODE void pmc_select_internal_osc(void)
    945          {
   \                     pmc_select_internal_osc:
   \        0x0   0xE92D'4000        PUSH     {LR}
    946          	pmc_enable_internal_osc();
   \        0x4   0xE3E0'00DF        MVN      R0,#+223
   \        0x8   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0xC   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x10   0xE311'0008        TST      R1,#0x8
   \       0x14   0x1A00'0007        BNE      ??pmc_select_internal_osc_0
   \       0x18   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x1C   0xE3C1'28FF        BIC      R2,R1,#0xFF0000
   \       0x20   0xE382'3008        ORR      R3,R2,#0x8
   \       0x24   0xE383'39DC        ORR      R3,R3,#0x370000
   \       0x28   0xE580'3000        STR      R3,[R0, #+0]
   \                     ??pmc_select_internal_osc_1:
   \       0x2C   0xE590'2048        LDR      R2,[R0, #+72]
   \       0x30   0xE312'0B80        TST      R2,#0x20000
   \       0x34   0x0AFF'FFFC        BEQ      ??pmc_select_internal_osc_1
    947          
    948          	/* switch MAIN clock to internal 12MHz RC */
    949          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \                     ??pmc_select_internal_osc_0:
   \       0x38   0xE3E0'1740        MVN      R1,#+16777216
   \       0x3C   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x40   0xE3C1'18FF        BIC      R1,R1,#0xFF0000
   \       0x44   0xE001'2002        AND      R2,R1,R2
   \       0x48   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0x4C   0xE580'3000        STR      R3,[R0, #+0]
    950          
    951          	/* in case where MCK is running on MAIN CLK */
    952          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \       0x50   0xE590'2008        LDR      R2,[R0, #+8]
   \       0x54   0xE312'0002        TST      R2,#0x2
   \       0x58   0x1A00'0002        BNE      ??pmc_select_internal_osc_2
   \       0x5C   0xE590'3008        LDR      R3,[R0, #+8]
   \       0x60   0xE313'0001        TST      R3,#0x1
   \       0x64   0x0A00'0002        BEQ      ??pmc_select_internal_osc_3
    953          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_internal_osc_2:
   \       0x68   0xE590'3048        LDR      R3,[R0, #+72]
   \       0x6C   0xE313'0008        TST      R3,#0x8
   \       0x70   0x0AFF'FFFC        BEQ      ??pmc_select_internal_osc_2
    954          
    955          	/* disable external OSC 12 MHz to save power*/
    956          	pmc_disable_external_osc();
   \                     ??pmc_select_internal_osc_3:
   \       0x74   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x78   0xE3E0'E001        MVN      LR,#+1
   \       0x7C   0xE001'1002        AND      R1,R1,R2
   \       0x80   0xE381'39DC        ORR      R3,R1,#0x370000
   \       0x84   0xE580'3000        STR      R3,[R0, #+0]
   \       0x88   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x8C   0xE3CE'E8FF        BIC      LR,LR,#0xFF0000
   \       0x90   0xE00E'E00C        AND      LR,LR,R12
   \       0x94   0xE38E'19DC        ORR      R1,LR,#0x370000
   \       0x98   0xE580'1000        STR      R1,[R0, #+0]
    957          }
   \       0x9C   0xE8BD'8000        POP      {PC}             ;; return
    958          

   \                                 In section SOFTPACK, align 4, keep-with-next
    959          RAMCODE void pmc_enable_internal_osc(void)
    960          {
    961          #ifdef CKGR_MOR_MOSCRCEN
    962          	/* Enable internal 12MHz RC when needed */
    963          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCRCEN) != CKGR_MOR_MOSCRCEN) {
   \                     pmc_enable_internal_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE311'0008        TST      R1,#0x8
   \       0x10   0x1A00'0007        BNE      ??pmc_enable_internal_osc_0
    964          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCRCEN | CKGR_MOR_KEY_PASSWD;
   \       0x14   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x18   0xE3C1'28FF        BIC      R2,R1,#0xFF0000
   \       0x1C   0xE382'3008        ORR      R3,R2,#0x8
   \       0x20   0xE383'39DC        ORR      R3,R3,#0x370000
   \       0x24   0xE580'3000        STR      R3,[R0, #+0]
    965          		/* Wait internal 12MHz RC Startup Time for clock stabilization */
    966          		while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
   \                     ??pmc_enable_internal_osc_1:
   \       0x28   0xE590'1048        LDR      R1,[R0, #+72]
   \       0x2C   0xE311'0B80        TST      R1,#0x20000
   \       0x30   0x0AFF'FFFC        BEQ      ??pmc_enable_internal_osc_1
    967          	}
    968          #endif
    969          }
   \                     ??pmc_enable_internal_osc_0:
   \       0x34   0xE12F'FF1E        BX       LR               ;; return
    970          

   \                                 In section SOFTPACK, align 4, keep-with-next
    971          RAMCODE void pmc_disable_internal_osc(void)
    972          {
    973          #ifdef CKGR_MOR_MOSCRCEN
    974          	/* disable internal 12MHz RC */
    975          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_KEY_PASSWD;
   \                     pmc_disable_internal_osc:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3E0'2008        MVN      R2,#+8
   \       0x10   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \       0x14   0xE002'2001        AND      R2,R2,R1
   \       0x18   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0x1C   0xE580'3000        STR      R3,[R0, #+0]
    976          #endif
    977          }
   \       0x20   0xE12F'FF1E        BX       LR               ;; return
    978          

   \                                 In section SOFTPACK, align 4, keep-with-next
    979          RAMCODE void pmc_enable_ulp1(void)
    980          {
    981          #ifdef CKGR_MOR_ULP1
    982          	/* enable ulp1 mode */
    983          	PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_ULP1 | CKGR_MOR_KEY_PASSWD;
   \                     pmc_enable_ulp1:
   \        0x0   0xE3E0'00DF        MVN      R0,#+223
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE381'2004        ORR      R2,R1,#0x4
   \       0x10   0xE392'29DC        ORRS     R2,R2,#0x370000
   \       0x14   0xE580'2000        STR      R2,[R0, #+0]
    984          	asm volatile ("nop");
   \       0x18   0xE1A0'0000        nop
    985          	asm volatile ("nop");
   \       0x1C   0xE1A0'0000        nop
    986          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_enable_ulp1_0:
   \       0x20   0xE590'1048        LDR      R1,[R0, #+72]
   \       0x24   0xE311'0008        TST      R1,#0x8
   \       0x28   0x0AFF'FFFC        BEQ      ??pmc_enable_ulp1_0
    987          #endif
    988          }
   \       0x2C   0xE12F'FF1E        BX       LR               ;; return
    989          

   \                                 In section SOFTPACK, align 4, keep-with-next
    990          void pmc_switch_mck_to_new_source(uint32_t mckr_css)
    991          {
    992          	uint32_t mckr = PMC->PMC_MCKR;
   \                     pmc_switch_mck_to_new_source:
   \        0x0   0xE3E0'10D7        MVN      R1,#+215
   \        0x4   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
    993          	uint32_t mask = PMC_MCKR_CSS_Msk;
    994          
    995          	if ((mckr ^ mckr_css) & mask) {
   \        0xC   0xE020'3002        EOR      R3,R0,R2
   \       0x10   0xE313'0003        TST      R3,#0x3
   \       0x14   0x0A00'0006        BEQ      ??pmc_switch_mck_to_new_source_0
    996          		PMC->PMC_MCKR = (mckr & ~mask) | (mckr_css & mask);
   \       0x18   0xE1A0'2122        LSR      R2,R2,#+2
   \       0x1C   0xE200'0003        AND      R0,R0,#0x3
   \       0x20   0xE180'0102        ORR      R0,R0,R2, LSL #+2
   \       0x24   0xE581'0000        STR      R0,[R1, #+0]
    997          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_new_source_1:
   \       0x28   0xE591'0040        LDR      R0,[R1, #+64]
   \       0x2C   0xE310'0008        TST      R0,#0x8
   \       0x30   0x0AFF'FFFC        BEQ      ??pmc_switch_mck_to_new_source_1
    998          	}
    999          
   1000          	_pmc_mck = 0;
   \                     ??pmc_switch_mck_to_new_source_0:
   \       0x34   0x....'....        B        ??Subroutine5_0
   1001          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??Subroutine5_0:
   \        0x0   0x....'....        LDR      R1,??DataTable29
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0xE581'0008        STR      R0,[R1, #+8]
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
   1002          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1003          RAMCODE void pmc_switch_mck_to_pll(void)
   1004          {
   1005          	/* Select PLL as input clock for PCK and MCK */
   1006          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_PLLA_CLK;
   \                     pmc_switch_mck_to_pll:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3C1'2003        BIC      R2,R1,#0x3
   \       0x10   0xE382'3002        ORR      R3,R2,#0x2
   \       0x14   0x....'....        B        ?Subroutine3
   1007          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1008          
   1009          	_pmc_mck = 0;
   1010          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine3:
   \        0x0   0xE580'3000        STR      R3,[R0, #+0]
   \                     ??Subroutine3_0:
   \        0x4   0xE590'1040        LDR      R1,[R0, #+64]
   \        0x8   0xE311'0008        TST      R1,#0x8
   \        0xC   0x0AFF'FFFC        BEQ      ??Subroutine3_0
   \       0x10                      REQUIRE ??Subroutine5_0
   \       0x10                      ;; // Fall through to label ??Subroutine5_0
   1011          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1012          RAMCODE void pmc_switch_mck_to_upll(void)
   1013          {
   1014          	/* Select UPLL as input clock for PCK and MCK */
   1015          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_UPLL_CLK;
   \                     pmc_switch_mck_to_upll:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE381'2003        ORR      R2,R1,#0x3
   \       0x10   0xE580'2000        STR      R2,[R0, #+0]
   \       0x14   0x....'....        B        ??Subroutine3_0
   1016          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1017          
   1018          	_pmc_mck = 0;
   1019          }
   1020          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1021          RAMCODE void pmc_switch_mck_to_main(void)
   1022          {
   1023          	/* Select Main Oscillator as input clock for PCK and MCK */
   1024          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   \                     pmc_switch_mck_to_main:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3C1'2003        BIC      R2,R1,#0x3
   \       0x10   0xE382'3001        ORR      R3,R2,#0x1
   \       0x14                      REQUIRE ?Subroutine3
   \       0x14                      ;; // Fall through to label ?Subroutine3
   1025          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1026          
   1027          	_pmc_mck = 0;
   1028          }
   1029          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1030          RAMCODE void pmc_switch_mck_to_slck(void)
   1031          {
   1032          	/* Select Slow Clock as input clock for PCK and MCK */
   1033          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_SLOW_CLK;
   \                     pmc_switch_mck_to_slck:
   \        0x0   0xE3E0'00D7        MVN      R0,#+215
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1000        LDR      R1,[R0, #+0]
   \        0xC   0xE3C1'2003        BIC      R2,R1,#0x3
   \       0x10   0xE580'2000        STR      R2,[R0, #+0]
   \       0x14   0x....'....        B        ??Subroutine3_0
   1034          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1035          
   1036          	_pmc_mck = 0;
   1037          }
   1038          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1039          RAMCODE void pmc_set_mck_prescaler(uint32_t prescaler)
   1040          {
   \                     pmc_set_mck_prescaler:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1041          	_ASSERT(!(prescaler & ~PMC_MCKR_PRES_Msk));
   \        0x8   0xE3D4'0070        BICS     R0,R4,#0x70
   \        0xC   0x0A00'0005        BEQ      ??pmc_set_mck_prescaler_0
   \       0x10   0xE3A0'2011        MOV      R2,#+17
   \       0x14   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x18   0x....'....        LDR      R1,??DataTable23
   \       0x1C   0x....'....        LDR      R0,??DataTable40
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1042          
   1043          	/* Change MCK Prescaler divider in PMC_MCKR register */
   1044          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_PRES_Msk) | prescaler;
   \                     ??pmc_set_mck_prescaler_0:
   \       0x28   0xE3E0'00D7        MVN      R0,#+215
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x34   0xE3C1'2070        BIC      R2,R1,#0x70
   \       0x38   0x....'....        B        ?Subroutine0
   1045          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1046          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE184'2002        ORR      R2,R4,R2
   \        0x4   0xE580'2000        STR      R2,[R0, #+0]
   \                     ??Subroutine0_0:
   \        0x8   0xE590'1040        LDR      R1,[R0, #+64]
   \        0xC   0xE311'0008        TST      R1,#0x8
   \       0x10   0x0AFF'FFFC        BEQ      ??Subroutine0_0
   \       0x14   0xE8BD'8010        POP      {R4,PC}          ;; return
   1047          
   1048          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1049          RAMCODE void pmc_set_mck_plladiv2(bool div2)
   1050          {
   1051          	uint32_t mckr = PMC->PMC_MCKR;
   1052          	if (div2) {
   1053          		if ((mckr & PMC_MCKR_PLLADIV2) != PMC_MCKR_PLLADIV2)
   1054          			PMC->PMC_MCKR = mckr | PMC_MCKR_PLLADIV2;
   1055          	} else {
   1056          		if ((mckr & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2)
   1057          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_PLLADIV2;
   1058          	}
   1059          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1060          }
   1061          #endif
   1062          
   1063          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1064          void pmc_set_mck_uplldiv2(bool div2)
   1065          {
   1066          	uint32_t mckr = PMC->PMC_MCKR;
   1067          	if (div2) {
   1068          		if ((mckr & PMC_MCKR_UPLLDIV2) != PMC_MCKR_UPLLDIV2)
   1069          			PMC->PMC_MCKR = mckr | PMC_MCKR_UPLLDIV2;
   1070          	} else {
   1071          		if ((PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2) == PMC_MCKR_UPLLDIV2)
   1072          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_UPLLDIV2;
   1073          	}
   1074          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1075          }
   1076          #endif
   1077          
   1078          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1079          RAMCODE void pmc_set_mck_h32mxdiv(bool div2)
   1080          {
   1081          	uint32_t mckr = PMC->PMC_MCKR;
   1082          	if (div2) {
   1083          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV2)
   1084          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV2;
   1085          	} else {
   1086          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV1)
   1087          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV1;
   1088          	}
   1089          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1090          }
   1091          #endif /* CONFIG_HAVE_PMC_H32MXDIV */
   1092          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1093          RAMCODE void pmc_set_mck_divider(uint32_t divider)
   1094          {
   \                     pmc_set_mck_divider:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1095          	_ASSERT(!(divider & ~PMC_MCKR_MDIV_Msk));
   \        0x8   0xE3D4'0E70        BICS     R0,R4,#0x700
   \        0xC   0x0A00'0005        BEQ      ??pmc_set_mck_divider_0
   \       0x10   0xE3A0'2047        MOV      R2,#+71
   \       0x14   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x18   0x....'....        LDR      R1,??DataTable23
   \       0x1C   0x....'....        LDR      R0,??DataTable40_1
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1096          
   1097          	/* change MCK Prescaler divider in PMC_MCKR register */
   1098          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_MDIV_Msk) | divider;
   \                     ??pmc_set_mck_divider_0:
   \       0x28   0xE3E0'00D7        MVN      R0,#+215
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x34   0xE3C1'2E70        BIC      R2,R1,#0x700
   \       0x38                      REQUIRE ?Subroutine0
   \       0x38                      ;; // Fall through to label ?Subroutine0
   1099          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1100          }
   1101          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1102          RAMCODE void pmc_configure_plla(const struct _pmc_plla_cfg* plla)
   1103          {
   1104          #if defined(PMC_PLL_UPDT_ID)
   1105          	_pmc_configure_pll(plla);
   \                     pmc_configure_plla:
   \        0x0   0x....'....        B        _pmc_configure_pll  ;; tailcall
   1106          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1107          	uint32_t pllar = 0;
   1108          
   1109          #ifdef CKGR_PLLAR_ONE
   1110          	pllar |= CKGR_PLLAR_ONE;
   1111          #endif
   1112          	pllar |= CKGR_PLLAR_MULA(plla->mul);
   1113          	pllar |= CKGR_PLLAR_DIVA(plla->div);
   1114          	pllar |= CKGR_PLLAR_PLLACOUNT(plla->count);
   1115          	PMC->CKGR_PLLAR = pllar;
   1116          
   1117          #ifdef CONFIG_HAVE_PMC_PLLA_CHARGEPUMP
   1118          	PMC->PMC_PLLICPR = plla->icp & PMC_PLLICPR_ICP_PLLA_Msk;
   1119          #endif /* CONFIG_HAVE_PMC_PLLA_CHARGEPUMP */
   1120          
   1121          	if (plla->mul > 0)
   1122          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
   1123          #endif
   1124          }
   1125          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1126          RAMCODE void pmc_disable_plla(void)
   1127          {
   1128          #if defined(PMC_PLL_UPDT_ID)
   1129          	_pmc_disable_pll(PLL_ID_PLLA);
   \                     pmc_disable_plla:
   \        0x0   0xE3E0'00F3        MVN      R0,#+243
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'0010        LDR      R0,[R0, #+16]
   \        0xC   0xE3E0'1001        MVN      R1,#+1
   \       0x10   0xE3C1'1F40        BIC      R1,R1,#0x100
   \       0x14   0xE001'1000        AND      R1,R1,R0
   \       0x18   0xE3E0'00F3        MVN      R0,#+243
   \       0x1C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x20   0xE580'1010        STR      R1,[R0, #+16]
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE3C1'1580        BIC      R1,R1,#0x20000000
   \       0x2C   0xE381'2540        ORR      R2,R1,#0x10000000
   \       0x30   0xE580'2000        STR      R2,[R0, #+0]
   \       0x34   0xE590'1010        LDR      R1,[R0, #+16]
   \       0x38   0xE381'2F40        ORR      R2,R1,#0x100
   \       0x3C   0xE580'2010        STR      R2,[R0, #+16]
   \       0x40   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x44   0xE3C1'2540        BIC      R2,R1,#0x10000000
   \       0x48   0xE580'2000        STR      R2,[R0, #+0]
   1130          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1131          	PMC->CKGR_PLLAR = (PMC->CKGR_PLLAR & ~CKGR_PLLAR_MULA_Msk) | CKGR_PLLAR_MULA(0);
   1132          #endif
   1133          }
   \       0x4C   0xE12F'FF1E        BX       LR               ;; return
   1134          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1135          bool pmc_has_system_clock(enum _pmc_system_clock clock)
   1136          {
   1137          	return _pmc_get_system_clock_bits(clock, NULL, NULL, NULL);
   \                     pmc_has_system_clock:
   \        0x0   0xE350'0000        CMP      R0,#+0
   \        0x4   0x0A00'0006        BEQ      ??pmc_has_system_clock_0
   \        0x8   0xE250'0003        SUBS     R0,R0,#+3
   \        0xC   0x0A00'0004        BEQ      ??pmc_has_system_clock_0
   \       0x10   0xE240'0002        SUB      R0,R0,#+2
   \       0x14   0xE350'0001        CMP      R0,#+1
   \       0x18   0x9A00'0001        BLS      ??pmc_has_system_clock_0
   \       0x1C   0xE250'0008        SUBS     R0,R0,#+8
   \       0x20   0x1A00'0001        BNE      ??pmc_has_system_clock_1
   \                     ??pmc_has_system_clock_0:
   \       0x24   0xE3A0'0001        MOV      R0,#+1
   \       0x28   0xE12F'FF1E        BX       LR
   \                     ??pmc_has_system_clock_1:
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0xE12F'FF1E        BX       LR               ;; return
   1138          }
   1139          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1140          RAMCODE void pmc_enable_system_clock(enum _pmc_system_clock clock)
   1141          {
   \                     pmc_enable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1142          	uint32_t scer, scsr;
   1143          
   1144          	if (!_pmc_get_system_clock_bits(clock, &scer, NULL, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE28D'1004        ADD      R1,SP,#+4
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0007        BNE      ??pmc_enable_system_clock_0
   1145          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable26
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000F        BCC      ??pmc_enable_system_clock_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable42
   \       0x38   0x....'....        BL       printf
   1146          		return;
   \       0x3C   0xE8BD'8013        POP      {R0,R1,R4,PC}
   1147          	}
   1148          
   1149          	PMC->PMC_SCER |= scer;
   \                     ??pmc_enable_system_clock_0:
   \       0x40   0xE3E0'00FF        MVN      R0,#+255
   \       0x44   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x48   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x4C   0xE59D'3004        LDR      R3,[SP, #+4]
   \       0x50   0xE183'3001        ORR      R3,R3,R1
   \       0x54   0xE580'3000        STR      R3,[R0, #+0]
   1150          	while (!(PMC->PMC_SCSR & scsr));
   \                     ??pmc_enable_system_clock_2:
   \       0x58   0xE3E0'00FF        MVN      R0,#+255
   \       0x5C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x60   0xE590'1008        LDR      R1,[R0, #+8]
   \       0x64   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x68   0xE110'0001        TST      R0,R1
   \       0x6C   0x0AFF'FFF9        BEQ      ??pmc_enable_system_clock_2
   1151          }
   \                     ??pmc_enable_system_clock_1:
   \       0x70   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1152          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1153          RAMCODE void pmc_disable_system_clock(enum _pmc_system_clock clock)
   1154          {
   \                     pmc_disable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1155          	uint32_t scdr, scsr;
   1156          
   1157          	if (!_pmc_get_system_clock_bits(clock, NULL, &scdr, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE28D'2004        ADD      R2,SP,#+4
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0007        BNE      ??pmc_disable_system_clock_0
   1158          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable26
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000F        BCC      ??pmc_disable_system_clock_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable42_1
   \       0x38   0x....'....        BL       printf
   1159          		return;
   \       0x3C   0xE8BD'8013        POP      {R0,R1,R4,PC}
   1160          	}
   1161          
   1162          	PMC->PMC_SCDR |= scdr;
   \                     ??pmc_disable_system_clock_0:
   \       0x40   0xE3E0'00FB        MVN      R0,#+251
   \       0x44   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x48   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x4C   0xE59D'3004        LDR      R3,[SP, #+4]
   \       0x50   0xE183'3001        ORR      R3,R3,R1
   \       0x54   0xE580'3000        STR      R3,[R0, #+0]
   1163          	while (PMC->PMC_SCSR & scsr);
   \                     ??pmc_disable_system_clock_2:
   \       0x58   0xE3E0'00FB        MVN      R0,#+251
   \       0x5C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x60   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x64   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x68   0xE110'0001        TST      R0,R1
   \       0x6C   0x1AFF'FFF9        BNE      ??pmc_disable_system_clock_2
   1164          }
   \                     ??pmc_disable_system_clock_1:
   \       0x70   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1165          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1166          bool pmc_is_system_clock_enabled(enum _pmc_system_clock clock)
   1167          {
   \                     pmc_is_system_clock_enabled:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1168          	uint32_t scsr;
   1169          
   1170          	if (!_pmc_get_system_clock_bits(clock, NULL, NULL, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0007        BNE      ??pmc_is_system_clock_enabled_0
   1171          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable26
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000D        BCC      ??pmc_is_system_clock_enabled_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable42_2
   \       0x38   0x....'....        BL       printf
   1172          		return false;
   \       0x3C   0xEA00'0009        B        ??pmc_is_system_clock_enabled_1
   1173          	}
   1174          
   1175          	return (PMC->PMC_SCSR & scsr) == scsr;
   \                     ??pmc_is_system_clock_enabled_0:
   \       0x40   0xE3E0'00F7        MVN      R0,#+247
   \       0x44   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x48   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x4C   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x50   0xE003'3001        AND      R3,R3,R1
   \       0x54   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x58   0xE153'0001        CMP      R3,R1
   \       0x5C   0x1A00'0001        BNE      ??pmc_is_system_clock_enabled_1
   \       0x60   0xE3A0'0001        MOV      R0,#+1
   \       0x64   0xE8BD'8016        POP      {R1,R2,R4,PC}
   \                     ??pmc_is_system_clock_enabled_1:
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
   1176          }
   1177          
   1178          #ifdef CONFIG_HAVE_PMC_FAST_STARTUP

   \                                 In section SOFTPACK, align 4, keep-with-next
   1179          void pmc_set_fast_startup_mode(uint32_t startup_mode)
   1180          {
   1181          	PMC->PMC_FSMR = startup_mode;
   \                     pmc_set_fast_startup_mode:
   \        0x0   0xE3E0'108F        MVN      R1,#+143
   \        0x4   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \        0x8   0xE581'0000        STR      R0,[R1, #+0]
   1182          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
   1183          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1184          void pmc_set_fast_startup_polarity(uint32_t high_level, uint32_t low_level)
   1185          {
   1186          #ifdef PMC_FSPR_FSTP0
   1187          	PMC->PMC_FSPR &= ~low_level;
   1188          	PMC->PMC_FSPR |= high_level;
   1189          #endif /* PMC_FSPR_FSTP0 */
   1190          }
   \                     pmc_set_fast_startup_polarity:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
   1191          #endif /* CONFIG_HAVE_PMC_FAST_STARTUP */
   1192          
   1193          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1194           * it doesn't support samv71 targets. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1195          RAMCODE void pmc_set_custom_pck_mck(const struct pck_mck_cfg *cfg)
   1196          {
   \                     pmc_set_custom_pck_mck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1197          	pmc_switch_mck_to_slck();
   \        0x8   0x....'....        BL       pmc_switch_mck_to_slck
   1198          
   1199          	if (cfg->extosc)
   \        0xC   0xE5D4'0004        LDRB     R0,[R4, #+4]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_0
   1200          		pmc_select_external_osc(cfg->ext_bypass);
   \       0x18   0xE5D4'0005        LDRB     R0,[R4, #+5]
   \       0x1C   0x....'....        BL       pmc_select_external_osc
   \       0x20   0xEA00'0000        B        ??pmc_set_custom_pck_mck_1
   1201          	else
   1202          		pmc_select_internal_osc();
   \                     ??pmc_set_custom_pck_mck_0:
   \       0x24   0x....'....        BL       pmc_select_internal_osc
   1203          
   1204          	pmc_switch_mck_to_main();
   \                     ??pmc_set_custom_pck_mck_1:
   \       0x28   0x....'....        BL       pmc_switch_mck_to_main
   1205          
   1206          	if (cfg->ext32k) {
   \       0x2C   0xE5D4'0006        LDRB     R0,[R4, #+6]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0A00'0003        BEQ      ??pmc_set_custom_pck_mck_2
   1207          		pmc_select_external_crystal();
   \       0x38   0x....'....        BL       pmc_select_external_crystal
   1208          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1209          		slowclock_set_bypass(cfg->ext32k_bypass);
   \       0x3C   0xE5D4'0007        LDRB     R0,[R4, #+7]
   \       0x40   0x....'....        BL       slowclock_set_bypass
   \       0x44   0xEA00'0000        B        ??pmc_set_custom_pck_mck_3
   1210          #endif
   1211          	}
   1212          	else
   1213          		pmc_select_internal_crystal();
   \                     ??pmc_set_custom_pck_mck_2:
   \       0x48   0x....'....        BL       pmc_select_internal_crystal
   1214          
   1215          	pmc_disable_plla();
   \                     ??pmc_set_custom_pck_mck_3:
   \       0x4C   0xE3E0'00F3        MVN      R0,#+243
   \       0x50   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x54   0xE590'0010        LDR      R0,[R0, #+16]
   \       0x58   0xE3E0'1001        MVN      R1,#+1
   \       0x5C   0xE3C1'1F40        BIC      R1,R1,#0x100
   \       0x60   0xE001'1000        AND      R1,R1,R0
   \       0x64   0xE3E0'00F3        MVN      R0,#+243
   \       0x68   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x6C   0xE580'1010        STR      R1,[R0, #+16]
   \       0x70   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x74   0xE3C1'1580        BIC      R1,R1,#0x20000000
   \       0x78   0xE381'2540        ORR      R2,R1,#0x10000000
   \       0x7C   0xE580'2000        STR      R2,[R0, #+0]
   \       0x80   0xE590'1010        LDR      R1,[R0, #+16]
   \       0x84   0xE381'2F40        ORR      R2,R1,#0x100
   \       0x88   0xE580'2010        STR      R2,[R0, #+16]
   \       0x8C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x90   0xE3C1'2540        BIC      R2,R1,#0x10000000
   \       0x94   0xE580'2000        STR      R2,[R0, #+0]
   1216          	if (cfg->plla.mul > 0 && cfg->plla.div > 0) {
   \       0x98   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x9C   0xE350'0000        CMP      R0,#+0
   \       0xA0   0x0A00'0004        BEQ      ??pmc_set_custom_pck_mck_4
   \       0xA4   0xE594'000C        LDR      R0,[R4, #+12]
   \       0xA8   0xE350'0000        CMP      R0,#+0
   \       0xAC   0x0A00'0001        BEQ      ??pmc_set_custom_pck_mck_4
   1217          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1218          		pmc_set_mck_plladiv2(cfg->plla_div2);
   1219          #endif
   1220          		pmc_configure_plla(&cfg->plla);
   \       0xB0   0xE284'0008        ADD      R0,R4,#+8
   \       0xB4   0x....'....        BL       _pmc_configure_pll
   1221          	}
   1222          
   1223          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1224          	pmc_set_mck_uplldiv2(cfg->upll_div2);
   1225          #endif
   1226          	pmc_set_mck_prescaler(cfg->pck_pres);
   \                     ??pmc_set_custom_pck_mck_4:
   \       0xB8   0xE594'0020        LDR      R0,[R4, #+32]
   \       0xBC   0x....'....        BL       pmc_set_mck_prescaler
   1227          	pmc_set_mck_divider(cfg->mck_div);
   \       0xC0   0xE594'0024        LDR      R0,[R4, #+36]
   \       0xC4   0x....'....        BL       pmc_set_mck_divider
   1228          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1229          	pmc_set_mck_h32mxdiv(cfg->h32mx_div2);
   1230          #endif
   1231          
   1232          	switch (cfg->pck_input) {
   \       0xC8   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xCC   0xE350'0000        CMP      R0,#+0
   \       0xD0   0x0A00'0013        BEQ      ??pmc_set_custom_pck_mck_5
   \       0xD4   0xE350'0002        CMP      R0,#+2
   \       0xD8   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_6
   \       0xDC   0xE350'0003        CMP      R0,#+3
   \       0xE0   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_7
   \       0xE4   0xE8BD'8010        POP      {R4,PC}
   1233          	case PMC_MCKR_CSS_PLLA_CLK:
   1234          		pmc_switch_mck_to_pll();
   \                     ??pmc_set_custom_pck_mck_6:
   \       0xE8   0xE8BD'4010        POP      {R4,LR}
   \       0xEC   0x....'....        B        pmc_switch_mck_to_pll  ;; tailcall
   1235          		break;
   1236          
   1237          	case PMC_MCKR_CSS_UPLL_CLK:
   1238          		pmc_switch_mck_to_upll();
   \                     ??pmc_set_custom_pck_mck_7:
   \       0xF0   0xE3E0'00F3        MVN      R0,#+243
   \       0xF4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0xF8   0xE590'101C        LDR      R1,[R0, #+28]
   \       0xFC   0xE381'2003        ORR      R2,R1,#0x3
   \      0x100   0xE580'201C        STR      R2,[R0, #+28]
   \      0x104   0xE1A0'1000        MOV      R1,R0
   \                     ??pmc_set_custom_pck_mck_8:
   \      0x108   0xE591'005C        LDR      R0,[R1, #+92]
   \      0x10C   0xE310'0008        TST      R0,#0x8
   \      0x110   0x0AFF'FFFC        BEQ      ??pmc_set_custom_pck_mck_8
   \      0x114   0x....'....        LDR      R1,??DataTable36
   \      0x118   0xE3A0'0000        MOV      R0,#+0
   \      0x11C   0xE581'0008        STR      R0,[R1, #+8]
   1239          		break;
   \      0x120   0xE8BD'8010        POP      {R4,PC}
   1240          
   1241          	case PMC_MCKR_CSS_SLOW_CLK:
   1242          		pmc_switch_mck_to_slck();
   \                     ??pmc_set_custom_pck_mck_5:
   \      0x124   0x....'....        BL       pmc_switch_mck_to_slck
   1243          		pmc_disable_internal_osc();
   \      0x128   0xE3E0'00F3        MVN      R0,#+243
   \      0x12C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x130   0xE590'1014        LDR      R1,[R0, #+20]
   \      0x134   0xE3E0'2008        MVN      R2,#+8
   \      0x138   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \      0x13C   0xE002'2001        AND      R2,R2,R1
   \      0x140   0xE3E0'30F3        MVN      R3,#+243
   \      0x144   0xE382'09DC        ORR      R0,R2,#0x370000
   \      0x148   0xE3C3'3FC0        BIC      R3,R3,#0x300
   \      0x14C   0xE583'0014        STR      R0,[R3, #+20]
   1244          		pmc_disable_external_osc();
   \      0x150   0xE593'0014        LDR      R0,[R3, #+20]
   \      0x154   0xE3E0'2740        MVN      R2,#+16777216
   \      0x158   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \      0x15C   0xE002'2000        AND      R2,R2,R0
   \      0x160   0xE382'19DC        ORR      R1,R2,#0x370000
   \      0x164   0xE583'1014        STR      R1,[R3, #+20]
   \      0x168   0xE593'1014        LDR      R1,[R3, #+20]
   \      0x16C   0xE3E0'2001        MVN      R2,#+1
   \      0x170   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \      0x174   0xE002'2001        AND      R2,R2,R1
   \      0x178   0xE382'09DC        ORR      R0,R2,#0x370000
   \      0x17C   0xE583'0014        STR      R0,[R3, #+20]
   1245          		break;
   1246          	}
   1247          }
   \      0x180   0xE8BD'8010        POP      {R4,PC}          ;; return
   1248          
   1249          /*----------------------------------------------------------------------------
   1250           *        Exported functions (Peripherals)
   1251           *----------------------------------------------------------------------------*/
   1252          
   1253          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1254           * it only supports a NULL (struct _pmc_periph_cfg*) parameter. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1255          RAMCODE void pmc_configure_peripheral(uint32_t id, const struct _pmc_periph_cfg* cfg, bool enable)
   1256          {
   \                     pmc_configure_peripheral:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
   1257          	_ASSERT(id < ID_PERIPH_COUNT);
   \       0x10   0xE354'0033        CMP      R4,#+51
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_peripheral_0
   \       0x18   0xE3A0'20E9        MOV      R2,#+233
   \       0x1C   0xE382'2E40        ORR      R2,R2,#0x400
   \       0x20   0x....'....        LDR      R1,??DataTable42_3
   \       0x24   0x....'....        LDR      R0,??DataTable42_4
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1258          
   1259          	pmc_disable_peripheral(id);
   \                     ??pmc_configure_peripheral_0:
   \       0x30   0xE1A0'0004        MOV      R0,R4
   \       0x34   0x....'....        BL       pmc_disable_peripheral
   1260          
   1261          	if (cfg != NULL) {
   \       0x38   0xE355'0000        CMP      R5,#+0
   \       0x3C   0x0A00'0006        BEQ      ??pmc_configure_peripheral_1
   1262          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1263          		if (cfg->gck.div > 0)
   \       0x40   0xE595'2004        LDR      R2,[R5, #+4]
   \       0x44   0xE352'0000        CMP      R2,#+0
   \       0x48   0x0A00'0005        BEQ      ??pmc_configure_peripheral_2
   1264          			pmc_configure_gck(id, cfg->gck.css, cfg->gck.div);
   \       0x4C   0xE595'1000        LDR      R1,[R5, #+0]
   \       0x50   0xE1A0'0004        MOV      R0,R4
   \       0x54   0x....'....        BL       pmc_configure_gck
   \       0x58   0xEA00'0001        B        ??pmc_configure_peripheral_2
   1265          #endif
   1266          
   1267          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1268          		_pmc_configure_peripheral_div(id, cfg->div);
   1269          #endif
   1270          	} else {
   1271          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1272          		pmc_disable_gck(id);
   \                     ??pmc_configure_peripheral_1:
   \       0x5C   0xE1A0'0004        MOV      R0,R4
   \       0x60   0x....'....        BL       pmc_disable_gck
   1273          #endif
   1274          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1275          		_pmc_configure_peripheral_div(id, 0);
   1276          #endif
   1277          	}
   1278          
   1279          	/* Enable peripheral, gck or only configure it */
   1280          	if (enable) {
   \                     ??pmc_configure_peripheral_2:
   \       0x64   0xE356'0000        CMP      R6,#+0
   \       0x68   0x0A00'0009        BEQ      ??pmc_configure_peripheral_3
   1281          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1282          		if (cfg && cfg->gck.div > 0)
   \       0x6C   0xE355'0000        CMP      R5,#+0
   \       0x70   0x0A00'0004        BEQ      ??pmc_configure_peripheral_4
   \       0x74   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x78   0xE350'0000        CMP      R0,#+0
   \       0x7C   0x0A00'0001        BEQ      ??pmc_configure_peripheral_4
   1283          			pmc_enable_gck(id);
   \       0x80   0xE1A0'0004        MOV      R0,R4
   \       0x84   0x....'....        BL       pmc_enable_gck
   1284          #endif
   1285          		pmc_enable_peripheral(id);
   \                     ??pmc_configure_peripheral_4:
   \       0x88   0xE1A0'0004        MOV      R0,R4
   \       0x8C   0xE8BD'4070        POP      {R4-R6,LR}
   \       0x90   0x....'....        B        pmc_enable_peripheral  ;; tailcall
   1286          	}
   1287          }
   \                     ??pmc_configure_peripheral_3:
   \       0x94   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1288          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1289          RAMCODE void pmc_enable_peripheral(uint32_t id)
   1290          {
   \                     pmc_enable_peripheral:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1291          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_peripheral_0
   \       0x10   0xE3A0'200B        MOV      R2,#+11
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        LDR      R0,??DataTable42_4
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1292          
   1293          	// select peripheral
   1294          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_enable_peripheral_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE204'107F        AND      R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1295          
   1296          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x3C   0xE58D'2000        STR      R2,[SP, #+0]
   1297          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_EN;
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE381'2490        ORR      R2,R1,#0x90000000
   \       0x48   0xE580'2000        STR      R2,[R0, #+0]
   1298          }
   \       0x4C   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1299          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1300          RAMCODE void pmc_disable_peripheral(uint32_t id)
   1301          {
   \                     pmc_disable_peripheral:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1302          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_peripheral_0
   \       0x10   0xE3A0'2016        MOV      R2,#+22
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        LDR      R0,??DataTable42_4
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1303          
   1304          	// select peripheral
   1305          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_disable_peripheral_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE204'107F        AND      R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1306          
   1307          	// disable it but keep previous configuration
   1308          	PMC->PMC_PCR = (PMC->PMC_PCR & ~PMC_PCR_EN) | PMC_PCR_CMD;
   \       0x38   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x3C   0xE3C2'3540        BIC      R3,R2,#0x10000000
   \       0x40   0xE383'C480        ORR      R12,R3,#0x80000000
   \       0x44   0xE580'C000        STR      R12,[R0, #+0]
   1309          }
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
   1310          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1311          bool pmc_is_peripheral_enabled(uint32_t id)
   1312          {
   \                     pmc_is_peripheral_enabled:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1313          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_is_peripheral_enabled_0
   \       0x10   0xE3A0'2021        MOV      R2,#+33
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        LDR      R0,??DataTable42_4
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1314          
   1315          #if defined(PMC_CSR_PID0) || defined(PMC_CSR0_PID5)
   1316          	return (PMC->PMC_CSR[(id >> 5) & 3] & (1 << (id & 31))) != 0;
   \                     ??pmc_is_peripheral_enabled_0:
   \       0x28   0xE3E0'005F        MVN      R0,#+95
   \       0x2C   0xE3A0'1003        MOV      R1,#+3
   \       0x30   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x34   0xE001'12A4        AND      R1,R1,R4, LSR #+5
   \       0x38   0xE790'0101        LDR      R0,[R0, +R1, LSL #+2]
   \       0x3C   0xE204'201F        AND      R2,R4,#0x1F
   \       0x40   0xE1A0'2230        LSR      R2,R0,R2
   \       0x44   0xE202'0001        AND      R0,R2,#0x1
   \       0x48   0xE8BD'8010        POP      {R4,PC}          ;; return
   1317          #elif defined(PMC_PCR_PID)
   1318          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1319          	volatile uint32_t pcr = PMC->PMC_PCR;
   1320          
   1321          	return (pcr & PMC_PCR_EN) != 0;
   1322          #else
   1323          	#error pmc_is_peripheral_enabled() needs to be updated.
   1324          #endif
   1325          }
   1326          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1327          uint32_t pmc_get_peripheral_clock(uint32_t id)
   1328          {
   \                     pmc_get_peripheral_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1329          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_get_peripheral_clock_0
   \       0x10   0xE3A0'2031        MOV      R2,#+49
   \       0x14   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        LDR      R0,??DataTable42_4
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1330          
   1331          	uint32_t div = get_peripheral_clock_matrix_div(id);
   \                     ??pmc_get_peripheral_clock_0:
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       get_peripheral_clock_matrix_div
   \       0x30   0xE1A0'4000        MOV      R4,R0
   1332          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1333          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1334          	volatile uint32_t pcr = PMC->PMC_PCR;
   1335          	div *= 1 << ((pcr & PMC_PCR_DIV_Msk) >> PMC_PCR_DIV_Pos);
   1336          #endif
   1337          
   1338          	return pmc_get_master_clock() / div;
   \       0x34   0x....'....        BL       pmc_get_master_clock
   \       0x38   0xE1A0'1004        MOV      R1,R4
   \       0x3C   0xE8BD'4010        POP      {R4,LR}
   \       0x40   0x....'....        B        __aeabi_uidiv
   1339          }
   1340          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1341          void pmc_disable_all_peripherals(void)
   1342          {
   \                     pmc_disable_all_peripherals:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   1343          	int i;
   1344          	for (i = 2; i < ID_PERIPH_COUNT; i++)
   \        0x4   0xE3E0'4077        MVN      R4,#+119
   \        0x8   0xE3A0'7016        MOV      R7,#+22
   \        0xC   0xE3A0'8002        MOV      R8,#+2
   \       0x10   0xE3C4'4FC0        BIC      R4,R4,#0x300
   \       0x14   0x....'....        LDR      R5,??DataTable42_4
   \       0x18   0x....'....        LDR      R6,??DataTable42_3
   \       0x1C   0xE387'7E50        ORR      R7,R7,#0x500
   1345          		pmc_disable_peripheral(i);
   \                     ??pmc_disable_all_peripherals_0:
   \       0x20   0xE358'0033        CMP      R8,#+51
   \       0x24   0x3A00'0004        BCC      ??pmc_disable_all_peripherals_1
   \       0x28   0xE1A0'2007        MOV      R2,R7
   \       0x2C   0xE1A0'1006        MOV      R1,R6
   \       0x30   0xE1A0'0005        MOV      R0,R5
   \       0x34   0x....'....        BL       __aeabi_assert
   \       0x38   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??pmc_disable_all_peripherals_1:
   \       0x3C   0xE208'007F        AND      R0,R8,#0x7F
   \       0x40   0xE584'0000        STR      R0,[R4, #+0]
   \       0x44   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x48   0xE288'8001        ADD      R8,R8,#+1
   \       0x4C   0xE3C1'2540        BIC      R2,R1,#0x10000000
   \       0x50   0xE382'3480        ORR      R3,R2,#0x80000000
   \       0x54   0xE584'3000        STR      R3,[R4, #+0]
   \       0x58   0xE358'0033        CMP      R8,#+51
   \       0x5C   0xBAFF'FFEF        BLT      ??pmc_disable_all_peripherals_0
   1346          }
   \       0x60   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
   1347          
   1348          /*----------------------------------------------------------------------------
   1349           *        Exported functions (PCK)
   1350           *----------------------------------------------------------------------------*/
   1351          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1352          void pmc_configure_pck(uint32_t index, uint32_t clock_source, uint32_t prescaler)
   1353          {
   \                     pmc_configure_pck:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
   1354          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \       0x10   0xE354'0002        CMP      R4,#+2
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_pck_0
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0xE3A0'204A        MOV      R2,#+74
   \       0x20   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x24   0xE281'0070        ADD      R0,R1,#+112
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1355          	assert(!(clock_source & ~PMC_PCK_CSS_Msk));
   \                     ??pmc_configure_pck_0:
   \       0x30   0xE3D5'001F        BICS     R0,R5,#0x1F
   \       0x34   0x0A00'0005        BEQ      ??pmc_configure_pck_1
   \       0x38   0xE3A0'204B        MOV      R2,#+75
   \       0x3C   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x40   0x....'....        LDR      R1,??DataTable42_3
   \       0x44   0x....'....        LDR      R0,??DataTable42_5
   \       0x48   0x....'....        BL       __aeabi_assert
   \       0x4C   0x....'....        BL       __iar_EmptyStepPoint
   1356          	assert(!(prescaler << PMC_PCK_PRES_Pos & ~PMC_PCK_PRES_Msk));
   \                     ??pmc_configure_pck_1:
   \       0x50   0xE1A0'6406        LSL      R6,R6,#+8
   \       0x54   0xE3D6'0CFF        BICS     R0,R6,#0xFF00
   \       0x58   0x0A00'0005        BEQ      ??pmc_configure_pck_2
   \       0x5C   0x....'....        LDR      R1,??DataTable42_3
   \       0x60   0xE3A0'204C        MOV      R2,#+76
   \       0x64   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x68   0xE281'00D0        ADD      R0,R1,#+208
   \       0x6C   0x....'....        BL       __aeabi_assert
   \       0x70   0x....'....        BL       __iar_EmptyStepPoint
   1357          
   1358          	pmc_disable_pck(index);
   \                     ??pmc_configure_pck_2:
   \       0x74   0xE1A0'0004        MOV      R0,R4
   \       0x78   0x....'....        BL       pmc_disable_pck
   1359          	PMC->PMC_PCK[index] = clock_source | PMC_PCK_PRES(prescaler);
   \       0x7C   0xE206'0CFF        AND      R0,R6,#0xFF00
   \       0x80   0xE3E0'10BF        MVN      R1,#+191
   \       0x84   0xE180'0005        ORR      R0,R0,R5
   \       0x88   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x8C   0xE781'0104        STR      R0,[R1, +R4, LSL #+2]
   1360          }
   \       0x90   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1361          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1362          void pmc_enable_pck(uint32_t index)
   1363          {
   \                     pmc_enable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1364          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0002        CMP      R4,#+2
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_pck_0
   \       0x10   0x....'....        LDR      R1,??DataTable42_3
   \       0x14   0xE3A0'2054        MOV      R2,#+84
   \       0x18   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x1C   0xE281'0070        ADD      R0,R1,#+112
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1365          
   1366          	switch (index) {
   \                     ??pmc_enable_pck_0:
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0002        BEQ      ??pmc_enable_pck_1
   \       0x30   0xE354'0001        CMP      R4,#+1
   \       0x34   0x0A00'0008        BEQ      ??pmc_enable_pck_2
   \       0x38   0xEA00'000F        B        ??pmc_enable_pck_3
   1367          #ifdef PMC_SCER_PCK0
   1368          	case 0:
   1369          		PMC->PMC_SCER = PMC_SCER_PCK0;
   \                     ??pmc_enable_pck_1:
   \       0x3C   0xE3E0'10FF        MVN      R1,#+255
   \       0x40   0xE3A0'0F40        MOV      R0,#+256
   \       0x44   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x48   0xE581'0000        STR      R0,[R1, #+0]
   1370          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY0));
   \                     ??pmc_enable_pck_4:
   \       0x4C   0xE591'0068        LDR      R0,[R1, #+104]
   \       0x50   0xE310'0F40        TST      R0,#0x100
   \       0x54   0x0AFF'FFFC        BEQ      ??pmc_enable_pck_4
   \       0x58   0xE8BD'8010        POP      {R4,PC}
   1371          		break;
   1372          #endif
   1373          #ifdef PMC_SCER_PCK1
   1374          	case 1:
   1375          		PMC->PMC_SCER = PMC_SCER_PCK1;
   \                     ??pmc_enable_pck_2:
   \       0x5C   0xE3E0'10FF        MVN      R1,#+255
   \       0x60   0xE3A0'0F80        MOV      R0,#+512
   \       0x64   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x68   0xE581'0000        STR      R0,[R1, #+0]
   1376          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY1));
   \                     ??pmc_enable_pck_5:
   \       0x6C   0xE591'0068        LDR      R0,[R1, #+104]
   \       0x70   0xE310'0F80        TST      R0,#0x200
   \       0x74   0x0AFF'FFFC        BEQ      ??pmc_enable_pck_5
   \       0x78   0xE8BD'8010        POP      {R4,PC}
   1377          		break;
   1378          #endif
   1379          #ifdef PMC_SCER_PCK2
   1380          	case 2:
   1381          		PMC->PMC_SCER = PMC_SCER_PCK2;
   1382          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY2));
   1383          		break;
   1384          #endif
   1385          #ifdef PMC_SCER_PCK3
   1386          	case 3:
   1387          		PMC->PMC_SCER = PMC_SCER_PCK3;
   1388          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY3));
   1389          		break;
   1390          #endif
   1391          #ifdef PMC_SCER_PCK4
   1392          	case 4:
   1393          		PMC->PMC_SCER = PMC_SCER_PCK4;
   1394          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY4));
   1395          		break;
   1396          #endif
   1397          #ifdef PMC_SCER_PCK5
   1398          	case 5:
   1399          		PMC->PMC_SCER = PMC_SCER_PCK5;
   1400          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY5));
   1401          		break;
   1402          #endif
   1403          #ifdef PMC_SCER_PCK6
   1404          	case 6:
   1405          		PMC->PMC_SCER = PMC_SCER_PCK6;
   1406          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY6));
   1407          		break;
   1408          #endif
   1409          	default:
   1410          		assert(0);
   \                     ??pmc_enable_pck_3:
   \       0x7C   0xE3A0'2082        MOV      R2,#+130
   \       0x80   0x....'....        B        ?Subroutine1
   1411          	}
   1412          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE382'2E50        ORR      R2,R2,#0x500
   \        0x4   0x....'....        LDR      R1,??DataTable42_3
   \        0x8   0x....'....        ADR      R0,??DataTable37  ;; "0"
   \        0xC   0x....'....        BL       __aeabi_assert
   \       0x10   0x....'....        BL       __iar_EmptyStepPoint
   \       0x14   0xE8BD'8010        POP      {R4,PC}          ;; return
   1413          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1414          void pmc_disable_pck(uint32_t index)
   1415          {
   \                     pmc_disable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1416          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0002        CMP      R4,#+2
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_pck_0
   \       0x10   0x....'....        LDR      R1,??DataTable42_3
   \       0x14   0xE3A0'2088        MOV      R2,#+136
   \       0x18   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x1C   0xE281'0070        ADD      R0,R1,#+112
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1417          
   1418          	switch (index) {
   \                     ??pmc_disable_pck_0:
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0002        BEQ      ??pmc_disable_pck_1
   \       0x30   0xE354'0001        CMP      R4,#+1
   \       0x34   0x0A00'0008        BEQ      ??pmc_disable_pck_2
   \       0x38   0xEA00'000F        B        ??pmc_disable_pck_3
   1419          #ifdef PMC_SCDR_PCK0
   1420          	case 0:
   1421          		PMC->PMC_SCDR = PMC_SCDR_PCK0;
   \                     ??pmc_disable_pck_1:
   \       0x3C   0xE3E0'10FB        MVN      R1,#+251
   \       0x40   0xE3A0'0F40        MOV      R0,#+256
   \       0x44   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x48   0xE581'0000        STR      R0,[R1, #+0]
   1422          		while (PMC->PMC_SCSR & PMC_SCSR_PCK0);
   \                     ??pmc_disable_pck_4:
   \       0x4C   0xE591'0004        LDR      R0,[R1, #+4]
   \       0x50   0xE310'0F40        TST      R0,#0x100
   \       0x54   0x1AFF'FFFC        BNE      ??pmc_disable_pck_4
   \       0x58   0xE8BD'8010        POP      {R4,PC}
   1423          		break;
   1424          #endif
   1425          #ifdef PMC_SCDR_PCK1
   1426          	case 1:
   1427          		PMC->PMC_SCDR = PMC_SCDR_PCK1;
   \                     ??pmc_disable_pck_2:
   \       0x5C   0xE3E0'10FB        MVN      R1,#+251
   \       0x60   0xE3A0'0F80        MOV      R0,#+512
   \       0x64   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x68   0xE581'0000        STR      R0,[R1, #+0]
   1428          		while (PMC->PMC_SCSR & PMC_SCSR_PCK1);
   \                     ??pmc_disable_pck_5:
   \       0x6C   0xE591'0004        LDR      R0,[R1, #+4]
   \       0x70   0xE310'0F80        TST      R0,#0x200
   \       0x74   0x1AFF'FFFC        BNE      ??pmc_disable_pck_5
   \       0x78   0xE8BD'8010        POP      {R4,PC}
   1429          		break;
   1430          #endif
   1431          #ifdef PMC_SCDR_PCK2
   1432          	case 2:
   1433          		PMC->PMC_SCDR = PMC_SCDR_PCK2;
   1434          		while (PMC->PMC_SCSR & PMC_SCSR_PCK2);
   1435          		break;
   1436          #endif
   1437          #ifdef PMC_SCDR_PCK3
   1438          	case 3:
   1439          		PMC->PMC_SCDR = PMC_SCDR_PCK3;
   1440          		while (PMC->PMC_SCSR & PMC_SCSR_PCK3);
   1441          		break;
   1442          #endif
   1443          #ifdef PMC_SCDR_PCK4
   1444          	case 4:
   1445          		PMC->PMC_SCDR = PMC_SCDR_PCK4;
   1446          		while (PMC->PMC_SCSR & PMC_SCSR_PCK4);
   1447          		break;
   1448          #endif
   1449          #ifdef PMC_SCDR_PCK5
   1450          	case 5:
   1451          		PMC->PMC_SCDR = PMC_SCDR_PCK5;
   1452          		while (PMC->PMC_SCSR & PMC_SCSR_PCK5);
   1453          		break;
   1454          #endif
   1455          #ifdef PMC_SCDR_PCK6
   1456          	case 6:
   1457          		PMC->PMC_SCDR = PMC_SCDR_PCK6;
   1458          		while (PMC->PMC_SCSR & PMC_SCSR_PCK6);
   1459          		break;
   1460          #endif
   1461          	default:
   1462          		assert(0);
   \                     ??pmc_disable_pck_3:
   \       0x7C   0xE3A0'20B6        MOV      R2,#+182
   \       0x80                      REQUIRE ?Subroutine1
   \       0x80                      ;; // Fall through to label ?Subroutine1
   1463          	}
   1464          }
   1465          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1466          uint32_t pmc_get_pck_clock(uint32_t index)
   1467          {
   \                     pmc_get_pck_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1468          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0001        CMP      R4,#+1
   \        0xC   0x9A00'0005        BLS      ??pmc_get_pck_clock_1
   \       0x10   0x....'....        LDR      R1,??DataTable42_3
   \       0x14   0xE3A0'20BC        MOV      R2,#+188
   \       0x18   0xE382'2E50        ORR      R2,R2,#0x500
   \       0x1C   0xE281'0070        ADD      R0,R1,#+112
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1469          	return _pmc_get_pck_clock(index);
   \                     ??pmc_get_pck_clock_1:
   \       0x28   0xE3E0'10BF        MVN      R1,#+191
   \       0x2C   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x30   0xE791'4104        LDR      R4,[R1, +R4, LSL #+2]
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0xE204'201F        AND      R2,R4,#0x1F
   \       0x3C   0xE352'0005        CMP      R2,#+5
   \       0x40   0x8A00'000F        BHI      ??pmc_get_pck_clock_2
   \       0x44   0xE7DF'3002        LDRB     R3,[PC, R2]
   \       0x48   0xE08F'F103        ADD      PC,PC,R3, LSL #+2
   \                     ??pmc_get_pck_clock_0:
   \       0x4C   0x0C 0x0D          DC8      0xC,0xD,0x6,0x1

   \              0x06 0x01
   \       0x50   0x04 0x03          DC8      0x4,0x3,0x0,0x0

   \              0x00 0x00
   \                     ??pmc_get_pck_clock_3:
   \       0x54   0x....'....        BL       pmc_get_master_clock
   \       0x58   0xEA00'0009        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_4:
   \       0x5C   0xE3A0'0001        MOV      R0,#+1
   \                     ??pmc_get_pck_clock_5:
   \       0x60   0x....'....        BL       _pmc_get_pll_clock
   \       0x64   0xEA00'0006        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_6:
   \       0x68   0xE531'2020        LDR      R2,[R1, #-32]!
   \       0x6C   0x....'....        LDR      R0,??DataTable36
   \       0x70   0xE312'0740        TST      R2,#0x1000000
   \       0x74   0x1590'0004        LDRNE    R0,[R0, #+4]
   \       0x78   0x0590'0000        LDREQ    R0,[R0, #+0]
   \       0x7C   0xEA00'0000        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_7:
   \       0x80   0x....'....        BL       slowclock_get_clock
   \                     ??pmc_get_pck_clock_2:
   \       0x84   0xE3A0'10FF        MOV      R1,#+255
   \       0x88   0xE001'1424        AND      R1,R1,R4, LSR #+8
   \       0x8C   0xE8BD'4010        POP      {R4,LR}
   \       0x90   0xE281'1001        ADD      R1,R1,#+1
   \       0x94   0x....'....        B        __aeabi_uidiv
   1470          }
   1471          
   1472          /*----------------------------------------------------------------------------
   1473           *        Exported functions (UPLL)
   1474           *----------------------------------------------------------------------------*/
   1475          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1476          void pmc_enable_upll_clock(void)
   1477          {
   1478          #if defined(PMC_PLL_UPDT_ID)
   1479          	struct _pmc_plla_cfg plla = {
   1480          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
   1481          		.mul = BOARD_PMC_UPLL_MUL,
   1482          		.div = BOARD_PMC_UPLL_DIV,
   1483          #else
   1484          		.mul = 49,
   1485          		.div = 1,
   1486          #endif
   1487          		.count = 0x3f,
   1488          		.fracr = 0,
   1489          		.pll_id = PLL_ID_UPLL,
   1490          };
   \                     pmc_enable_upll_clock:
   \        0x0   0x....'....        LDR      R1,??DataTable42_6
   \        0x4   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x8   0xE891'503C        LDM      R1,{R2-R5,R12,LR}
   \        0xC   0xE24D'D018        SUB      SP,SP,#+24
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0xE880'503C        STM      R0,{R2-R5,R12,LR}
   1491          	_pmc_configure_pll(&plla);
   \       0x18   0x....'....        BL       _pmc_configure_pll
   1492          #else
   1493          	uint32_t uckr = CKGR_UCKR_UPLLEN | CKGR_UCKR_UPLLCOUNT(0x3);
   1494          
   1495          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS
   1496          	uckr |= CKGR_UCKR_BIASCOUNT(0x1);
   1497          #endif
   1498          
   1499          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1500          	switch (_pmc_main_oscillators.crystal_freq) {
   1501          #ifdef SFR_UTMICKTRIM_FREQ_48
   1502          	case 48000000:
   1503          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_48;
   1504          		break;
   1505          #endif
   1506          	case 24000000:
   1507          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_24;
   1508          		break;
   1509          	case 16000000:
   1510          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_16;
   1511          		break;
   1512          	default:
   1513          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_12;
   1514          	}
   1515          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1516          	switch (_pmc_main_oscillators.crystal_freq) {
   1517          	case 16000000:
   1518          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL16;
   1519          		break;
   1520          	default:
   1521          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL12;
   1522          	}
   1523          #endif
   1524          
   1525          	/* enable the 480MHz UTMI PLL  */
   1526          	PMC->CKGR_UCKR = uckr;
   1527          
   1528          	/* wait until UPLL is locked */
   1529          	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   1530          #endif
   1531          }
   \       0x1C   0xE28D'D01C        ADD      SP,SP,#+28
   \       0x20   0xE8BD'8030        POP      {R4,R5,PC}       ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x0000'0027        DC32 39, 1, 63, 1, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0001  

   \              0x0000'0000
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   1532          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1533          void pmc_disable_upll_clock(void)
   1534          {
   1535          #if defined(PMC_PLL_UPDT_ID)
   1536          	_pmc_disable_pll(PLL_ID_UPLL);
   \                     pmc_disable_upll_clock:
   \        0x0   0xE3E0'00F3        MVN      R0,#+243
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'0010        LDR      R0,[R0, #+16]
   \        0xC   0xE3E0'1001        MVN      R1,#+1
   \       0x10   0xE3C1'1F40        BIC      R1,R1,#0x100
   \       0x14   0xE001'1000        AND      R1,R1,R0
   \       0x18   0xE3E0'20F3        MVN      R2,#+243
   \       0x1C   0xE381'0001        ORR      R0,R1,#0x1
   \       0x20   0xE3C2'2FC0        BIC      R2,R2,#0x300
   \       0x24   0xE582'0010        STR      R0,[R2, #+16]
   \       0x28   0xE1A0'0002        MOV      R0,R2
   \       0x2C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x30   0xE1A0'3000        MOV      R3,R0
   \       0x34   0xE3C1'1580        BIC      R1,R1,#0x20000000
   \       0x38   0xE381'2540        ORR      R2,R1,#0x10000000
   \       0x3C   0xE580'2000        STR      R2,[R0, #+0]
   \       0x40   0xE593'1010        LDR      R1,[R3, #+16]
   \       0x44   0xE381'2F40        ORR      R2,R1,#0x100
   \       0x48   0xE583'2010        STR      R2,[R3, #+16]
   \       0x4C   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x50   0xE3C1'2540        BIC      R2,R1,#0x10000000
   \       0x54   0xE580'2000        STR      R2,[R0, #+0]
   \       0x58   0xE590'000C        LDR      R0,[R0, #+12]
   \       0x5C   0xE3C0'1DC0        BIC      R1,R0,#0x3000
   \       0x60   0xE583'100C        STR      R1,[R3, #+12]
   1537          #else
   1538          	PMC->CKGR_UCKR &= ~CKGR_UCKR_UPLLEN;
   1539          #endif
   1540          }
   \       0x64   0xE12F'FF1E        BX       LR               ;; return
   1541          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1542          bool pmc_is_upll_clock_enabled(void)
   1543          {
   1544          #if defined(PMC_PLL_UPDT_ID)
   1545          	return _pmc_pll_enabled(PLL_ID_UPLL);
   \                     pmc_is_upll_clock_enabled:
   \        0x0   0xE3E0'0013        MVN      R0,#+19
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'0000        LDR      R0,[R0, #+0]
   \        0xC   0xE1A0'10A0        LSR      R1,R0,#+1
   \       0x10   0xE201'0001        AND      R0,R1,#0x1
   \       0x14   0xE12F'FF1E        BX       LR               ;; return
   1546          #else
   1547          	return (PMC->PMC_SR & PMC_SR_LOCKU) != 0;
   1548          #endif
   1549          }
   1550          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1551          uint32_t pmc_get_upll_clock(void)
   1552          {
   \                     pmc_get_upll_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   1553          #if defined(PMC_PLL_UPDT_ID)
   1554          	return _pmc_get_pll_clock(PLL_ID_UPLL);
   \        0x4   0x....'....        LDR      R0,??DataTable36
   \        0x8   0xE590'0004        LDR      R0,[R0, #+4]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'0000        BNE      ??pmc_get_upll_clock_0
   \       0x14   0x....'....        BL       pmc_set_main_oscillator_freq
   \                     ??pmc_get_upll_clock_0:
   \       0x18   0xE3E0'10F3        MVN      R1,#+243
   \       0x1C   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x20   0xE591'2010        LDR      R2,[R1, #+16]
   \       0x24   0xE3A0'4001        MOV      R4,#+1
   \       0x28   0xE382'3001        ORR      R3,R2,#0x1
   \       0x2C   0xE581'3010        STR      R3,[R1, #+16]
   \       0x30   0xE1A0'2001        MOV      R2,R1
   \       0x34   0xE592'1004        LDR      R1,[R2, #+4]
   \       0x38   0xE1A0'3002        MOV      R3,R2
   \       0x3C   0xE593'2004        LDR      R2,[R3, #+4]
   \       0x40   0xE593'E000        LDR      LR,[R3, #+0]
   \       0x44   0xE1A0'3502        LSL      R3,R2,#+10
   \       0x48   0xE1A0'C523        LSR      R12,R3,#+10
   \       0x4C   0xE083'2C90        UMULL    R2,R3,R0,R12
   \       0x50   0xE084'1C21        ADD      R1,R4,R1, LSR #+24
   \       0x54   0xE1A0'2B22        LSR      R2,R2,#+22
   \       0x58   0xE182'2503        ORR      R2,R2,R3, LSL #+10
   \       0x5C   0xE020'2091        MLA      R0,R1,R0,R2
   \       0x60   0xE1A0'00A0        LSR      R0,R0,#+1
   \       0x64   0xE8BD'8010        POP      {R4,PC}          ;; return
   1555          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1556          	uint32_t upllclk;
   1557          
   1558          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1559          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1560          	switch (clktrim) {
   1561          #ifdef SFR_UTMICKTRIM_FREQ_48
   1562          		case SFR_UTMICKTRIM_FREQ_48:
   1563          			upllclk = 10 * _pmc_main_oscillators.crystal_freq;
   1564          			break;
   1565          #endif
   1566          		case SFR_UTMICKTRIM_FREQ_24:
   1567          			upllclk = 20 * _pmc_main_oscillators.crystal_freq;
   1568          			break;
   1569          		case SFR_UTMICKTRIM_FREQ_16:
   1570          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1571          			break;
   1572          		default:
   1573          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1574          			break;
   1575          	}
   1576          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1577          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1578          	switch (clktrim) {
   1579          		case UTMI_CKTRIM_FREQ_XTAL16:
   1580          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1581          			break;
   1582          		default:
   1583          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1584          			break;
   1585          	}
   1586          #else
   1587          	upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1588          #endif
   1589          
   1590          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1591          	if (PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2)
   1592          		upllclk >>= 1;
   1593          #endif
   1594          
   1595          	return upllclk;
   1596          #endif
   1597          }
   1598          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1599          RAMCODE bool pmc_ext32k_monitor(void)
   1600          {
   1601          	bool bypass = false;
   1602          	volatile int count;
   1603          	/* 32.768kHz crystal oscillator frequency monitor  */
   1604          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1605          	if(!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \                     pmc_ext32k_monitor:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x8   0x....'....        BL       slowclock_is_internal
   \        0xC   0xE3A0'4000        MOV      R4,#+0
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0022        BNE      ??pmc_ext32k_monitor_0
   1606          		slowclock_set_bypass(false);
   \       0x18   0x....'....        BL       slowclock_set_bypass
   1607          
   1608          		/* Wait 5 slow clock cycles for internal resynchronization. */
   1609          		for (count = 0; count < 0x100000; count++);
   \       0x1C   0xE58D'4000        STR      R4,[SP, #+0]
   \       0x20   0xEA00'0002        B        ??pmc_ext32k_monitor_1
   \                     ??pmc_ext32k_monitor_2:
   \       0x24   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x28   0xE280'1001        ADD      R1,R0,#+1
   \       0x2C   0xE58D'1000        STR      R1,[SP, #+0]
   \                     ??pmc_ext32k_monitor_1:
   \       0x30   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x34   0xE351'0940        CMP      R1,#+1048576
   \       0x38   0xBAFF'FFF9        BLT      ??pmc_ext32k_monitor_2
   1610          
   1611          		/* 32.768 kHz Crystal Oscillator Frequency Monitoring Enabled */
   1612          		PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD | CKGR_MOR_XT32KFME;
   \       0x3C   0xE3E0'50DF        MVN      R5,#+223
   \       0x40   0xE3C5'5FC0        BIC      R5,R5,#0x300
   \       0x44   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x48   0xE380'19DC        ORR      R1,R0,#0x370000
   \       0x4C   0xE381'1640        ORR      R1,R1,#0x4000000
   \       0x50   0xE585'1000        STR      R1,[R5, #+0]
   1613          
   1614          		/* Wait 4 slow clock cycles for internal resynchronization */
   1615          		for (count = 0; count < 0x1000; count++);
   \       0x54   0xE58D'4000        STR      R4,[SP, #+0]
   \       0x58   0xEA00'0002        B        ??pmc_ext32k_monitor_3
   \                     ??pmc_ext32k_monitor_4:
   \       0x5C   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x60   0xE281'2001        ADD      R2,R1,#+1
   \       0x64   0xE58D'2000        STR      R2,[SP, #+0]
   \                     ??pmc_ext32k_monitor_3:
   \       0x68   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x6C   0xE351'0D40        CMP      R1,#+4096
   \       0x70   0xBAFF'FFF9        BLT      ??pmc_ext32k_monitor_4
   1616          
   1617          		/* check if the 32.768 kHz crystal oscillator was correct */
   1618          		if((PMC->PMC_SR & PMC_SR_XT32KERR) == PMC_SR_XT32KERR) {
   \       0x74   0xE595'1048        LDR      R1,[R5, #+72]
   \       0x78   0xE311'0980        TST      R1,#0x200000
   \       0x7C   0x0A00'0004        BEQ      ??pmc_ext32k_monitor_5
   1619          			slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x80   0xE3A0'0000        MOV      R0,#+0
   \       0x84   0x....'....        BL       slowclock_select_external
   1620          			slowclock_set_bypass(true);
   \       0x88   0xE3A0'0001        MOV      R0,#+1
   \       0x8C   0x....'....        BL       slowclock_set_bypass
   1621          			bypass = true;
   \       0x90   0xE3A0'4001        MOV      R4,#+1
   1622          		}
   1623          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_XT32KFME) | CKGR_MOR_KEY_PASSWD;
   \                     ??pmc_ext32k_monitor_5:
   \       0x94   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x98   0xE3C0'1640        BIC      R1,R0,#0x4000000
   \       0x9C   0xE381'29DC        ORR      R2,R1,#0x370000
   \       0xA0   0xE585'2000        STR      R2,[R5, #+0]
   1624          	}
   1625          #endif
   1626          	return bypass;
   \                     ??pmc_ext32k_monitor_0:
   \       0xA4   0xE1A0'0004        MOV      R0,R4
   \       0xA8   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
   1627          }
   1628          
   1629          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS
   1630          void pmc_enable_upll_bias(void)
   1631          {
   1632          	PMC->CKGR_UCKR |= CKGR_UCKR_BIASEN;
   1633          }
   1634          
   1635          void pmc_disable_upll_bias(void)
   1636          {
   1637          	PMC->CKGR_UCKR &= ~CKGR_UCKR_BIASEN;
   1638          }
   1639          #endif /* CONFIG_HAVE_PMC_UPLL_BIAS */
   1640          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1641          uint32_t pmc_get_utmi_clock_trim(void)
   1642          {
   1643          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1644          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1645          	switch (clktrim) {
   1646          #ifdef SFR_UTMICKTRIM_FREQ_48
   1647          		case SFR_UTMICKTRIM_FREQ_48:
   1648          			return 48000000;
   1649          #endif
   1650          		case SFR_UTMICKTRIM_FREQ_24:
   1651          			return 24000000;
   1652          		case SFR_UTMICKTRIM_FREQ_16:
   1653          			return 16000000;
   1654          		default:
   1655          			return 12000000;
   1656          	}
   1657          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1658          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1659          	switch (clktrim) {
   1660          		case UTMI_CKTRIM_FREQ_XTAL16:
   1661          			return 16000000;
   1662          		default:
   1663          			return 12000000;
   1664          	}
   1665          #elif defined(CONFIG_SOC_SAM9X60)
   1666          	struct _pmc_plla_cfg plla;
   1667          
   1668          	_pmc_get_pll_config(PLL_ID_UPLL, &plla);
   \                     pmc_get_utmi_clock_trim:
   \        0x0   0xE3E0'00F3        MVN      R0,#+243
   \        0x4   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \        0x8   0xE590'1010        LDR      R1,[R0, #+16]
   \        0xC   0xE381'2001        ORR      R2,R1,#0x1
   \       0x10   0xE580'2010        STR      R2,[R0, #+16]
   \       0x14   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x18   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x1C   0xE590'C000        LDR      R12,[R0, #+0]
   1669          	return 480000000U * (plla.div + 1) / (plla.mul + 1);
   \       0x20   0xE3A0'2001        MOV      R2,#+1
   \       0x24   0x....'....        LDR      R0,??DataTable42_7  ;; 0x39387000
   \       0x28   0xE082'1C21        ADD      R1,R2,R1, LSR #+24
   \       0x2C   0x....'....        B        __aeabi_uidiv
   1670          #else
   1671          	return 12000000;
   1672          #endif
   1673          }
   1674          
   1675          /*----------------------------------------------------------------------------
   1676           *        Exported functions (Generated clocks)
   1677           *----------------------------------------------------------------------------*/
   1678          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1679          struct pck_mck_cfg pmc_get_pck_mck_cfg(void)
   1680          {
   \                     pmc_get_pck_mck_cfg:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE24D'D028        SUB      SP,SP,#+40
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE3A0'1028        MOV      R1,#+40
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0x....'....        BL       __aeabi_memclr4
   1681          	struct pck_mck_cfg cfg = { 0 };
   1682          	cfg.pck_input = PMC->PMC_MCKR & PMC_MCKR_CSS_Msk;
   \       0x18   0xE3E0'00F3        MVN      R0,#+243
   \       0x1C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x20   0xE590'101C        LDR      R1,[R0, #+28]
   1683          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \       0x24   0xE3A0'5000        MOV      R5,#+0
   \       0x28   0xE201'2003        AND      R2,R1,#0x3
   \       0x2C   0xE58D'2000        STR      R2,[SP, #+0]
   \       0x30   0xE590'0014        LDR      R0,[R0, #+20]
   \       0x34   0xE310'0740        TST      R0,#0x1000000
   1684          		cfg.extosc = true;
   \       0x38   0x13A0'0001        MOVNE    R0,#+1
   \       0x3C   0x15CD'0004        STRBNE   R0,[SP, #+4]
   1685          	} else {
   1686          		cfg.extosc = false;
   \       0x40   0x05CD'5004        STRBEQ   R5,[SP, #+4]
   1687          	}
   1688          	if (!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0x....'....        BL       slowclock_is_internal
   \       0x4C   0xE350'0000        CMP      R0,#+0
   1689          		cfg.ext32k = true;
   \       0x50   0x03A0'0001        MOVEQ    R0,#+1
   \       0x54   0x05CD'0006        STRBEQ   R0,[SP, #+6]
   1690          	} else {
   1691          		cfg.ext32k = false;
   \       0x58   0x15CD'5006        STRBNE   R5,[SP, #+6]
   1692          	}
   1693          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1694          	/* Get ext32k bypass state*/
   1695          	if(slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \       0x5C   0xE3A0'0000        MOV      R0,#+0
   \       0x60   0x....'....        BL       slowclock_is_internal
   \       0x64   0xE350'0000        CMP      R0,#+0
   \       0x68   0xE1A0'0005        MOV      R0,R5
   \       0x6C   0x0A00'0005        BEQ      ??pmc_get_pck_mck_cfg_0
   1696          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x70   0x....'....        BL       slowclock_select_external
   1697          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   \       0x74   0x....'....        BL       pmc_ext32k_monitor
   \       0x78   0xE5CD'0007        STRB     R0,[SP, #+7]
   1698          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x7C   0xE3A0'0000        MOV      R0,#+0
   \       0x80   0x....'....        BL       slowclock_select_internal
   \       0x84   0xEA00'0004        B        ??pmc_get_pck_mck_cfg_1
   1699          	} else {
   1700          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_get_pck_mck_cfg_0:
   \       0x88   0x....'....        BL       slowclock_select_internal
   1701          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \       0x8C   0xE3A0'0000        MOV      R0,#+0
   \       0x90   0x....'....        BL       slowclock_select_external
   1702          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   \       0x94   0x....'....        BL       pmc_ext32k_monitor
   \       0x98   0xE5CD'0007        STRB     R0,[SP, #+7]
   1703          	}
   1704          #endif
   1705          	cfg.pck_pres = (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk);
   \                     ??pmc_get_pck_mck_cfg_1:
   \       0x9C   0xE3E0'00F3        MVN      R0,#+243
   \       0xA0   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0xA4   0xE590'101C        LDR      R1,[R0, #+28]
   \       0xA8   0xE201'2070        AND      R2,R1,#0x70
   \       0xAC   0xE58D'2020        STR      R2,[SP, #+32]
   1706          	cfg.mck_div = (PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk);
   \       0xB0   0xE590'001C        LDR      R0,[R0, #+28]
   \       0xB4   0xE200'2E70        AND      R2,R0,#0x700
   \       0xB8   0xE58D'2024        STR      R2,[SP, #+36]
   1707          
   1708          #ifdef PMC_PLL_UPDT_ID
   1709          	if ((cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) | (cfg.pck_input == PMC_MCKR_CSS_UPLL_CLK)) {
   \       0xBC   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0xC0   0xE352'0002        CMP      R2,#+2
   \       0xC4   0x1A00'0009        BNE      ??pmc_get_pck_mck_cfg_2
   \       0xC8   0xE3A0'0001        MOV      R0,#+1
   \                     ??pmc_get_pck_mck_cfg_3:
   \       0xCC   0xE3A0'1000        MOV      R1,#+0
   \                     ??pmc_get_pck_mck_cfg_4:
   \       0xD0   0xE191'0000        ORRS     R0,R1,R0
   \       0xD4   0x0A00'0018        BEQ      ??pmc_get_pck_mck_cfg_5
   1710          		if (cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   \       0xD8   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xDC   0xE351'0002        CMP      R1,#+2
   1711          			cfg.plla.pll_id = PLL_ID_PLLA;
   1712          		} else {
   1713          			cfg.plla.pll_id = PLL_ID_UPLL;
   \       0xE0   0x13A0'0001        MOVNE    R0,#+1
   \       0xE4   0x058D'5014        STREQ    R5,[SP, #+20]
   \       0xE8   0x158D'0014        STRNE    R0,[SP, #+20]
   \       0xEC   0xEA00'0005        B        ??pmc_get_pck_mck_cfg_6
   1714          		}
   \                     ??pmc_get_pck_mck_cfg_2:
   \       0xF0   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0xF4   0xE3A0'0000        MOV      R0,#+0
   \       0xF8   0xE352'0003        CMP      R2,#+3
   \       0xFC   0x1AFF'FFF2        BNE      ??pmc_get_pck_mck_cfg_3
   \      0x100   0xE3A0'1001        MOV      R1,#+1
   \      0x104   0xEAFF'FFF1        B        ??pmc_get_pck_mck_cfg_4
   1715          		PMC->PMC_PLL_UPDT = (PMC->PMC_PLL_UPDT & ~PMC_PLL_UPDT_ID) | cfg.plla.pll_id;
   \                     ??pmc_get_pck_mck_cfg_6:
   \      0x108   0xE3E0'00F3        MVN      R0,#+243
   \      0x10C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x110   0xE590'1010        LDR      R1,[R0, #+16]
   \      0x114   0xE1A0'20A1        LSR      R2,R1,#+1
   \      0x118   0xE59D'1014        LDR      R1,[SP, #+20]
   \      0x11C   0xE181'1082        ORR      R1,R1,R2, LSL #+1
   \      0x120   0xE580'1010        STR      R1,[R0, #+16]
   1716          		cfg.plla.mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
   \      0x124   0xE590'1004        LDR      R1,[R0, #+4]
   \      0x128   0xE1A0'2C21        LSR      R2,R1,#+24
   \      0x12C   0xE58D'2008        STR      R2,[SP, #+8]
   1717          		cfg.plla.div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
   \      0x130   0xE590'2000        LDR      R2,[R0, #+0]
   \      0x134   0xE202'00FF        AND      R0,R2,#0xFF
   \      0x138   0xE58D'000C        STR      R0,[SP, #+12]
   1718          	}
   1719          #else
   1720          	if(cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   1721          		cfg.plla.mul = (PMC->CKGR_PLLAR & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
   1722          		cfg.plla.div = (PMC->CKGR_PLLAR & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
   1723          		cfg.plla.count = (PMC->CKGR_PLLAR & CKGR_PLLAR_PLLACOUNT_Msk) >> CKGR_PLLAR_PLLACOUNT_Pos;
   1724          	}
   1725          #endif
   1726          #ifdef CKGR_MOR_MOSCXTBY	
   1727          	if((PMC->CKGR_MOR & CKGR_MOR_MOSCXTBY) == CKGR_MOR_MOSCXTBY) {
   1728          		cfg.ext_bypass = true;
   1729          	} else {
   1730          		cfg.ext_bypass = false;
   1731          	}
   1732          #endif
   1733          
   1734          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1735          	if((PMC->PMC_MCKR & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2) {
   1736          		cfg.plla_div2 = true;
   1737          	} else {
   1738          		cfg.plla_div2 = false;
   1739          	}
   1740          #endif
   1741          
   1742          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1743          	if ((PMC->PMC_MCKR & PMC_MCKR_H32MXDIV_H32MXDIV2) == PMC_MCKR_H32MXDIV_H32MXDIV2) {
   1744          		cfg.h32mx_div2 = true;
   1745          	} else {
   1746          		cfg.h32mx_div2 = false;
   1747          	}
   1748          #endif
   1749          	return cfg;
   \                     ??pmc_get_pck_mck_cfg_5:
   \      0x13C   0xE1A0'0004        MOV      R0,R4
   \      0x140   0xE1A0'100D        MOV      R1,SP
   \      0x144   0xE3A0'2028        MOV      R2,#+40
   \      0x148   0x....'....        BL       __aeabi_memcpy4
   \      0x14C   0xE28D'D02C        ADD      SP,SP,#+44
   \      0x150   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
   1750          }
   1751          
   1752          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1753          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1754          void pmc_configure_gck(uint32_t id, uint32_t clock_source, uint32_t div)
   1755          {
   \                     pmc_configure_gck:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1A0'6000        MOV      R6,R0
   \        0x8   0xE1A0'4001        MOV      R4,R1
   \        0xC   0xE1A0'5002        MOV      R5,R2
   1756          	assert(id < ID_PERIPH_COUNT);
   \       0x10   0xE356'0033        CMP      R6,#+51
   \       0x14   0x3A00'0005        BCC      ??pmc_configure_gck_0
   \       0x18   0xE3A0'20DC        MOV      R2,#+220
   \       0x1C   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x20   0x....'....        LDR      R1,??DataTable42_3
   \       0x24   0x....'....        LDR      R0,??DataTable42_4
   \       0x28   0x....'....        BL       __aeabi_assert
   \       0x2C   0x....'....        BL       __iar_EmptyStepPoint
   1757          	assert(!(clock_source & ~PMC_PCR_GCKCSS_Msk));
   \                     ??pmc_configure_gck_0:
   \       0x30   0xE3D4'0D7C        BICS     R0,R4,#0x1F00
   \       0x34   0x0A00'0005        BEQ      ??pmc_configure_gck_1
   \       0x38   0xE3A0'20DD        MOV      R2,#+221
   \       0x3C   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x40   0x....'....        LDR      R1,??DataTable42_3
   \       0x44   0x....'....        LDR      R0,??DataTable42_8
   \       0x48   0x....'....        BL       __aeabi_assert
   \       0x4C   0x....'....        BL       __iar_EmptyStepPoint
   1758          	assert(div > 0);
   \                     ??pmc_configure_gck_1:
   \       0x50   0xE355'0000        CMP      R5,#+0
   \       0x54   0x1A00'0005        BNE      ??pmc_configure_gck_2
   \       0x58   0xE3A0'20DE        MOV      R2,#+222
   \       0x5C   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x60   0x....'....        LDR      R1,??DataTable42_3
   \       0x64   0x....'....        LDR      R0,??DataTable42_9
   \       0x68   0x....'....        BL       __aeabi_assert
   \       0x6C   0x....'....        BL       __iar_EmptyStepPoint
   1759          	assert(!((div << PMC_PCR_GCKDIV_Pos) & ~PMC_PCR_GCKDIV_Msk));
   \                     ??pmc_configure_gck_2:
   \       0x70   0xE3E0'06FF        MVN      R0,#+267386880
   \       0x74   0xE110'0A05        TST      R0,R5, LSL #+20
   \       0x78   0x0A00'0005        BEQ      ??pmc_configure_gck_3
   \       0x7C   0xE3A0'20DF        MOV      R2,#+223
   \       0x80   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x84   0x....'....        LDR      R1,??DataTable42_3
   \       0x88   0x....'....        LDR      R0,??DataTable42_10
   \       0x8C   0x....'....        BL       __aeabi_assert
   \       0x90   0x....'....        BL       __iar_EmptyStepPoint
   1760          
   1761          	pmc_disable_gck(id);
   \                     ??pmc_configure_gck_3:
   \       0x94   0xE1A0'0006        MOV      R0,R6
   \       0x98   0x....'....        BL       pmc_disable_gck
   1762          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \       0x9C   0xE3E0'0077        MVN      R0,#+119
   \       0xA0   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0xA4   0xE206'107F        AND      R1,R6,#0x7F
   \       0xA8   0xE580'1000        STR      R1,[R0, #+0]
   1763          	volatile uint32_t pcr = PMC->PMC_PCR & ~(PMC_PCR_GCKCSS_Msk | PMC_PCR_GCKDIV_Msk);
   \       0xAC   0xE590'2000        LDR      R2,[R0, #+0]
   \       0xB0   0xE3E0'36FF        MVN      R3,#+267386880
   \       0xB4   0xE3C3'3D7C        BIC      R3,R3,#0x1F00
   \       0xB8   0xE003'3002        AND      R3,R3,R2
   \       0xBC   0xE58D'3000        STR      R3,[SP, #+0]
   1764          	PMC->PMC_PCR = pcr | clock_source | PMC_PCR_CMD | PMC_PCR_GCKDIV(div - 1);
   \       0xC0   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0xC4   0xE245'3001        SUB      R3,R5,#+1
   \       0xC8   0xE3A0'16FF        MOV      R1,#+267386880
   \       0xCC   0xE184'2002        ORR      R2,R4,R2
   \       0xD0   0xE001'1A03        AND      R1,R1,R3, LSL #+20
   \       0xD4   0xE181'1002        ORR      R1,R1,R2
   \       0xD8   0xE381'2480        ORR      R2,R1,#0x80000000
   \       0xDC   0xE580'2000        STR      R2,[R0, #+0]
   1765          }
   \       0xE0   0xE8BD'8073        POP      {R0,R1,R4-R6,PC}  ;; return
   1766          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1767          void pmc_enable_gck(uint32_t id)
   1768          {
   \                     pmc_enable_gck:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1769          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_enable_gck_1
   \       0x10   0xE3A0'20E9        MOV      R2,#+233
   \       0x14   0xE382'2E60        ORR      R2,R2,#0x600
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        LDR      R0,??DataTable42_4
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1770          
   1771          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_enable_gck_1:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE204'107F        AND      R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1772          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x3C   0xE58D'2000        STR      R2,[SP, #+0]
   1773          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_GCKEN;
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE381'24A0        ORR      R2,R1,#0xA0000000
   \       0x48   0xE580'2000        STR      R2,[R0, #+0]
   1774          
   1775          #if defined(PMC_GCSR_PID0) || defined(PMC_GCSR0_GPID5)
   1776          	/* check whether or not fGCLK(Max) is out of range */
   1777          	switch(id) {
   \       0x4C   0xE244'0005        SUB      R0,R4,#+5
   \       0x50   0xE350'002A        CMP      R0,#+42
   \       0x54   0x8A00'0047        BHI      ??pmc_enable_gck_2
   \       0x58   0xE7DF'2000        LDRB     R2,[PC, R0]
   \       0x5C   0xE08F'F102        ADD      PC,PC,R2, LSL #+2
   \                     ??pmc_enable_gck_0:
   \       0x60   0x37 0x37          DC8      0x37,0x37,0x37,0x37

   \              0x37 0x37
   \       0x64   0x37 0x37          DC8      0x37,0x37,0x37,0x20

   \              0x37 0x20
   \       0x68   0x37 0x37          DC8      0x37,0x37,0x37,0x37

   \              0x37 0x37
   \       0x6C   0x37 0x45          DC8      0x37,0x45,0x37,0x45

   \              0x37 0x45
   \       0x70   0x45 0x45          DC8      0x45,0x45,0x45,0x45

   \              0x45 0x45
   \       0x74   0x0A 0x20          DC8      0xA,0x20,0x45,0x45

   \              0x45 0x45
   \       0x78   0x45 0x45          DC8      0x45,0x45,0x45,0x37

   \              0x45 0x37
   \       0x7C   0x37 0x2B          DC8      0x37,0x2B,0x45,0x45

   \              0x45 0x45
   \       0x80   0x37 0x45          DC8      0x37,0x45,0x45,0x45

   \              0x45 0x45
   \       0x84   0x45 0x15          DC8      0x45,0x15,0x45,0x45

   \              0x45 0x45
   \       0x88   0x37 0x45          DC8      0x37,0x45,0x37,0x0

   \              0x37 0x00
   1778          	case ID_LCDC:
   1779          		if (pmc_get_gck_clock(id) > 140000000) {
   \                     ??pmc_enable_gck_3:
   \       0x8C   0xE3A0'0019        MOV      R0,#+25
   \       0x90   0x....'....        BL       pmc_get_gck_clock
   \       0x94   0x....'....        LDR      R1,??DataTable42_11  ;; 0x8583b01
   \       0x98   0xE150'0001        CMP      R0,R1
   \       0x9C   0x3A00'0035        BCC      ??pmc_enable_gck_2
   1780          			trace_warning("fGCK(Max) for LCDC should not exceed 140MHz!\r\n");
   \       0xA0   0x....'....        LDR      R0,??DataTable42_12
   \       0xA4   0xE590'2000        LDR      R2,[R0, #+0]
   \       0xA8   0xE352'0003        CMP      R2,#+3
   \       0xAC   0x3A00'0031        BCC      ??pmc_enable_gck_2
   \       0xB0   0x....'....        LDR      R0,??DataTable42_13
   \       0xB4   0xEA00'001F        B        ??pmc_enable_gck_4
   1781          		}
   1782          		break;
   1783          	case ID_CLASSD0:
   1784          		if (pmc_get_gck_clock(id) > 100000000) {
   \                     ??pmc_enable_gck_5:
   \       0xB8   0xE3A0'002A        MOV      R0,#+42
   \       0xBC   0x....'....        BL       pmc_get_gck_clock
   \       0xC0   0x....'....        LDR      R1,??DataTable42_14  ;; 0x5f5e101
   \       0xC4   0xE150'0001        CMP      R0,R1
   \       0xC8   0x3A00'002A        BCC      ??pmc_enable_gck_2
   1785          			trace_warning("fGCK(Max) for CLASSD should not exceed 100MHz!\r\n");
   \       0xCC   0x....'....        LDR      R0,??DataTable42_12
   \       0xD0   0xE590'2000        LDR      R2,[R0, #+0]
   \       0xD4   0xE352'0003        CMP      R2,#+3
   \       0xD8   0x3A00'0026        BCC      ??pmc_enable_gck_2
   \       0xDC   0x....'....        LDR      R0,??DataTable42_15
   \       0xE0   0xEA00'0014        B        ??pmc_enable_gck_4
   1786          		}
   1787          		break;
   1788          	case ID_SDMMC0:
   1789          	case ID_SDMMC1:
   1790          		if (pmc_get_gck_clock(id) > 105000000) {
   \                     ??pmc_enable_gck_6:
   \       0xE4   0xE1A0'0004        MOV      R0,R4
   \       0xE8   0x....'....        BL       pmc_get_gck_clock
   \       0xEC   0x....'....        LDR      R1,??DataTable42_16  ;; 0x6422c41
   \       0xF0   0xE150'0001        CMP      R0,R1
   \       0xF4   0x3A00'001F        BCC      ??pmc_enable_gck_2
   1791          			trace_warning("fGCK(Max) for SDMMC should not exceed 105MHz!\r\n");
   \       0xF8   0x....'....        LDR      R0,??DataTable42_12
   \       0xFC   0xE590'2000        LDR      R2,[R0, #+0]
   \      0x100   0xE352'0003        CMP      R2,#+3
   \      0x104   0x3A00'001B        BCC      ??pmc_enable_gck_2
   \      0x108   0x....'....        LDR      R0,??DataTable42_17
   \      0x10C   0xEA00'0009        B        ??pmc_enable_gck_4
   1792          		}
   1793          		break;
   1794          	case ID_I2SMCC:
   1795          		if (pmc_get_gck_clock(id) > 105000000) {
   \                     ??pmc_enable_gck_7:
   \      0x110   0xE3A0'0022        MOV      R0,#+34
   \      0x114   0x....'....        BL       pmc_get_gck_clock
   \      0x118   0x....'....        LDR      R1,??DataTable42_16  ;; 0x6422c41
   \      0x11C   0xE150'0001        CMP      R0,R1
   \      0x120   0x3A00'0014        BCC      ??pmc_enable_gck_2
   1796          			trace_warning("fGCK(Max) for I2SMCC should not exceed 105MHz!\r\n");
   \      0x124   0x....'....        LDR      R0,??DataTable42_12
   \      0x128   0xE590'2000        LDR      R2,[R0, #+0]
   \      0x12C   0xE352'0003        CMP      R2,#+3
   \      0x130   0x3A00'0010        BCC      ??pmc_enable_gck_2
   \      0x134   0x....'....        LDR      R0,??DataTable42_18
   \                     ??pmc_enable_gck_4:
   \      0x138   0x....'....        BL       printf
   \      0x13C   0xEA00'000D        B        ??pmc_enable_gck_2
   1797          		}
   1798          		break;
   1799          	case ID_ADC:
   1800          	case ID_TC0: case ID_TC1:
   1801          	case ID_PIT64B:
   1802          	case ID_DBGU:
   1803          	case ID_FLEXCOM0: case ID_FLEXCOM1: case ID_FLEXCOM2: case ID_FLEXCOM3:
   1804          	case ID_FLEXCOM4: case ID_FLEXCOM5: case ID_FLEXCOM6: case ID_FLEXCOM7:
   1805          	case ID_FLEXCOM8: case ID_FLEXCOM9:	case ID_FLEXCOM10: case ID_FLEXCOM11:
   1806          	case ID_FLEXCOM12:
   1807          		if (3 * pmc_get_gck_clock(id) > pmc_get_master_clock()) {
   \                     ??pmc_enable_gck_8:
   \      0x140   0x....'....        BL       pmc_get_master_clock
   \      0x144   0xE1A0'5000        MOV      R5,R0
   \      0x148   0xE1A0'0004        MOV      R0,R4
   \      0x14C   0x....'....        BL       pmc_get_gck_clock
   \      0x150   0xE080'0080        ADD      R0,R0,R0, LSL #+1
   \      0x154   0xE155'0000        CMP      R5,R0
   \      0x158   0x2A00'0006        BCS      ??pmc_enable_gck_2
   1808          			trace_warning("fGCK(Max) for perpheral %d should not exceed fMCK/3!\r\n", id);
   \      0x15C   0x....'....        LDR      R1,??DataTable42_12
   \      0x160   0xE591'2000        LDR      R2,[R1, #+0]
   \      0x164   0xE352'0003        CMP      R2,#+3
   \      0x168   0x3A00'0002        BCC      ??pmc_enable_gck_2
   \      0x16C   0xE1A0'1004        MOV      R1,R4
   \      0x170   0x....'....        LDR      R0,??DataTable42_19
   \      0x174   0x....'....        BL       printf
   1809          		}
   1810          		break;
   1811          	}
   1812          
   1813          	while ((PMC->PMC_GCSR[(id >> 5) & 3] & (1 << (id & 31))) == 0);
   \                     ??pmc_enable_gck_2:
   \      0x178   0xE3E0'003F        MVN      R0,#+63
   \      0x17C   0xE3A0'1003        MOV      R1,#+3
   \      0x180   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \      0x184   0xE001'12A4        AND      R1,R1,R4, LSR #+5
   \      0x188   0xE790'0101        LDR      R0,[R0, +R1, LSL #+2]
   \      0x18C   0xE204'301F        AND      R3,R4,#0x1F
   \      0x190   0xE3A0'1001        MOV      R1,#+1
   \      0x194   0xE111'0330        TST      R1,R0, LSR R3
   \      0x198   0x0AFF'FFF6        BEQ      ??pmc_enable_gck_2
   1814          #elif defined (PMC_SR_GCKRDY)
   1815          	while (!(PMC->PMC_SR & PMC_SR_GCKRDY));
   1816          #else
   1817          	#error pmc_enable_gck() needs to be updated.
   1818          #endif
   1819          }
   \      0x19C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
   1820          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1821          RAMCODE void pmc_disable_gck(uint32_t id)
   1822          {
   \                     pmc_disable_gck:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1823          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_disable_gck_0
   \       0x10   0xE3A0'201F        MOV      R2,#+31
   \       0x14   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        ADR      R0,?_15
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1824          
   1825          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_disable_gck_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE204'107F        AND      R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1826          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x38   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x3C   0xE58D'2000        STR      R2,[SP, #+0]
   1827          	PMC->PMC_PCR = PMC_PCR_CMD | (pcr & ~PMC_PCR_GCKEN);
   \       0x40   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x44   0xE3C1'2580        BIC      R2,R1,#0x20000000
   \       0x48   0xE382'3480        ORR      R3,R2,#0x80000000
   \       0x4C   0xE580'3000        STR      R3,[R0, #+0]
   1828          }
   \       0x50   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1829          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1830          uint32_t pmc_get_gck_clock(uint32_t id)
   1831          {
   \                     pmc_get_gck_clock:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'5000        MOV      R5,R0
   1832          	uint32_t clk = 0;
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   1833          	assert(id < ID_PERIPH_COUNT);
   \        0xC   0xE355'0033        CMP      R5,#+51
   \       0x10   0x3A00'0005        BCC      ??pmc_get_gck_clock_0
   \       0x14   0xE3A0'2029        MOV      R2,#+41
   \       0x18   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x1C   0x....'....        LDR      R1,??DataTable42_3
   \       0x20   0x....'....        ADR      R0,?_15
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
   1834          
   1835          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_get_gck_clock_0:
   \       0x2C   0xE3E0'10DF        MVN      R1,#+223
   \       0x30   0xE205'007F        AND      R0,R5,#0x7F
   \       0x34   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \       0x38   0xE581'0068        STR      R0,[R1, #+104]
   1836          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x3C   0xE591'0068        LDR      R0,[R1, #+104]
   \       0x40   0xE58D'0000        STR      R0,[SP, #+0]
   1837          
   1838          	switch (pcr & PMC_PCR_GCKCSS_Msk) {
   \       0x44   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x48   0xE213'0D7C        ANDS     R0,R3,#0x1F00
   \       0x4C   0x0A00'0008        BEQ      ??pmc_get_gck_clock_1
   \       0x50   0xE350'0F80        CMP      R0,#+512
   \       0x54   0x0A00'0008        BEQ      ??pmc_get_gck_clock_2
   \       0x58   0xE350'0FC0        CMP      R0,#+768
   \       0x5C   0x0A00'0012        BEQ      ??pmc_get_gck_clock_3
   \       0x60   0xE350'0E40        CMP      R0,#+1024
   \       0x64   0x0A00'000A        BEQ      ??pmc_get_gck_clock_4
   \       0x68   0xE350'0E50        CMP      R0,#+1280
   \       0x6C   0x0A00'000B        BEQ      ??pmc_get_gck_clock_5
   \       0x70   0xEA00'000F        B        ??pmc_get_gck_clock_6
   1839          	case PMC_PCR_GCKCSS_SLOW_CLK:
   1840          		clk = pmc_get_slow_clock();
   \                     ??pmc_get_gck_clock_1:
   \       0x74   0x....'....        BL       slowclock_get_clock
   \       0x78   0xEA00'000C        B        ??pmc_get_gck_clock_7
   1841          		break;
   1842          	case PMC_PCR_GCKCSS_MAIN_CLK:
   1843          		clk = pmc_get_main_clock();
   \                     ??pmc_get_gck_clock_2:
   \       0x7C   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x80   0x....'....        LDR      R0,??DataTable42_20
   \       0x84   0xE312'0740        TST      R2,#0x1000000
   \       0x88   0x1590'4004        LDRNE    R4,[R0, #+4]
   \       0x8C   0x0590'4000        LDREQ    R4,[R0, #+0]
   \       0x90   0xEA00'0007        B        ??pmc_get_gck_clock_6
   1844          		break;
   1845          	case PMC_PCR_GCKCSS_PLLA_CLK:
   1846          		clk = pmc_get_plla_clock();
   \                     ??pmc_get_gck_clock_4:
   \       0x94   0xE3A0'0000        MOV      R0,#+0
   \       0x98   0x....'....        BL       _pmc_get_pll_clock
   \       0x9C   0xEA00'0003        B        ??pmc_get_gck_clock_7
   1847          		break;
   1848          	case PMC_PCR_GCKCSS_UPLL_CLK:
   1849          		clk = pmc_get_upll_clock();
   \                     ??pmc_get_gck_clock_5:
   \       0xA0   0xE3A0'0001        MOV      R0,#+1
   \       0xA4   0x....'....        BL       _pmc_get_pll_clock
   \       0xA8   0xEA00'0000        B        ??pmc_get_gck_clock_7
   1850          		break;
   1851          	case PMC_PCR_GCKCSS_MCK_CLK:
   1852          		clk = pmc_get_master_clock();
   \                     ??pmc_get_gck_clock_3:
   \       0xAC   0x....'....        BL       pmc_get_master_clock
   \                     ??pmc_get_gck_clock_7:
   \       0xB0   0xE1A0'4000        MOV      R4,R0
   1853          		break;
   1854          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1855          	case PMC_PCR_GCKCSS_AUDIO_CLK:
   1856          		clk = pmc_get_audio_pmc_clock();
   1857          		break;
   1858          #endif
   1859          	}
   1860          
   1861          	uint32_t div = (pcr & PMC_PCR_GCKDIV_Msk) >> PMC_PCR_GCKDIV_Pos;
   \                     ??pmc_get_gck_clock_6:
   \       0xB4   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xB8   0xE3A0'20FF        MOV      R2,#+255
   \       0xBC   0xE002'0A21        AND      R0,R2,R1, LSR #+20
   1862          	return ROUND_INT_DIV(clk, div + 1);
   \       0xC0   0xE354'0000        CMP      R4,#+0
   \       0xC4   0x1A00'0001        BNE      ??pmc_get_gck_clock_8
   \       0xC8   0xE3A0'0000        MOV      R0,#+0
   \       0xCC   0xE8BD'8032        POP      {R1,R4,R5,PC}
   \                     ??pmc_get_gck_clock_8:
   \       0xD0   0xE290'1001        ADDS     R1,R0,#+1
   \       0xD4   0x1084'00A1        ADDNE    R0,R4,R1, LSR #+1
   \       0xD8   0x0044'00A1        SUBEQ    R0,R4,R1, LSR #+1
   \       0xDC   0xE8BD'4034        POP      {R2,R4,R5,LR}
   \       0xE0   0x....'....        B        __aeabi_uidiv
   1863          }
   1864          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1865          bool pmc_is_gck_enabled(uint32_t id)
   1866          {
   \                     pmc_is_gck_enabled:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1867          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0033        CMP      R4,#+51
   \        0xC   0x3A00'0005        BCC      ??pmc_is_gck_enabled_0
   \       0x10   0xE3A0'204B        MOV      R2,#+75
   \       0x14   0xE382'2E70        ORR      R2,R2,#0x700
   \       0x18   0x....'....        LDR      R1,??DataTable42_3
   \       0x1C   0x....'....        ADR      R0,?_15
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1868          
   1869          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_is_gck_enabled_0:
   \       0x28   0xE3E0'0077        MVN      R0,#+119
   \       0x2C   0xE3C0'0FC0        BIC      R0,R0,#0x300
   \       0x30   0xE204'107F        AND      R1,R4,#0x7F
   \       0x34   0xE580'1000        STR      R1,[R0, #+0]
   1870          
   1871          	return (PMC->PMC_PCR & PMC_PCR_GCKEN) != 0;
   \       0x38   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x3C   0xE1A0'2EA0        LSR      R2,R0,#+29
   \       0x40   0xE202'0001        AND      R0,R2,#0x1
   \       0x44   0xE8BD'8010        POP      {R4,PC}          ;; return
   1872          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0xFF00'FEFE        DC32     0xff00fefe

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     ?_0+0x4C

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable33:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0xAAAA'AAAB        DC32     0xaaaaaaab

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x30 0x00          DC8      "0",0x0,0x0

   \              0x00 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable40:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable40_1:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_1:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_2:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_4:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_5:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_6:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_7:
   \        0x0   0x3938'7000        DC32     0x39387000

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_8:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_9:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_10:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_11:
   \        0x0   0x0858'3B01        DC32     0x8583b01

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_12:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_13:
   \        0x0   0x....'....        DC32     ?_0+0xF4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_14:
   \        0x0   0x05F5'E101        DC32     0x5f5e101

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_15:
   \        0x0   0x....'....        DC32     ?_0+0x128

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_16:
   \        0x0   0x0642'2C41        DC32     0x6422c41

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_17:
   \        0x0   0x....'....        DC32     ?_0+0x160

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_18:
   \        0x0   0x....'....        DC32     ?_0+0x194

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_19:
   \        0x0   0x....'....        DC32     ?_0+0x1CC

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_20:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68

   \              0x70 0x65    

   \              0x72 0x69    

   \              0x70 0x68
   \       0x40   0x65 0x72          DC8 0x65, 0x72, 0x61, 0x6C, 0x73, 0x5C, 0x70, 0x6D

   \              0x61 0x6C    

   \              0x73 0x5C    

   \              0x70 0x6D
   \       0x48   0x63 0x2E          DC8 0x63, 0x2E, 0x63, 0

   \              0x63 0x00
   \       0x4C   0x2D 0x46          DC8 "-F- Unknown PLL which index is %d\015\012"

   \              0x2D 0x20    

   \              0x55 0x6E    

   \              0x6B 0x6E    

   \              0x6F 0x77    

   \              0x6E 0x20    

   \              0x50 0x4C    

   \              0x4C 0x20    

   \              0x77 0x68    

   \              0x69 0x63    

   \              0x68 0x20    

   \              0x69 0x6E    

   \              0x64 0x65    

   \              0x78 0x20    

   \              0x69 0x73    

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00
   \       0x70   0x69 0x6E          DC8 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x3C, 0x20

   \              0x64 0x65    

   \              0x78 0x20    

   \              0x3C 0x20
   \       0x78   0x28 0x73          DC8 0x28, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x20

   \              0x69 0x7A    

   \              0x65 0x6F    

   \              0x66 0x20
   \       0x80   0x28 0x28          DC8 0x28, 0x28, 0x28, 0x28, 0x50, 0x6D, 0x63, 0x20

   \              0x28 0x28    

   \              0x50 0x6D    

   \              0x63 0x20
   \       0x88   0x2A 0x29          DC8 0x2A, 0x29, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46

   \              0x30 0x78    

   \              0x46 0x46    

   \              0x46 0x46
   \       0x90   0x46 0x43          DC8 0x46, 0x43, 0x30, 0x30, 0x55, 0x29, 0x2D, 0x3E

   \              0x30 0x30    

   \              0x55 0x29    

   \              0x2D 0x3E
   \       0x98   0x50 0x4D          DC8 0x50, 0x4D, 0x43, 0x5F, 0x50, 0x43, 0x4B, 0x29

   \              0x43 0x5F    

   \              0x50 0x43    

   \              0x4B 0x29
   \       0xA0   0x29 0x20          DC8 0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65

   \              0x2F 0x20    

   \              0x73 0x69    

   \              0x7A 0x65
   \       0xA8   0x6F 0x66          DC8 0x6F, 0x66, 0x28, 0x2A, 0x28, 0x28, 0x28, 0x50

   \              0x28 0x2A    

   \              0x28 0x28    

   \              0x28 0x50
   \       0xB0   0x6D 0x63          DC8 0x6D, 0x63, 0x20, 0x2A, 0x29, 0x30, 0x78, 0x46

   \              0x20 0x2A    

   \              0x29 0x30    

   \              0x78 0x46
   \       0xB8   0x46 0x46          DC8 0x46, 0x46, 0x46, 0x46, 0x43, 0x30, 0x30, 0x55

   \              0x46 0x46    

   \              0x43 0x30    

   \              0x30 0x55
   \       0xC0   0x29 0x2D          DC8 0x29, 0x2D, 0x3E, 0x50, 0x4D, 0x43, 0x5F, 0x50

   \              0x3E 0x50    

   \              0x4D 0x43    

   \              0x5F 0x50
   \       0xC8   0x43 0x4B          DC8 0x43, 0x4B, 0x29, 0x29, 0x29, 0

   \              0x29 0x29    

   \              0x29 0x00
   \       0xCE   0x00 0x00          DC8 0, 0
   \       0xD0   0x21 0x28          DC8 "!(prescaler << 8 & ~(0xffu << 8))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x3C 0x3C    

   \              0x20 0x38    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x66    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00
   \       0xF2   0x00 0x00          DC8 0, 0
   \       0xF4   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \       0xFC   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \      0x104   0x72 0x20          DC8 0x72, 0x20, 0x4C, 0x43, 0x44, 0x43, 0x20, 0x73

   \              0x4C 0x43    

   \              0x44 0x43    

   \              0x20 0x73
   \      0x10C   0x68 0x6F          DC8 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F

   \              0x75 0x6C    

   \              0x64 0x20    

   \              0x6E 0x6F
   \      0x114   0x74 0x20          DC8 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64

   \              0x65 0x78    

   \              0x63 0x65    

   \              0x65 0x64
   \      0x11C   0x20 0x31          DC8 0x20, 0x31, 0x34, 0x30, 0x4D, 0x48, 0x7A, 0x21

   \              0x34 0x30    

   \              0x4D 0x48    

   \              0x7A 0x21
   \      0x124   0x0D 0x0A          DC8 0x0D, 0x0A, 0

   \              0x00
   \      0x127   0x00               DC8 0
   \      0x128   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \      0x130   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \      0x138   0x72 0x20          DC8 0x72, 0x20, 0x43, 0x4C, 0x41, 0x53, 0x53, 0x44

   \              0x43 0x4C    

   \              0x41 0x53    

   \              0x53 0x44
   \      0x140   0x20 0x73          DC8 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20

   \              0x68 0x6F    

   \              0x75 0x6C    

   \              0x64 0x20
   \      0x148   0x6E 0x6F          DC8 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65

   \              0x74 0x20    

   \              0x65 0x78    

   \              0x63 0x65
   \      0x150   0x65 0x64          DC8 0x65, 0x64, 0x20, 0x31, 0x30, 0x30, 0x4D, 0x48

   \              0x20 0x31    

   \              0x30 0x30    

   \              0x4D 0x48
   \      0x158   0x7A 0x21          DC8 0x7A, 0x21, 0x0D, 0x0A, 0

   \              0x0D 0x0A    

   \              0x00
   \      0x15D   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \      0x160   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \      0x168   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \      0x170   0x72 0x20          DC8 0x72, 0x20, 0x53, 0x44, 0x4D, 0x4D, 0x43, 0x20

   \              0x53 0x44    

   \              0x4D 0x4D    

   \              0x43 0x20
   \      0x178   0x73 0x68          DC8 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E

   \              0x6F 0x75    

   \              0x6C 0x64    

   \              0x20 0x6E
   \      0x180   0x6F 0x74          DC8 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65

   \              0x20 0x65    

   \              0x78 0x63    

   \              0x65 0x65
   \      0x188   0x64 0x20          DC8 0x64, 0x20, 0x31, 0x30, 0x35, 0x4D, 0x48, 0x7A

   \              0x31 0x30    

   \              0x35 0x4D    

   \              0x48 0x7A
   \      0x190   0x21 0x0D          DC8 0x21, 0x0D, 0x0A, 0

   \              0x0A 0x00
   \      0x194   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \      0x19C   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \      0x1A4   0x72 0x20          DC8 0x72, 0x20, 0x49, 0x32, 0x53, 0x4D, 0x43, 0x43

   \              0x49 0x32    

   \              0x53 0x4D    

   \              0x43 0x43
   \      0x1AC   0x20 0x73          DC8 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20

   \              0x68 0x6F    

   \              0x75 0x6C    

   \              0x64 0x20
   \      0x1B4   0x6E 0x6F          DC8 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65

   \              0x74 0x20    

   \              0x65 0x78    

   \              0x63 0x65
   \      0x1BC   0x65 0x64          DC8 0x65, 0x64, 0x20, 0x31, 0x30, 0x35, 0x4D, 0x48

   \              0x20 0x31    

   \              0x30 0x35    

   \              0x4D 0x48
   \      0x1C4   0x7A 0x21          DC8 0x7A, 0x21, 0x0D, 0x0A, 0

   \              0x0D 0x0A    

   \              0x00
   \      0x1C9   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \      0x1CC   0x2D 0x57          DC8 0x2D, 0x57, 0x2D, 0x20, 0x66, 0x47, 0x43, 0x4B

   \              0x2D 0x20    

   \              0x66 0x47    

   \              0x43 0x4B
   \      0x1D4   0x28 0x4D          DC8 0x28, 0x4D, 0x61, 0x78, 0x29, 0x20, 0x66, 0x6F

   \              0x61 0x78    

   \              0x29 0x20    

   \              0x66 0x6F
   \      0x1DC   0x72 0x20          DC8 0x72, 0x20, 0x70, 0x65, 0x72, 0x70, 0x68, 0x65

   \              0x70 0x65    

   \              0x72 0x70    

   \              0x68 0x65
   \      0x1E4   0x72 0x61          DC8 0x72, 0x61, 0x6C, 0x20, 0x25, 0x64, 0x20, 0x73

   \              0x6C 0x20    

   \              0x25 0x64    

   \              0x20 0x73
   \      0x1EC   0x68 0x6F          DC8 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F

   \              0x75 0x6C    

   \              0x64 0x20    

   \              0x6E 0x6F
   \      0x1F4   0x74 0x20          DC8 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64

   \              0x65 0x78    

   \              0x63 0x65    

   \              0x65 0x64
   \      0x1FC   0x20 0x66          DC8 0x20, 0x66, 0x4D, 0x43, 0x4B, 0x2F, 0x33, 0x21

   \              0x4D 0x43    

   \              0x4B 0x2F    

   \              0x33 0x21
   \      0x204   0x0D 0x0A          DC8 0x0D, 0x0A, 0

   \              0x00
   \      0x207   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x34, 0x35, 0x20, 0x55, 0x6E, 0x6B

   \              0x34 0x35    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x35, 0x38, 0x20, 0x55, 0x6E, 0x6B

   \              0x35 0x38    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x37, 0x31, 0x20, 0x55, 0x6E, 0x6B

   \              0x37 0x31    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x69 0x64          DC8 "id < (51)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x35 0x31    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x70 0x6C          DC8 "plla->div == 1"

   \              0x6C 0x61    

   \              0x2D 0x3E    

   \              0x64 0x69    

   \              0x76 0x20    

   \              0x3D 0x3D    

   \              0x20 0x31    

   \              0x00
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x21 0x28          DC8 "!(prescaler & ~(0x7u << 4))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x37 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x34 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x21 0x28          DC8 "!(divider & ~(0x7u << 8))"

   \              0x64 0x69    

   \              0x76 0x69    

   \              0x64 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x37 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x21 0x28          DC8 "!(clock_source & ~(0x1fu << 0))"

   \              0x63 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x5F    

   \              0x73 0x6F    

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x31    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x30 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_17:
   \        0x0   0x30 0x00          DC8 "0"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x21 0x28          DC8 "!(clock_source & ~(0x1fu << 8))"

   \              0x63 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x5F    

   \              0x73 0x6F    

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x31    

   \              0x66 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x64 0x69          DC8 "div > 0"

   \              0x76 0x20    

   \              0x3E 0x20    

   \              0x30 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x21 0x28          DC8 "!((div << 20) & ~(0xffu << 20))"

   \              0x28 0x64    

   \              0x69 0x76    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x32 0x30    

   \              0x29 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x66 0x66    

   \              0x75 0x20    

   \              0x3C 0x3C    

   \              0x20 0x32    

   \              0x30 0x29    

   \              0x29 0x00
   1873          
   1874          #endif /* CONFIG_HAVE_PMC_GENERATED_CLOCKS */
   1875          
   1876          /*----------------------------------------------------------------------------
   1877           *        Exported functions (Audio PLL)
   1878           *----------------------------------------------------------------------------*/
   1879          
   1880          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1881          void pmc_configure_audio(const struct _pmc_audio_cfg *cfg)
   1882          {
   1883          #ifdef PMC_AUDIO_PLL0_PLLEN
   1884          	/* reset audio clock */
   1885          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_RESETN |
   1886          	                         PMC_AUDIO_PLL0_PLLEN);
   1887          	PMC->PMC_AUDIO_PLL0 |= PMC_AUDIO_PLL0_RESETN;
   1888          
   1889          	/* configure values */
   1890          	PMC->PMC_AUDIO_PLL0 = PMC_AUDIO_PLL0_ND(cfg->nd)
   1891          	                    | PMC_AUDIO_PLL0_QDPMC(cfg->qdpmc)
   1892          	                    | PMC_AUDIO_PLL0_PLLFLT_STD
   1893          	                    | PMC_AUDIO_PLL0_RESETN;
   1894          	PMC->PMC_AUDIO_PLL1 = PMC_AUDIO_PLL1_FRACR(cfg->fracr)
   1895          	                    | PMC_AUDIO_PLL1_DIV(cfg->div)
   1896          	                    | PMC_AUDIO_PLL1_QDAUDIO(cfg->qdaudio);
   1897          #else
   1898          	/* reset audio clock */
   1899          	PMC->PMC_APLLCCR &= ~(PMC_APLLCCR_RESETN |
   1900          	                      PMC_APLLCCR_PLLEN);
   1901          	PMC->PMC_APLLCCR |= PMC_APLLCCR_RESETN;
   1902          
   1903          	/* configure values */
   1904          	PMC->PMC_APLLCCR = PMC_APLLCCR_ND(cfg->nd)
   1905          	                 | PMC_APLLCCR_FRACR(cfg->fracr)
   1906          	                 | PMC_APLLCCR_RESETN;
   1907          	PMC->PMC_APLLPCR = PMC_APLLPCR_QDAUDIO(cfg->div * cfg->qdaudio);
   1908          	PMC->PMC_APLLICR = PMC_APLLICR_QDPMC(cfg->qdpmc);
   1909          #endif
   1910          }
   1911          
   1912          void pmc_enable_audio(bool pmc_clock, bool pad_clock)
   1913          {
   1914          #ifdef PMC_AUDIO_PLL0_PLLEN
   1915          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1916          	pll0 &= ~(PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1917          	pll0 |= PMC_AUDIO_PLL0_PLLEN;
   1918          	if (pad_clock)
   1919          		pll0 |= PMC_AUDIO_PLL0_PADEN;
   1920          	if (pmc_clock)
   1921          		pll0 |= PMC_AUDIO_PLL0_PMCEN;
   1922          	PMC->PMC_AUDIO_PLL0 = pll0;
   1923          #else
   1924          	PMC->PMC_APLLCCR |= PMC_APLLCCR_PLLEN;
   1925          
   1926          	if (pad_clock)
   1927          		PMC->PMC_APLLPCR |= PMC_APLLPCR_PADEN;
   1928          	else
   1929          		PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1930          
   1931          	if (pmc_clock)
   1932          		PMC->PMC_APLLICR |= PMC_APLLICR_PMCEN;
   1933          	else
   1934          		PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1935          #endif
   1936          
   1937          	/* Wait for the Audio PLL Startup Time (tSTART = 100 usec) */
   1938          	usleep(100);
   1939          }
   1940          
   1941          void pmc_disable_audio()
   1942          {
   1943          #ifdef PMC_AUDIO_PLL0_PLLEN
   1944          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_PLLEN | PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1945          #else
   1946          	PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1947          	PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1948          	PMC->PMC_APLLCCR &= ~PMC_APLLCCR_PLLEN;
   1949          #endif
   1950          }
   1951          
   1952          uint32_t pmc_get_audio_pmc_clock(void)
   1953          {
   1954          	uint32_t nd, fracr, qdpmc;
   1955          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1956          
   1957          #ifdef PMC_AUDIO_PLL0_PLLEN
   1958          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1959          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1960          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1961          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1962          	qdpmc = (pll0 & PMC_AUDIO_PLL0_QDPMC_Msk) >> PMC_AUDIO_PLL0_QDPMC_Pos;
   1963          #else
   1964          	uint32_t ccr = PMC->PMC_APLLCCR;
   1965          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1966          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1967          	qdpmc = (PMC->PMC_APLLICR & PMC_APLLICR_QDPMC_Msk) >> PMC_APLLICR_QDPMC_Pos;
   1968          #endif
   1969          
   1970          	clk *= ((nd + 1) << 22) + fracr;
   1971          	clk /= 1 << 22;
   1972          	clk /= qdpmc + 1;
   1973          	return (uint32_t)clk;
   1974          }
   1975          
   1976          uint32_t pmc_get_audio_pad_clock(void)
   1977          {
   1978          	uint32_t nd, fracr, qdaudio, div;
   1979          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1980          
   1981          #ifdef PMC_AUDIO_PLL0_PLLEN
   1982          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1983          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1984          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1985          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1986          	qdaudio = (pll1 & PMC_AUDIO_PLL1_QDAUDIO_Msk) >> PMC_AUDIO_PLL1_QDAUDIO_Pos;
   1987          	if (qdaudio == 0)
   1988          		return 0;
   1989          	div = (pll1 & PMC_AUDIO_PLL1_DIV_Msk) >> PMC_AUDIO_PLL1_DIV_Pos;
   1990          	if (div != 2 && div != 3)
   1991          		return 0;
   1992          #else
   1993          	uint32_t ccr = PMC->PMC_APLLCCR;
   1994          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1995          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1996          	qdaudio = (PMC->PMC_APLLPCR & PMC_APLLPCR_QDAUDIO_Msk) >> PMC_APLLPCR_QDAUDIO_Pos;
   1997          	if (qdaudio == 0)
   1998          		return 0;
   1999          	div = 1;
   2000          #endif
   2001          
   2002          	clk *= ((nd + 1) << 22) + fracr;
   2003          	clk /= 1 << 22;
   2004          	clk /= div * qdaudio;
   2005          	return (uint32_t)clk;
   2006          }
   2007          #endif /* CONFIG_HAVE_PMC_AUDIO_CLOCK */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _pmc_configure_pll
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> printf
         8   -> usleep
      40   _pmc_get_pll_clock
        40   -> _pmc_get_pll_config
        40   -> pmc_set_main_oscillator_freq
        40   -> printf
         0 __aeabi_uidiv
      16   _pmc_get_pll_config
        16   -> __aeabi_memclr4
       4   _pmc_get_system_clock_bits
      24   pmc_configure_gck
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> pmc_disable_gck
      16   pmc_configure_pck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_disable_pck
      16   pmc_configure_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_configure_gck
        16   -> pmc_disable_gck
        16   -> pmc_disable_peripheral
        16   -> pmc_enable_gck
         0   -> pmc_enable_peripheral
       0   pmc_configure_plla
         0   -> _pmc_configure_pll
      24   pmc_disable_all_peripherals
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       0   pmc_disable_external_osc
      16   pmc_disable_gck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   pmc_disable_internal_osc
       8   pmc_disable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_disable_peripheral
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_disable_plla
      16   pmc_disable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_disable_upll_clock
       4   pmc_enable_external_osc
      16   pmc_enable_gck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_get_gck_clock
        16   -> pmc_get_master_clock
        16   -> printf
       0   pmc_enable_internal_osc
       8   pmc_enable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pmc_enable_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   pmc_enable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_enable_ulp1
      40   pmc_enable_upll_clock
        40   -> _pmc_configure_pll
      16   pmc_ext32k_monitor
        16   -> slowclock_is_internal
        16   -> slowclock_select_external
        16   -> slowclock_set_bypass
      16   pmc_get_gck_clock
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> _pmc_get_pll_clock
        16   -> pmc_get_master_clock
        16   -> slowclock_get_clock
         0 __aeabi_uidiv
       0   pmc_get_main_clock
       0   pmc_get_main_oscillator_freq
         0   -> pmc_set_main_oscillator_freq
      16   pmc_get_master_clock
        16   -> _pmc_get_pll_clock
        16   -> slowclock_get_clock
       8   pmc_get_pck_clock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> _pmc_get_pll_clock
         8   -> pmc_get_master_clock
         8   -> slowclock_get_clock
         0 __aeabi_uidiv
      56   pmc_get_pck_mck_cfg
        56   -> __aeabi_memclr4
        56   -> __aeabi_memcpy4
        56   -> pmc_ext32k_monitor
        56   -> slowclock_is_internal
        56   -> slowclock_select_external
        56   -> slowclock_select_internal
       8   pmc_get_peripheral_clock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> get_peripheral_clock_matrix_div
         8   -> pmc_get_master_clock
         0 __aeabi_uidiv
       4   pmc_get_plla_clock
         0 __aeabi_uidiv
       8   pmc_get_processor_clock
         8   -> pmc_get_master_clock
       0   pmc_get_slow_clock
         0   -> slowclock_get_clock
       8   pmc_get_upll_clock
         8   -> pmc_set_main_oscillator_freq
       0   pmc_get_utmi_clock_trim
         0 __aeabi_uidiv
       0   pmc_has_system_clock
       8   pmc_is_gck_enabled
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_is_peripheral_enabled
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pmc_is_system_clock_enabled
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_is_upll_clock_enabled
       8   pmc_select_external_crystal
         8   -> pmc_switch_mck_to_main
         8   -> pmc_switch_mck_to_slck
         8   -> slowclock_select_external
       4   pmc_select_external_osc
       8   pmc_select_internal_crystal
         8   -> pmc_switch_mck_to_main
         8   -> pmc_switch_mck_to_slck
         8   -> slowclock_select_internal
       4   pmc_select_internal_osc
       8   pmc_set_custom_pck_mck
         8   -> _pmc_configure_pll
         8   -> pmc_select_external_crystal
         8   -> pmc_select_external_osc
         8   -> pmc_select_internal_crystal
         8   -> pmc_select_internal_osc
         8   -> pmc_set_mck_divider
         8   -> pmc_set_mck_prescaler
         8   -> pmc_switch_mck_to_main
         0   -> pmc_switch_mck_to_pll
         8   -> pmc_switch_mck_to_slck
         8   -> slowclock_set_bypass
       0   pmc_set_fast_startup_mode
       0   pmc_set_fast_startup_polarity
      32   pmc_set_main_oscillator_freq
        32   -> pmc_select_external_osc
        32   -> pmc_select_internal_osc
        32   -> pmc_switch_mck_to_new_source
        32   -> pmc_switch_mck_to_slck
        32 __aeabi_idiv
       8   pmc_set_mck_divider
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_set_mck_prescaler
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_switch_mck_to_main
       0   pmc_switch_mck_to_new_source
       0   pmc_switch_mck_to_pll
       0   pmc_switch_mck_to_slck
       0   pmc_switch_mck_to_upll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable29
       4  ??DataTable33
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_10
       4  ??DataTable42_11
       4  ??DataTable42_12
       4  ??DataTable42_13
       4  ??DataTable42_14
       4  ??DataTable42_15
       4  ??DataTable42_16
       4  ??DataTable42_17
       4  ??DataTable42_18
       4  ??DataTable42_19
       4  ??DataTable42_2
       4  ??DataTable42_20
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable42_5
       4  ??DataTable42_6
       4  ??DataTable42_7
       4  ??DataTable42_8
       4  ??DataTable42_9
      16  ??Subroutine5_0
      24  ?Subroutine0
      24  ?Subroutine1
      16  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
     520  ?_0
     112  ?_10
     112  ?_11
      16  ?_12
      28  ?_13
      28  ?_14
      12  ?_15
      32  ?_16
       2  ?_17
      32  ?_18
       8  ?_19
      32  ?_20
      24  ?_21
     112  ?_9
     448  _pmc_configure_pll
     176  _pmc_get_pll_clock
     140  _pmc_get_pll_config
     112  _pmc_get_system_clock_bits
      12  _pmc_main_oscillators
          _pmc_mck
     228  pmc_configure_gck
     148  pmc_configure_pck
     152  pmc_configure_peripheral
       4  pmc_configure_plla
     100  pmc_disable_all_peripherals
      60  pmc_disable_external_osc
      84  pmc_disable_gck
      36  pmc_disable_internal_osc
     128  pmc_disable_pck
      76  pmc_disable_peripheral
      80  pmc_disable_plla
     116  pmc_disable_system_clock
     104  pmc_disable_upll_clock
     144  pmc_enable_external_osc
     416  pmc_enable_gck
      56  pmc_enable_internal_osc
     132  pmc_enable_pck
      80  pmc_enable_peripheral
     116  pmc_enable_system_clock
      48  pmc_enable_ulp1
      36  pmc_enable_upll_clock
     172  pmc_ext32k_monitor
     228  pmc_get_gck_clock
      32  pmc_get_main_clock
      20  pmc_get_main_oscillator_freq
     280  pmc_get_master_clock
     152  pmc_get_pck_clock
     340  pmc_get_pck_mck_cfg
      68  pmc_get_peripheral_clock
     116  pmc_get_plla_clock
      68  pmc_get_processor_clock
       8  pmc_get_slow_clock
     104  pmc_get_upll_clock
      48  pmc_get_utmi_clock_trim
      52  pmc_has_system_clock
      72  pmc_is_gck_enabled
      76  pmc_is_peripheral_enabled
     112  pmc_is_system_clock_enabled
      24  pmc_is_upll_clock_enabled
      48  pmc_select_external_crystal
     368  pmc_select_external_osc
      44  pmc_select_internal_crystal
     160  pmc_select_internal_osc
     388  pmc_set_custom_pck_mck
      16  pmc_set_fast_startup_mode
       4  pmc_set_fast_startup_polarity
     500  pmc_set_main_oscillator_freq
      56  pmc_set_mck_divider
      60  pmc_set_mck_prescaler
      20  pmc_switch_mck_to_main
      56  pmc_switch_mck_to_new_source
      24  pmc_switch_mck_to_pll
      24  pmc_switch_mck_to_slck
      24  pmc_switch_mck_to_upll

 
    12 bytes in section .data
 1'058 bytes in section .rodata
 7'236 bytes in section SOFTPACK
 
 7'236 bytes of CODE  memory
 1'058 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
