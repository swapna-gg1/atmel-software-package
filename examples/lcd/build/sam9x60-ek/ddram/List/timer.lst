###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         15/Jan/2021  07:27:13
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c
#    Command line      =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5520.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c -D
#        "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_LCD -D CONFIG_HAVE_LCDC -D CONFIG_HAVE_LCDC_OVR1 -D
#        CONFIG_HAVE_LCDC_OVR2 -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_DDR2_W972GG6KB -D CONFIG_HAVE_RSTC_EXTERNAL_RESET -D
#        CONFIG_HAVE_RSTC_INDEPENDENT_RESET -D CONFIG_HAVE_RTT -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale            =  C
#    List file         =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List\timer.lst
#    Object file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj\timer.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\utils\timer.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *         Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include "board.h"
     35          #include "irqflags.h"
     36          #include "irq/irq.h"
     37          #include "peripherals/pmc.h"
     38          #include "peripherals/tc.h"
     39          #include "timer.h"
     40          
     41          /*----------------------------------------------------------------------------
     42           *         Local type definitions
     43           *----------------------------------------------------------------------------*/
     44          
     45          struct _timer {
     46          	Tc* tc;
     47          	uint8_t channel;
     48          	uint32_t channel_freq;
     49          	volatile uint32_t upper;
     50          };
     51          
     52          /*----------------------------------------------------------------------------
     53           *         Local variables
     54           *----------------------------------------------------------------------------*/
     55          
     56          /** System timer */

   \                                 In section .bss, align 4
     57          static struct _timer _timer;
   \                     _timer:
   \        0x0                      DS8 16
     58          
     59          /*----------------------------------------------------------------------------
     60           *         Local Functions
     61           *----------------------------------------------------------------------------*/
     62          

   \                                 In section SOFTPACK, align 4, keep-with-next
     63          static void timer_update_upper_tick_counter(void)
     64          {
   \                     timer_update_upper_tick_counter:
   \        0x0   0x....'....        B        ?Subroutine0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
     65          	uint32_t status = tc_get_status(_timer.tc, _timer.channel);
     66          	if ((status & TC_SR_COVFS) == TC_SR_COVFS)
   \        0x4   0x....'....        LDR      R4,??DataTable10
   \        0x8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       tc_get_status
   \       0x14   0xE310'0001        TST      R0,#0x1
     67          		_timer.upper++;
   \       0x18   0x1594'000C        LDRNE    R0,[R4, #+12]
   \       0x1C   0x1280'1001        ADDNE    R1,R0,#+1
   \       0x20   0x1584'100C        STRNE    R1,[R4, #+12]
     68          }
   \       0x24   0xE8BD'8010        POP      {R4,PC}          ;; return
     69          
     70          static uint32_t timer_get_upper_tick_counter(void)
     71          {
     72          	timer_update_upper_tick_counter();
     73          	return _timer.upper;
     74          }
     75          
     76          #ifndef CONFIG_TIMER_POLLING
     77          
     78          /**
     79           *  \brief Handler for timer interrupt.
     80           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     81          static void timer_irq_handler(uint32_t source, void* user_arg)
     82          {
   \                     timer_irq_handler:
   \        0x0   0xE1A0'0000        Nop
   \        0x4                      REQUIRE ?Subroutine0
   \        0x4                      ;; // Fall through to label ?Subroutine0
     83          	timer_update_upper_tick_counter();
     84          }
     85          
     86          #endif /* !CONFIG_TIMER_POLLING */
     87          

   \                                 In section SOFTPACK, align 4, keep-with-next
     88          static uint64_t _timer_get_tick(void)
     89          {
   \                     _timer_get_tick:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0x....'....        LDR      R6,??DataTable10
     90          	uint32_t upper, lower;
     91          
     92          	do {
     93          		upper = timer_get_upper_tick_counter();
   \                     ??_timer_get_tick_0:
   \        0x8   0x....'....        BL       timer_update_upper_tick_counter
   \        0xC   0xE596'500C        LDR      R5,[R6, #+12]
     94          		COMPILER_BARRIER();
     95          		lower = tc_get_cv(_timer.tc, _timer.channel);
   \       0x10   0xE5D6'1004        LDRB     R1,[R6, #+4]
   \       0x14   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x18   0x....'....        BL       tc_get_cv
   \       0x1C   0xE1A0'4000        MOV      R4,R0
     96          	} while (upper != timer_get_upper_tick_counter());
   \       0x20   0x....'....        BL       timer_update_upper_tick_counter
   \       0x24   0xE596'000C        LDR      R0,[R6, #+12]
   \       0x28   0xE155'0000        CMP      R5,R0
   \       0x2C   0x1AFF'FFF5        BNE      ??_timer_get_tick_0
     97          	return (((uint64_t)upper) << TC_CHANNEL_SIZE) | lower;
   \       0x30   0xE1A0'1005        MOV      R1,R5
   \       0x34   0xE1A0'0004        MOV      R0,R4
   \       0x38   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
     98          }
     99          
    100          /*----------------------------------------------------------------------------
    101           *         Exported Functions
    102           *----------------------------------------------------------------------------*/
    103          

   \                                 In section SOFTPACK, align 4, keep-with-next
    104          void timer_configure(Tc* tc, uint8_t channel, uint32_t clock_source)
    105          {
   \                     timer_configure:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
    106          	uint32_t tc_id = get_tc_id_from_addr(tc, channel);
   \       0x10   0x....'....        BL       get_tc_id_from_addr
    107          
    108          	_timer.tc = tc;
   \       0x14   0x....'....        LDR      R8,??DataTable10
   \       0x18   0xE1A0'7000        MOV      R7,R0
   \       0x1C   0xE588'4000        STR      R4,[R8, #+0]
    109          	_timer.channel = channel;
   \       0x20   0xE5C8'5004        STRB     R5,[R8, #+4]
    110          
    111          	if (!pmc_is_peripheral_enabled(tc_id))
   \       0x24   0x....'....        BL       pmc_is_peripheral_enabled
   \       0x28   0xE350'0000        CMP      R0,#+0
   \       0x2C   0x1A00'0003        BNE      ??timer_configure_0
    112          		pmc_configure_peripheral(tc_id, NULL, true);
   \       0x30   0xE3A0'2001        MOV      R2,#+1
   \       0x34   0xE3A0'1000        MOV      R1,#+0
   \       0x38   0xE1A0'0007        MOV      R0,R7
   \       0x3C   0x....'....        BL       pmc_configure_peripheral
    113          
    114          	tc_configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP |
    115          			(clock_source & TC_CMR_TCCLKS_Msk));
   \                     ??timer_configure_0:
   \       0x40   0xE206'0007        AND      R0,R6,#0x7
   \       0x44   0xE380'2C80        ORR      R2,R0,#0x8000
   \       0x48   0xE1A0'1005        MOV      R1,R5
   \       0x4C   0xE1A0'0004        MOV      R0,R4
   \       0x50   0x....'....        BL       tc_configure
    116          	_timer.channel_freq = tc_get_channel_freq(tc, channel);
   \       0x54   0xE1A0'1005        MOV      R1,R5
   \       0x58   0xE1A0'0004        MOV      R0,R4
   \       0x5C   0x....'....        BL       tc_get_channel_freq
   \       0x60   0xE588'0008        STR      R0,[R8, #+8]
    117          #ifndef CONFIG_TIMER_POLLING
    118          	irq_add_handler(tc_id, timer_irq_handler, &_timer);
   \       0x64   0xE1A0'2008        MOV      R2,R8
   \       0x68   0x....'....        ADR      R1,timer_irq_handler
   \       0x6C   0xE1A0'0007        MOV      R0,R7
   \       0x70   0x....'....        BL       irq_add_handler
    119          	irq_enable(tc_id);
   \       0x74   0xE1A0'0007        MOV      R0,R7
   \       0x78   0x....'....        BL       irq_enable
    120          	tc_enable_it(tc, channel, TC_IER_COVFS);
   \       0x7C   0xE3A0'2001        MOV      R2,#+1
   \       0x80   0xE1A0'1005        MOV      R1,R5
   \       0x84   0xE1A0'0004        MOV      R0,R4
   \       0x88   0x....'....        BL       tc_enable_it
    121          #endif
    122          	tc_start(tc, channel);
   \       0x8C   0xE1A0'1005        MOV      R1,R5
   \       0x90   0xE1A0'0004        MOV      R0,R4
   \       0x94   0xE8BD'41F0        POP      {R4-R8,LR}
   \       0x98   0x....'....        B        tc_start         ;; tailcall
    123          }
    124          

   \                                 In section SOFTPACK, align 4, keep-with-next
    125          uint64_t timer_get_interval(uint64_t start, uint64_t end)
    126          {
    127          	if (end >= start)
   \                     timer_get_interval:
   \        0x0   0xE153'0001        CMP      R3,R1
   \        0x4   0x3A00'0005        BCC      ??timer_get_interval_0
   \        0x8   0x8A00'0001        BHI      ??timer_get_interval_1
   \        0xC   0xE152'0000        CMP      R2,R0
   \       0x10   0x3A00'0002        BCC      ??timer_get_interval_0
    128          		return end - start;
   \                     ??timer_get_interval_1:
   \       0x14   0xE052'0000        SUBS     R0,R2,R0
   \       0x18   0xE0C3'1001        SBC      R1,R3,R1
   \       0x1C   0xE12F'FF1E        BX       LR
    129          	return end + (0xffffffffffffffffu - start) + 1;
   \                     ??timer_get_interval_0:
   \       0x20   0xE252'2001        SUBS     R2,R2,#+1
   \       0x24   0xE2C3'3000        SBC      R3,R3,#+0
   \       0x28   0xE052'0000        SUBS     R0,R2,R0
   \       0x2C   0xE0C3'1001        SBC      R1,R3,R1
   \       0x30   0xE290'0001        ADDS     R0,R0,#+1
   \       0x34   0xE2A1'1000        ADC      R1,R1,#+0
   \       0x38   0xE12F'FF1E        BX       LR               ;; return
    130          }
    131          

   \                                 In section SOFTPACK, align 4, keep-with-next
    132          void timer_start_timeout(struct _timeout* timeout, uint64_t count)
    133          {
   \                     timer_start_timeout:
   \        0x0   0xE92D'4178        PUSH     {R3-R6,R8,LR}
   \        0x4   0xE1A0'6000        MOV      R6,R0
   \        0x8   0xE1A0'4002        MOV      R4,R2
   \        0xC   0xE1A0'5003        MOV      R5,R3
    134          	timeout->start = timer_get_tick();
   \       0x10   0x....'....        BL       _timer_get_tick
   \       0x14   0xE1A0'2000        MOV      R2,R0
   \       0x18   0xE1A0'3001        MOV      R3,R1
   \       0x1C   0xE3A0'8FFA        MOV      R8,#+1000
   \       0x20   0xE081'0892        UMULL    R0,R1,R2,R8
   \       0x24   0xE021'1893        MLA      R1,R3,R8,R1
   \       0x28   0x....'....        LDR      R12,??DataTable10
   \       0x2C   0xE3A0'3000        MOV      R3,#+0
   \       0x30   0xE59C'2008        LDR      R2,[R12, #+8]
   \       0x34   0x....'....        BL       __aeabi_uldivmod
   \       0x38   0xE1C6'00F0        STRD     R0,R1,[R6, #+0]
    135          	timeout->count = count ;
   \       0x3C   0xE1C6'40F8        STRD     R4,R5,[R6, #+8]
    136          }
   \       0x40   0xE8BD'8171        POP      {R0,R4-R6,R8,PC}  ;; return
    137          

   \                                 In section SOFTPACK, align 4, keep-with-next
    138          void timer_reset_timeout(struct _timeout* timeout)
    139          {
   \                     timer_reset_timeout:
   \        0x0   0xE92D'4058        PUSH     {R3,R4,R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    140          	timeout->start = timer_get_tick();
   \        0x8   0x....'....        BL       _timer_get_tick
   \        0xC   0xE1A0'2000        MOV      R2,R0
   \       0x10   0xE1A0'3001        MOV      R3,R1
   \       0x14   0xE3A0'6FFA        MOV      R6,#+1000
   \       0x18   0xE081'0692        UMULL    R0,R1,R2,R6
   \       0x1C   0xE021'1693        MLA      R1,R3,R6,R1
   \       0x20   0x....'....        LDR      R12,??DataTable10
   \       0x24   0xE3A0'3000        MOV      R3,#+0
   \       0x28   0xE59C'2008        LDR      R2,[R12, #+8]
   \       0x2C   0x....'....        BL       __aeabi_uldivmod
   \       0x30   0xE1C4'00F0        STRD     R0,R1,[R4, #+0]
    141          }
   \       0x34   0xE8BD'8051        POP      {R0,R4,R6,PC}    ;; return
    142          

   \                                 In section SOFTPACK, align 4, keep-with-next
    143          uint8_t timer_timeout_reached(struct _timeout* timeout)
    144          {
   \                     timer_timeout_reached:
   \        0x0   0xE92D'4058        PUSH     {R3,R4,R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    145          	return timer_get_interval(timeout->start, timer_get_tick()) >= timeout->count;
   \        0x8   0x....'....        BL       _timer_get_tick
   \        0xC   0xE1A0'2000        MOV      R2,R0
   \       0x10   0xE1A0'3001        MOV      R3,R1
   \       0x14   0xE3A0'6FFA        MOV      R6,#+1000
   \       0x18   0xE081'0692        UMULL    R0,R1,R2,R6
   \       0x1C   0xE021'1693        MLA      R1,R3,R6,R1
   \       0x20   0x....'....        LDR      R12,??DataTable10
   \       0x24   0xE3A0'3000        MOV      R3,#+0
   \       0x28   0xE59C'2008        LDR      R2,[R12, #+8]
   \       0x2C   0x....'....        BL       __aeabi_uldivmod
   \       0x30   0xE1A0'2000        MOV      R2,R0
   \       0x34   0xE1A0'3001        MOV      R3,R1
   \       0x38   0xE1C4'00D0        LDRD     R0,R1,[R4, #+0]
   \       0x3C   0x....'....        BL       timer_get_interval
   \       0x40   0xE1C4'20D8        LDRD     R2,R3,[R4, #+8]
   \       0x44   0xE151'0003        CMP      R1,R3
   \       0x48   0x3A00'0004        BCC      ??timer_timeout_reached_0
   \       0x4C   0x8A00'0001        BHI      ??timer_timeout_reached_1
   \       0x50   0xE150'0002        CMP      R0,R2
   \       0x54   0x3A00'0001        BCC      ??timer_timeout_reached_0
   \                     ??timer_timeout_reached_1:
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xE8BD'8052        POP      {R1,R4,R6,PC}
   \                     ??timer_timeout_reached_0:
   \       0x60   0xE3A0'0000        MOV      R0,#+0
   \       0x64   0xE8BD'8052        POP      {R1,R4,R6,PC}    ;; return
    146          }
    147          

   \                                 In section SOFTPACK, align 4, keep-with-next
    148          void timer_sleep(uint64_t count)
    149          {
   \                     timer_sleep:
   \        0x0   0xE92D'4178        PUSH     {R3-R6,R8,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    150          	uint64_t end_tick = timer_get_tick() + count;
   \        0xC   0x....'....        BL       _timer_get_tick
   \       0x10   0xE1A0'2000        MOV      R2,R0
   \       0x14   0xE1A0'3001        MOV      R3,R1
   \       0x18   0xE3A0'8FFA        MOV      R8,#+1000
   \       0x1C   0xE081'0892        UMULL    R0,R1,R2,R8
   \       0x20   0x....'....        LDR      R6,??DataTable10
   \       0x24   0xE021'1893        MLA      R1,R3,R8,R1
   \       0x28   0xE596'2008        LDR      R2,[R6, #+8]
   \       0x2C   0xE3A0'3000        MOV      R3,#+0
   \       0x30   0x....'....        BL       __aeabi_uldivmod
   \       0x34   0x....'....        B        ?Subroutine1
    151          
    152          	while (timer_get_tick() <= end_tick);
    153          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE090'4004        ADDS     R4,R0,R4
   \        0x4   0xE0A1'5005        ADC      R5,R1,R5
   \                     ??Subroutine1_0:
   \        0x8   0x....'....        BL       _timer_get_tick
   \        0xC   0xE1A0'2000        MOV      R2,R0
   \       0x10   0xE1A0'3001        MOV      R3,R1
   \       0x14   0xE081'0892        UMULL    R0,R1,R2,R8
   \       0x18   0xE021'1893        MLA      R1,R3,R8,R1
   \       0x1C   0xE596'2008        LDR      R2,[R6, #+8]
   \       0x20   0xE3A0'3000        MOV      R3,#+0
   \       0x24   0x....'....        BL       __aeabi_uldivmod
   \       0x28   0xE155'0001        CMP      R5,R1
   \       0x2C   0x8AFF'FFF5        BHI      ??Subroutine1_0
   \       0x30   0x2154'0000        CMPCS    R4,R0
   \       0x34   0x2AFF'FFF3        BCS      ??Subroutine1_0
   \       0x38   0xE8BD'8171        POP      {R0,R4-R6,R8,PC}  ;; return
    154          

   \                                 In section SOFTPACK, align 4, keep-with-next
    155          uint64_t timer_get_tick(void)
    156          {
   \                     timer_get_tick:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    157          	return (_timer_get_tick() * 1000) / _timer.channel_freq;
   \        0x4   0x....'....        BL       _timer_get_tick
   \        0x8   0xE1A0'2000        MOV      R2,R0
   \        0xC   0xE1A0'3001        MOV      R3,R1
   \       0x10   0xE3A0'4FFA        MOV      R4,#+1000
   \       0x14   0xE081'0492        UMULL    R0,R1,R2,R4
   \       0x18   0xE021'1493        MLA      R1,R3,R4,R1
   \       0x1C   0x....'....        LDR      R12,??DataTable10
   \       0x20   0xE8BD'4010        POP      {R4,LR}
   \       0x24   0xE59C'2008        LDR      R2,[R12, #+8]
   \       0x28   0xE3A0'3000        MOV      R3,#+0
   \       0x2C   0x....'....        B        __aeabi_uldivmod
    158          }
    159          

   \                                 In section SOFTPACK, align 4, keep-with-next
    160          void sleep(uint32_t count)
    161          {
    162          	timer_sleep(count * 1000);
   \                     sleep:
   \        0x0   0xE3A0'1FFA        MOV      R1,#+1000
   \        0x4   0xE000'0091        MUL      R0,R1,R0
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0x....'....        B        timer_sleep      ;; tailcall
    163          }
    164          

   \                                 In section SOFTPACK, align 4, keep-with-next
    165          void msleep(uint32_t count)
    166          {
   \                     msleep:
   \        0x0   0xE92D'4178        PUSH     {R3-R6,R8,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    167          	timer_sleep(count);
   \        0x8   0x....'....        BL       _timer_get_tick
   \        0xC   0xE1A0'2000        MOV      R2,R0
   \       0x10   0xE1A0'3001        MOV      R3,R1
   \       0x14   0xE3A0'8FFA        MOV      R8,#+1000
   \       0x18   0xE081'0892        UMULL    R0,R1,R2,R8
   \       0x1C   0x....'....        LDR      R6,??DataTable10
   \       0x20   0xE021'1893        MLA      R1,R3,R8,R1
   \       0x24   0xE596'2008        LDR      R2,[R6, #+8]
   \       0x28   0xE3A0'3000        MOV      R3,#+0
   \       0x2C   0x....'....        BL       __aeabi_uldivmod
   \       0x30   0xE3A0'5000        MOV      R5,#+0
   \       0x34                      REQUIRE ?Subroutine1
   \       0x34                      ;; // Fall through to label ?Subroutine1
    168          }
    169          

   \                                 In section SOFTPACK, align 4, keep-with-next
    170          void usleep(uint32_t count)
    171          {
   \                     usleep:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    172          	uint64_t deadline;
    173          
    174          	/* Disable interrupts */
    175          	arch_irq_disable();
   \        0x8   0xE10F'0000        mrs R0, cpsr
   \        0xC   0xE380'0080        ORR      R0,R0,#0x80
   \       0x10   0xE121'F000        msr cpsr_c, R0
    176          
    177          	/* Compute deadline */
    178          	deadline = _timer_get_tick();
   \       0x14   0x....'....        BL       _timer_get_tick
    179          	deadline += ROUND_INT_DIV((_timer.channel_freq / 1000) * count, 1000);
   \       0x18   0x....'....        LDR      R2,??DataTable10
   \       0x1C   0x....'....        LDR      LR,??DataTable10_1  ;; 0x83126e98
   \       0x20   0xE592'3008        LDR      R3,[R2, #+8]
   \       0x24   0xE08C'EE93        UMULL    LR,R12,R3,LR
   \       0x28   0xE1A0'C4AC        LSR      R12,R12,#+9
   \       0x2C   0xE012'0C94        MULS     R2,R4,R12
   \       0x30   0x....'....        LDRNE    R12,??DataTable10_1  ;; 0x83126e98
   \       0x34   0x1282'2F7D        ADDNE    R2,R2,#+500
   \       0x38   0x1083'CC92        UMULLNE  R12,R3,R2,R12
   \       0x3C   0x03A0'2000        MOVEQ    R2,#+0
   \       0x40   0x11A0'24A3        LSRNE    R2,R3,#+9
   \       0x44   0xE3A0'3000        MOV      R3,#+0
   \       0x48   0xE090'4002        ADDS     R4,R0,R2
   \       0x4C   0xE0A1'5003        ADC      R5,R1,R3
    180          
    181          	/* Wait for deadline to be reached */
    182          	while ((int64_t)(_timer_get_tick() - deadline) < 0);
   \                     ??usleep_0:
   \       0x50   0x....'....        BL       _timer_get_tick
   \       0x54   0xE050'0004        SUBS     R0,R0,R4
   \       0x58   0xE0C1'1005        SBC      R1,R1,R5
   \       0x5C   0xE351'0000        CMP      R1,#+0
   \       0x60   0xBAFF'FFFA        BLT      ??usleep_0
    183          
    184          	/* Re-enable interrupts */
    185          	arch_irq_enable();
   \       0x64   0xE10F'0000        mrs R0, cpsr
   \       0x68   0xE3C0'0080        BIC      R0,R0,#0x80
   \       0x6C   0xE121'F000        msr cpsr_c, R0
    186          }
   \       0x70   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     _timer

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x8312'6E98        DC32     0x83126e98

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _timer_get_tick
        16   -> tc_get_cv
        16   -> timer_update_upper_tick_counter
      24   msleep
        24   -> _timer_get_tick
        24 __aeabi_uldivmod
       0   sleep
         0   -> timer_sleep
      24   timer_configure
        24   -> get_tc_id_from_addr
        24   -> irq_add_handler
        24   -> irq_enable
        24   -> pmc_configure_peripheral
        24   -> pmc_is_peripheral_enabled
        24   -> tc_configure
        24   -> tc_enable_it
        24   -> tc_get_channel_freq
         0   -> tc_start
       0   timer_get_interval
       8   timer_get_tick
         8   -> _timer_get_tick
         0 __aeabi_uldivmod
       0   timer_irq_handler
         8   -> tc_get_status
      16   timer_reset_timeout
        16   -> _timer_get_tick
        16 __aeabi_uldivmod
      24   timer_sleep
        24   -> _timer_get_tick
        24 __aeabi_uldivmod
      24   timer_start_timeout
        24   -> _timer_get_tick
        24 __aeabi_uldivmod
      16   timer_timeout_reached
        16   -> _timer_get_tick
        16   -> timer_get_interval
        16 __aeabi_uldivmod
       0   timer_update_upper_tick_counter
         8   -> tc_get_status
      16   usleep
        16   -> _timer_get_tick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
      40  ?Subroutine0
      60  ?Subroutine1
      16  _timer
      60  _timer_get_tick
      52  msleep
      16  sleep
     156  timer_configure
      60  timer_get_interval
      48  timer_get_tick
       4  timer_irq_handler
      56  timer_reset_timeout
      56  timer_sleep
      68  timer_start_timeout
     104  timer_timeout_reached
       4  timer_update_upper_tick_counter
     116  usleep

 
  16 bytes in section .bss
 908 bytes in section SOFTPACK
 
 908 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
