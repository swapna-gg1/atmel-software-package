###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         15/Jan/2021  07:27:12
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\lcd_draw.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EW4FA9.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\lcd_draw.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_LCD -D CONFIG_HAVE_LCDC -D CONFIG_HAVE_LCDC_OVR1 -D
#        CONFIG_HAVE_LCDC_OVR2 -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_DDR2_W972GG6KB -D CONFIG_HAVE_RSTC_EXTERNAL_RESET -D
#        CONFIG_HAVE_RSTC_INDEPENDENT_RESET -D CONFIG_HAVE_RTT -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\List\lcd_draw.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\build\sam9x60-ek\ddram\Obj\lcd_draw.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\lcd\lcd_draw.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup lcd_draw
     31           *
     32           * Implementation of draw function on LCD, Include draw text, image
     33           * and basic shapes (line, rectangle, circle).
     34           *
     35           */
     36          
     37          /** \file */
     38          
     39          /*----------------------------------------------------------------------------
     40           *        Headers
     41           *----------------------------------------------------------------------------*/
     42          
     43          #include "board.h"
     44          #include "compiler.h"
     45          
     46          #include "display/lcdc.h"
     47          
     48          #include "lcd_draw.h"
     49          #include "lcd_font.h"
     50          #include "font.h"
     51          
     52          #include <string.h>
     53          #include <stdlib.h>
     54          #include <assert.h>
     55          
     56          /*----------------------------------------------------------------------------
     57           *        Local variable
     58           *----------------------------------------------------------------------------*/
     59          
     60          /** Front color cache */

   \                                 In section .bss, align 4
     61          static uint32_t front_color;
   \                     front_color:
   \        0x0                      DS8 4
     62          
     63          /*----------------------------------------------------------------------------
     64           *        Local functions
     65           *----------------------------------------------------------------------------*/
     66          
     67          /**
     68           * Hide canvas layer
     69           */
     70          static void _hide_canvas(void)
     71          {
     72          	//lcdc_enable_layer(lcdc_get_canvas()->layer_id, false);
     73          }
     74          
     75          /**
     76           * Update canvas
     77           */
     78          static void _show_canvas(void)
     79          {
     80          	//lcdc_enable_layer(lcdc_get_canvas()->layer_id, true);
     81          }
     82          
     83          /**
     84           * Set front color
     85           * \param color Pixel color.
     86           */
     87          static void _set_front_color(uint32_t color)
     88          {
     89          	front_color = color;
     90          }
     91          
     92          /**
     93           * \brief Draw a pixel on LCD of front color.
     94           *
     95           * \param dwX       X-coordinate of pixel.
     96           * \param dwY       Y-coordinate of pixel.
     97           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     98          static void _draw_pixel(uint32_t dwX, uint32_t dwY)
     99          {
   \                     _draw_pixel:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    100          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \        0xC   0x....'....        BL       lcdc_get_canvas
    101          	uint8_t *buffer = pDisp->buffer;
   \       0x10   0xE590'2000        LDR      R2,[R0, #+0]
    102          	uint16_t w = pDisp->width;
    103          	//uint16_t h = pDisp->height;
    104          	uint16_t cw = pDisp->bpp / 8;	/* color width */
   \       0x14   0xE5D0'3008        LDRB     R3,[R0, #+8]
    105          	uint32_t rw = w * cw;	/* row width in bytes */
   \       0x18   0xE1D0'00B4        LDRH     R0,[R0, #+4]
    106          	//uint8_t  r, g, b;
    107          	uint8_t *pPix;
    108          
    109          	if (buffer == NULL)
   \       0x1C   0xE352'0000        CMP      R2,#+0
   \       0x20   0xE1A0'11A3        LSR      R1,R3,#+3
   \       0x24   0xE000'0091        MUL      R0,R1,R0
   \       0x28   0x0A00'0029        BEQ      ??_draw_pixel_0
    110          		return;
    111          
    112          	if (rw & 0x3)
   \       0x2C   0xE310'0003        TST      R0,#0x3
    113          		rw = (rw | 0x3) + 1;	/* 4-byte aligned rows */
   \       0x30   0x1380'0003        ORRNE    R0,R0,#0x3
    114          	pPix = &buffer[dwY * rw + cw * dwX];
   \       0x34   0xE001'0194        MUL      R1,R4,R1
   \       0x38   0x1280'0001        ADDNE    R0,R0,#+1
   \       0x3C   0xE021'1590        MLA      R1,R0,R5,R1
    115          
    116          	switch (pDisp->bpp) {
   \       0x40   0xE353'0010        CMP      R3,#+16
   \       0x44   0xE082'0001        ADD      R0,R2,R1
   \       0x48   0x0A00'0004        BEQ      ??_draw_pixel_1
   \       0x4C   0xE353'0018        CMP      R3,#+24
   \       0x50   0x0A00'0009        BEQ      ??_draw_pixel_2
   \       0x54   0xE353'0020        CMP      R3,#+32
   \       0x58   0x0A00'0011        BEQ      ??_draw_pixel_3
   \       0x5C   0xE8BD'8031        POP      {R0,R4,R5,PC}
    117          	case 16:		/* TRGB 1555 */
    118          		pPix[0] = (front_color) & 0xFF;
   \                     ??_draw_pixel_1:
   \       0x60   0x....'....        LDR      R1,??DataTable13
   \       0x64   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x68   0xE5C0'2000        STRB     R2,[R0, #+0]
    119          		pPix[1] = (front_color >> 8) & 0xFF;
   \       0x6C   0xE591'1000        LDR      R1,[R1, #+0]
   \       0x70   0xE1A0'3421        LSR      R3,R1,#+8
   \       0x74   0xE5C0'3001        STRB     R3,[R0, #+1]
    120          		break;
   \       0x78   0xE8BD'8031        POP      {R0,R4,R5,PC}
    121          	case 24:		/*  RGB  888 */
    122          		pPix[0] = (front_color) & 0xFF;
   \                     ??_draw_pixel_2:
   \       0x7C   0x....'....        LDR      R1,??DataTable13
   \       0x80   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x84   0xE5C0'2000        STRB     R2,[R0, #+0]
    123          		pPix[1] = (front_color >> 8) & 0xFF;
   \       0x88   0xE591'3000        LDR      R3,[R1, #+0]
   \       0x8C   0xE1A0'C423        LSR      R12,R3,#+8
   \       0x90   0xE5C0'C001        STRB     R12,[R0, #+1]
    124          		pPix[2] = (front_color >> 16) & 0xFF;
   \       0x94   0xE591'1000        LDR      R1,[R1, #+0]
   \       0x98   0xE1A0'2821        LSR      R2,R1,#+16
   \       0x9C   0xE5C0'2002        STRB     R2,[R0, #+2]
    125          		break;
   \       0xA0   0xE8BD'8031        POP      {R0,R4,R5,PC}
    126          	case 32:		/* ARGB 8888 */
    127          		pPix[0] = (front_color) & 0xFF;
   \                     ??_draw_pixel_3:
   \       0xA4   0x....'....        LDR      R1,??DataTable13
   \       0xA8   0xE591'2000        LDR      R2,[R1, #+0]
   \       0xAC   0xE5C0'2000        STRB     R2,[R0, #+0]
    128          		pPix[1] = (front_color >> 8) & 0xFF;
   \       0xB0   0xE591'3000        LDR      R3,[R1, #+0]
   \       0xB4   0xE1A0'C423        LSR      R12,R3,#+8
   \       0xB8   0xE5C0'C001        STRB     R12,[R0, #+1]
    129          		pPix[2] = (front_color >> 16) & 0xFF;
   \       0xBC   0xE591'2000        LDR      R2,[R1, #+0]
   \       0xC0   0xE1A0'3822        LSR      R3,R2,#+16
   \       0xC4   0xE5C0'3002        STRB     R3,[R0, #+2]
    130          		pPix[3] = (front_color >> 24) & 0xFF;
   \       0xC8   0xE591'1000        LDR      R1,[R1, #+0]
   \       0xCC   0xE1A0'2C21        LSR      R2,R1,#+24
   \       0xD0   0xE5C0'2003        STRB     R2,[R0, #+3]
    131          		break;
    132          	}
    133          }
   \                     ??_draw_pixel_0:
   \       0xD4   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    134          
    135          /**
    136           * \brief Fill rectangle with front color.
    137           * \param dwX1  X-coordinate of top left.
    138           * \param dwY1  Y-coordinate of top left.
    139           * \param dwX2  X-coordinate of bottom right.
    140           * \param dwY1  Y-coordinate of bottom right.
    141           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    142          static void _fill_rect(uint32_t dwX1, uint32_t dwY1, uint32_t dwX2, uint32_t dwY2)
    143          {
   \                     _fill_rect:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1A0'9000        MOV      R9,R0
   \        0x8   0xE1A0'4001        MOV      R4,R1
   \        0xC   0xE1A0'7002        MOV      R7,R2
   \       0x10   0xE1A0'6003        MOV      R6,R3
    144          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \       0x14   0x....'....        BL       lcdc_get_canvas
    145          	uint16_t w = pDisp->width;
    146          	uint16_t cw = pDisp->bpp / 8;	/* color width */
   \       0x18   0xE5D0'1008        LDRB     R1,[R0, #+8]
    147          	uint32_t rw = w * cw;	/* row width in bytes */
   \       0x1C   0xE1D0'20B4        LDRH     R2,[R0, #+4]
   \       0x20   0xE1A0'81A1        LSR      R8,R1,#+3
    148          	uint8_t *base;
    149          	uint8_t *buffer = pDisp->buffer;
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE005'0298        MUL      R5,R8,R2
    150          	uint32_t fillStart, fillEnd;
    151          	uint32_t i;
    152          	if (buffer == NULL)
   \       0x2C   0xE351'0000        CMP      R1,#+0
   \       0x30   0x0A00'0019        BEQ      ??_fill_rect_0
    153          		return;
    154          
    155          	/* 4-byte aligned rows */
    156          	if (rw & 0x3)
   \       0x34   0xE315'0003        TST      R5,#0x3
    157          		rw = (rw | 0x3) + 1;
   \       0x38   0x1385'0003        ORRNE    R0,R5,#0x3
   \       0x3C   0x1280'5001        ADDNE    R5,R0,#+1
    158          	/* Buffer address for the starting row */
    159          	base = &buffer[dwY1 * rw];
    160          
    161          	fillStart = dwX1 * cw;
    162          	fillEnd = dwX2 * cw;
    163          
    164          #if 1				/* Memcopy pixel */
    165          	buffer = base;
   \       0x40   0xE002'0495        MUL      R2,R5,R4
   \       0x44   0xE00A'0798        MUL      R10,R8,R7
   \       0x48   0xE000'0998        MUL      R0,R8,R9
   \       0x4C   0xE081'7002        ADD      R7,R1,R2
   \       0x50   0xE156'0004        CMP      R6,R4
   \       0x54   0x3A00'0010        BCC      ??_fill_rect_0
   \       0x58   0xE58D'6000        STR      R6,[SP, #+0]
   \       0x5C   0x....'....        LDR      R9,??DataTable13
   \       0x60   0xE1A0'6000        MOV      R6,R0
    166          	for (; dwY1 <= dwY2; dwY1++) {
    167          		for (i = fillStart; i <= fillEnd; i += cw) {
   \                     ??_fill_rect_1:
   \       0x64   0xE1A0'B006        MOV      R11,R6
   \       0x68   0xEA00'0004        B        ??_fill_rect_2
    168          			memcpy(&buffer[i], &front_color, cw);
   \                     ??_fill_rect_3:
   \       0x6C   0xE1A0'2008        MOV      R2,R8
   \       0x70   0xE1A0'1009        MOV      R1,R9
   \       0x74   0xE087'000B        ADD      R0,R7,R11
   \       0x78   0x....'....        BL       __aeabi_memcpy
    169          		}
   \       0x7C   0xE088'B00B        ADD      R11,R8,R11
   \                     ??_fill_rect_2:
   \       0x80   0xE15A'000B        CMP      R10,R11
   \       0x84   0x2AFF'FFF8        BCS      ??_fill_rect_3
    170          		buffer = &buffer[rw];
    171          	}
   \       0x88   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x8C   0xE284'4001        ADD      R4,R4,#+1
   \       0x90   0xE087'7005        ADD      R7,R7,R5
   \       0x94   0xE151'0004        CMP      R1,R4
   \       0x98   0x2AFF'FFF1        BCS      ??_fill_rect_1
    172          #endif
    173          
    174          #if 0				/* Pixel by pixel */
    175          	for (; dwY1 <= dwY2; dwY1++) {
    176          		for (i = dwX1; i <= dwX2; i++) {
    177          			_draw_pixel(i, dwY1);
    178          		}
    179          	}
    180          #endif
    181          
    182          #if 0				/* Optimized */
    183          	/* First row */
    184          	for (i = fillStart; i <= fillEnd; i += cw) {
    185          		memcpy(&base[i], &front_color, cw);
    186          	}
    187          	/* Next rows, copy first */
    188          	buffer = &base[rw + fillStart];
    189          	for (i = dwY1 + 1; i <= dwY2; i++) {
    190          		memcpy(buffer, &base[fillStart], fillEnd - fillStart + cw);
    191          		buffer = &buffer[rw];
    192          	}
    193          #endif
    194          }
   \                     ??_fill_rect_0:
   \       0x9C   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    195          
    196          /**
    197           * \brief Draw a line on LCD, which is not horizontal or vertical.
    198           *
    199           * \param dwX1       X-coordinate of line start.
    200           * \param dwY1       Y-coordinate of line start.
    201           * \param dwX2       X-coordinate of line end.
    202           * \param dwY2       Y-coordinate of line end.
    203           */
    204          
    205          /*
    206          static uint32_t _draw_line_bresenham (uint32_t dwX1, uint32_t dwY1, uint32_t dwX2, uint32_t dwY2)
    207          {
    208          	int dx, dy;
    209          	int i;
    210          	int xinc, yinc, cumul;
    211          	int x, y;
    212          
    213          	x = dwX1;
    214          	y = dwY1;
    215          	dx = dwX2 - dwX1;
    216          	dy = dwY2 - dwY1;
    217          
    218          	xinc = (dx > 0) ? 1 : -1;
    219          	yinc = (dy > 0) ? 1 : -1;
    220          	dx = (dx > 0) ? dx : -dx;
    221          	dy = (dy > 0) ? dy : -dy;
    222          
    223          	_draw_pixel(x, y);
    224          
    225          	if (dx > dy) {
    226          		cumul = dx / 2;
    227          		for (i = 1; i <= dx; i++) {
    228          			x += xinc;
    229          			cumul += dy;
    230          
    231          			if (cumul >= dx) {
    232          				cumul -= dx;
    233          				y += yinc;
    234          			}
    235          			_draw_pixel(x, y);
    236          		}
    237          	} else {
    238          		cumul = dy / 2;
    239          		for (i = 1; i <= dy; i++) {
    240          			y += yinc;
    241          			cumul += dx;
    242          
    243          			if (cumul >= dy) {
    244          				cumul -= dy;
    245          				x += xinc;
    246          			}
    247          
    248          			_draw_pixel(x, y);
    249          		}
    250          	}
    251          
    252          	return 0;
    253          }
    254          */
    255          
    256          static uint32_t _draw_line_bresenham (uint32_t dwX1, uint32_t dwY1, uint32_t dwX2, uint32_t dwY2)
    257          {
    258              int dx = abs(dwX2 - dwX1);
    259              int dy = abs(dwY2 - dwY1);
    260              int sx = (dwX1 < dwX2) ? 1 : -1;
    261              int sy = (dwY1 < dwY2) ? 1 : -1;
    262              int err = dx - dy;
    263              int e2 ;
    264          
    265              while (1) {
    266                _draw_pixel(dwX1, dwY1);
    267                if ((dwX1 == dwX2) && (dwY1 == dwY2))
    268                  break;
    269                e2 = 2 * err;
    270          	  if (e2 > -dy) {
    271          		  err -= dy; dwX1 += sx;
    272          	  }
    273                if (e2 < dx) {
    274          		  err += dx; dwY1 += sy;
    275          	  }
    276              }
    277          	return 0;
    278          }
    279          
    280          /*----------------------------------------------------------------------------
    281           *        Exported functions
    282           *----------------------------------------------------------------------------*/
    283          
    284          /**
    285           * \brief Fills the given LCD buffer with a particular color.
    286           *
    287           * \param color  Fill color.
    288           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    289          void lcd_fill(uint32_t color)
    290          {
   \                     lcd_fill:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    291          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \        0x8   0x....'....        BL       lcdc_get_canvas
    292          	_set_front_color(color);
   \        0xC   0x....'....        LDR      R1,??DataTable13
   \       0x10   0xE581'4000        STR      R4,[R1, #+0]
    293          	_hide_canvas();
    294          	_fill_rect(0, 0, pDisp->width, pDisp->height);
   \       0x14   0xE1D0'30B6        LDRH     R3,[R0, #+6]
   \       0x18   0xE1D0'20B4        LDRH     R2,[R0, #+4]
   \       0x1C   0xE8BD'4010        POP      {R4,LR}
   \       0x20   0x....'....        B        ?Subroutine0
    295          	_show_canvas();
    296          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE3A0'1000        MOV      R1,#+0
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        B        _fill_rect       ;; tailcall
    297          

   \                                 In section SOFTPACK, align 4, keep-with-next
    298          void lcd_fill_white(void)
    299          {
   \                     lcd_fill_white:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    300          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \        0x4   0x....'....        BL       lcdc_get_canvas
    301          	_hide_canvas();
    302          	_set_front_color(0x0000FF);
    303          	_fill_rect(0, 0, pDisp->width / 3, pDisp->height);
   \        0x8   0xE3A0'10AB        MOV      R1,#+171
   \        0xC   0xE381'1CAA        ORR      R1,R1,#0xAA00
   \       0x10   0xE1A0'4000        MOV      R4,R0
   \       0x14   0x....'....        LDR      R5,??DataTable13
   \       0x18   0xE3A0'00FF        MOV      R0,#+255
   \       0x1C   0xE585'0000        STR      R0,[R5, #+0]
   \       0x20   0xE1D4'00B4        LDRH     R0,[R4, #+4]
   \       0x24   0xE1D4'30B6        LDRH     R3,[R4, #+6]
   \       0x28   0xE001'0190        MUL      R1,R0,R1
   \       0x2C   0xE1A0'28A1        LSR      R2,R1,#+17
   \       0x30   0xE3A0'1000        MOV      R1,#+0
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0x....'....        BL       _fill_rect
    304          	_set_front_color(0xFFFFFF);
   \       0x3C   0xE3E0'04FF        MVN      R0,#-16777216
   \       0x40   0xE585'0000        STR      R0,[R5, #+0]
    305          	_fill_rect(pDisp->width/3, 0, pDisp->width/3+pDisp->width/3, pDisp->height);
   \       0x44   0xE1D4'10B4        LDRH     R1,[R4, #+4]
   \       0x48   0xE3A0'20AB        MOV      R2,#+171
   \       0x4C   0xE382'2CAA        ORR      R2,R2,#0xAA00
   \       0x50   0xE002'0291        MUL      R2,R1,R2
   \       0x54   0xE1D4'30B6        LDRH     R3,[R4, #+6]
   \       0x58   0xE1A0'08A2        LSR      R0,R2,#+17
   \       0x5C   0xE1A0'2080        LSL      R2,R0,#+1
   \       0x60   0xE3A0'1000        MOV      R1,#+0
   \       0x64   0x....'....        BL       _fill_rect
    306          	_set_front_color(0xFF0000);
   \       0x68   0xE3A0'08FF        MOV      R0,#+16711680
   \       0x6C   0xE585'0000        STR      R0,[R5, #+0]
    307          	_fill_rect(pDisp->width/3+pDisp->width/3, 0, pDisp->width-1, pDisp->height);
   \       0x70   0xE3A0'C0AB        MOV      R12,#+171
   \       0x74   0xE1D4'00B4        LDRH     R0,[R4, #+4]
   \       0x78   0xE1D4'30B6        LDRH     R3,[R4, #+6]
   \       0x7C   0xE38C'CCAA        ORR      R12,R12,#0xAA00
   \       0x80   0xE00C'0C90        MUL      R12,R0,R12
   \       0x84   0xE28D'D004        ADD      SP,SP,#+4
   \       0x88   0xE8BD'4030        POP      {R4,R5,LR}
   \       0x8C   0xE240'2001        SUB      R2,R0,#+1
   \       0x90   0xE1A0'08AC        LSR      R0,R12,#+17
   \       0x94   0xE3A0'1000        MOV      R1,#+0
   \       0x98   0xE1A0'0080        LSL      R0,R0,#+1
   \       0x9C   0x....'....        B        _fill_rect       ;; tailcall
    308          	_show_canvas();
    309          }
    310          

   \                                 In section SOFTPACK, align 4, keep-with-next
    311          void lcd_fill_yuv422(void)
    312          {
   \                     lcd_fill_yuv422:
   \        0x0   0xE92D'4FF0        PUSH     {R4-R11,LR}
   \        0x4   0xE24D'D00C        SUB      SP,SP,#+12
    313          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \        0x8   0x....'....        BL       lcdc_get_canvas
    314          	uint8_t *buffur = pDisp->buffer;
   \        0xC   0xE590'4000        LDR      R4,[R0, #+0]
    315          	uint32_t i;
    316          	uint32_t h = pDisp->width;
   \       0x10   0xE1D0'50B4        LDRH     R5,[R0, #+4]
    317          	uint32_t v = pDisp->height;
   \       0x14   0xE1D0'00B6        LDRH     R0,[R0, #+6]
    318          	for(i=0;i<h*v*2/8;) {
   \       0x18   0xE3A0'9000        MOV      R9,#+0
   \       0x1C   0xE3A0'70A5        MOV      R7,#+165
   \       0x20   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x24   0xE3A0'80EF        MOV      R8,#+239
   \       0x28   0xE3A0'6051        MOV      R6,#+81
   \       0x2C   0xEA00'0007        B        ??lcd_fill_yuv422_0
    319          		if(((i/h)%2)==0) {
    320          			buffur[i++]=81; buffur[i++]=239;buffur[i++]=81;buffur[i++]=90;
   \                     ??lcd_fill_yuv422_1:
   \       0x30   0xE7C4'6009        STRB     R6,[R4, +R9]
   \       0x34   0xE7C4'800A        STRB     R8,[R4, +R10]
   \       0x38   0xE28A'0001        ADD      R0,R10,#+1
   \       0x3C   0xE7C4'6000        STRB     R6,[R4, +R0]
   \       0x40   0xE280'0001        ADD      R0,R0,#+1
   \       0x44   0xE3A0'105A        MOV      R1,#+90
   \                     ??lcd_fill_yuv422_2:
   \       0x48   0xE7C4'1000        STRB     R1,[R4, +R0]
   \       0x4C   0xE280'9001        ADD      R9,R0,#+1
    321          		} else {
   \                     ??lcd_fill_yuv422_0:
   \       0x50   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x54   0xE002'0591        MUL      R2,R1,R5
   \       0x58   0xE1A0'3082        LSL      R3,R2,#+1
   \       0x5C   0xE159'01A3        CMP      R9,R3, LSR #+3
   \       0x60   0x2A00'000D        BCS      ??lcd_fill_yuv422_3
   \       0x64   0xE1A0'0009        MOV      R0,R9
   \       0x68   0xE1A0'1005        MOV      R1,R5
   \       0x6C   0x....'....        BL       __aeabi_uidiv
   \       0x70   0xE289'A001        ADD      R10,R9,#+1
   \       0x74   0xE310'0001        TST      R0,#0x1
   \       0x78   0x0AFF'FFEC        BEQ      ??lcd_fill_yuv422_1
    322          			buffur[i++]=165;buffur[i++]=180;buffur[i++]=165;buffur[i++]=42;
   \       0x7C   0xE7C4'7009        STRB     R7,[R4, +R9]
   \       0x80   0xE3A0'00B4        MOV      R0,#+180
   \       0x84   0xE7C4'000A        STRB     R0,[R4, +R10]
   \       0x88   0xE28A'0001        ADD      R0,R10,#+1
   \       0x8C   0xE7C4'7000        STRB     R7,[R4, +R0]
   \       0x90   0xE280'0001        ADD      R0,R0,#+1
   \       0x94   0xE3A0'102A        MOV      R1,#+42
   \       0x98   0xEAFF'FFEA        B        ??lcd_fill_yuv422_2
    323          		}
    324          	}
    325          	for(i=h*v*2/8;i<h*v*2/8*2;) {
   \                     ??lcd_fill_yuv422_3:
   \       0x9C   0xE58D'5000        STR      R5,[SP, #+0]
   \       0xA0   0xE1A0'71A3        LSR      R7,R3,#+3
   \       0xA4   0xE3A0'8086        MOV      R8,#+134
   \       0xA8   0xE3A0'907F        MOV      R9,#+127
   \       0xAC   0xE3A0'A0CA        MOV      R10,#+202
   \       0xB0   0xE59D'5004        LDR      R5,[SP, #+4]
   \       0xB4   0xEA00'0009        B        ??lcd_fill_yuv422_4
    326          		if(((i/h)%2)==0) {
    327          			buffur[i++]=107; buffur[i++]=202;buffur[i++]=107;buffur[i++]=222;
   \                     ??lcd_fill_yuv422_5:
   \       0xB8   0xE3A0'006B        MOV      R0,#+107
   \       0xBC   0xE7C4'0007        STRB     R0,[R4, +R7]
   \       0xC0   0xE7C4'A00B        STRB     R10,[R4, +R11]
   \       0xC4   0xE28B'0001        ADD      R0,R11,#+1
   \       0xC8   0xE3A0'106B        MOV      R1,#+107
   \       0xCC   0xE7C4'1000        STRB     R1,[R4, +R0]
   \       0xD0   0xE280'0001        ADD      R0,R0,#+1
   \       0xD4   0xE3A0'20DE        MOV      R2,#+222
   \       0xD8   0xE7C4'2000        STRB     R2,[R4, +R0]
   \                     ??lcd_fill_yuv422_6:
   \       0xDC   0xE280'7001        ADD      R7,R0,#+1
    328          		} else {
   \                     ??lcd_fill_yuv422_4:
   \       0xE0   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xE4   0xE001'0195        MUL      R1,R5,R1
   \       0xE8   0xE1A0'2081        LSL      R2,R1,#+1
   \       0xEC   0xE1A0'01A2        LSR      R0,R2,#+3
   \       0xF0   0xE157'0080        CMP      R7,R0, LSL #+1
   \       0xF4   0x2A00'000D        BCS      ??lcd_fill_yuv422_7
   \       0xF8   0xE1A0'0007        MOV      R0,R7
   \       0xFC   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x100   0x....'....        BL       __aeabi_uidiv
   \      0x104   0xE287'B001        ADD      R11,R7,#+1
   \      0x108   0xE310'0001        TST      R0,#0x1
   \      0x10C   0x0AFF'FFE9        BEQ      ??lcd_fill_yuv422_5
    329          			buffur[i++]=127;buffur[i++]=134;buffur[i++]=127;buffur[i++]=102;
   \      0x110   0xE7C4'9007        STRB     R9,[R4, +R7]
   \      0x114   0xE7C4'800B        STRB     R8,[R4, +R11]
   \      0x118   0xE28B'0001        ADD      R0,R11,#+1
   \      0x11C   0xE7C4'9000        STRB     R9,[R4, +R0]
   \      0x120   0xE280'0001        ADD      R0,R0,#+1
   \      0x124   0xE3A0'1066        MOV      R1,#+102
   \      0x128   0xE7C4'1000        STRB     R1,[R4, +R0]
   \      0x12C   0xEAFF'FFEA        B        ??lcd_fill_yuv422_6
    330          		}
    331          	}
    332          	for(i=h*v*2/8*2;i<h*v*2/8*3;) {
   \                     ??lcd_fill_yuv422_7:
   \      0x130   0xE1A0'31A2        LSR      R3,R2,#+3
   \      0x134   0xE080'2080        ADD      R2,R0,R0, LSL #+1
   \      0x138   0xE58D'3004        STR      R3,[SP, #+4]
   \      0x13C   0xE1A0'A080        LSL      R10,R0,#+1
   \      0x140   0xE58D'2008        STR      R2,[SP, #+8]
   \      0x144   0xE3A0'7028        MOV      R7,#+40
   \      0x148   0xE3A0'80AA        MOV      R8,#+170
   \      0x14C   0xE3A0'90EF        MOV      R9,#+239
   \      0x150   0xEA00'0008        B        ??lcd_fill_yuv422_8
    333          		if(((i/h)%2)==0) {
    334          			buffur[i++]=170; buffur[i++]=16;buffur[i++]=170;buffur[i++]=166;
   \                     ??lcd_fill_yuv422_9:
   \      0x154   0xE7C4'800A        STRB     R8,[R4, +R10]
   \      0x158   0xE3A0'0010        MOV      R0,#+16
   \      0x15C   0xE7C4'000B        STRB     R0,[R4, +R11]
   \      0x160   0xE28B'0001        ADD      R0,R11,#+1
   \      0x164   0xE7C4'8000        STRB     R8,[R4, +R0]
   \      0x168   0xE280'0001        ADD      R0,R0,#+1
   \      0x16C   0xE3A0'10A6        MOV      R1,#+166
   \      0x170   0xE7C4'1000        STRB     R1,[R4, +R0]
   \                     ??lcd_fill_yuv422_10:
   \      0x174   0xE280'A001        ADD      R10,R0,#+1
    335          		} else {
   \                     ??lcd_fill_yuv422_8:
   \      0x178   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x17C   0xE15A'0001        CMP      R10,R1
   \      0x180   0x2A00'000D        BCS      ??lcd_fill_yuv422_11
   \      0x184   0xE1A0'000A        MOV      R0,R10
   \      0x188   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x18C   0x....'....        BL       __aeabi_uidiv
   \      0x190   0xE28A'B001        ADD      R11,R10,#+1
   \      0x194   0xE310'0001        TST      R0,#0x1
   \      0x198   0x0AFF'FFED        BEQ      ??lcd_fill_yuv422_9
    336          			buffur[i++]=40;buffur[i++]=109;buffur[i++]=40;buffur[i++]=239;
   \      0x19C   0xE7C4'700A        STRB     R7,[R4, +R10]
   \      0x1A0   0xE3A0'006D        MOV      R0,#+109
   \      0x1A4   0xE7C4'000B        STRB     R0,[R4, +R11]
   \      0x1A8   0xE28B'0001        ADD      R0,R11,#+1
   \      0x1AC   0xE7C4'7000        STRB     R7,[R4, +R0]
   \      0x1B0   0xE280'0001        ADD      R0,R0,#+1
   \      0x1B4   0xE7C4'9000        STRB     R9,[R4, +R0]
   \      0x1B8   0xEAFF'FFED        B        ??lcd_fill_yuv422_10
    337          		}
    338          	}
    339          	for(i=h*v*2/8*3;i<h*v*2/8*4;) {
   \                     ??lcd_fill_yuv422_11:
   \      0x1BC   0xE59D'2004        LDR      R2,[SP, #+4]
   \      0x1C0   0xE1A0'A001        MOV      R10,R1
   \      0x1C4   0xE1A0'0102        LSL      R0,R2,#+2
   \      0x1C8   0xE58D'0008        STR      R0,[SP, #+8]
   \      0x1CC   0xE3A0'8022        MOV      R8,#+34
   \      0x1D0   0xE3A0'9090        MOV      R9,#+144
   \      0x1D4   0xEA00'0007        B        ??lcd_fill_yuv422_12
    340          		if(((i/h)%2)==0) {
    341          			buffur[i++]=144;buffur[i++]=34;buffur[i++]=144;buffur[i++]=53;
   \                     ??lcd_fill_yuv422_13:
   \      0x1D8   0xE7C4'900A        STRB     R9,[R4, +R10]
   \      0x1DC   0xE7C4'800B        STRB     R8,[R4, +R11]
   \      0x1E0   0xE28B'0001        ADD      R0,R11,#+1
   \      0x1E4   0xE7C4'9000        STRB     R9,[R4, +R0]
   \      0x1E8   0xE280'0001        ADD      R0,R0,#+1
   \      0x1EC   0xE3A0'1035        MOV      R1,#+53
   \                     ??lcd_fill_yuv422_14:
   \      0x1F0   0xE7C4'1000        STRB     R1,[R4, +R0]
   \      0x1F4   0xE280'A001        ADD      R10,R0,#+1
    342          		} else {
   \                     ??lcd_fill_yuv422_12:
   \      0x1F8   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x1FC   0xE15A'0001        CMP      R10,R1
   \      0x200   0x2A00'000D        BCS      ??lcd_fill_yuv422_15
   \      0x204   0xE1A0'000A        MOV      R0,R10
   \      0x208   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x20C   0x....'....        BL       __aeabi_uidiv
   \      0x210   0xE28A'B001        ADD      R11,R10,#+1
   \      0x214   0xE310'0001        TST      R0,#0x1
   \      0x218   0x0AFF'FFEE        BEQ      ??lcd_fill_yuv422_13
    343          			buffur[i++]=81; buffur[i++]=239;buffur[i++]=81;buffur[i++]=90;
   \      0x21C   0xE7C4'600A        STRB     R6,[R4, +R10]
   \      0x220   0xE3A0'00EF        MOV      R0,#+239
   \      0x224   0xE7C4'000B        STRB     R0,[R4, +R11]
   \      0x228   0xE28B'0001        ADD      R0,R11,#+1
   \      0x22C   0xE7C4'6000        STRB     R6,[R4, +R0]
   \      0x230   0xE280'0001        ADD      R0,R0,#+1
   \      0x234   0xE3A0'105A        MOV      R1,#+90
   \      0x238   0xEAFF'FFEC        B        ??lcd_fill_yuv422_14
    344          		}
    345          	}
    346          	for(i=h*v*2/8*4;i<h*v*2/8*5;) {
   \                     ??lcd_fill_yuv422_15:
   \      0x23C   0xE1A0'A001        MOV      R10,R1
   \      0x240   0xE3A0'606D        MOV      R6,#+109
   \      0x244   0xE3A0'80DE        MOV      R8,#+222
   \      0x248   0xE3A0'906B        MOV      R9,#+107
   \      0x24C   0xEA00'0007        B        ??lcd_fill_yuv422_16
    347          		if(((i/h)%2)==0) {
    348          			buffur[i++]=40;buffur[i++]=109;buffur[i++]=40;buffur[i++]=239;
   \                     ??lcd_fill_yuv422_17:
   \      0x250   0xE7C4'700A        STRB     R7,[R4, +R10]
   \      0x254   0xE7C4'600B        STRB     R6,[R4, +R11]
   \      0x258   0xE28B'0001        ADD      R0,R11,#+1
   \      0x25C   0xE7C4'7000        STRB     R7,[R4, +R0]
   \      0x260   0xE280'0001        ADD      R0,R0,#+1
   \      0x264   0xE3A0'10EF        MOV      R1,#+239
   \      0x268   0xE7C4'1000        STRB     R1,[R4, +R0]
   \                     ??lcd_fill_yuv422_18:
   \      0x26C   0xE280'A001        ADD      R10,R0,#+1
    349          		} else {
   \                     ??lcd_fill_yuv422_16:
   \      0x270   0xE59D'1004        LDR      R1,[SP, #+4]
   \      0x274   0xE081'2101        ADD      R2,R1,R1, LSL #+2
   \      0x278   0xE15A'0002        CMP      R10,R2
   \      0x27C   0x2A00'000D        BCS      ??lcd_fill_yuv422_19
   \      0x280   0xE1A0'000A        MOV      R0,R10
   \      0x284   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x288   0x....'....        BL       __aeabi_uidiv
   \      0x28C   0xE28A'B001        ADD      R11,R10,#+1
   \      0x290   0xE310'0001        TST      R0,#0x1
   \      0x294   0x0AFF'FFED        BEQ      ??lcd_fill_yuv422_17
    350          			buffur[i++]=107; buffur[i++]=202;buffur[i++]=107;buffur[i++]=222;
   \      0x298   0xE7C4'900A        STRB     R9,[R4, +R10]
   \      0x29C   0xE3A0'00CA        MOV      R0,#+202
   \      0x2A0   0xE7C4'000B        STRB     R0,[R4, +R11]
   \      0x2A4   0xE28B'0001        ADD      R0,R11,#+1
   \      0x2A8   0xE7C4'9000        STRB     R9,[R4, +R0]
   \      0x2AC   0xE280'0001        ADD      R0,R0,#+1
   \      0x2B0   0xE7C4'8000        STRB     R8,[R4, +R0]
   \      0x2B4   0xEAFF'FFEC        B        ??lcd_fill_yuv422_18
    351          		}
    352          	}
    353          	for(i=h*v*2/8*5;i<h*v*2/8*6;) {
   \                     ??lcd_fill_yuv422_19:
   \      0x2B8   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x2BC   0xE3A0'7092        MOV      R7,#+146
   \      0x2C0   0xE001'0195        MUL      R1,R5,R1
   \      0x2C4   0xE3A0'80D3        MOV      R8,#+211
   \      0x2C8   0xE1A0'2081        LSL      R2,R1,#+1
   \      0x2CC   0xE1A0'61A2        LSR      R6,R2,#+3
   \      0x2D0   0xE086'B106        ADD      R11,R6,R6, LSL #+2
   \      0x2D4   0xE3A0'9086        MOV      R9,#+134
   \      0x2D8   0xE3A0'A07F        MOV      R10,#+127
   \      0x2DC   0xE58D'5004        STR      R5,[SP, #+4]
   \      0x2E0   0xEA00'0007        B        ??lcd_fill_yuv422_20
    354          		if(((i/h)%2)==0) {
    355          			buffur[i++]=211;buffur[i++]=146;buffur[i++]=211;buffur[i++]=15;
   \                     ??lcd_fill_yuv422_21:
   \      0x2E4   0xE7C4'800B        STRB     R8,[R4, +R11]
   \      0x2E8   0xE7C4'7005        STRB     R7,[R4, +R5]
   \      0x2EC   0xE285'0001        ADD      R0,R5,#+1
   \      0x2F0   0xE7C4'8000        STRB     R8,[R4, +R0]
   \      0x2F4   0xE280'0001        ADD      R0,R0,#+1
   \      0x2F8   0xE3A0'100F        MOV      R1,#+15
   \                     ??lcd_fill_yuv422_22:
   \      0x2FC   0xE7C4'1000        STRB     R1,[R4, +R0]
   \      0x300   0xE280'B001        ADD      R11,R0,#+1
    356          		} else {
   \                     ??lcd_fill_yuv422_20:
   \      0x304   0xE086'0086        ADD      R0,R6,R6, LSL #+1
   \      0x308   0xE15B'0080        CMP      R11,R0, LSL #+1
   \      0x30C   0x2A00'000C        BCS      ??lcd_fill_yuv422_23
   \      0x310   0xE1A0'000B        MOV      R0,R11
   \      0x314   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x318   0x....'....        BL       __aeabi_uidiv
   \      0x31C   0xE28B'5001        ADD      R5,R11,#+1
   \      0x320   0xE310'0001        TST      R0,#0x1
   \      0x324   0x0AFF'FFEE        BEQ      ??lcd_fill_yuv422_21
    357          			buffur[i++]=127;buffur[i++]=134;buffur[i++]=127;buffur[i++]=102;
   \      0x328   0xE7C4'A00B        STRB     R10,[R4, +R11]
   \      0x32C   0xE7C4'9005        STRB     R9,[R4, +R5]
   \      0x330   0xE285'0001        ADD      R0,R5,#+1
   \      0x334   0xE7C4'A000        STRB     R10,[R4, +R0]
   \      0x338   0xE280'0001        ADD      R0,R0,#+1
   \      0x33C   0xE3A0'1066        MOV      R1,#+102
   \      0x340   0xEAFF'FFED        B        ??lcd_fill_yuv422_22
    358          		}
    359          	}
    360          	for(i=h*v*2/8*6;i<h*v*2/8*7;) {
   \                     ??lcd_fill_yuv422_23:
   \      0x344   0xE3A0'7090        MOV      R7,#+144
   \      0x348   0xE3A0'802A        MOV      R8,#+42
   \      0x34C   0xE3A0'90B4        MOV      R9,#+180
   \      0x350   0xE3A0'A0A5        MOV      R10,#+165
   \      0x354   0xE1A0'6080        LSL      R6,R0,#+1
   \      0x358   0xE59D'5004        LDR      R5,[SP, #+4]
   \      0x35C   0xEA00'0006        B        ??lcd_fill_yuv422_24
    361          		if(((i/h)%2)==0) {
    362          			buffur[i++]=165;buffur[i++]=180;buffur[i++]=165;buffur[i++]=42;
   \                     ??lcd_fill_yuv422_25:
   \      0x360   0xE7C4'A006        STRB     R10,[R4, +R6]
   \      0x364   0xE7C4'900B        STRB     R9,[R4, +R11]
   \      0x368   0xE28B'0001        ADD      R0,R11,#+1
   \      0x36C   0xE7C4'A000        STRB     R10,[R4, +R0]
   \      0x370   0xE280'0001        ADD      R0,R0,#+1
   \      0x374   0xE7C4'8000        STRB     R8,[R4, +R0]
   \                     ??lcd_fill_yuv422_26:
   \      0x378   0xE280'6001        ADD      R6,R0,#+1
    363          		} else {
   \                     ??lcd_fill_yuv422_24:
   \      0x37C   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x380   0xE001'0195        MUL      R1,R5,R1
   \      0x384   0xE1A0'2081        LSL      R2,R1,#+1
   \      0x388   0xE1A0'01A2        LSR      R0,R2,#+3
   \      0x38C   0xE060'0180        RSB      R0,R0,R0, LSL #+3
   \      0x390   0xE156'0000        CMP      R6,R0
   \      0x394   0x2A00'000E        BCS      ??lcd_fill_yuv422_27
   \      0x398   0xE1A0'0006        MOV      R0,R6
   \      0x39C   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x3A0   0x....'....        BL       __aeabi_uidiv
   \      0x3A4   0xE286'B001        ADD      R11,R6,#+1
   \      0x3A8   0xE310'0001        TST      R0,#0x1
   \      0x3AC   0x0AFF'FFEB        BEQ      ??lcd_fill_yuv422_25
    364          			buffur[i++]=144;buffur[i++]=34;buffur[i++]=144;buffur[i++]=53;
   \      0x3B0   0xE7C4'7006        STRB     R7,[R4, +R6]
   \      0x3B4   0xE3A0'0022        MOV      R0,#+34
   \      0x3B8   0xE7C4'000B        STRB     R0,[R4, +R11]
   \      0x3BC   0xE28B'0001        ADD      R0,R11,#+1
   \      0x3C0   0xE7C4'7000        STRB     R7,[R4, +R0]
   \      0x3C4   0xE280'0001        ADD      R0,R0,#+1
   \      0x3C8   0xE3A0'1035        MOV      R1,#+53
   \      0x3CC   0xE7C4'1000        STRB     R1,[R4, +R0]
   \      0x3D0   0xEAFF'FFE8        B        ??lcd_fill_yuv422_26
    365          		}
    366          	}
   \                     ??lcd_fill_yuv422_27:
   \      0x3D4   0xE59D'1000        LDR      R1,[SP, #+0]
    367          	for(i=h*v*2/8*7;i<h*v*2/8*8;) {
   \      0x3D8   0xE1A0'A000        MOV      R10,R0
   \      0x3DC   0xE002'0195        MUL      R2,R5,R1
   \      0x3E0   0xE3A0'50A6        MOV      R5,#+166
   \      0x3E4   0xE1A0'0122        LSR      R0,R2,#+2
   \      0x3E8   0xE1A0'3180        LSL      R3,R0,#+3
   \      0x3EC   0xE58D'3004        STR      R3,[SP, #+4]
   \      0x3F0   0xE3A0'6010        MOV      R6,#+16
   \      0x3F4   0xE3A0'70AA        MOV      R7,#+170
   \      0x3F8   0xE3A0'8086        MOV      R8,#+134
   \      0x3FC   0xE3A0'907F        MOV      R9,#+127
   \      0x400   0xE58D'1000        STR      R1,[SP, #+0]
   \      0x404   0xEA00'0007        B        ??lcd_fill_yuv422_28
    368          		if(((i/h)%2)==0) {
    369          			buffur[i++]=127;buffur[i++]=134;buffur[i++]=127;buffur[i++]=102;
   \                     ??lcd_fill_yuv422_29:
   \      0x408   0xE7C4'900A        STRB     R9,[R4, +R10]
   \      0x40C   0xE7C4'800B        STRB     R8,[R4, +R11]
   \      0x410   0xE28B'0001        ADD      R0,R11,#+1
   \      0x414   0xE7C4'9000        STRB     R9,[R4, +R0]
   \      0x418   0xE280'0001        ADD      R0,R0,#+1
   \      0x41C   0xE3A0'1066        MOV      R1,#+102
   \      0x420   0xE7C4'1000        STRB     R1,[R4, +R0]
   \                     ??lcd_fill_yuv422_30:
   \      0x424   0xE280'A001        ADD      R10,R0,#+1
    370          		} else {
   \                     ??lcd_fill_yuv422_28:
   \      0x428   0xE59D'1004        LDR      R1,[SP, #+4]
   \      0x42C   0xE15A'0001        CMP      R10,R1
   \      0x430   0x2A00'000C        BCS      ??lcd_fill_yuv422_31
   \      0x434   0xE1A0'000A        MOV      R0,R10
   \      0x438   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x43C   0x....'....        BL       __aeabi_uidiv
   \      0x440   0xE28A'B001        ADD      R11,R10,#+1
   \      0x444   0xE310'0001        TST      R0,#0x1
   \      0x448   0x0AFF'FFEE        BEQ      ??lcd_fill_yuv422_29
    371          			buffur[i++]=170; buffur[i++]=16;buffur[i++]=170;buffur[i++]=166;
   \      0x44C   0xE7C4'700A        STRB     R7,[R4, +R10]
   \      0x450   0xE7C4'600B        STRB     R6,[R4, +R11]
   \      0x454   0xE28B'0001        ADD      R0,R11,#+1
   \      0x458   0xE7C4'7000        STRB     R7,[R4, +R0]
   \      0x45C   0xE280'0001        ADD      R0,R0,#+1
   \      0x460   0xE7C4'5000        STRB     R5,[R4, +R0]
   \      0x464   0xEAFF'FFEE        B        ??lcd_fill_yuv422_30
    372          		}
    373          	}
    374          }
   \                     ??lcd_fill_yuv422_31:
   \      0x468   0xE28D'D00C        ADD      SP,SP,#+12
   \      0x46C   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    375          
    376          /**
    377           * \brief Draw a pixel on LCD of given color.
    378           *
    379           * \param x  X-coordinate of pixel.
    380           * \param y  Y-coordinate of pixel.
    381           * \param color  Pixel color.
    382           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    383          void lcd_draw_pixel(uint32_t x, uint32_t y, uint32_t color)
    384          {
    385          	_set_front_color(color);
   \                     lcd_draw_pixel:
   \        0x0   0x....'....        LDR      R3,??DataTable15
   \        0x4   0xE583'2000        STR      R2,[R3, #+0]
    386          	_hide_canvas();
    387          	_draw_pixel(x, y);
   \        0x8   0x....'....        B        _draw_pixel      ;; tailcall
    388          	_show_canvas();
    389          }
    390          
    391          /**
    392           * \brief Read a pixel from LCD.
    393           *
    394           * \param x  X-coordinate of pixel.
    395           * \param y  Y-coordinate of pixel.
    396           *
    397           * \return color  Readed pixel color.
    398           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    399          extern uint32_t lcd_read_pixel(uint32_t x, uint32_t y)
    400          {
   \                     lcd_read_pixel:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    401          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \        0xC   0x....'....        BL       lcdc_get_canvas
    402          	uint8_t *buffer = pDisp->buffer;
   \       0x10   0xE590'3000        LDR      R3,[R0, #+0]
    403          	uint16_t w = pDisp->width;
    404          	//uint16_t h = pDisp->height;
    405          	uint16_t cw = pDisp->bpp / 8;	/* color width */
   \       0x14   0xE5D0'2008        LDRB     R2,[R0, #+8]
    406          	uint32_t rw = w * cw;	/* row width in bytes */
   \       0x18   0xE1D0'00B4        LDRH     R0,[R0, #+4]
    407          	uint8_t *pPix;
    408          	uint32_t color = 0;
    409          
    410          	if (buffer == NULL)
   \       0x1C   0xE353'0000        CMP      R3,#+0
   \       0x20   0xE1A0'11A2        LSR      R1,R2,#+3
   \       0x24   0xE00C'0091        MUL      R12,R1,R0
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0x0A00'001D        BEQ      ??lcd_read_pixel_0
    411          		return 0;
    412          
    413          	if (rw & 0x3)
   \       0x30   0xE31C'0003        TST      R12,#0x3
    414          		rw = (rw | 0x3) + 1;	/* 4-byte aligned rows */
   \       0x34   0x138C'C003        ORRNE    R12,R12,#0x3
    415          	pPix = &buffer[x * rw + cw * y];
   \       0x38   0xE001'0195        MUL      R1,R5,R1
   \       0x3C   0x128C'C001        ADDNE    R12,R12,#+1
   \       0x40   0xE021'149C        MLA      R1,R12,R4,R1
    416          
    417          	switch (pDisp->bpp) {
   \       0x44   0xE352'0010        CMP      R2,#+16
   \       0x48   0xE083'1001        ADD      R1,R3,R1
   \       0x4C   0x0A00'0004        BEQ      ??lcd_read_pixel_1
   \       0x50   0xE352'0018        CMP      R2,#+24
   \       0x54   0x0A00'0006        BEQ      ??lcd_read_pixel_2
   \       0x58   0xE352'0020        CMP      R2,#+32
   \       0x5C   0x0A00'000A        BEQ      ??lcd_read_pixel_3
   \       0x60   0xE8BD'8032        POP      {R1,R4,R5,PC}
    418          	case 16:		/* TRGB 1555 */
    419          		color = pPix[0] | (pPix[1] << 8);
   \                     ??lcd_read_pixel_1:
   \       0x64   0xE5D1'0000        LDRB     R0,[R1, #+0]
   \       0x68   0xE5D1'1001        LDRB     R1,[R1, #+1]
   \       0x6C   0xE180'0401        ORR      R0,R0,R1, LSL #+8
    420          		break;
   \       0x70   0xE8BD'8032        POP      {R1,R4,R5,PC}
    421          	case 24:		/*  RGB  888 */
    422          		color = pPix[0] | (pPix[1] << 8) | (pPix[2] << 16);
   \                     ??lcd_read_pixel_2:
   \       0x74   0xE5D1'0000        LDRB     R0,[R1, #+0]
   \       0x78   0xE5D1'2001        LDRB     R2,[R1, #+1]
   \       0x7C   0xE180'3402        ORR      R3,R0,R2, LSL #+8
   \       0x80   0xE5D1'0002        LDRB     R0,[R1, #+2]
   \       0x84   0xE183'0800        ORR      R0,R3,R0, LSL #+16
    423          		break;
   \       0x88   0xE8BD'8032        POP      {R1,R4,R5,PC}
    424          	case 32:		/* ARGB 8888 */
    425          		color =
    426          			pPix[0] | (pPix[1] << 8) | (pPix[2] << 16) | (pPix[3] <<
    427          								      24);
   \                     ??lcd_read_pixel_3:
   \       0x8C   0xE5D1'2000        LDRB     R2,[R1, #+0]
   \       0x90   0xE5D1'0001        LDRB     R0,[R1, #+1]
   \       0x94   0xE182'3400        ORR      R3,R2,R0, LSL #+8
   \       0x98   0xE5D1'2002        LDRB     R2,[R1, #+2]
   \       0x9C   0xE5D1'1003        LDRB     R1,[R1, #+3]
   \       0xA0   0xE183'0802        ORR      R0,R3,R2, LSL #+16
   \       0xA4   0xE180'0C01        ORR      R0,R0,R1, LSL #+24
    428          		break;
    429          	}
    430          	return color;
   \                     ??lcd_read_pixel_0:
   \       0xA8   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    431          }
    432          
    433          /**
    434           * \brief Draw a line on LCD, horizontal and vertical line are supported.
    435           *
    436           * \param x1        X-coordinate of line start.
    437           * \param y1        Y-coordinate of line start.
    438           * \param x2        X-coordinate of line end.
    439           * \param y2        Y-coordinate of line end.
    440           * \param color     Pixel color.
    441           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    442          void lcd_draw_line(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2,
    443          		    uint32_t color)
    444          {
   \                     lcd_draw_line:
   \        0x0   0xE92D'4FFF        PUSH     {R0-R11,LR}
   \        0x4   0xE24D'D004        SUB      SP,SP,#+4
   \        0x8   0xE59D'0038        LDR      R0,[SP, #+56]
    445          	_set_front_color(color);
   \        0xC   0x....'....        LDR      R1,??DataTable15
   \       0x10   0xE581'0000        STR      R0,[R1, #+0]
    446          
    447          	if ((x1 == x2) && (y1 > y2)) {
   \       0x14   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x18   0xE59D'100C        LDR      R1,[SP, #+12]
   \       0x1C   0xE150'0001        CMP      R0,R1
   \       0x20   0x1A00'0008        BNE      ??lcd_draw_line_0
   \       0x24   0xE59D'2010        LDR      R2,[SP, #+16]
   \       0x28   0xE59D'3008        LDR      R3,[SP, #+8]
   \       0x2C   0xE152'0003        CMP      R2,R3
   \       0x30   0x2A00'0017        BCS      ??lcd_draw_line_1
    448          		SWAP(y1, y2);
   \       0x34   0xE59D'0010        LDR      R0,[SP, #+16]
   \       0x38   0xE58D'3000        STR      R3,[SP, #+0]
   \       0x3C   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x40   0xE28D'0010        ADD      R0,SP,#+16
   \       0x44   0xEA00'000B        B        ??lcd_draw_line_2
    449          	}
    450          	if ((x1 > x2) & (y1 == y2)) {
   \                     ??lcd_draw_line_0:
   \       0x48   0xE151'0000        CMP      R1,R0
   \       0x4C   0x2A00'000C        BCS      ??lcd_draw_line_3
   \       0x50   0xE59D'0008        LDR      R0,[SP, #+8]
   \       0x54   0xE59D'3010        LDR      R3,[SP, #+16]
   \       0x58   0xE150'0003        CMP      R0,R3
   \       0x5C   0x1A00'0008        BNE      ??lcd_draw_line_3
    451          		SWAP(x1, x2);
   \       0x60   0xE28D'0004        ADD      R0,SP,#+4
   \       0x64   0xE590'2000        LDR      R2,[R0, #0]
   \       0x68   0xE59D'000C        LDR      R0,[SP, #+12]
   \       0x6C   0xE58D'2000        STR      R2,[SP, #+0]
   \       0x70   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x74   0xE28D'000C        ADD      R0,SP,#+12
   \                     ??lcd_draw_line_2:
   \       0x78   0xE59D'1000        LDR      R1,[SP, #0]
   \       0x7C   0xE580'1000        STR      R1,[R0, #+0]
   \       0x80   0xEA00'0003        B        ??lcd_draw_line_1
    452          	}
   \                     ??lcd_draw_line_3:
   \       0x84   0xE59D'2008        LDR      R2,[SP, #+8]
   \       0x88   0xE59D'C010        LDR      R12,[SP, #+16]
   \       0x8C   0xE152'000C        CMP      R2,R12
   \       0x90   0x1A00'0006        BNE      ??lcd_draw_line_4
    453          
    454          	if ((x1 == x2) || (y1 == y2)) {
    455          		lcd_draw_filled_rectangle(x1, y1, x2, y2, color);
   \                     ??lcd_draw_line_1:
   \       0x94   0xE59D'3010        LDR      R3,[SP, #+16]
   \       0x98   0xE59D'200C        LDR      R2,[SP, #+12]
   \       0x9C   0xE59D'1008        LDR      R1,[SP, #+8]
   \       0xA0   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0xA4   0x....'....        BL       _fill_rect
    456          	} else {
    457          		_hide_canvas();
    458          		_draw_line_bresenham(x1, y1, x2, y2);
    459          		_show_canvas();
    460          	}
    461          }
   \       0xA8   0xE28D'D014        ADD      SP,SP,#+20
   \       0xAC   0xE8BD'8FF0        POP      {R4-R11,PC}
   \                     ??lcd_draw_line_4:
   \       0xB0   0xE59D'6004        LDR      R6,[SP, #+4]
   \       0xB4   0xE1A0'5002        MOV      R5,R2
   \       0xB8   0xE051'7006        SUBS     R7,R1,R6
   \       0xBC   0x4267'7000        RSBMI    R7,R7,#+0
   \       0xC0   0xE05C'8005        SUBS     R8,R12,R5
   \       0xC4   0x4268'8000        RSBMI    R8,R8,#+0
   \       0xC8   0xE156'0001        CMP      R6,R1
   \       0xCC   0x33A0'9001        MOVCC    R9,#+1
   \       0xD0   0x23E0'9000        MVNCS    R9,#+0
   \       0xD4   0xE155'000C        CMP      R5,R12
   \       0xD8   0x33A0'A001        MOVCC    R10,#+1
   \       0xDC   0x23E0'A000        MVNCS    R10,#+0
   \       0xE0   0xE047'B008        SUB      R11,R7,R8
   \       0xE4   0xE268'4000        RSB      R4,R8,#+0
   \       0xE8   0xEA00'0006        B        ??lcd_draw_line_5
   \                     ??lcd_draw_line_6:
   \       0xEC   0xE1A0'008B        LSL      R0,R11,#+1
   \       0xF0   0xE154'0000        CMP      R4,R0
   \       0xF4   0xB04B'B008        SUBLT    R11,R11,R8
   \       0xF8   0xB089'6006        ADDLT    R6,R9,R6
   \       0xFC   0xE150'0007        CMP      R0,R7
   \      0x100   0xB087'B00B        ADDLT    R11,R7,R11
   \      0x104   0xB08A'5005        ADDLT    R5,R10,R5
   \                     ??lcd_draw_line_5:
   \      0x108   0xE1A0'1005        MOV      R1,R5
   \      0x10C   0xE1A0'0006        MOV      R0,R6
   \      0x110   0x....'....        BL       _draw_pixel
   \      0x114   0xE59D'100C        LDR      R1,[SP, #+12]
   \      0x118   0xE156'0001        CMP      R6,R1
   \      0x11C   0x1AFF'FFF2        BNE      ??lcd_draw_line_6
   \      0x120   0xE59D'0010        LDR      R0,[SP, #+16]
   \      0x124   0xE155'0000        CMP      R5,R0
   \      0x128   0x1AFF'FFEF        BNE      ??lcd_draw_line_6
   \      0x12C   0xE28D'D014        ADD      SP,SP,#+20
   \      0x130   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    462          
    463          /**
    464           * \brief Draws a rectangle on LCD, at the given coordinates.
    465           *
    466           * \param x      X-coordinate of upper-left rectangle corner.
    467           * \param y      Y-coordinate of upper-left rectangle corner.
    468           * \param width  Rectangle width in pixels.
    469           * \param height  Rectangle height in pixels.
    470           * \param color  Rectangle color.
    471           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    472          void lcd_draw_rectangle(uint32_t x, uint32_t y, uint32_t width, uint32_t height,
    473          			 uint32_t color)
    474          {
   \                     lcd_draw_rectangle:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE59D'0018        LDR      R0,[SP, #+24]
    475          	uint32_t x1 = x + width - 1;
   \       0x10   0xE082'1004        ADD      R1,R2,R4
    476          	uint32_t y1 = y + height - 1;
   \       0x14   0xE083'2005        ADD      R2,R3,R5
    477          
    478          	_set_front_color(color);
   \       0x18   0x....'....        LDR      R3,??DataTable15
   \       0x1C   0xE241'6001        SUB      R6,R1,#+1
   \       0x20   0xE242'7001        SUB      R7,R2,#+1
   \       0x24   0xE583'0000        STR      R0,[R3, #+0]
    479          	_hide_canvas();
    480          	_fill_rect(x, y, x1, y);
   \       0x28   0xE1A0'3005        MOV      R3,R5
   \       0x2C   0xE1A0'2006        MOV      R2,R6
   \       0x30   0xE1A0'1005        MOV      R1,R5
   \       0x34   0xE1A0'0004        MOV      R0,R4
   \       0x38   0x....'....        BL       _fill_rect
    481          	_fill_rect(x1, y, x1, y1);
   \       0x3C   0xE1A0'3007        MOV      R3,R7
   \       0x40   0xE1A0'2006        MOV      R2,R6
   \       0x44   0xE1A0'1005        MOV      R1,R5
   \       0x48   0xE1A0'0006        MOV      R0,R6
   \       0x4C   0x....'....        BL       _fill_rect
    482          	_fill_rect(x, y, x, y1);
   \       0x50   0xE1A0'3007        MOV      R3,R7
   \       0x54   0xE1A0'2004        MOV      R2,R4
   \       0x58   0xE1A0'1005        MOV      R1,R5
   \       0x5C   0xE1A0'0004        MOV      R0,R4
   \       0x60   0x....'....        BL       _fill_rect
    483          	_fill_rect(x, y1, x1, y1);
   \       0x64   0xE1A0'3007        MOV      R3,R7
   \       0x68   0xE1A0'2006        MOV      R2,R6
   \       0x6C   0xE1A0'1007        MOV      R1,R7
   \       0x70   0xE1A0'0004        MOV      R0,R4
   \       0x74   0xE28D'D004        ADD      SP,SP,#+4
   \       0x78   0xE8BD'40F0        POP      {R4-R7,LR}
   \       0x7C   0x....'....        B        _fill_rect       ;; tailcall
    484          	_show_canvas();
    485          }
    486          
    487          /**
    488           * \brief Draws a rectangle with fill inside on LCD, at the given coordinates.
    489           *
    490           * \param dwX1   X-coordinate of upper-left rectangle corner.
    491           * \param dwY1   Y-coordinate of upper-left rectangle corner.
    492           * \param dwX2   X-coordinate of down-right rectangle corner.
    493           * \param dwY2   Y-coordinate of down-right rectangle corner.
    494           * \param color Rectangle color.
    495           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    496          void lcd_draw_filled_rectangle(uint32_t dwX1, uint32_t dwY1,
    497          				uint32_t dwX2, uint32_t dwY2, uint32_t color)
    498          {
   \                     lcd_draw_filled_rectangle:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE59D'C008        LDR      R12,[SP, #+8]
    499          	_set_front_color(color);
   \        0x8   0x....'....        LDR      LR,??DataTable15
   \        0xC   0xE58E'C000        STR      R12,[LR, #+0]
    500          	_hide_canvas();
    501          	_fill_rect(dwX1, dwY1, dwX2, dwY2);
   \       0x10   0xE8BD'5000        POP      {R12,LR}
   \       0x14   0x....'....        B        _fill_rect       ;; tailcall
    502          	_show_canvas();
    503          }
    504          
    505          /**
    506           * \brief Draws a circle on LCD, at the given coordinates.
    507           *
    508           * \param dwX     X-coordinate of circle center.
    509           * \param dwY     Y-coordinate of circle center.
    510           * \param dwR     circle radius.
    511           * \param color circle color.
    512           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    513          void lcd_draw_circle(uint32_t dwX, uint32_t dwY, uint32_t dwR, uint32_t color)
    514          {
   \                     lcd_draw_circle:
   \        0x0   0xE352'0000        CMP      R2,#+0
   \        0x4   0x1A00'0000        BNE      ??lcd_draw_circle_0
   \        0x8   0xE12F'FF1E        BX       LR
   \                     ??lcd_draw_circle_0:
   \        0xC   0xE92D'4FFE        PUSH     {R1-R11,LR}
    515          	int32_t d;		/* Decision Variable */
    516          	uint32_t curX;		/* Current X Value */
    517          	uint32_t curY;		/* Current Y Value */
    518          
    519          	if (dwR == 0)
    520          		return;
    521          	_set_front_color(color);
   \       0x10   0x....'....        LDR      R12,??DataTable15
    522          
    523          	d = 3 - (dwR << 1);
    524          	curX = 0;
   \       0x14   0xE3A0'4000        MOV      R4,#+0
   \       0x18   0xE58C'3000        STR      R3,[R12, #+0]
   \       0x1C   0xE3A0'3003        MOV      R3,#+3
   \       0x20   0xE043'5082        SUB      R5,R3,R2, LSL #+1
    525          	curY = dwR;
    526          
    527          	_hide_canvas();
   \       0x24   0xE1A0'6000        MOV      R6,R0
   \       0x28   0xE1A0'7001        MOV      R7,R1
   \       0x2C   0xE58D'0004        STR      R0,[SP, #+4]
   \       0x30   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x34   0xE1A0'8002        MOV      R8,R2
   \       0x38   0xEA00'002F        B        ??lcd_draw_circle_1
    528          	while (curX <= curY) {
    529          		_draw_pixel(dwX + curX, dwY + curY);
    530          		_draw_pixel(dwX + curX, dwY - curY);
    531          		_draw_pixel(dwX - curX, dwY + curY);
    532          		_draw_pixel(dwX - curX, dwY - curY);
    533          		_draw_pixel(dwX + curY, dwY + curX);
    534          		_draw_pixel(dwX + curY, dwY - curX);
    535          		_draw_pixel(dwX - curY, dwY + curX);
    536          		_draw_pixel(dwX - curY, dwY - curX);
    537          
    538          		if (d < 0) {
    539          			d += (curX << 2) + 6;
    540          		} else {
    541          			d += ((curX - curY) << 2) + 10;
   \                     ??lcd_draw_circle_2:
   \       0x3C   0xE044'0008        SUB      R0,R4,R8
   \       0x40   0xE085'1100        ADD      R1,R5,R0, LSL #+2
   \       0x44   0xE281'500A        ADD      R5,R1,#+10
    542          			curY--;
   \       0x48   0xE248'8001        SUB      R8,R8,#+1
   \       0x4C   0xEA00'0027        B        ??lcd_draw_circle_3
    543          		}
   \                     ??lcd_draw_circle_4:
   \       0x50   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x54   0xE1A0'0006        MOV      R0,R6
   \       0x58   0xE088'9001        ADD      R9,R8,R1
   \       0x5C   0xE1A0'1009        MOV      R1,R9
   \       0x60   0x....'....        BL       _draw_pixel
   \       0x64   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x68   0xE1A0'0006        MOV      R0,R6
   \       0x6C   0xE041'A008        SUB      R10,R1,R8
   \       0x70   0xE1A0'100A        MOV      R1,R10
   \       0x74   0x....'....        BL       _draw_pixel
   \       0x78   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x7C   0xE041'B004        SUB      R11,R1,R4
   \       0x80   0xE1A0'1009        MOV      R1,R9
   \       0x84   0xE1A0'000B        MOV      R0,R11
   \       0x88   0x....'....        BL       _draw_pixel
   \       0x8C   0xE1A0'100A        MOV      R1,R10
   \       0x90   0xE1A0'000B        MOV      R0,R11
   \       0x94   0x....'....        BL       _draw_pixel
   \       0x98   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x9C   0xE088'9001        ADD      R9,R8,R1
   \       0xA0   0xE1A0'1007        MOV      R1,R7
   \       0xA4   0xE1A0'0009        MOV      R0,R9
   \       0xA8   0x....'....        BL       _draw_pixel
   \       0xAC   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xB0   0xE1A0'0009        MOV      R0,R9
   \       0xB4   0xE041'A004        SUB      R10,R1,R4
   \       0xB8   0xE1A0'100A        MOV      R1,R10
   \       0xBC   0x....'....        BL       _draw_pixel
   \       0xC0   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0xC4   0xE041'9008        SUB      R9,R1,R8
   \       0xC8   0xE1A0'1007        MOV      R1,R7
   \       0xCC   0xE1A0'0009        MOV      R0,R9
   \       0xD0   0x....'....        BL       _draw_pixel
   \       0xD4   0xE1A0'100A        MOV      R1,R10
   \       0xD8   0xE1A0'0009        MOV      R0,R9
   \       0xDC   0x....'....        BL       _draw_pixel
   \       0xE0   0xE355'0000        CMP      R5,#+0
   \       0xE4   0x5AFF'FFD4        BPL      ??lcd_draw_circle_2
   \       0xE8   0xE085'0104        ADD      R0,R5,R4, LSL #+2
   \       0xEC   0xE280'5006        ADD      R5,R0,#+6
    544          		curX++;
   \                     ??lcd_draw_circle_3:
   \       0xF0   0xE284'4001        ADD      R4,R4,#+1
   \       0xF4   0xE287'7001        ADD      R7,R7,#+1
   \       0xF8   0xE286'6001        ADD      R6,R6,#+1
    545          	}
   \                     ??lcd_draw_circle_1:
   \       0xFC   0xE158'0004        CMP      R8,R4
   \      0x100   0x2AFF'FFD2        BCS      ??lcd_draw_circle_4
    546          	_show_canvas();
    547          }
   \      0x104   0xE28D'D00C        ADD      SP,SP,#+12
   \      0x108   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    548          
    549          /**
    550           * \brief Draws a filled circle on LCD, at the given coordinates.
    551           *
    552           * \param dwX     X-coordinate of circle center.
    553           * \param dwY     Y-coordinate of circle center.
    554           * \param dwR     circle radius.
    555           * \param color circle color.
    556           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    557          void lcd_draw_filled_circle(uint32_t dwX, uint32_t dwY, uint32_t dwR,
    558          			     uint32_t color)
    559          {
   \                     lcd_draw_filled_circle:
   \        0x0   0xE352'0000        CMP      R2,#+0
   \        0x4   0x1A00'0000        BNE      ??lcd_draw_filled_circle_0
   \        0x8   0xE12F'FF1E        BX       LR
   \                     ??lcd_draw_filled_circle_0:
   \        0xC   0xE92D'4FF8        PUSH     {R3-R11,LR}
    560          	signed int d;		// Decision Variable
    561          	uint32_t dwCurX;	// Current X Value
    562          	uint32_t dwCurY;	// Current Y Value
    563          	uint32_t dwXmin, dwYmin;
    564          
    565          	if (dwR == 0)
    566          		return;
    567          	_set_front_color(color);
   \       0x10   0x....'....        LDR      R12,??DataTable15
    568          
    569          	d = 3 - (dwR << 1);
    570          	dwCurX = 0;
   \       0x14   0xE3A0'4000        MOV      R4,#+0
   \       0x18   0xE58C'3000        STR      R3,[R12, #+0]
   \       0x1C   0xE3A0'3003        MOV      R3,#+3
   \       0x20   0xE043'8082        SUB      R8,R3,R2, LSL #+1
   \       0x24   0xE3A0'9000        MOV      R9,#+0
    571          	dwCurY = dwR;
    572          
    573          	_hide_canvas();
   \       0x28   0xE1A0'B000        MOV      R11,R0
   \       0x2C   0xE1A0'A001        MOV      R10,R1
   \       0x30   0xE1A0'5000        MOV      R5,R0
   \       0x34   0xE1A0'6001        MOV      R6,R1
   \       0x38   0xE1A0'7002        MOV      R7,R2
   \       0x3C   0xEA00'0014        B        ??lcd_draw_filled_circle_1
    574          	while (dwCurX <= dwCurY) {
    575          		dwXmin = (dwCurX > dwX) ? 0 : dwX - dwCurX;
    576          		dwYmin = (dwCurY > dwY) ? 0 : dwY - dwCurY;
    577          		_fill_rect(dwXmin, dwYmin, dwX + dwCurX, dwYmin);
    578          		_fill_rect(dwXmin, dwY + dwCurY, dwX + dwCurX, dwY + dwCurY);
    579          		dwXmin = (dwCurY > dwX) ? 0 : dwX - dwCurY;
    580          		dwYmin = (dwCurX > dwY) ? 0 : dwY - dwCurX;
    581          		_fill_rect(dwXmin, dwYmin, dwX + dwCurY, dwYmin);
    582          		_fill_rect(dwXmin, dwY + dwCurX, dwX + dwCurY, dwY + dwCurX);
    583          
    584          		if (d < 0) {
    585          			d += (dwCurX << 2) + 6;
    586          		} else {
    587          			d += ((dwCurX - dwCurY) << 2) + 10;
   \                     ??lcd_draw_filled_circle_2:
   \       0x40   0xE049'0007        SUB      R0,R9,R7
   \       0x44   0xE088'0100        ADD      R0,R8,R0, LSL #+2
   \       0x48   0xE280'800A        ADD      R8,R0,#+10
    588          			dwCurY--;
   \       0x4C   0xE247'7001        SUB      R7,R7,#+1
   \       0x50   0xEA00'000C        B        ??lcd_draw_filled_circle_3
    589          		}
   \                     ??lcd_draw_filled_circle_4:
   \       0x54   0xE1A0'3001        MOV      R3,R1
   \       0x58   0xE087'2005        ADD      R2,R7,R5
   \       0x5C   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x60   0x....'....        BL       _fill_rect
   \       0x64   0xE1A0'300A        MOV      R3,R10
   \       0x68   0xE087'2005        ADD      R2,R7,R5
   \       0x6C   0xE1A0'100A        MOV      R1,R10
   \       0x70   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0x74   0x....'....        BL       _fill_rect
   \       0x78   0xE358'0000        CMP      R8,#+0
   \       0x7C   0x5AFF'FFEF        BPL      ??lcd_draw_filled_circle_2
   \       0x80   0xE088'0109        ADD      R0,R8,R9, LSL #+2
   \       0x84   0xE280'8006        ADD      R8,R0,#+6
    590          
    591          		dwCurX++;
   \                     ??lcd_draw_filled_circle_3:
   \       0x88   0xE289'9001        ADD      R9,R9,#+1
   \       0x8C   0xE28A'A001        ADD      R10,R10,#+1
   \       0x90   0xE28B'B001        ADD      R11,R11,#+1
   \                     ??lcd_draw_filled_circle_1:
   \       0x94   0xE157'0009        CMP      R7,R9
   \       0x98   0x3A00'0017        BCC      ??lcd_draw_filled_circle_5
   \       0x9C   0xE155'0009        CMP      R5,R9
   \       0xA0   0x2045'0009        SUBCS    R0,R5,R9
   \       0xA4   0x358D'4000        STRCC    R4,[SP, #+0]
   \       0xA8   0x258D'0000        STRCS    R0,[SP, #+0]
   \       0xAC   0xE156'0007        CMP      R6,R7
   \       0xB0   0x33A0'1000        MOVCC    R1,#+0
   \       0xB4   0x2046'1007        SUBCS    R1,R6,R7
   \       0xB8   0xE1A0'3001        MOV      R3,R1
   \       0xBC   0xE1A0'200B        MOV      R2,R11
   \       0xC0   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xC4   0x....'....        BL       _fill_rect
   \       0xC8   0xE087'1006        ADD      R1,R7,R6
   \       0xCC   0xE1A0'3001        MOV      R3,R1
   \       0xD0   0xE1A0'200B        MOV      R2,R11
   \       0xD4   0xE59D'0000        LDR      R0,[SP, #+0]
   \       0xD8   0x....'....        BL       _fill_rect
   \       0xDC   0xE155'0007        CMP      R5,R7
   \       0xE0   0x2045'0007        SUBCS    R0,R5,R7
   \       0xE4   0x358D'4000        STRCC    R4,[SP, #+0]
   \       0xE8   0x258D'0000        STRCS    R0,[SP, #+0]
   \       0xEC   0xE156'0009        CMP      R6,R9
   \       0xF0   0x33A0'1000        MOVCC    R1,#+0
   \       0xF4   0x2046'1009        SUBCS    R1,R6,R9
   \       0xF8   0xEAFF'FFD5        B        ??lcd_draw_filled_circle_4
    592          	}
    593          	_show_canvas();
    594          }
   \                     ??lcd_draw_filled_circle_5:
   \       0xFC   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    595          
    596          /**
    597           * \brief Draws a string inside a LCD buffer, at the given coordinates. Line breaks
    598           * will be honored.
    599           *
    600           * \param x        X-coordinate of string top-left corner.
    601           * \param y        Y-coordinate of string top-left corner.
    602           * \param p_string  String to display.
    603           * \param color    String color.
    604           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    605          void lcd_draw_string(uint32_t x, uint32_t y, const char *p_string, uint32_t color)
    606          {
   \                     lcd_draw_string:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1A0'5001        MOV      R5,R1
   \        0x8   0xE1A0'6002        MOV      R6,R2
   \        0xC   0xE1A0'7003        MOV      R7,R3
   \       0x10   0xE1A0'4000        MOV      R4,R0
    607          	uint32_t xorg = x;
    608          	uint8_t font_sel = lcd_get_selected_font();
   \       0x14   0x....'....        BL       lcd_get_selected_font
    609          	uint8_t width = font_param[font_sel].width ;
   \       0x18   0x....'....        LDR      R1,??DataTable15_1
   \       0x1C   0xE1A0'8004        MOV      R8,R4
    610          	uint8_t height = font_param[font_sel].height;
   \       0x20   0xE081'2180        ADD      R2,R1,R0, LSL #+3
   \       0x24   0xE7D1'9180        LDRB     R9,[R1, +R0, LSL #+3]
   \       0x28   0xE5D2'A001        LDRB     R10,[R2, #+1]
    611          	uint8_t char_space = font_param[font_sel].char_space;
   \       0x2C   0xE5D2'B002        LDRB     R11,[R2, #+2]
    612          
    613          	/* Font 10*8 reverse height and width */
    614          	if (font_sel == FONT10x8) {
   \       0x30   0xE350'0001        CMP      R0,#+1
   \       0x34   0x1A00'000F        BNE      ??lcd_draw_string_0
    615          		width = font_param[font_sel].height ;
   \       0x38   0xE5D1'9009        LDRB     R9,[R1, #+9]
    616          		height = font_param[font_sel].width;
   \       0x3C   0xE5D1'A008        LDRB     R10,[R1, #+8]
   \       0x40   0xEA00'000C        B        ??lcd_draw_string_0
    617          	}
    618          
    619          	while (*p_string) {
    620          		if (*p_string == '\n') {
    621          			y += height + char_space;
    622          			x = xorg;
    623          		} else {
    624          			lcd_draw_char(x, y, *p_string, color);
   \                     ??lcd_draw_string_1:
   \       0x44   0xE1A0'3007        MOV      R3,R7
   \       0x48   0xE1A0'1005        MOV      R1,R5
   \       0x4C   0xE1A0'0004        MOV      R0,R4
   \       0x50   0x....'....        BL       lcd_draw_char
    625          			x += width + char_space;
   \       0x54   0xE08B'0009        ADD      R0,R11,R9
   \       0x58   0xE080'4004        ADD      R4,R0,R4
   \       0x5C   0xEA00'0004        B        ??lcd_draw_string_2
    626          		}
   \                     ??lcd_draw_string_3:
   \       0x60   0xE352'000A        CMP      R2,#+10
   \       0x64   0x1AFF'FFF6        BNE      ??lcd_draw_string_1
   \       0x68   0xE08B'000A        ADD      R0,R11,R10
   \       0x6C   0xE080'5005        ADD      R5,R0,R5
   \       0x70   0xE1A0'4008        MOV      R4,R8
    627          		p_string++;
   \                     ??lcd_draw_string_2:
   \       0x74   0xE286'6001        ADD      R6,R6,#+1
    628          	}
   \                     ??lcd_draw_string_0:
   \       0x78   0xE5D6'2000        LDRB     R2,[R6, #+0]
   \       0x7C   0xE352'0000        CMP      R2,#+0
   \       0x80   0x1AFF'FFF6        BNE      ??lcd_draw_string_3
    629          }
   \       0x84   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    630          
    631          /**
    632           * \brief Draws a string inside a LCD buffer, at the given coordinates
    633           * with given background color. Line breaks will be honored.
    634           *
    635           * \param x         X-coordinate of string top-left corner.
    636           * \param y         Y-coordinate of string top-left corner.
    637           * \param p_string  String to display.
    638           * \param fontColor String color.
    639           * \param bgColor   Background color.
    640           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    641          void lcd_draw_string_with_bgcolor(uint32_t x, uint32_t y,
    642          								   const char *p_string,
    643          								   uint32_t fontColor,
    644          								   uint32_t bgColor)
    645          {
   \                     lcd_draw_string_with_bgcolor:
   \        0x0   0xE92D'4FFE        PUSH     {R1-R11,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
   \       0x10   0xE1A0'8003        MOV      R8,R3
   \       0x14   0xE59D'7030        LDR      R7,[SP, #+48]
    646          	uint32_t xorg = x;
   \       0x18   0xE58D'4000        STR      R4,[SP, #+0]
    647          	uint8_t font_sel = lcd_get_selected_font();
   \       0x1C   0x....'....        BL       lcd_get_selected_font
    648          	uint8_t width = font_param[font_sel].width ;
   \       0x20   0x....'....        LDR      R1,??DataTable15_1
    649          	uint8_t height = font_param[font_sel].height;
    650          	uint8_t char_space = font_param[font_sel].char_space;
    651          
    652          	/* Font 10*8 reverse height and width */
    653          	if (font_sel == FONT10x8) {
   \       0x24   0xE350'0001        CMP      R0,#+1
   \       0x28   0xE081'2180        ADD      R2,R1,R0, LSL #+3
   \       0x2C   0xE7D1'9180        LDRB     R9,[R1, +R0, LSL #+3]
   \       0x30   0xE5D2'A001        LDRB     R10,[R2, #+1]
   \       0x34   0xE5D2'B002        LDRB     R11,[R2, #+2]
    654          		width = font_param[font_sel].height ;
    655          		height = font_param[font_sel].width;
   \       0x38   0xE58D'8004        STR      R8,[SP, #+4]
   \       0x3C   0x05D1'9009        LDRBEQ   R9,[R1, #+9]
   \       0x40   0x05D1'A008        LDRBEQ   R10,[R1, #+8]
   \       0x44   0xE59D'8000        LDR      R8,[SP, #+0]
   \       0x48   0xEA00'000D        B        ??lcd_draw_string_with_bgcolor_0
    656          	}
    657          
    658          	while (*p_string) {
    659          		if (*p_string == '\n') {
    660          			y += height + char_space;;
    661          			x = xorg;
    662          		} else {
    663          			lcd_draw_char_with_bgcolor(x, y, *p_string, fontColor, bgColor);
   \                     ??lcd_draw_string_with_bgcolor_1:
   \       0x4C   0xE58D'7000        STR      R7,[SP, #+0]
   \       0x50   0xE59D'3004        LDR      R3,[SP, #+4]
   \       0x54   0xE1A0'1005        MOV      R1,R5
   \       0x58   0xE1A0'0004        MOV      R0,R4
   \       0x5C   0x....'....        BL       lcd_draw_char_with_bgcolor
    664          			x += width + char_space;;
   \       0x60   0xE08B'0009        ADD      R0,R11,R9
   \       0x64   0xE080'4004        ADD      R4,R0,R4
   \       0x68   0xEA00'0004        B        ??lcd_draw_string_with_bgcolor_2
    665          		}
   \                     ??lcd_draw_string_with_bgcolor_3:
   \       0x6C   0xE352'000A        CMP      R2,#+10
   \       0x70   0x1AFF'FFF5        BNE      ??lcd_draw_string_with_bgcolor_1
   \       0x74   0xE08B'000A        ADD      R0,R11,R10
   \       0x78   0xE080'5005        ADD      R5,R0,R5
   \       0x7C   0xE1A0'4008        MOV      R4,R8
    666          		p_string++;
   \                     ??lcd_draw_string_with_bgcolor_2:
   \       0x80   0xE286'6001        ADD      R6,R6,#+1
    667          	}
   \                     ??lcd_draw_string_with_bgcolor_0:
   \       0x84   0xE5D6'2000        LDRB     R2,[R6, #+0]
   \       0x88   0xE352'0000        CMP      R2,#+0
   \       0x8C   0x1AFF'FFF6        BNE      ??lcd_draw_string_with_bgcolor_3
    668          }
   \       0x90   0xE28D'D00C        ADD      SP,SP,#+12
   \       0x94   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    669          
    670          /**
    671           * \brief Returns the width & height in pixels that a string will occupy on the screen
    672           * if drawn using lcd_draw_string.
    673           *
    674           * \param p_string  String.
    675           * \param p_width   Pointer for storing the string width (optional).
    676           * \param p_height  Pointer for storing the string height (optional).
    677           *
    678           * \return String width in pixels.
    679           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    680          void lcd_get_string_size(const char *p_string, uint32_t * p_width, uint32_t * p_height)
    681          {
   \                     lcd_get_string_size:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
    682          	uint8_t font_sel = lcd_get_selected_font();
   \       0x10   0x....'....        BL       lcd_get_selected_font
    683          	uint8_t width = font_param[font_sel].width;
   \       0x14   0x....'....        LDR      R1,??DataTable15_1
    684          	uint8_t height = font_param[font_sel].height;
    685          	uint8_t char_space = font_param[font_sel].char_space;
    686          	uint32_t str_width = 0;
   \       0x18   0xE3A0'E000        MOV      LR,#+0
   \       0x1C   0xE081'C180        ADD      R12,R1,R0, LSL #+3
   \       0x20   0xE5DC'3001        LDRB     R3,[R12, #+1]
   \       0x24   0xE7D1'2180        LDRB     R2,[R1, +R0, LSL #+3]
   \       0x28   0xE5DC'C002        LDRB     R12,[R12, #+2]
    687          
    688          	/* Font 10*8 reverse height and width */
    689          	if (font_sel == FONT10x8) {
   \       0x2C   0xE350'0001        CMP      R0,#+1
   \       0x30   0x1A00'0007        BNE      ??lcd_get_string_size_0
    690          		width = font_param[font_sel].height ;
   \       0x34   0xE5D1'2009        LDRB     R2,[R1, #+9]
    691          		height = font_param[font_sel].width;
   \       0x38   0xE5D1'3008        LDRB     R3,[R1, #+8]
   \       0x3C   0xEA00'0004        B        ??lcd_get_string_size_0
    692          	}
    693          
    694          	while (*p_string) {
    695          		if (*p_string == '\n')
   \                     ??lcd_get_string_size_1:
   \       0x40   0xE350'000A        CMP      R0,#+10
    696          			height += height + char_space;
    697          		else
    698          			str_width += width + char_space;
   \       0x44   0x108C'0002        ADDNE    R0,R12,R2
   \       0x48   0x008C'3083        ADDEQ    R3,R12,R3, LSL #+1
   \       0x4C   0x1080'E00E        ADDNE    LR,R0,LR
    699          		p_string++;
   \       0x50   0xE284'4001        ADD      R4,R4,#+1
    700          	}
   \                     ??lcd_get_string_size_0:
   \       0x54   0xE5D4'0000        LDRB     R0,[R4, #+0]
   \       0x58   0xE350'0000        CMP      R0,#+0
   \       0x5C   0x1AFF'FFF7        BNE      ??lcd_get_string_size_1
    701          	if (width > 0)
   \       0x60   0xE352'0000        CMP      R2,#+0
    702          		str_width -= char_space;
   \       0x64   0x104E'E00C        SUBNE    LR,LR,R12
    703          
    704          	if (p_width != NULL)
   \       0x68   0xE355'0000        CMP      R5,#+0
    705          		*p_width = str_width;
   \       0x6C   0x1585'E000        STRNE    LR,[R5, #+0]
    706          	if (p_height != NULL)
   \       0x70   0xE356'0000        CMP      R6,#+0
    707          		*p_height = height;
   \       0x74   0x1203'30FF        ANDNE    R3,R3,#0xFF
   \       0x78   0x1586'3000        STRNE    R3,[R6, #+0]
    708          }
   \       0x7C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    709          
    710          /**
    711           * \brief Draw a raw image at given position on LCD.
    712           *
    713           * \param dwX       X-coordinate of image start.
    714           * \param dwY       Y-coordinate of image start.
    715           * \param pImage    Image buffer.
    716           * \param width     Image width.
    717           * \param height    Image height.
    718           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    719          void lcd_draw_image(uint32_t dwX, uint32_t dwY, const uint8_t * pImage,
    720          		     uint32_t width, uint32_t height)
    721          {
   \                     lcd_draw_image:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'9001        MOV      R9,R1
   \        0xC   0xE1A0'5002        MOV      R5,R2
   \       0x10   0xE1A0'6003        MOV      R6,R3
    722          	struct _lcdc_layer *pDisp = lcdc_get_canvas();
   \       0x14   0x....'....        BL       lcdc_get_canvas
    723          	uint16_t cw = pDisp->bpp / 8;	/* color width */
   \       0x18   0xE5D0'1008        LDRB     R1,[R0, #+8]
    724          	uint32_t rw = pDisp->width * cw;	/* Row width in bytes */
   \       0x1C   0xE1D0'30B4        LDRH     R3,[R0, #+4]
    725          	uint32_t rws = width * cw;	/* Source Row Width */
    726          	uint32_t rl = (rw & 0x3) ? ((rw | 0x3) + 1) : rw;	/* Aligned length */
    727          	uint32_t rls = (rws & 0x3) ? ((rws | 0x3) + 1) : rws;	/* Aligned length */
    728          	uint8_t *pSrc, *pDst;
    729          	uint32_t i;
    730          
    731          	pSrc = (uint8_t *) pImage;
    732          	pDst = pDisp->buffer;
    733          	pDst = &pDst[dwX * cw + dwY * rl];
   \       0x20   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x24   0xE1A0'21A1        LSR      R2,R1,#+3
   \       0x28   0xE008'0392        MUL      R8,R2,R3
   \       0x2C   0xE001'0692        MUL      R1,R2,R6
   \       0x30   0xE318'0003        TST      R8,#0x3
   \       0x34   0x1388'3003        ORRNE    R3,R8,#0x3
   \       0x38   0x1283'8001        ADDNE    R8,R3,#+1
   \       0x3C   0xE311'0003        TST      R1,#0x3
   \       0x40   0x1381'3003        ORRNE    R3,R1,#0x3
   \       0x44   0x1283'7001        ADDNE    R7,R3,#+1
   \       0x48   0xE003'0998        MUL      R3,R8,R9
   \       0x4C   0xE023'3492        MLA      R3,R2,R4,R3
   \       0x50   0xE59D'6020        LDR      R6,[SP, #+32]
   \       0x54   0x01A0'7001        MOVEQ    R7,R1
   \       0x58   0xE080'9003        ADD      R9,R0,R3
    734          
    735          	for (i = 0; i < height; i++) {
   \       0x5C   0xE356'0000        CMP      R6,#+0
   \       0x60   0x0A00'0008        BEQ      ??lcd_draw_image_0
   \       0x64   0xE1A0'4001        MOV      R4,R1
    736          		memcpy(pDst, pSrc, rws);
   \                     ??lcd_draw_image_1:
   \       0x68   0xE1A0'2004        MOV      R2,R4
   \       0x6C   0xE1A0'1005        MOV      R1,R5
   \       0x70   0xE1A0'0009        MOV      R0,R9
   \       0x74   0x....'....        BL       __aeabi_memcpy
    737          		pSrc = &pSrc[rls];
   \       0x78   0xE085'5007        ADD      R5,R5,R7
    738          		pDst = &pDst[rl];
   \       0x7C   0xE089'9008        ADD      R9,R9,R8
    739          	}
   \       0x80   0xE256'6001        SUBS     R6,R6,#+1
   \       0x84   0x1AFF'FFF7        BNE      ??lcd_draw_image_1
    740          }
   \                     ??lcd_draw_image_0:
   \       0x88   0xE8BD'83F1        POP      {R0,R4-R9,PC}    ;; return
    741          
    742          /**
    743           * \brief Clear a window with an color.
    744           *
    745           * \param dwX         X-coordinate of the window.
    746           * \param dwY         Y-coordinate of the window.
    747           * \param width     window width.
    748           * \param height    window height.
    749           * \param color     background color
    750           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    751          void lcd_clear_window(uint32_t dwX, uint32_t dwY, uint32_t width,
    752          		       uint32_t height, uint32_t color)
    753          {
   \                     lcd_clear_window:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE59D'C008        LDR      R12,[SP, #+8]
    754          	_set_front_color(color);
   \        0x8   0x....'....        LDR      LR,??DataTable13
    755          	_hide_canvas();
    756          	_fill_rect(0, 0, dwX + width - 1, dwY + height - 1);
   \        0xC   0xE083'1001        ADD      R1,R3,R1
   \       0x10   0xE58E'C000        STR      R12,[LR, #+0]
   \       0x14   0xE082'0000        ADD      R0,R2,R0
   \       0x18   0xE8BD'5000        POP      {R12,LR}
   \       0x1C   0xE241'3001        SUB      R3,R1,#+1
   \       0x20   0xE240'2001        SUB      R2,R0,#+1
   \       0x24                      REQUIRE ?Subroutine0
   \       0x24                      ;; // Fall through to label ?Subroutine0
    757          	_show_canvas();
    758          }
    759          
    760          /*----------------------------------------------------------------------------
    761           *        Local functions
    762           *----------------------------------------------------------------------------*/
    763          
    764          /**
    765           * Draw fast vertical line
    766           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    767          void lcd_draw_fast_vline (uint32_t x, uint32_t y, uint32_t h, uint32_t color)
    768          {
   \                     lcd_draw_fast_vline:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    769          	lcd_draw_line(x, y, x, y+h-1, color);
   \        0x4   0xE58D'3000        STR      R3,[SP, #+0]
   \        0x8   0xE082'2001        ADD      R2,R2,R1
   \        0xC   0xE242'3001        SUB      R3,R2,#+1
   \       0x10   0xE1A0'2000        MOV      R2,R0
   \       0x14   0x....'....        BL       lcd_draw_line
    770          }
   \       0x18   0xE8BD'8001        POP      {R0,PC}          ;; return
    771          /**
    772           * Draw fast horizontal line
    773           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    774          void lcd_draw_fast_hline (uint32_t x, uint32_t y, uint32_t w, uint32_t color)
    775          {
   \                     lcd_draw_fast_hline:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    776          	lcd_draw_line(x, y, x+w-1, y, color);
   \        0x4   0xE58D'3000        STR      R3,[SP, #+0]
   \        0x8   0xE082'2000        ADD      R2,R2,R0
   \        0xC   0xE1A0'3001        MOV      R3,R1
   \       0x10   0xE242'2001        SUB      R2,R2,#+1
   \       0x14   0x....'....        BL       lcd_draw_line
    777          }
   \       0x18   0xE8BD'8001        POP      {R0,PC}          ;; return
    778          /**
    779           * Fill rectangle with color
    780           */
    781          static void _lcd_fill_rectangle (uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color)
    782          {
    783          	uint32_t i;
    784          	for (i=x; i<x+w; i++) lcd_draw_fast_vline(i, y, h, color);
    785          }
    786          /**
    787           * Draw a circle
    788           */
    789          static void _lcd_draw_circle (uint32_t x0, uint32_t y0, uint32_t r, uint8_t corner, uint32_t color)
    790          {
    791          	int32_t f = 1 - r;
    792          	int32_t ddF_x = 1;
    793          	int32_t ddF_y = -2 * (int32_t)r;
    794          	int32_t x = 0;
    795          	int32_t y = r;
    796          
    797          	while (x<y) {
    798          		if (f >= 0)
    799          		{
    800          			y--;
    801          			ddF_y += 2;
    802          			f     += ddF_y;
    803          		}
    804          		x++;
    805          		ddF_x += 2;
    806          		f     += ddF_x;
    807          		if (corner & 0x4) {
    808          			_draw_pixel(x0 + x, y0 + y);
    809          			_draw_pixel(x0 + y, y0 + x);
    810          		}
    811          		if (corner & 0x2) {
    812          			_draw_pixel(x0 + x, y0 - y);
    813          			_draw_pixel(x0 + y, y0 - x);
    814          		}
    815          		if (corner & 0x8) {
    816          			_draw_pixel(x0 - y, y0 + x);
    817          			_draw_pixel(x0 - x, y0 + y);
    818          		}
    819          		if (corner & 0x1) {
    820          			_draw_pixel(x0 - y, y0 - x);
    821          			_draw_pixel(x0 - x, y0 - y);
    822          		}
    823          	}
    824          }
    825          /**
    826           * Fill a circle
    827           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    828          static void _lcd_fill_circle (uint32_t x0, uint32_t y0, uint32_t r, uint8_t corner, uint32_t delta, uint32_t color)
    829          {
   \                     _lcd_fill_circle:
   \        0x0   0xE92D'4FF0        PUSH     {R4-R11,LR}
    830          	int32_t f = 1 - r;
   \        0x4   0xE262'B001        RSB      R11,R2,#+1
    831          	int32_t ddF_x = 1;
    832          	int32_t ddF_y = -2 * (int32_t)r;
    833          	int32_t x = 0;
    834          	int32_t y = r;
   \        0x8   0xE1A0'7002        MOV      R7,R2
   \        0xC   0xE24D'D00C        SUB      SP,SP,#+12
   \       0x10   0xE1A0'C082        LSL      R12,R2,#+1
   \       0x14   0xE203'2002        AND      R2,R3,#0x2
   \       0x18   0xE59D'5030        LDR      R5,[SP, #+48]
   \       0x1C   0xE59D'6034        LDR      R6,[SP, #+52]
   \       0x20   0xE3A0'A001        MOV      R10,#+1
   \       0x24   0xE26C'8000        RSB      R8,R12,#+0
   \       0x28   0xE3A0'9000        MOV      R9,#+0
   \       0x2C   0xE5CD'2004        STRB     R2,[SP, #+4]
   \       0x30   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x34   0xE1A0'4001        MOV      R4,R1
   \       0x38   0xE5CD'3005        STRB     R3,[SP, #+5]
   \       0x3C   0xEA00'002C        B        ??_lcd_fill_circle_0
    835          
    836          	while (x<y) {
    837          		if (f >= 0) {
    838          			y--;
    839          			ddF_y += 2;
    840          			f += ddF_y;
    841          		}
    842          		x++;
    843          		ddF_x += 2;
    844          		f += ddF_x;
    845          
    846          		if (corner & 0x1) {
   \                     ??_lcd_fill_circle_1:
   \       0x40   0xE5DD'1005        LDRB     R1,[SP, #+5]
   \       0x44   0xE35B'0000        CMP      R11,#+0
   \       0x48   0x5288'8002        ADDPL    R8,R8,#+2
   \       0x4C   0x5247'7001        SUBPL    R7,R7,#+1
   \       0x50   0x5088'B00B        ADDPL    R11,R8,R11
   \       0x54   0xE28A'A002        ADD      R10,R10,#+2
   \       0x58   0xE289'9001        ADD      R9,R9,#+1
   \       0x5C   0xE08A'B00B        ADD      R11,R10,R11
   \       0x60   0xE311'0001        TST      R1,#0x1
   \       0x64   0x0A00'000F        BEQ      ??_lcd_fill_circle_2
    847          			lcd_draw_fast_vline(x0+x, y0-y, 2*y+1+delta, color);
   \       0x68   0xE59D'2008        LDR      R2,[SP, #+8]
   \       0x6C   0xE044'1007        SUB      R1,R4,R7
   \       0x70   0xE089'0002        ADD      R0,R9,R2
   \       0x74   0xE085'3087        ADD      R3,R5,R7, LSL #+1
   \       0x78   0xE58D'6000        STR      R6,[SP, #+0]
   \       0x7C   0xE081'3003        ADD      R3,R1,R3
   \       0x80   0xE1A0'2000        MOV      R2,R0
   \       0x84   0x....'....        BL       lcd_draw_line
    848          			lcd_draw_fast_vline(x0+y, y0-x, 2*x+1+delta, color);
   \       0x88   0xE59D'2008        LDR      R2,[SP, #+8]
   \       0x8C   0xE044'1009        SUB      R1,R4,R9
   \       0x90   0xE087'0002        ADD      R0,R7,R2
   \       0x94   0xE085'3089        ADD      R3,R5,R9, LSL #+1
   \       0x98   0xE58D'6000        STR      R6,[SP, #+0]
   \       0x9C   0xE081'3003        ADD      R3,R1,R3
   \       0xA0   0xE1A0'2000        MOV      R2,R0
   \       0xA4   0x....'....        BL       lcd_draw_line
    849          		}
    850          		if (corner & 0x2) {
   \                     ??_lcd_fill_circle_2:
   \       0xA8   0xE5DD'1004        LDRB     R1,[SP, #+4]
   \       0xAC   0xE351'0000        CMP      R1,#+0
   \       0xB0   0x0A00'000F        BEQ      ??_lcd_fill_circle_0
    851          			lcd_draw_fast_vline(x0-x, y0-y, 2*y+1+delta, color);
   \       0xB4   0xE59D'2008        LDR      R2,[SP, #+8]
   \       0xB8   0xE044'1007        SUB      R1,R4,R7
   \       0xBC   0xE042'0009        SUB      R0,R2,R9
   \       0xC0   0xE085'3087        ADD      R3,R5,R7, LSL #+1
   \       0xC4   0xE58D'6000        STR      R6,[SP, #+0]
   \       0xC8   0xE081'3003        ADD      R3,R1,R3
   \       0xCC   0xE1A0'2000        MOV      R2,R0
   \       0xD0   0x....'....        BL       lcd_draw_line
    852          			lcd_draw_fast_vline(x0-y, y0-x, 2*x+1+delta, color);
   \       0xD4   0xE59D'2008        LDR      R2,[SP, #+8]
   \       0xD8   0xE044'1009        SUB      R1,R4,R9
   \       0xDC   0xE042'0007        SUB      R0,R2,R7
   \       0xE0   0xE085'3089        ADD      R3,R5,R9, LSL #+1
   \       0xE4   0xE58D'6000        STR      R6,[SP, #+0]
   \       0xE8   0xE081'3003        ADD      R3,R1,R3
   \       0xEC   0xE1A0'2000        MOV      R2,R0
   \       0xF0   0x....'....        BL       lcd_draw_line
    853          		}
    854          	}
   \                     ??_lcd_fill_circle_0:
   \       0xF4   0xE159'0007        CMP      R9,R7
   \       0xF8   0xBAFF'FFD0        BLT      ??_lcd_fill_circle_1
    855          }
   \       0xFC   0xE28D'D00C        ADD      SP,SP,#+12
   \      0x100   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    856          
    857          /*----------------------------------------------------------------------------
    858           *        Global functions
    859           *----------------------------------------------------------------------------*/
    860          
    861          /**
    862           * Draw a rectangle with rounded corners
    863           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    864          void lcd_draw_rounded_rect (uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t r, uint32_t color)
    865          {
   \                     lcd_draw_rounded_rect:
   \        0x0   0xE92D'4FFF        PUSH     {R0-R11,LR}
   \        0x4   0xE24D'D014        SUB      SP,SP,#+20
   \        0x8   0xE59D'4048        LDR      R4,[SP, #+72]
   \        0xC   0xE59D'504C        LDR      R5,[SP, #+76]
    866          	_set_front_color(color);
   \       0x10   0x....'....        LDR      R0,??DataTable15
    867          	_hide_canvas();
    868          	// smarter version
    869          	lcd_draw_fast_hline(x+r, y, w-2*r, color); // Top
   \       0x14   0xE59D'C01C        LDR      R12,[SP, #+28]
   \       0x18   0xE59D'E014        LDR      LR,[SP, #+20]
   \       0x1C   0xE580'5000        STR      R5,[R0, #+0]
   \       0x20   0xE04C'7084        SUB      R7,R12,R4, LSL #+1
   \       0x24   0xE084'E00E        ADD      LR,R4,LR
   \       0x28   0xE58D'E008        STR      LR,[SP, #+8]
   \       0x2C   0xE1A0'3005        MOV      R3,R5
   \       0x30   0xE1A0'2007        MOV      R2,R7
   \       0x34   0xE59D'1018        LDR      R1,[SP, #+24]
   \       0x38   0xE1A0'000E        MOV      R0,LR
   \       0x3C   0x....'....        BL       lcd_draw_fast_hline
    870          	lcd_draw_fast_hline(x+r, y+h-1, w-2*r, color); // Bottom
   \       0x40   0xE59D'0018        LDR      R0,[SP, #+24]
   \       0x44   0xE59D'E020        LDR      LR,[SP, #+32]
   \       0x48   0xE1A0'3005        MOV      R3,R5
   \       0x4C   0xE08E'E000        ADD      LR,LR,R0
   \       0x50   0xE1A0'2007        MOV      R2,R7
   \       0x54   0xE24E'1001        SUB      R1,LR,#+1
   \       0x58   0xE59D'0008        LDR      R0,[SP, #+8]
   \       0x5C   0x....'....        BL       lcd_draw_fast_hline
    871          	lcd_draw_fast_vline(x, y+r, h-2*r, color); // Left
   \       0x60   0xE59D'3018        LDR      R3,[SP, #+24]
   \       0x64   0xE59D'1020        LDR      R1,[SP, #+32]
   \       0x68   0xE084'3003        ADD      R3,R4,R3
   \       0x6C   0xE041'6084        SUB      R6,R1,R4, LSL #+1
   \       0x70   0xE58D'3004        STR      R3,[SP, #+4]
   \       0x74   0xE1A0'3005        MOV      R3,R5
   \       0x78   0xE1A0'2006        MOV      R2,R6
   \       0x7C   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0x80   0xE59D'0014        LDR      R0,[SP, #+20]
   \       0x84   0x....'....        BL       lcd_draw_fast_vline
    872          	lcd_draw_fast_vline(x+w-1, y+r, h-2*r, color); // Right
   \       0x88   0xE1A0'3005        MOV      R3,R5
   \       0x8C   0xE59D'E014        LDR      LR,[SP, #+20]
   \       0x90   0xE59D'501C        LDR      R5,[SP, #+28]
   \       0x94   0xE1A0'2006        MOV      R2,R6
   \       0x98   0xE085'500E        ADD      R5,R5,LR
   \       0x9C   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0xA0   0xE245'0001        SUB      R0,R5,#+1
   \       0xA4   0x....'....        BL       lcd_draw_fast_vline
    873          	// draw four corners
    874          	_lcd_draw_circle(x+r, y+r, r, 1, color);
   \       0xA8   0xE1A0'0084        LSL      R0,R4,#+1
   \       0xAC   0xE260'0000        RSB      R0,R0,#+0
   \       0xB0   0xE59D'5004        LDR      R5,[SP, #+4]
   \       0xB4   0xE59D'6008        LDR      R6,[SP, #+8]
   \       0xB8   0xE264'7001        RSB      R7,R4,#+1
   \       0xBC   0xE3A0'8001        MOV      R8,#+1
   \       0xC0   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xC4   0xE1A0'9000        MOV      R9,R0
   \       0xC8   0xE3A0'A000        MOV      R10,#+0
   \       0xCC   0xE1A0'B004        MOV      R11,R4
   \       0xD0   0xEA00'000C        B        ??lcd_draw_rounded_rect_0
   \                     ??lcd_draw_rounded_rect_1:
   \       0xD4   0xE357'0000        CMP      R7,#+0
   \       0xD8   0x524B'B001        SUBPL    R11,R11,#+1
   \       0xDC   0xE28A'A001        ADD      R10,R10,#+1
   \       0xE0   0xE045'100A        SUB      R1,R5,R10
   \       0xE4   0xE046'000B        SUB      R0,R6,R11
   \       0xE8   0x5289'9002        ADDPL    R9,R9,#+2
   \       0xEC   0x5089'7007        ADDPL    R7,R9,R7
   \       0xF0   0x....'....        BL       _draw_pixel
   \       0xF4   0xE045'100B        SUB      R1,R5,R11
   \       0xF8   0xE046'000A        SUB      R0,R6,R10
   \       0xFC   0x....'....        BL       _draw_pixel
   \      0x100   0xE288'8002        ADD      R8,R8,#+2
   \      0x104   0xE088'7007        ADD      R7,R8,R7
   \                     ??lcd_draw_rounded_rect_0:
   \      0x108   0xE15A'000B        CMP      R10,R11
   \      0x10C   0xBAFF'FFF0        BLT      ??lcd_draw_rounded_rect_1
    875          	_lcd_draw_circle(x+w-r-1, y+r, r, 2, color);
   \      0x110   0xE59D'2014        LDR      R2,[SP, #+20]
   \      0x114   0xE59D'301C        LDR      R3,[SP, #+28]
   \      0x118   0xE59D'5004        LDR      R5,[SP, #+4]
   \      0x11C   0xE083'3002        ADD      R3,R3,R2
   \      0x120   0xE043'3004        SUB      R3,R3,R4
   \      0x124   0xE243'1001        SUB      R1,R3,#+1
   \      0x128   0xE58D'100C        STR      R1,[SP, #+12]
   \      0x12C   0xE1A0'6001        MOV      R6,R1
   \      0x130   0xE264'7001        RSB      R7,R4,#+1
   \      0x134   0xE3A0'8001        MOV      R8,#+1
   \      0x138   0xE59D'9000        LDR      R9,[SP, #+0]
   \      0x13C   0xE3A0'A000        MOV      R10,#+0
   \      0x140   0xE1A0'B004        MOV      R11,R4
   \      0x144   0xEA00'000C        B        ??lcd_draw_rounded_rect_2
   \                     ??lcd_draw_rounded_rect_3:
   \      0x148   0xE357'0000        CMP      R7,#+0
   \      0x14C   0x524B'B001        SUBPL    R11,R11,#+1
   \      0x150   0xE28A'A001        ADD      R10,R10,#+1
   \      0x154   0xE045'100B        SUB      R1,R5,R11
   \      0x158   0xE08A'0006        ADD      R0,R10,R6
   \      0x15C   0x5289'9002        ADDPL    R9,R9,#+2
   \      0x160   0x5089'7007        ADDPL    R7,R9,R7
   \      0x164   0x....'....        BL       _draw_pixel
   \      0x168   0xE045'100A        SUB      R1,R5,R10
   \      0x16C   0xE08B'0006        ADD      R0,R11,R6
   \      0x170   0x....'....        BL       _draw_pixel
   \      0x174   0xE288'8002        ADD      R8,R8,#+2
   \      0x178   0xE088'7007        ADD      R7,R8,R7
   \                     ??lcd_draw_rounded_rect_2:
   \      0x17C   0xE15A'000B        CMP      R10,R11
   \      0x180   0xBAFF'FFF0        BLT      ??lcd_draw_rounded_rect_3
    876          	_lcd_draw_circle(x+w-r-1, y+h-r-1, r, 4, color);
   \      0x184   0xE59D'1018        LDR      R1,[SP, #+24]
   \      0x188   0xE59D'3020        LDR      R3,[SP, #+32]
   \      0x18C   0xE59D'600C        LDR      R6,[SP, #+12]
   \      0x190   0xE083'3001        ADD      R3,R3,R1
   \      0x194   0xE043'3004        SUB      R3,R3,R4
   \      0x198   0xE243'0001        SUB      R0,R3,#+1
   \      0x19C   0xE58D'0004        STR      R0,[SP, #+4]
   \      0x1A0   0xE1A0'5000        MOV      R5,R0
   \      0x1A4   0xE264'7001        RSB      R7,R4,#+1
   \      0x1A8   0xE3A0'8001        MOV      R8,#+1
   \      0x1AC   0xE59D'9000        LDR      R9,[SP, #+0]
   \      0x1B0   0xE3A0'A000        MOV      R10,#+0
   \      0x1B4   0xE1A0'B004        MOV      R11,R4
   \      0x1B8   0xEA00'000C        B        ??lcd_draw_rounded_rect_4
   \                     ??lcd_draw_rounded_rect_5:
   \      0x1BC   0xE357'0000        CMP      R7,#+0
   \      0x1C0   0x524B'B001        SUBPL    R11,R11,#+1
   \      0x1C4   0xE28A'A001        ADD      R10,R10,#+1
   \      0x1C8   0xE08B'1005        ADD      R1,R11,R5
   \      0x1CC   0xE08A'0006        ADD      R0,R10,R6
   \      0x1D0   0x5289'9002        ADDPL    R9,R9,#+2
   \      0x1D4   0x5089'7007        ADDPL    R7,R9,R7
   \      0x1D8   0x....'....        BL       _draw_pixel
   \      0x1DC   0xE08A'1005        ADD      R1,R10,R5
   \      0x1E0   0xE08B'0006        ADD      R0,R11,R6
   \      0x1E4   0x....'....        BL       _draw_pixel
   \      0x1E8   0xE288'8002        ADD      R8,R8,#+2
   \      0x1EC   0xE088'7007        ADD      R7,R8,R7
   \                     ??lcd_draw_rounded_rect_4:
   \      0x1F0   0xE15A'000B        CMP      R10,R11
   \      0x1F4   0xBAFF'FFF0        BLT      ??lcd_draw_rounded_rect_5
    877          	_lcd_draw_circle(x+r, y+h-r-1, r, 8, color);
   \      0x1F8   0xE59D'5004        LDR      R5,[SP, #+4]
   \      0x1FC   0xE59D'6008        LDR      R6,[SP, #+8]
   \      0x200   0xE264'7001        RSB      R7,R4,#+1
   \      0x204   0xE3A0'8001        MOV      R8,#+1
   \      0x208   0xE59D'9000        LDR      R9,[SP, #+0]
   \      0x20C   0xE3A0'A000        MOV      R10,#+0
   \      0x210   0xEA00'000C        B        ??lcd_draw_rounded_rect_6
   \                     ??lcd_draw_rounded_rect_7:
   \      0x214   0xE357'0000        CMP      R7,#+0
   \      0x218   0x5244'4001        SUBPL    R4,R4,#+1
   \      0x21C   0xE28A'A001        ADD      R10,R10,#+1
   \      0x220   0xE08A'1005        ADD      R1,R10,R5
   \      0x224   0xE046'0004        SUB      R0,R6,R4
   \      0x228   0x5289'9002        ADDPL    R9,R9,#+2
   \      0x22C   0x5089'7007        ADDPL    R7,R9,R7
   \      0x230   0x....'....        BL       _draw_pixel
   \      0x234   0xE084'1005        ADD      R1,R4,R5
   \      0x238   0xE046'000A        SUB      R0,R6,R10
   \      0x23C   0x....'....        BL       _draw_pixel
   \      0x240   0xE288'8002        ADD      R8,R8,#+2
   \      0x244   0xE088'7007        ADD      R7,R8,R7
   \                     ??lcd_draw_rounded_rect_6:
   \      0x248   0xE15A'0004        CMP      R10,R4
   \      0x24C   0xBAFF'FFF0        BLT      ??lcd_draw_rounded_rect_7
    878          	_show_canvas();
    879          }
   \      0x250   0xE28D'D024        ADD      SP,SP,#+36
   \      0x254   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    880          /**
    881           * Fill a rectangle with rounded corners
    882           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    883          void lcd_fill_rounded_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t r, uint32_t color)
    884          {
   \                     lcd_fill_rounded_rect:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE24D'D010        SUB      SP,SP,#+16
   \        0x8   0xE1A0'9002        MOV      R9,R2
   \        0xC   0xE59D'7038        LDR      R7,[SP, #+56]
   \       0x10   0xE59D'403C        LDR      R4,[SP, #+60]
    885          	_set_front_color(color);
   \       0x14   0x....'....        LDR      R2,??DataTable15
    886          	_hide_canvas();
    887          	if (w>(2*r)) {
   \       0x18   0xE1A0'6087        LSL      R6,R7,#+1
   \       0x1C   0xE582'4000        STR      R4,[R2, #+0]
   \       0x20   0xE156'0009        CMP      R6,R9
   \       0x24   0x2A00'0048        BCS      ??lcd_fill_rounded_rect_0
   \       0x28   0xE58D'000C        STR      R0,[SP, #+12]
    888          		_lcd_fill_rectangle(x+r, y, w-(2*r), h, color);
   \       0x2C   0xE59D'E00C        LDR      LR,[SP, #+12]
   \       0x30   0xE049'0006        SUB      R0,R9,R6
   \       0x34   0xE087'500E        ADD      R5,R7,LR
   \       0x38   0xE1A0'B005        MOV      R11,R5
   \       0x3C   0xE080'800B        ADD      R8,R0,R11
   \       0x40   0xE58D'3004        STR      R3,[SP, #+4]
   \       0x44   0xE15B'0008        CMP      R11,R8
   \       0x48   0x2A00'000C        BCS      ??lcd_fill_rounded_rect_1
   \       0x4C   0xE083'0001        ADD      R0,R3,R1
   \       0x50   0xE240'A001        SUB      R10,R0,#+1
   \       0x54   0xE58D'1008        STR      R1,[SP, #+8]
   \                     ??lcd_fill_rounded_rect_2:
   \       0x58   0xE58D'4000        STR      R4,[SP, #+0]
   \       0x5C   0xE1A0'300A        MOV      R3,R10
   \       0x60   0xE1A0'200B        MOV      R2,R11
   \       0x64   0xE59D'1008        LDR      R1,[SP, #+8]
   \       0x68   0xE1A0'000B        MOV      R0,R11
   \       0x6C   0x....'....        BL       lcd_draw_line
   \       0x70   0xE28B'B001        ADD      R11,R11,#+1
   \       0x74   0xE15B'0008        CMP      R11,R8
   \       0x78   0x3AFF'FFF6        BCC      ??lcd_fill_rounded_rect_2
   \       0x7C   0xE59D'1008        LDR      R1,[SP, #+8]
    889          		// draw four corners
    890          		_lcd_fill_circle(x+w-r-1, y+r, r, 1, h-2*r-1, color);
   \                     ??lcd_fill_rounded_rect_1:
   \       0x80   0xE59D'0004        LDR      R0,[SP, #+4]
   \       0x84   0xE58D'4004        STR      R4,[SP, #+4]
   \       0x88   0xE040'0006        SUB      R0,R0,R6
   \       0x8C   0xE240'8001        SUB      R8,R0,#+1
   \       0x90   0xE59D'000C        LDR      R0,[SP, #+12]
   \       0x94   0xE087'6001        ADD      R6,R7,R1
   \       0x98   0xE089'0000        ADD      R0,R9,R0
   \       0x9C   0xE040'0007        SUB      R0,R0,R7
   \       0xA0   0xE58D'8000        STR      R8,[SP, #+0]
   \       0xA4   0xE3A0'3001        MOV      R3,#+1
   \       0xA8   0xE1A0'2007        MOV      R2,R7
   \       0xAC   0xE1A0'1006        MOV      R1,R6
   \       0xB0   0xE240'0001        SUB      R0,R0,#+1
   \       0xB4   0x....'....        BL       _lcd_fill_circle
    891          		_lcd_fill_circle(x+r, y+r, r, 2, h-2*r-1, color);
   \       0xB8   0xE1A0'0006        MOV      R0,R6
   \       0xBC   0xE1A0'1008        MOV      R1,R8
   \       0xC0   0xE1A0'6005        MOV      R6,R5
   \       0xC4   0xE1A0'2087        LSL      R2,R7,#+1
   \       0xC8   0xE58D'403C        STR      R4,[SP, #+60]
   \       0xCC   0xE267'B001        RSB      R11,R7,#+1
   \       0xD0   0xE3A0'A001        MOV      R10,#+1
   \       0xD4   0xE262'8000        RSB      R8,R2,#+0
   \       0xD8   0xE3A0'9000        MOV      R9,#+0
   \       0xDC   0xE1A0'4001        MOV      R4,R1
   \       0xE0   0xE1A0'5000        MOV      R5,R0
   \       0xE4   0xEA00'0016        B        ??lcd_fill_rounded_rect_3
   \                     ??lcd_fill_rounded_rect_4:
   \       0xE8   0xE35B'0000        CMP      R11,#+0
   \       0xEC   0xE59D'303C        LDR      R3,[SP, #+60]
   \       0xF0   0x5247'7001        SUBPL    R7,R7,#+1
   \       0xF4   0xE289'9001        ADD      R9,R9,#+1
   \       0xF8   0xE045'1007        SUB      R1,R5,R7
   \       0xFC   0xE046'0009        SUB      R0,R6,R9
   \      0x100   0xE58D'3000        STR      R3,[SP, #+0]
   \      0x104   0xE084'C087        ADD      R12,R4,R7, LSL #+1
   \      0x108   0xE081'300C        ADD      R3,R1,R12
   \      0x10C   0xE1A0'2000        MOV      R2,R0
   \      0x110   0x5288'8002        ADDPL    R8,R8,#+2
   \      0x114   0x5088'B00B        ADDPL    R11,R8,R11
   \      0x118   0x....'....        BL       lcd_draw_line
   \      0x11C   0xE59D'303C        LDR      R3,[SP, #+60]
   \      0x120   0xE045'1009        SUB      R1,R5,R9
   \      0x124   0xE046'0007        SUB      R0,R6,R7
   \      0x128   0xE58D'3000        STR      R3,[SP, #+0]
   \      0x12C   0xE084'C089        ADD      R12,R4,R9, LSL #+1
   \      0x130   0xE081'300C        ADD      R3,R1,R12
   \      0x134   0xE1A0'2000        MOV      R2,R0
   \      0x138   0x....'....        BL       lcd_draw_line
   \      0x13C   0xE28A'A002        ADD      R10,R10,#+2
   \      0x140   0xE08A'B00B        ADD      R11,R10,R11
   \                     ??lcd_fill_rounded_rect_3:
   \      0x144   0xE159'0007        CMP      R9,R7
   \      0x148   0xBAFF'FFE6        BLT      ??lcd_fill_rounded_rect_4
    892          	}
    893          	_show_canvas();
    894          }
   \                     ??lcd_fill_rounded_rect_0:
   \      0x14C   0xE28D'D014        ADD      SP,SP,#+20
   \      0x150   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     front_color

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     front_color

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     font_param

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _draw_pixel
        16   -> lcdc_get_canvas
      40   _fill_rect
        40   -> __aeabi_memcpy
        40   -> lcdc_get_canvas
      48   _lcd_fill_circle
        48   -> lcd_draw_line
       8   lcd_clear_window
         0   -> _fill_rect
      48   lcd_draw_circle
        48   -> _draw_pixel
       8   lcd_draw_fast_hline
         8   -> lcd_draw_line
       8   lcd_draw_fast_vline
         8   -> lcd_draw_line
      40   lcd_draw_filled_circle
        40   -> _fill_rect
       8   lcd_draw_filled_rectangle
         0   -> _fill_rect
      32   lcd_draw_image
        32   -> __aeabi_memcpy
        32   -> lcdc_get_canvas
      56   lcd_draw_line
        56   -> _draw_pixel
        56   -> _fill_rect
       0   lcd_draw_pixel
         0   -> _draw_pixel
      24   lcd_draw_rectangle
         0   -> _fill_rect
        24   -> _fill_rect
      72   lcd_draw_rounded_rect
        72   -> _draw_pixel
        72   -> lcd_draw_fast_hline
        72   -> lcd_draw_fast_vline
      40   lcd_draw_string
        40   -> lcd_draw_char
        40   -> lcd_get_selected_font
      48   lcd_draw_string_with_bgcolor
        48   -> lcd_draw_char_with_bgcolor
        48   -> lcd_get_selected_font
       8   lcd_fill
         0   -> _fill_rect
         8   -> lcdc_get_canvas
      56   lcd_fill_rounded_rect
        56   -> _lcd_fill_circle
        56   -> lcd_draw_line
      16   lcd_fill_white
         0   -> _fill_rect
        16   -> _fill_rect
        16   -> lcdc_get_canvas
      48   lcd_fill_yuv422
        48   -> lcdc_get_canvas
        48 __aeabi_uidiv
      16   lcd_get_string_size
        16   -> lcd_get_selected_font
      16   lcd_read_pixel
        16   -> lcdc_get_canvas


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
      12  ?Subroutine0
     216  _draw_pixel
     160  _fill_rect
     260  _lcd_fill_circle
       4  front_color
      36  lcd_clear_window
     268  lcd_draw_circle
      28  lcd_draw_fast_hline
      28  lcd_draw_fast_vline
     256  lcd_draw_filled_circle
      24  lcd_draw_filled_rectangle
     140  lcd_draw_image
     308  lcd_draw_line
      12  lcd_draw_pixel
     128  lcd_draw_rectangle
     600  lcd_draw_rounded_rect
     136  lcd_draw_string
     152  lcd_draw_string_with_bgcolor
      36  lcd_fill
     340  lcd_fill_rounded_rect
     160  lcd_fill_white
   1'136  lcd_fill_yuv422
     128  lcd_get_string_size
     172  lcd_read_pixel

 
     4 bytes in section .bss
 4'748 bytes in section SOFTPACK
 
 4'748 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
