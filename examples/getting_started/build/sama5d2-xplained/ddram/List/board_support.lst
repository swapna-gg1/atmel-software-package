###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         31/Mar/2021  13:03:58
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW2DC1.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_TWI -D
#        CONFIG_HAVE_I2C_BUS -D CONFIG_HAVE_TWI_FIFO -D
#        CONFIG_HAVE_PMIC_ACT8945A -D CONFIG_HAVE_LED -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d2-xplained\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d2-xplained\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d2-xplained\ddram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d2-xplained\ddram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d2-xplained\ddram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015-2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          #include "string.h"
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "trace.h"
     44          #include "intmath.h"
     45          
     46          #include "irq/irq.h"
     47          #ifdef CONFIG_HAVE_ISC
     48          #include "video/isc.h"
     49          #endif
     50          #include "peripherals/matrix.h"
     51          #include "gpio/pio.h"
     52          #include "peripherals/pmc.h"
     53          #include "sdmmc/sdmmc.h"
     54          #include "extram/smc.h"
     55          #include "peripherals/wdt.h"
     56          
     57          #include "extram/ddram.h"
     58          
     59          #include "arm/mmu_cp15.h"
     60          #include "mm/l1cache.h"
     61          #include "mm/l2cache_l2cc.h"
     62          
     63          #include "board_support.h"
     64          
     65          #ifdef CONFIG_HAVE_PMIC_ACT8945A
     66          #include "power/act8945a.h"
     67          #endif
     68          
     69          /*----------------------------------------------------------------------------
     70           *        Local constants
     71           *----------------------------------------------------------------------------*/
     72          

   \                                 In section .rodata, align 4, keep-with-next
     73          static const struct _l2cc_config l2cc_cfg = {
   \                     l2cc_cfg:
   \        0x0   0x00 0x3B          DC8 0, 59, 216, 1

   \              0xD8 0x01
     74          	.instruct_prefetch = true,	// Instruction prefetch enable
     75          	.data_prefetch = true,	// Data prefetch enable
     76          	.double_linefill = true,
     77          	.incr_double_linefill = true,
     78          	/* Disable Write back (enables write through, Use this setting
     79          	   if DDR2 mem is not write-back) */
     80          	//cfg.no_write_back = true,
     81          	.non_sec_lockdown = true,
     82          	.cache_replacement = true,
     83          	.force_write_alloc = L2CC_FWA_DEFAULT,
     84          	.offset = 1,
     85          	.prefetch_drop = true,
     86          	.standby_mode = true,
     87          	.dyn_clock_gating = true
     88          };
     89          

   \                                 In section .data, align 4
   \        0x0   0x....'....        DC32 ?_2
     90          static const char* board_name = BOARD_NAME;
     91          
     92          /*----------------------------------------------------------------------------
     93           *        Local variables
     94           *----------------------------------------------------------------------------*/
     95          

   \                                 In section .bss, align 16384
     96          ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     97          
     98          #ifdef CONFIG_HAVE_PMIC_ACT8945A

   \                                 In section .data, align 4
     99          static struct _act8945a act8945a = {
    100          	.bus = BOARD_ACT8945A_TWI_BUS,
    101          	.addr = BOARD_ACT8945A_TWI_ADDR,
    102          	.desc = {
    103          		.pin_chglev = BOARD_ACT8945A_PIN_CHGLEV,
    104          		.pin_irq = BOARD_ACT8945A_PIN_IRQ,
    105          		.pin_lbo = BOARD_ACT8945A_PIN_LBO
    106          	}
    107          };
    108          
    109          static bool act8945a_initialized = false;
   \                     act8945a_initialized:
   \        0x0   0x00               DC8 0
   \        0x1   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \        0x4   0x06 0x5B          DC8 6, 91, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \        0xC   0x0000'1000        DC32 4'096
   \       0x10   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0000'0001        DC32 1
   \       0x18   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'2000        DC32 8'192
   \       0x20   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x0000'0001        DC32 1
   \       0x28   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0100        DC32 256
   \       0x30   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x34   0x0000'0001        DC32 1
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
    110          #endif /* CONFIG_HAVE_PMIC_ACT8945A */
    111          
    112          /*----------------------------------------------------------------------------
    113           *        Local functions
    114           *----------------------------------------------------------------------------*/
    115          
    116          static void board_cfg_matrix_default(void)
    117          {
    118          	matrix_set_default_config();
    119          }
    120          
    121          /*----------------------------------------------------------------------------
    122           *        Exported functions
    123           *----------------------------------------------------------------------------*/

   \                                 In section SOFTPACK, align 4, keep-with-next
    124          const char* get_board_name(void)
    125          {
    126          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable8
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    127          }
    128          

   \                                 In section SOFTPACK, align 4, keep-with-next
    129          void board_cfg_clocks(void)
    130          {
   \                     board_cfg_clocks:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
    131          	struct _pmc_plla_cfg plla_config = {
    132          		.count = 0x3f,
    133          	};
   \        0x4   0x....'....        LDR      R1,??DataTable8_1
   \        0x8   0xE891'100C        LDM      R1,{R2,R3,R12}
   \        0xC   0xE24D'D00C        SUB      SP,SP,#+12
    134          
    135          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
    136          	plla_config.mul = BOARD_PMC_PLLA_MUL;
   \       0x10   0xE3A0'E052        MOV      LR,#+82
   \       0x14   0xE1A0'000D        MOV      R0,SP
    137          	plla_config.div = BOARD_PMC_PLLA_DIV;
   \       0x18   0xE3A0'5001        MOV      R5,#+1
   \       0x1C   0xE880'100C        STM      R0,{R2,R3,R12}
   \       0x20   0xE58D'E000        STR      LR,[SP, #+0]
   \       0x24   0xE58D'5004        STR      R5,[SP, #+4]
    138          #else
    139          	switch (pmc_get_main_oscillator_freq()) {
    140          	case 24000000:
    141          		plla_config.mul = 40;
    142          		plla_config.div = 1;
    143          		break;
    144          	case 16000000:
    145          		plla_config.mul = 61;
    146          		plla_config.div = 1;
    147          		break;
    148          	case 12000000:
    149          		plla_config.mul = 82;
    150          		plla_config.div = 1;
    151          		break;
    152          	}
    153          #endif
    154          	pmc_switch_mck_to_slck();
   \       0x28   0x....'....        BL       pmc_switch_mck_to_slck
    155          	pmc_set_mck_h32mxdiv(true);
   \       0x2C   0xE3A0'0001        MOV      R0,#+1
   \       0x30   0x....'....        BL       pmc_set_mck_h32mxdiv
    156          	pmc_set_mck_plladiv2(true);
   \       0x34   0xE3A0'0001        MOV      R0,#+1
   \       0x38   0x....'....        BL       pmc_set_mck_plladiv2
    157          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0x....'....        BL       pmc_set_mck_prescaler
    158          	pmc_set_mck_divider(PMC_MCKR_MDIV_EQ_PCK);
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0x....'....        BL       pmc_set_mck_divider
    159          	pmc_disable_plla();
   \       0x4C   0x....'....        BL       pmc_disable_plla
    160          	pmc_select_external_osc(false);
   \       0x50   0xE3A0'0000        MOV      R0,#+0
   \       0x54   0x....'....        BL       pmc_select_external_osc
    161          	pmc_configure_plla(&plla_config);
   \       0x58   0xE1A0'000D        MOV      R0,SP
   \       0x5C   0x....'....        BL       pmc_configure_plla
    162          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV3);
   \       0x60   0xE3A0'0FC0        MOV      R0,#+768
   \       0x64   0x....'....        BL       pmc_set_mck_divider
    163          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0x....'....        BL       pmc_set_mck_prescaler
    164          	pmc_switch_mck_to_pll();
   \       0x70   0x....'....        BL       pmc_switch_mck_to_pll
    165          }
   \       0x74   0xE28D'D010        ADD      SP,SP,#+16
   \       0x78   0xE8BD'8020        POP      {R5,PC}          ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0, 0, 63

   \              0x0000'0000  

   \              0x0000'003F
    166          

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    168          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'5001        MOV      R5,R1
   \       0x10   0xE1A0'6002        MOV      R6,R2
    169          	/* Disable Watchdog */
    170          	wdt_disable();
   \       0x14   0x....'....        BL       wdt_disable
    171          
    172          	/* Disable all PIO interrupts */
    173          	pio_reset_all_it();
   \       0x18   0x....'....        BL       pio_reset_all_it
    174          
    175          	/* Set the external oscillator frequency */
    176          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x1C   0xE3A0'08B7        MOV      R0,#+11993088
   \       0x20   0xE380'0D6C        ORR      R0,R0,#0x1B00
   \       0x24   0x....'....        BL       pmc_set_main_oscillator_freq
    177          
    178          	if (clocks) {
   \       0x28   0xE354'0000        CMP      R4,#+0
   \       0x2C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_0
    179          		/* Configure system clocks */
    180          		board_cfg_clocks();
   \       0x30   0x....'....        BL       board_cfg_clocks
    181          	}
    182          
    183          	/* Setup default interrupt handlers */
    184          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0x34   0x....'....        BL       irq_initialize
    185          
    186          	/* Configure system timer */
    187          	board_cfg_timer();
   \       0x38   0x....'....        BL       board_cfg_timer
    188          
    189          	board_cfg_matrix_default();
   \       0x3C   0x....'....        BL       matrix_set_default_config
    190          
    191          	if (ddram) {
   \       0x40   0xE355'0000        CMP      R5,#+0
   \       0x44   0x0A00'0005        BEQ      ??board_cfg_lowlevel_1
    192          		/* Configure DDRAM */
    193          		board_cfg_ddram();
   \       0x48   0x....'....        BL       board_cfg_matrix_for_ddr
   \       0x4C   0xE3A0'1001        MOV      R1,#+1
   \       0x50   0xE1A0'000D        MOV      R0,SP
   \       0x54   0x....'....        BL       ddram_init_descriptor
   \       0x58   0xE1A0'000D        MOV      R0,SP
   \       0x5C   0x....'....        BL       ddram_configure
    194          	}
    195          
    196          	if (mmu) {
   \                     ??board_cfg_lowlevel_1:
   \       0x60   0xE356'0000        CMP      R6,#+0
   \       0x64   0x0A00'0000        BEQ      ??board_cfg_lowlevel_2
    197          		/* Setup MMU */
    198          		board_cfg_mmu();
   \       0x68   0x....'....        BL       board_cfg_mmu
    199          	}
    200          }
   \                     ??board_cfg_lowlevel_2:
   \       0x6C   0xE28D'D030        ADD      SP,SP,#+48
   \       0x70   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void board_restore_pio_reset_state(void)
    203          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    204          	int i;
    205          
    206          	/* all pins, excluding JTAG and NTRST */
    207          	struct _pin pins[] = {
    208          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    209          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    210          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    211          		{ PIO_GROUP_D, 0xFFFFFFFF ^ PIN_JTAG, PIO_INPUT, PIO_PULLUP },
    212          	};
   \        0x8   0x....'....        LDR      R1,??DataTable8_2
   \        0xC   0xE1A0'000D        MOV      R0,SP
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    213          
    214          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1A0'000D        MOV      R0,SP
   \       0x20   0x....'....        BL       pio_configure
    215          	for (i = 0; i < ARRAY_SIZE(pins); i++)
    216          		pio_clear(&pins[i]);
   \       0x24   0xE1A0'000D        MOV      R0,SP
   \       0x28   0x....'....        BL       pio_clear
   \       0x2C   0xE28D'0010        ADD      R0,SP,#+16
   \       0x30   0x....'....        BL       pio_clear
   \       0x34   0xE28D'0020        ADD      R0,SP,#+32
   \       0x38   0x....'....        BL       pio_clear
   \       0x3C   0xE28D'0030        ADD      R0,SP,#+48
   \       0x40   0x....'....        BL       pio_clear
    217          }
   \       0x44   0xE28D'D044        ADD      SP,SP,#+68
   \       0x48   0xE8BD'8000        POP      {PC}             ;; return
    218          

   \                                 In section SOFTPACK, align 4, keep-with-next
    219          void board_save_misc_power(void)
    220          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    221          	int i;
    222          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'04F8        MOV      R0,#-134217728
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0xE380'0B40        ORR      R0,R0,#0x10000
   \       0x10   0xE3A0'5003        MOV      R5,#+3
   \       0x14   0x....'....        BL       get_tc_id_from_addr
   \       0x18   0xE1A0'4000        MOV      R4,R0
    223          
    224          	/* disable USB clock */
    225          	pmc_disable_upll_clock();
   \       0x1C   0x....'....        BL       pmc_disable_upll_clock
    226          	pmc_disable_upll_bias();
   \       0x20   0x....'....        BL       pmc_disable_upll_bias
    227          
    228          	/* Disable audio clock */
    229          	pmc_disable_audio();
   \       0x24   0x....'....        BL       pmc_disable_audio
    230          
    231          	/* disable system clocks */
    232          #ifdef VARIANT_SRAM
    233          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    234          #endif
    235          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0x28   0xE3A0'0001        MOV      R0,#+1
   \       0x2C   0x....'....        BL       pmc_disable_system_clock
    236          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x30   0xE3A0'0003        MOV      R0,#+3
   \       0x34   0x....'....        BL       pmc_disable_system_clock
    237          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UDP);
   \       0x38   0xE3A0'0004        MOV      R0,#+4
   \       0x3C   0x....'....        BL       pmc_disable_system_clock
    238          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x40   0xE3A0'0005        MOV      R0,#+5
   \       0x44   0x....'....        BL       pmc_disable_system_clock
    239          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x48   0xE3A0'0006        MOV      R0,#+6
   \       0x4C   0x....'....        BL       pmc_disable_system_clock
    240          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK2);
   \       0x50   0xE3A0'0007        MOV      R0,#+7
   \       0x54   0x....'....        BL       pmc_disable_system_clock
    241          #ifdef CONFIG_HAVE_ISC
    242          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_ISC);
    243          #endif
    244          
    245          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    246          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x58   0xEA00'0001        B        ??board_save_misc_power_0
    247          		if (i == ID_PIOA)
   \                     ??board_save_misc_power_1:
   \       0x5C   0xE355'0012        CMP      R5,#+18
   \       0x60   0x0A00'0007        BEQ      ??board_save_misc_power_2
    248          			continue;
    249          		if (i == tc_id)
   \                     ??board_save_misc_power_0:
   \       0x64   0xE155'0004        CMP      R5,R4
   \       0x68   0x0A00'0005        BEQ      ??board_save_misc_power_2
    250          			continue;
    251          #ifdef VARIANT_DDRAM
    252          		if (i == ID_MPDDRC)
   \       0x6C   0xE355'000D        CMP      R5,#+13
   \       0x70   0x0A00'0003        BEQ      ??board_save_misc_power_2
    253          			continue;
    254          		if (i == ID_SFRBU)
   \       0x74   0xE355'004D        CMP      R5,#+77
   \       0x78   0x0A00'0001        BEQ      ??board_save_misc_power_2
    255          			continue;
    256          #endif
    257          		pmc_disable_peripheral(i);
   \       0x7C   0xE1A0'0005        MOV      R0,R5
   \       0x80   0x....'....        BL       pmc_disable_peripheral
    258          	}
   \                     ??board_save_misc_power_2:
   \       0x84   0xE285'5001        ADD      R5,R5,#+1
   \       0x88   0xE355'004F        CMP      R5,#+79
   \       0x8C   0xBAFF'FFF2        BLT      ??board_save_misc_power_1
    259          }
   \       0x90   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    260          

   \                                 In section SOFTPACK, align 4, keep-with-next
    261          void board_cfg_mmu(void)
    262          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
    263          	uint32_t addr;
    264          
    265          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'00E3        BNE      ??board_cfg_mmu_0
    266          		return;
    267          
    268          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    269          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    270          	   be verified for correct operation when write-back is enabled */
    271          
    272          	/* Reset table entries */
    273          	for (addr = 0; addr < 4096; addr++)
    274          		tlb[addr] = 0;
   \       0x10   0x....'....        LDR      R4,??DataTable8_3
   \       0x14   0xE3A0'1C40        MOV      R1,#+16384
   \       0x18   0xE1A0'0004        MOV      R0,R4
   \       0x1C   0x....'....        BL       __aeabi_memclr4
    275          
    276          	/* 0x00000000: ROM */
    277          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    278          	           | TTB_SECT_AP_READ_ONLY
    279          	           | TTB_SECT_DOMAIN(0xf)
    280          	           | TTB_SECT_EXEC
    281          	           | TTB_SECT_CACHEABLE_WB
    282          	           | TTB_TYPE_SECT;
   \       0x20   0xE308'09EE        MOVW     R0,#+35310
    283          
    284          	/* 0x00100000: NFC SRAM */
    285          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    286          	           | TTB_SECT_AP_FULL_ACCESS
    287          	           | TTB_SECT_DOMAIN(0xf)
    288          	           | TTB_SECT_EXEC
    289          	           | TTB_SECT_SHAREABLE_DEVICE
    290          	           | TTB_TYPE_SECT;
   \       0x24   0x....'....        LDR      R1,??DataTable8_4  ;; 0x100de6
    291          
    292          	/* 0x00200000: SRAM */
    293          	tlb[0x002] = TTB_SECT_ADDR(0x00200000)
    294          	           | TTB_SECT_AP_FULL_ACCESS
    295          	           | TTB_SECT_DOMAIN(0xf)
    296          	           | TTB_SECT_EXEC
    297          	           | TTB_SECT_CACHEABLE_WB
    298          	           | TTB_TYPE_SECT;
   \       0x28   0x....'....        LDR      R2,??DataTable8_5  ;; 0x200dee
   \       0x2C   0xE584'0000        STR      R0,[R4, #+0]
   \       0x30   0xE584'1004        STR      R1,[R4, #+4]
   \       0x34   0xE584'2008        STR      R2,[R4, #+8]
    299          
    300          #ifdef CONFIG_HAVE_UDPHS
    301          	/* 0x00300000: UDPHS (RAM) */
    302          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    303          	           | TTB_SECT_AP_FULL_ACCESS
    304          	           | TTB_SECT_DOMAIN(0xf)
    305          	           | TTB_SECT_EXEC_NEVER
    306          	           | TTB_SECT_SHAREABLE_DEVICE
    307          	           | TTB_TYPE_SECT;
    308          
    309          	/* 0x00400000: UHPHS (OHCI) */
    310          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    311          	           | TTB_SECT_AP_FULL_ACCESS
    312          	           | TTB_SECT_DOMAIN(0xf)
    313          	           | TTB_SECT_EXEC_NEVER
    314          	           | TTB_SECT_SHAREABLE_DEVICE
    315          	           | TTB_TYPE_SECT;
    316          
    317          	/* 0x00500000: UDPHS (EHCI) */
    318          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    319          	           | TTB_SECT_AP_FULL_ACCESS
    320          	           | TTB_SECT_DOMAIN(0xf)
    321          	           | TTB_SECT_EXEC_NEVER
    322          	           | TTB_SECT_SHAREABLE_DEVICE
    323          	           | TTB_TYPE_SECT;
    324          #endif /* CONFIG_HAVE_UDPHS */
    325          
    326          	/* 0x00600000: AXIMX */
    327          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    328          	           | TTB_SECT_AP_FULL_ACCESS
    329          	           | TTB_SECT_DOMAIN(0xf)
    330          	           | TTB_SECT_EXEC_NEVER
    331          	           | TTB_SECT_SHAREABLE_DEVICE
    332          	           | TTB_TYPE_SECT;
   \       0x38   0x....'....        LDR      R3,??DataTable8_6  ;; 0x600df6
    333          
    334          	/* 0x00700000: DAP */
    335          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    336          	           | TTB_SECT_AP_FULL_ACCESS
    337          	           | TTB_SECT_DOMAIN(0xf)
    338          	           | TTB_SECT_EXEC_NEVER
    339          	           | TTB_SECT_SHAREABLE_DEVICE
    340          	           | TTB_TYPE_SECT;
   \       0x3C   0xE383'0940        ORR      R0,R3,#0x100000
   \       0x40   0xE584'3018        STR      R3,[R4, #+24]
    341          #ifdef CONFIG_HAVE_PPP
    342          	/* 0x00800000: pPP */
    343          	tlb[0x008] = TTB_SECT_ADDR(0x00800000)
    344          	           | TTB_SECT_AP_FULL_ACCESS
    345          	           | TTB_SECT_DOMAIN(0xf)
    346          	           | TTB_SECT_EXEC_NEVER
    347          	           | TTB_SECT_SHAREABLE_DEVICE
    348          	           | TTB_TYPE_SECT;
    349          #endif
    350          #ifdef CONFIG_HAVE_L2CC
    351          	/* 0x00a00000: L2CC */
    352          	tlb[0x00a] = TTB_SECT_ADDR(0x00a00000)
    353          	           | TTB_SECT_AP_FULL_ACCESS
    354          	           | TTB_SECT_DOMAIN(0xf)
    355          	           | TTB_SECT_EXEC_NEVER
    356          	           | TTB_SECT_SHAREABLE_DEVICE
    357          	           | TTB_TYPE_SECT;
   \       0x44   0xE280'19C0        ADD      R1,R0,#+3145728
    358          	tlb[0x00b] = TTB_SECT_ADDR(0x00b00000)
    359          	           | TTB_SECT_AP_FULL_ACCESS
    360          	           | TTB_SECT_DOMAIN(0xf)
    361          	           | TTB_SECT_EXEC_NEVER
    362          	           | TTB_SECT_SHAREABLE_DEVICE
    363          	           | TTB_TYPE_SECT;
   \       0x48   0xE280'2840        ADD      R2,R0,#+4194304
   \       0x4C   0xE584'001C        STR      R0,[R4, #+28]
   \       0x50   0xE584'1028        STR      R1,[R4, #+40]
   \       0x54   0xE584'202C        STR      R2,[R4, #+44]
    364          #endif
    365          
    366          	/* 0x10000000: EBI Chip Select 0 */
    367          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x58   0xE3A0'1F40        MOV      R1,#+256
   \       0x5C   0xE284'2E40        ADD      R2,R4,#+1024
   \       0x60   0xE300'0DF2        MOVW     R0,#+3570
    368          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    369          	                  | TTB_SECT_AP_FULL_ACCESS
    370          	                  | TTB_SECT_DOMAIN(0xf)
    371          	                  | TTB_SECT_EXEC_NEVER
    372          	                  | TTB_SECT_STRONGLY_ORDERED
    373          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_1:
   \       0x64   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x68   0xE281'1001        ADD      R1,R1,#+1
   \       0x6C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \       0x70   0xE281'1001        ADD      R1,R1,#+1
   \       0x74   0xE482'3004        STR      R3,[R2], #+4
   \       0x78   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \       0x7C   0xE281'1001        ADD      R1,R1,#+1
   \       0x80   0xE482'C004        STR      R12,[R2], #+4
   \       0x84   0xE180'3A01        ORR      R3,R0,R1, LSL #+20
   \       0x88   0xE281'1001        ADD      R1,R1,#+1
   \       0x8C   0xE351'0F80        CMP      R1,#+512
   \       0x90   0xE482'E004        STR      LR,[R2], #+4
   \       0x94   0xE482'3004        STR      R3,[R2], #+4
   \       0x98   0x3AFF'FFF1        BCC      ??board_cfg_mmu_1
    374          
    375          	/* 0x20000000: DDR Chip Select */
    376          	/* (64MB cacheable, 448MB strongly ordered) */
    377          	for (addr = 0x200; addr < 0x240; addr++)
   \       0x9C   0xE3A0'2F80        MOV      R2,#+512
   \       0xA0   0xE284'3E80        ADD      R3,R4,#+2048
   \       0xA4   0xE240'1004        SUB      R1,R0,#+4
    378          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    379          	                  | TTB_SECT_AP_FULL_ACCESS
    380          	                  | TTB_SECT_DOMAIN(0xf)
    381          	                  | TTB_SECT_EXEC
    382          	                  | TTB_SECT_CACHEABLE_WB
    383          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_2:
   \       0xA8   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xAC   0xE282'2001        ADD      R2,R2,#+1
   \       0xB0   0xE181'EA02        ORR      LR,R1,R2, LSL #+20
   \       0xB4   0xE282'2001        ADD      R2,R2,#+1
   \       0xB8   0xE483'C004        STR      R12,[R3], #+4
   \       0xBC   0xE181'5A02        ORR      R5,R1,R2, LSL #+20
   \       0xC0   0xE282'2001        ADD      R2,R2,#+1
   \       0xC4   0xE483'E004        STR      LR,[R3], #+4
   \       0xC8   0xE181'CA02        ORR      R12,R1,R2, LSL #+20
   \       0xCC   0xE282'2001        ADD      R2,R2,#+1
   \       0xD0   0xE352'0F90        CMP      R2,#+576
   \       0xD4   0xE483'5004        STR      R5,[R3], #+4
   \       0xD8   0xE483'C004        STR      R12,[R3], #+4
   \       0xDC   0x3AFF'FFF1        BCC      ??board_cfg_mmu_2
    384          	for (addr = 0x240; addr < 0x400; addr++)
   \       0xE0   0xE3A0'3F90        MOV      R3,#+576
   \       0xE4   0xE284'CE90        ADD      R12,R4,#+2304
   \       0xE8   0xE3C0'2010        BIC      R2,R0,#0x10
    385          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    386          	                  | TTB_SECT_AP_FULL_ACCESS
    387          	                  | TTB_SECT_DOMAIN(0xf)
    388          	                  | TTB_SECT_EXEC
    389          	                  | TTB_SECT_STRONGLY_ORDERED
    390          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0xEC   0xE182'EA03        ORR      LR,R2,R3, LSL #+20
   \       0xF0   0xE283'3001        ADD      R3,R3,#+1
   \       0xF4   0xE182'5A03        ORR      R5,R2,R3, LSL #+20
   \       0xF8   0xE283'3001        ADD      R3,R3,#+1
   \       0xFC   0xE48C'E004        STR      LR,[R12], #+4
   \      0x100   0xE182'6A03        ORR      R6,R2,R3, LSL #+20
   \      0x104   0xE283'3001        ADD      R3,R3,#+1
   \      0x108   0xE48C'5004        STR      R5,[R12], #+4
   \      0x10C   0xE182'EA03        ORR      LR,R2,R3, LSL #+20
   \      0x110   0xE283'3001        ADD      R3,R3,#+1
   \      0x114   0xE353'0E40        CMP      R3,#+1024
   \      0x118   0xE48C'6004        STR      R6,[R12], #+4
   \      0x11C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x120   0x3AFF'FFF1        BCC      ??board_cfg_mmu_3
    391          
    392          	/* 0x40000000: DDR AESB Chip Select */
    393          	for (addr = 0x400; addr < 0x600; addr++)
   \      0x124   0xE3A0'3E40        MOV      R3,#+1024
   \      0x128   0xE284'CD40        ADD      R12,R4,#+4096
    394          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    395          	                  | TTB_SECT_AP_FULL_ACCESS
    396          	                  | TTB_SECT_DOMAIN(0xf)
    397          	                  | TTB_SECT_EXEC
    398          	                  | TTB_SECT_CACHEABLE_WB
    399          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_4:
   \      0x12C   0xE181'EA03        ORR      LR,R1,R3, LSL #+20
   \      0x130   0xE283'3001        ADD      R3,R3,#+1
   \      0x134   0xE181'5A03        ORR      R5,R1,R3, LSL #+20
   \      0x138   0xE283'3001        ADD      R3,R3,#+1
   \      0x13C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x140   0xE181'6A03        ORR      R6,R1,R3, LSL #+20
   \      0x144   0xE283'3001        ADD      R3,R3,#+1
   \      0x148   0xE48C'5004        STR      R5,[R12], #+4
   \      0x14C   0xE181'EA03        ORR      LR,R1,R3, LSL #+20
   \      0x150   0xE283'3001        ADD      R3,R3,#+1
   \      0x154   0xE353'0E60        CMP      R3,#+1536
   \      0x158   0xE48C'6004        STR      R6,[R12], #+4
   \      0x15C   0xE48C'E004        STR      LR,[R12], #+4
   \      0x160   0x3AFF'FFF1        BCC      ??board_cfg_mmu_4
    400          
    401          	/* 0x60000000: EBI Chip Select 1 */
    402          	for (addr = 0x600; addr < 0x700; addr++)
   \      0x164   0xE3A0'1E60        MOV      R1,#+1536
   \      0x168   0xE284'3D60        ADD      R3,R4,#+6144
    403          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    404          	                  | TTB_SECT_AP_FULL_ACCESS
    405          	                  | TTB_SECT_DOMAIN(0xf)
    406          	                  | TTB_SECT_EXEC_NEVER
    407          	                  | TTB_SECT_STRONGLY_ORDERED
    408          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_5:
   \      0x16C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x170   0xE281'1001        ADD      R1,R1,#+1
   \      0x174   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x178   0xE281'1001        ADD      R1,R1,#+1
   \      0x17C   0xE483'C004        STR      R12,[R3], #+4
   \      0x180   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x184   0xE281'1001        ADD      R1,R1,#+1
   \      0x188   0xE483'E004        STR      LR,[R3], #+4
   \      0x18C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x190   0xE281'1001        ADD      R1,R1,#+1
   \      0x194   0xE351'0E70        CMP      R1,#+1792
   \      0x198   0xE483'5004        STR      R5,[R3], #+4
   \      0x19C   0xE483'C004        STR      R12,[R3], #+4
   \      0x1A0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_5
    409          
    410          	/* 0x70000000: EBI Chip Select 2 */
    411          	for (addr = 0x700; addr < 0x800; addr++)
   \      0x1A4   0xE3A0'1E70        MOV      R1,#+1792
   \      0x1A8   0xE284'3D70        ADD      R3,R4,#+7168
    412          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    413          	                  | TTB_SECT_AP_FULL_ACCESS
    414          	                  | TTB_SECT_DOMAIN(0xf)
    415          	                  | TTB_SECT_EXEC_NEVER
    416          	                  | TTB_SECT_STRONGLY_ORDERED
    417          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_6:
   \      0x1AC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1B0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1B4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x1B8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1BC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1C0   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x1C4   0xE281'1001        ADD      R1,R1,#+1
   \      0x1C8   0xE483'E004        STR      LR,[R3], #+4
   \      0x1CC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1D0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1D4   0xE351'0E80        CMP      R1,#+2048
   \      0x1D8   0xE483'5004        STR      R5,[R3], #+4
   \      0x1DC   0xE483'C004        STR      R12,[R3], #+4
   \      0x1E0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_6
    418          
    419          	/* 0x80000000: EBI Chip Select 3 */
    420          	for (addr = 0x800; addr < 0x900; addr++)
   \      0x1E4   0xE3A0'1E80        MOV      R1,#+2048
   \      0x1E8   0xE284'3D80        ADD      R3,R4,#+8192
    421          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    422          	                  | TTB_SECT_AP_FULL_ACCESS
    423          	                  | TTB_SECT_DOMAIN(0xf)
    424          	                  | TTB_SECT_EXEC_NEVER
    425          	                  | TTB_SECT_STRONGLY_ORDERED
    426          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_7:
   \      0x1EC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x1F0   0xE281'1001        ADD      R1,R1,#+1
   \      0x1F4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x1F8   0xE281'1001        ADD      R1,R1,#+1
   \      0x1FC   0xE483'C004        STR      R12,[R3], #+4
   \      0x200   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x204   0xE281'1001        ADD      R1,R1,#+1
   \      0x208   0xE483'E004        STR      LR,[R3], #+4
   \      0x20C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x210   0xE281'1001        ADD      R1,R1,#+1
   \      0x214   0xE351'0E90        CMP      R1,#+2304
   \      0x218   0xE483'5004        STR      R5,[R3], #+4
   \      0x21C   0xE483'C004        STR      R12,[R3], #+4
   \      0x220   0x3AFF'FFF1        BCC      ??board_cfg_mmu_7
    427          
    428          	/* 0x90000000: QSPI0/1 AESB MEM */
    429          	for (addr = 0x900; addr < 0xa00; addr++)
   \      0x224   0xE3A0'1E90        MOV      R1,#+2304
   \      0x228   0xE284'3D90        ADD      R3,R4,#+9216
    430          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    431          	                  | TTB_SECT_AP_FULL_ACCESS
    432          	                  | TTB_SECT_DOMAIN(0xf)
    433          	                  | TTB_SECT_EXEC
    434          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    435          	                  | TTB_SECT_CACHEABLE_WB
    436          #else
    437          	                  | TTB_SECT_STRONGLY_ORDERED
    438          #endif
    439          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_8:
   \      0x22C   0xE182'CA01        ORR      R12,R2,R1, LSL #+20
   \      0x230   0xE281'1001        ADD      R1,R1,#+1
   \      0x234   0xE182'EA01        ORR      LR,R2,R1, LSL #+20
   \      0x238   0xE281'1001        ADD      R1,R1,#+1
   \      0x23C   0xE483'C004        STR      R12,[R3], #+4
   \      0x240   0xE182'5A01        ORR      R5,R2,R1, LSL #+20
   \      0x244   0xE281'1001        ADD      R1,R1,#+1
   \      0x248   0xE483'E004        STR      LR,[R3], #+4
   \      0x24C   0xE182'CA01        ORR      R12,R2,R1, LSL #+20
   \      0x250   0xE281'1001        ADD      R1,R1,#+1
   \      0x254   0xE351'0EA0        CMP      R1,#+2560
   \      0x258   0xE483'5004        STR      R5,[R3], #+4
   \      0x25C   0xE483'C004        STR      R12,[R3], #+4
   \      0x260   0x3AFF'FFF1        BCC      ??board_cfg_mmu_8
    440          
    441          	/* 0xa0000000: SDMMC0 */
    442          	for (addr = 0xa00; addr < 0xb00; addr++)
   \      0x264   0xE3A0'1EA0        MOV      R1,#+2560
   \      0x268   0xE284'3DA0        ADD      R3,R4,#+10240
    443          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    444          	                  | TTB_SECT_AP_FULL_ACCESS
    445          	                  | TTB_SECT_DOMAIN(0xf)
    446          	                  | TTB_SECT_EXEC_NEVER
    447          	                  //| TTB_SECT_SHAREABLE_DEVICE
    448          	                  | TTB_SECT_STRONGLY_ORDERED
    449          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_9:
   \      0x26C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x270   0xE281'1001        ADD      R1,R1,#+1
   \      0x274   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x278   0xE281'1001        ADD      R1,R1,#+1
   \      0x27C   0xE483'C004        STR      R12,[R3], #+4
   \      0x280   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x284   0xE281'1001        ADD      R1,R1,#+1
   \      0x288   0xE483'E004        STR      LR,[R3], #+4
   \      0x28C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x290   0xE281'1001        ADD      R1,R1,#+1
   \      0x294   0xE351'0EB0        CMP      R1,#+2816
   \      0x298   0xE483'5004        STR      R5,[R3], #+4
   \      0x29C   0xE483'C004        STR      R12,[R3], #+4
   \      0x2A0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_9
    450          
    451          	/* 0xb0000000: SDMMC1 */
    452          	for (addr = 0xb00; addr < 0xc00; addr++)
   \      0x2A4   0xE3A0'1EB0        MOV      R1,#+2816
   \      0x2A8   0xE284'3DB0        ADD      R3,R4,#+11264
    453          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    454          	                  | TTB_SECT_AP_FULL_ACCESS
    455          	                  | TTB_SECT_DOMAIN(0xf)
    456          	                  | TTB_SECT_EXEC_NEVER
    457          	                  //| TTB_SECT_SHAREABLE_DEVICE
    458          	                  | TTB_SECT_STRONGLY_ORDERED
    459          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_10:
   \      0x2AC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2B0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2B4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x2B8   0xE281'1001        ADD      R1,R1,#+1
   \      0x2BC   0xE483'C004        STR      R12,[R3], #+4
   \      0x2C0   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x2C4   0xE281'1001        ADD      R1,R1,#+1
   \      0x2C8   0xE483'E004        STR      LR,[R3], #+4
   \      0x2CC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2D0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2D4   0xE351'0EC0        CMP      R1,#+3072
   \      0x2D8   0xE483'5004        STR      R5,[R3], #+4
   \      0x2DC   0xE483'C004        STR      R12,[R3], #+4
   \      0x2E0   0x3AFF'FFF1        BCC      ??board_cfg_mmu_10
    460          
    461          	/* 0xc0000000: NFC Command Register */
    462          	for (addr = 0xc00; addr < 0xd00; addr++)
   \      0x2E4   0xE3A0'1EC0        MOV      R1,#+3072
   \      0x2E8   0xE284'3DC0        ADD      R3,R4,#+12288
    463          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    464          	                  | TTB_SECT_AP_FULL_ACCESS
    465          	                  | TTB_SECT_DOMAIN(0xf)
    466          	                  | TTB_SECT_EXEC_NEVER
    467          	                  //| TTB_SECT_SHAREABLE_DEVICE
    468          	                  | TTB_SECT_STRONGLY_ORDERED
    469          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_11:
   \      0x2EC   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x2F0   0xE281'1001        ADD      R1,R1,#+1
   \      0x2F4   0xE180'EA01        ORR      LR,R0,R1, LSL #+20
   \      0x2F8   0xE281'1001        ADD      R1,R1,#+1
   \      0x2FC   0xE483'C004        STR      R12,[R3], #+4
   \      0x300   0xE180'5A01        ORR      R5,R0,R1, LSL #+20
   \      0x304   0xE281'1001        ADD      R1,R1,#+1
   \      0x308   0xE483'E004        STR      LR,[R3], #+4
   \      0x30C   0xE180'CA01        ORR      R12,R0,R1, LSL #+20
   \      0x310   0xE281'1001        ADD      R1,R1,#+1
   \      0x314   0xE351'0ED0        CMP      R1,#+3328
   \      0x318   0xE483'5004        STR      R5,[R3], #+4
   \      0x31C   0xE483'C004        STR      R12,[R3], #+4
   \      0x320   0x3AFF'FFF1        BCC      ??board_cfg_mmu_11
    470          
    471          	/* 0xd0000000: QSPI0/1 MEM */
    472          	for (addr = 0xd00; addr < 0xe00; addr++)
   \      0x324   0xE3A0'0ED0        MOV      R0,#+3328
   \      0x328   0xE284'1DD0        ADD      R1,R4,#+13312
    473          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    474          	                  | TTB_SECT_AP_FULL_ACCESS
    475          	                  | TTB_SECT_DOMAIN(0xf)
    476          	                  | TTB_SECT_EXEC
    477          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    478          	                  | TTB_SECT_CACHEABLE_WB
    479          #else
    480          	                  | TTB_SECT_STRONGLY_ORDERED
    481          #endif
    482          	                  | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_12:
   \      0x32C   0xE182'3A00        ORR      R3,R2,R0, LSL #+20
   \      0x330   0xE280'0001        ADD      R0,R0,#+1
   \      0x334   0xE182'CA00        ORR      R12,R2,R0, LSL #+20
   \      0x338   0xE280'0001        ADD      R0,R0,#+1
   \      0x33C   0xE481'3004        STR      R3,[R1], #+4
   \      0x340   0xE182'EA00        ORR      LR,R2,R0, LSL #+20
   \      0x344   0xE280'0001        ADD      R0,R0,#+1
   \      0x348   0xE481'C004        STR      R12,[R1], #+4
   \      0x34C   0xE182'3A00        ORR      R3,R2,R0, LSL #+20
   \      0x350   0xE280'0001        ADD      R0,R0,#+1
   \      0x354   0xE350'0EE0        CMP      R0,#+3584
   \      0x358   0xE481'E004        STR      LR,[R1], #+4
   \      0x35C   0xE481'3004        STR      R3,[R1], #+4
   \      0x360   0x3AFF'FFF1        BCC      ??board_cfg_mmu_12
    483          
    484          	/* 0xf0000000: Internal Peripherals */
    485          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    486          	           | TTB_SECT_AP_FULL_ACCESS
    487          	           | TTB_SECT_DOMAIN(0xf)
    488          	           | TTB_SECT_EXEC
    489          	           | TTB_SECT_STRONGLY_ORDERED
    490          	           | TTB_TYPE_SECT;
   \      0x364   0xE3A0'0DF0        MOV      R0,#+15360
   \      0x368   0xE382'14F0        ORR      R1,R2,#0xF0000000
   \      0x36C   0xE784'1000        STR      R1,[R4, +R0]
    491          
    492          	/* 0xf8000000: Internal Peripherals */
    493          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    494          	           | TTB_SECT_AP_FULL_ACCESS
    495          	           | TTB_SECT_DOMAIN(0xf)
    496          	           | TTB_SECT_EXEC
    497          	           | TTB_SECT_STRONGLY_ORDERED
    498          	           | TTB_TYPE_SECT;
   \      0x370   0xE084'0000        ADD      R0,R4,R0
   \      0x374   0xE381'2680        ORR      R2,R1,#0x8000000
    499          
    500          	/* 0xfc000000: Internal Peripherals */
    501          	tlb[0xfc0] = TTB_SECT_ADDR(0xfc000000)
    502          	           | TTB_SECT_AP_FULL_ACCESS
    503          	           | TTB_SECT_DOMAIN(0xf)
    504          	           | TTB_SECT_EXEC
    505          	           | TTB_SECT_STRONGLY_ORDERED
    506          	           | TTB_TYPE_SECT;
   \      0x378   0xE381'36C0        ORR      R3,R1,#0xC000000
   \      0x37C   0xE580'2200        STR      R2,[R0, #+512]
   \      0x380   0xE580'3300        STR      R3,[R0, #+768]
    507          
    508          	/* Enable MMU, I-Cache and D-Cache */
    509          	mmu_configure(tlb);
   \      0x384   0xE1A0'0004        MOV      R0,R4
   \      0x388   0x....'....        BL       mmu_configure
    510          	icache_enable();
   \      0x38C   0x....'....        BL       icache_enable
    511          	mmu_enable();
   \      0x390   0x....'....        BL       mmu_enable
    512          	dcache_enable();
   \      0x394   0x....'....        BL       dcache_enable
    513          
    514          	board_cfg_l2cc();
   \      0x398   0xE8BD'4070        POP      {R4-R6,LR}
   \      0x39C   0x....'....        B        ?Subroutine0
   \                     ??board_cfg_mmu_0:
   \      0x3A0   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    515          }
    516          

   \                                 In section SOFTPACK, align 4, keep-with-next
    517          void board_cfg_l2cc(void)
    518          {
    519          	l2cc_configure(&l2cc_cfg);
   \                     board_cfg_l2cc:
   \        0x0   0xE320'F000        Nop
   \        0x4                      REQUIRE ?Subroutine0
   \        0x4                      ;; // Fall through to label ?Subroutine0
    520          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0x....'....        LDR      R0,??DataTable8_7
   \        0x4   0x....'....        B        l2cc_configure   ;; tailcall
    521          

   \                                 In section SOFTPACK, align 4, keep-with-next
    522          void board_cfg_matrix_for_ddr(void)
    523          {
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    524          	int i;
    525          
    526          	/* Disable write protection */
    527          	matrix_remove_write_protection(MATRIX0);
   \        0x4   0xE3A0'44F0        MOV      R4,#-268435456
   \        0x8   0xE384'4B60        ORR      R4,R4,#0x18000
   \        0xC   0xE1A0'0004        MOV      R0,R4
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    528          
    529          	/* 128 KiB internal SRAM: Non-secure */
    530          	matrix_configure_slave_sec(MATRIX0, H64MX_SLAVE_SRAM, 0x1, 0, 0);
   \       0x14   0xE3A0'1000        MOV      R1,#+0
   \       0x18   0xE3A0'3000        MOV      R3,#+0
   \       0x1C   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x20   0xE3A0'2001        MOV      R2,#+1
   \       0x24   0xE3A0'100A        MOV      R1,#+10
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    531          	matrix_set_slave_region_size(MATRIX0, H64MX_SLAVE_SRAM,
    532          			MATRIX_AREA_128K, 0x1);
   \       0x30   0xE3A0'3001        MOV      R3,#+1
   \       0x34   0xE3A0'2005        MOV      R2,#+5
   \       0x38   0xE3A0'100A        MOV      R1,#+10
   \       0x3C   0xE1A0'0004        MOV      R0,R4
   \       0x40   0x....'....        BL       matrix_set_slave_region_size
    533          	matrix_set_slave_split_addr(MATRIX0, H64MX_SLAVE_SRAM,
    534          			MATRIX_AREA_128K, 0x1);
   \       0x44   0xE3A0'3001        MOV      R3,#+1
   \       0x48   0xE3A0'2005        MOV      R2,#+5
   \       0x4C   0xE3A0'100A        MOV      R1,#+10
   \       0x50   0xE1A0'0004        MOV      R0,R4
   \       0x54   0x....'....        BL       matrix_set_slave_split_addr
    535          
    536          	/* External DDR */
    537          	for (i = H64MX_SLAVE_DDR_PORT0; i <= H64MX_SLAVE_DDR_PORT7; i++) {
    538          		matrix_configure_slave_sec(MATRIX0, i, 0xff, 0xff, 0xff);
   \       0x58   0xE3A0'00FF        MOV      R0,#+255
   \       0x5C   0xE3A0'30FF        MOV      R3,#+255
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x64   0xE3A0'20FF        MOV      R2,#+255
   \       0x68   0xE3A0'1002        MOV      R1,#+2
   \       0x6C   0xE1A0'0004        MOV      R0,R4
   \       0x70   0x....'....        BL       matrix_configure_slave_sec
    539          		matrix_set_slave_split_addr(MATRIX0, i, MATRIX_AREA_128M, 0xf);
   \       0x74   0xE3A0'300F        MOV      R3,#+15
   \       0x78   0xE3A0'200F        MOV      R2,#+15
   \       0x7C   0xE3A0'1002        MOV      R1,#+2
   \       0x80   0xE1A0'0004        MOV      R0,R4
   \       0x84   0x....'....        BL       matrix_set_slave_split_addr
    540          		matrix_set_slave_region_size(MATRIX0, i, MATRIX_AREA_128M, 0x1);
   \       0x88   0xE3A0'3001        MOV      R3,#+1
   \       0x8C   0xE3A0'200F        MOV      R2,#+15
   \       0x90   0xE3A0'1002        MOV      R1,#+2
   \       0x94   0xE1A0'0004        MOV      R0,R4
   \       0x98   0x....'....        BL       matrix_set_slave_region_size
   \       0x9C   0xE3A0'00FF        MOV      R0,#+255
   \       0xA0   0xE3A0'30FF        MOV      R3,#+255
   \       0xA4   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xA8   0xE3A0'20FF        MOV      R2,#+255
   \       0xAC   0xE3A0'1003        MOV      R1,#+3
   \       0xB0   0xE1A0'0004        MOV      R0,R4
   \       0xB4   0x....'....        BL       matrix_configure_slave_sec
   \       0xB8   0xE3A0'300F        MOV      R3,#+15
   \       0xBC   0xE3A0'200F        MOV      R2,#+15
   \       0xC0   0xE3A0'1003        MOV      R1,#+3
   \       0xC4   0xE1A0'0004        MOV      R0,R4
   \       0xC8   0x....'....        BL       matrix_set_slave_split_addr
   \       0xCC   0xE3A0'3001        MOV      R3,#+1
   \       0xD0   0xE3A0'200F        MOV      R2,#+15
   \       0xD4   0xE3A0'1003        MOV      R1,#+3
   \       0xD8   0xE1A0'0004        MOV      R0,R4
   \       0xDC   0x....'....        BL       matrix_set_slave_region_size
   \       0xE0   0xE3A0'00FF        MOV      R0,#+255
   \       0xE4   0xE3A0'30FF        MOV      R3,#+255
   \       0xE8   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xEC   0xE3A0'20FF        MOV      R2,#+255
   \       0xF0   0xE3A0'1004        MOV      R1,#+4
   \       0xF4   0xE1A0'0004        MOV      R0,R4
   \       0xF8   0x....'....        BL       matrix_configure_slave_sec
   \       0xFC   0xE3A0'300F        MOV      R3,#+15
   \      0x100   0xE3A0'200F        MOV      R2,#+15
   \      0x104   0xE3A0'1004        MOV      R1,#+4
   \      0x108   0xE1A0'0004        MOV      R0,R4
   \      0x10C   0x....'....        BL       matrix_set_slave_split_addr
   \      0x110   0xE3A0'3001        MOV      R3,#+1
   \      0x114   0xE3A0'200F        MOV      R2,#+15
   \      0x118   0xE3A0'1004        MOV      R1,#+4
   \      0x11C   0xE1A0'0004        MOV      R0,R4
   \      0x120   0x....'....        BL       matrix_set_slave_region_size
   \      0x124   0xE3A0'00FF        MOV      R0,#+255
   \      0x128   0xE3A0'30FF        MOV      R3,#+255
   \      0x12C   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x130   0xE3A0'20FF        MOV      R2,#+255
   \      0x134   0xE3A0'1005        MOV      R1,#+5
   \      0x138   0xE1A0'0004        MOV      R0,R4
   \      0x13C   0x....'....        BL       matrix_configure_slave_sec
   \      0x140   0xE3A0'300F        MOV      R3,#+15
   \      0x144   0xE3A0'200F        MOV      R2,#+15
   \      0x148   0xE3A0'1005        MOV      R1,#+5
   \      0x14C   0xE1A0'0004        MOV      R0,R4
   \      0x150   0x....'....        BL       matrix_set_slave_split_addr
   \      0x154   0xE3A0'3001        MOV      R3,#+1
   \      0x158   0xE3A0'200F        MOV      R2,#+15
   \      0x15C   0xE3A0'1005        MOV      R1,#+5
   \      0x160   0xE1A0'0004        MOV      R0,R4
   \      0x164   0x....'....        BL       matrix_set_slave_region_size
   \      0x168   0xE3A0'00FF        MOV      R0,#+255
   \      0x16C   0xE3A0'30FF        MOV      R3,#+255
   \      0x170   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x174   0xE3A0'20FF        MOV      R2,#+255
   \      0x178   0xE3A0'1006        MOV      R1,#+6
   \      0x17C   0xE1A0'0004        MOV      R0,R4
   \      0x180   0x....'....        BL       matrix_configure_slave_sec
   \      0x184   0xE3A0'300F        MOV      R3,#+15
   \      0x188   0xE3A0'200F        MOV      R2,#+15
   \      0x18C   0xE3A0'1006        MOV      R1,#+6
   \      0x190   0xE1A0'0004        MOV      R0,R4
   \      0x194   0x....'....        BL       matrix_set_slave_split_addr
   \      0x198   0xE3A0'3001        MOV      R3,#+1
   \      0x19C   0xE3A0'200F        MOV      R2,#+15
   \      0x1A0   0xE3A0'1006        MOV      R1,#+6
   \      0x1A4   0xE1A0'0004        MOV      R0,R4
   \      0x1A8   0x....'....        BL       matrix_set_slave_region_size
   \      0x1AC   0xE3A0'00FF        MOV      R0,#+255
   \      0x1B0   0xE3A0'30FF        MOV      R3,#+255
   \      0x1B4   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x1B8   0xE3A0'20FF        MOV      R2,#+255
   \      0x1BC   0xE3A0'1007        MOV      R1,#+7
   \      0x1C0   0xE1A0'0004        MOV      R0,R4
   \      0x1C4   0x....'....        BL       matrix_configure_slave_sec
   \      0x1C8   0xE3A0'300F        MOV      R3,#+15
   \      0x1CC   0xE3A0'200F        MOV      R2,#+15
   \      0x1D0   0xE3A0'1007        MOV      R1,#+7
   \      0x1D4   0xE1A0'0004        MOV      R0,R4
   \      0x1D8   0x....'....        BL       matrix_set_slave_split_addr
   \      0x1DC   0xE3A0'3001        MOV      R3,#+1
   \      0x1E0   0xE3A0'200F        MOV      R2,#+15
   \      0x1E4   0xE3A0'1007        MOV      R1,#+7
   \      0x1E8   0xE1A0'0004        MOV      R0,R4
   \      0x1EC   0x....'....        BL       matrix_set_slave_region_size
   \      0x1F0   0xE3A0'00FF        MOV      R0,#+255
   \      0x1F4   0xE3A0'30FF        MOV      R3,#+255
   \      0x1F8   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x1FC   0xE3A0'20FF        MOV      R2,#+255
   \      0x200   0xE3A0'1008        MOV      R1,#+8
   \      0x204   0xE1A0'0004        MOV      R0,R4
   \      0x208   0x....'....        BL       matrix_configure_slave_sec
   \      0x20C   0xE3A0'300F        MOV      R3,#+15
   \      0x210   0xE3A0'200F        MOV      R2,#+15
   \      0x214   0xE3A0'1008        MOV      R1,#+8
   \      0x218   0xE1A0'0004        MOV      R0,R4
   \      0x21C   0x....'....        BL       matrix_set_slave_split_addr
   \      0x220   0xE3A0'3001        MOV      R3,#+1
   \      0x224   0xE3A0'200F        MOV      R2,#+15
   \      0x228   0xE3A0'1008        MOV      R1,#+8
   \      0x22C   0xE1A0'0004        MOV      R0,R4
   \      0x230   0x....'....        BL       matrix_set_slave_region_size
   \      0x234   0xE3A0'00FF        MOV      R0,#+255
   \      0x238   0xE3A0'30FF        MOV      R3,#+255
   \      0x23C   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x240   0xE3A0'20FF        MOV      R2,#+255
   \      0x244   0xE3A0'1009        MOV      R1,#+9
   \      0x248   0xE1A0'0004        MOV      R0,R4
   \      0x24C   0x....'....        BL       matrix_configure_slave_sec
   \      0x250   0xE3A0'300F        MOV      R3,#+15
   \      0x254   0xE3A0'200F        MOV      R2,#+15
   \      0x258   0xE3A0'1009        MOV      R1,#+9
   \      0x25C   0xE1A0'0004        MOV      R0,R4
   \      0x260   0x....'....        BL       matrix_set_slave_split_addr
   \      0x264   0xE1A0'0004        MOV      R0,R4
   \      0x268   0xE28D'D008        ADD      SP,SP,#+8
   \      0x26C   0xE8BD'4010        POP      {R4,LR}
   \      0x270   0xE3A0'3001        MOV      R3,#+1
   \      0x274   0xE3A0'200F        MOV      R2,#+15
   \      0x278   0xE3A0'1009        MOV      R1,#+9
   \      0x27C   0x....'....        B        matrix_set_slave_region_size  ;; tailcall
    541          	}
    542          }
    543          

   \                                 In section SOFTPACK, align 4, keep-with-next
    544          void board_cfg_matrix_for_nand(void)
    545          {
   \                     board_cfg_matrix_for_nand:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    546          	/* Disable write protection */
    547          	matrix_remove_write_protection(MATRIX1);
   \        0x4   0xE3A0'44FC        MOV      R4,#-67108864
   \        0x8   0xE384'4BF0        ORR      R4,R4,#0x3C000
   \        0xC   0xE1A0'0004        MOV      R0,R4
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    548          
    549          	/* NFC Command Register */
    550          	matrix_configure_slave_sec(MATRIX1,
    551          			H32MX_SLAVE_NFC_CMD, 0xc0, 0xc0, 0xc0);
   \       0x14   0xE3A0'10C0        MOV      R1,#+192
   \       0x18   0xE3A0'30C0        MOV      R3,#+192
   \       0x1C   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x20   0xE3A0'20C0        MOV      R2,#+192
   \       0x24   0xE3A0'1003        MOV      R1,#+3
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    552          	matrix_set_slave_split_addr(MATRIX1,
    553          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x30   0xE3A0'30C0        MOV      R3,#+192
   \       0x34   0xE3A0'200F        MOV      R2,#+15
   \       0x38   0xE3A0'1003        MOV      R1,#+3
   \       0x3C   0xE1A0'0004        MOV      R0,R4
   \       0x40   0x....'....        BL       matrix_set_slave_split_addr
    554          	matrix_set_slave_region_size(MATRIX1,
    555          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x44   0xE3A0'30C0        MOV      R3,#+192
   \       0x48   0xE3A0'200F        MOV      R2,#+15
   \       0x4C   0xE3A0'1003        MOV      R1,#+3
   \       0x50   0xE1A0'0004        MOV      R0,R4
   \       0x54   0x....'....        BL       matrix_set_slave_region_size
    556          
    557          	/* NFC SRAM */
    558          	matrix_configure_slave_sec(MATRIX1,
    559          			H32MX_SLAVE_NFC_SRAM, 0x1, 0x1, 0x1);
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xE3A0'3001        MOV      R3,#+1
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x64   0xE3A0'2001        MOV      R2,#+1
   \       0x68   0xE3A0'1004        MOV      R1,#+4
   \       0x6C   0xE1A0'0004        MOV      R0,R4
   \       0x70   0x....'....        BL       matrix_configure_slave_sec
    560          	matrix_set_slave_split_addr(MATRIX1,
    561          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x74   0xE3A0'3001        MOV      R3,#+1
   \       0x78   0xE3A0'2001        MOV      R2,#+1
   \       0x7C   0xE3A0'1004        MOV      R1,#+4
   \       0x80   0xE1A0'0004        MOV      R0,R4
   \       0x84   0x....'....        BL       matrix_set_slave_split_addr
    562          	matrix_set_slave_region_size(MATRIX1,
    563          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x88   0xE1A0'0004        MOV      R0,R4
   \       0x8C   0xE28D'D008        ADD      SP,SP,#+8
   \       0x90   0xE8BD'4010        POP      {R4,LR}
   \       0x94   0xE3A0'3001        MOV      R3,#+1
   \       0x98   0xE3A0'2001        MOV      R2,#+1
   \       0x9C   0xE3A0'1004        MOV      R1,#+4
   \       0xA0   0x....'....        B        matrix_set_slave_region_size  ;; tailcall
    564          }
    565          

   \                                 In section SOFTPACK, align 4, keep-with-next
    566          void board_cfg_ddram(void)
    567          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
    568          #ifdef BOARD_DDRAM_TYPE
    569          	board_cfg_matrix_for_ddr();
   \        0x8   0x....'....        BL       board_cfg_matrix_for_ddr
    570          	struct _mpddrc_desc desc;
    571          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \        0xC   0xE3A0'1001        MOV      R1,#+1
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0x....'....        BL       ddram_init_descriptor
    572          	ddram_configure(&desc);
   \       0x18   0xE1A0'000D        MOV      R0,SP
   \       0x1C   0x....'....        BL       ddram_configure
    573          #endif
    574          }
   \       0x20   0xE28D'D034        ADD      SP,SP,#+52
   \       0x24   0xE8BD'8000        POP      {PC}             ;; return
    575          
    576          #ifdef CONFIG_HAVE_NAND_FLASH
    577          void board_cfg_nand_flash(void)
    578          {
    579          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    580          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    581          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
    582          	board_cfg_matrix_for_nand();
    583          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
    584          #else
    585          	trace_fatal("Cannot configure NAND: target board has no NAND definitions!");
    586          #endif
    587          }
    588          #endif /* CONFIG_HAVE_NAND_FLASH */
    589          
    590          #ifdef CONFIG_HAVE_SDMMC
    591          #if defined(BOARD_SDMMC0_PINS) || defined(BOARD_SDMMC1_PINS)
    592          static void board_cfg_sd_clk_caps(uint32_t periph_id, uint32_t *caps0,
    593              uint32_t *caps1)
    594          {
    595          		uint32_t base_freq, mult_freq, val;
    596          
    597          		/* Retrieve the frequency of BASECLK and TEOCLK.
    598          		 * Usual values of this frequency are 12 MHz, 24 MHz. */
    599          		base_freq = pmc_get_main_clock();
    600          		base_freq = ROUND_INT_DIV(base_freq, 1000000lu);
    601          		val = base_freq > (SDMMC_CA0R_BASECLKF_Msk >> SDMMC_CA0R_BASECLKF_Pos)
    602          		    ? 0 : base_freq;
    603          		*caps0 |= SDMMC_CA0R_BASECLKF(val);
    604          		val = base_freq > (SDMMC_CA0R_TEOCLKF_Msk >> SDMMC_CA0R_TEOCLKF_Pos)
    605          		    ? 0 : base_freq;
    606          		*caps0 |= SDMMC_CA0R_TEOCLKF(val) | SDMMC_CA0R_TEOCLKU;
    607          
    608          		/* Retrieve the frequency of MULTCLK.
    609          		 * Usual values of this frequency are 100 MHz, 104 MHz. */
    610          		mult_freq = pmc_get_gck_clock(periph_id);
    611          		base_freq *= 1000000lu;
    612          		val = ROUND_INT_DIV(mult_freq, base_freq);
    613          		val = val < 2 ? 1 : val - 1;
    614          		val = min_u32(val, SDMMC_CA1R_CLKMULT_Msk >> SDMMC_CA1R_CLKMULT_Pos);
    615          		*caps1 |= SDMMC_CA1R_CLKMULT(val);
    616          }
    617          #endif
    618          
    619          bool board_cfg_sdmmc(uint32_t periph_id)
    620          {
    621          	switch (periph_id) {
    622          #ifdef SDMMC0
    623          	case ID_SDMMC0:
    624          	{
    625          #if defined(BOARD_SDMMC0_CAPS0) && defined(BOARD_SDMMC0_PINS)
    626          		struct _pin pins[] = BOARD_SDMMC0_PINS;
    627          		uint32_t caps0 = BOARD_SDMMC0_CAPS0, caps1 = 0;
    628          
    629          #ifdef CONFIG_BOARD_SAMA5D2_XPLAINED
    630          		struct _pin vsel_pin = PIN_SDMMC0_VDDSEL_IOS1;
    631          		int vsel_ix;
    632          
    633          #ifndef SDMMC_TRIM_LOW_VOLTAGE
    634          		/* Set PMIC output 7 to 1.8V (VDDSDHC1V8) */
    635          		if (!act8945a_initialized) {
    636          			board_cfg_pmic();
    637          			if (!act8945a_initialized)
    638          				return false;
    639          		}
    640          		if (!act8945a_set_regulator_voltage(&act8945a, 7, 1800))
    641          			return false;
    642          		if (!act8945a_enable_regulator(&act8945a, 7, true))
    643          			return false;
    644          #endif
    645          
    646          		/* The PIOs of SDMMC0 normally include SDMMC0_VDDSEL. On regular
    647          		 * SAMA5D2-XULT, the SDMMC0_VDDSEL line has a pull-down resistor
    648          		 * hence at power-on time VCCQ is 3.3V. In this default config
    649          		 * we enable SDMMC0_VDDSEL, which can switch VCCQ to 1.8V.
    650          		 * Changing VCCQ on the fly is required with UHS-I SD cards. It
    651          		 * is illegal with e.MMC devices. Detect if the board has been
    652          		 * modified to supply 1.8V VCCQ at power-on time.
    653          		 * First, search for the SDMMC0_VDDSEL PIO on this board. */
    654          		for (vsel_ix = 0; vsel_ix < ARRAY_SIZE(pins); vsel_ix++)
    655          			if (pins[vsel_ix].mask == vsel_pin.mask
    656          			    && pins[vsel_ix].group == vsel_pin.group)
    657          				break;
    658          		if (vsel_ix < ARRAY_SIZE(pins)) {
    659          			/* Second, sense whether the SDMMC0_VDDSEL line is
    660          			 * pulled up or down */
    661          			vsel_pin.type = PIO_INPUT;
    662          			vsel_pin.attribute = PIO_PULLUP;
    663          			pio_configure(&vsel_pin, 1);
    664          			if (pio_get(&vsel_pin)) {
    665          				/* The line is pulled up => at power-on time
    666          				 * VCCQ is 1.8V. If the SDMMC0_VDDSEL function
    667          				 * was enabled, then everytime SRR:SWRSTALL was
    668          				 * triggered, VCCQ would switch to 3.3V. */
    669          				pins[vsel_ix].type = PIO_OUTPUT_1;
    670          				pins[vsel_ix].attribute = PIO_DEFAULT;
    671          				/* Deviation from the specification: we use the
    672          				 * Voltage Support capabilities to indicate the
    673          				 * supported signaling levels (VCCQ). */
    674          				caps0 &= ~SDMMC_CA0R_V33VSUP;
    675          				caps0 &= ~SDMMC_CA0R_V30VSUP;
    676          				caps0 |= SDMMC_CA0R_V18VSUP;
    677          			}
    678          		}
    679          #endif
    680          		/* Program capabilities for SDMMC0 */
    681          		board_cfg_sd_clk_caps(ID_SDMMC0, &caps0, &caps1);
    682          		sdmmc_set_capabilities(SDMMC0, caps0, SDMMC_CA0R_SLTYPE_Msk |
    683          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    684          		    SDMMC_CA0R_ED8SUP | SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    685          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    686          
    687          		/* Configure SDMMC0 pins */
    688          		pio_configure(pins, ARRAY_SIZE(pins));
    689          		return true;
    690          #else
    691          		trace_fatal("Cannot configure SDMMC0: target board has no SDMMC0 definitions!");
    692          		return false;
    693          #endif
    694          	}
    695          #endif
    696          	case ID_SDMMC1:
    697          	{
    698          #if defined(BOARD_SDMMC1_CAPS0) && defined(BOARD_SDMMC1_PINS)
    699          		const struct _pin pins[] = BOARD_SDMMC1_PINS;
    700          		uint32_t caps0 = BOARD_SDMMC1_CAPS0, caps1 = 0;
    701          
    702          		/* Program capabilities for SDMMC1 */
    703          		board_cfg_sd_clk_caps(ID_SDMMC1, &caps0, &caps1);
    704          		sdmmc_set_capabilities(SDMMC1, caps0, SDMMC_CA0R_SLTYPE_Msk |
    705          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    706          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    707          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    708          
    709          		/* Configure SDMMC1 pins */
    710          		pio_configure(pins, ARRAY_SIZE(pins));
    711          		return true;
    712          #else
    713          		trace_fatal("Cannot configure SDMMC1: target board has no SDMMC1 definitions!");
    714          		return false;
    715          #endif
    716          	}
    717          	default:
    718          		return false;
    719          	}
    720          }
    721          #endif /* CONFIG_HAVE_SDMMC */
    722          

   \                                 In section SOFTPACK, align 4, keep-with-next
    723          void board_cfg_pmic(void)
    724          {
   \                     board_cfg_pmic:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    725          #ifdef CONFIG_HAVE_PMIC_ACT8945A
    726          	if (act8945a_initialized)
   \        0x4   0x....'....        LDR      R4,??DataTable8_8
   \        0x8   0xE5D4'1000        LDRB     R1,[R4, #+0]
   \        0xC   0xE351'0000        CMP      R1,#+0
   \       0x10   0x1A00'0019        BNE      ??board_cfg_pmic_0
    727          		return;
    728          
    729          	if (!act8945a_configure(&act8945a))
   \       0x14   0xE284'0004        ADD      R0,R4,#+4
   \       0x18   0x....'....        BL       act8945a_configure
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x0A00'000E        BEQ      ??board_cfg_pmic_1
    730          		goto Fail;
    731          #if defined(CONFIG_BOARD_SAMA5D2_XPLAINED)
    732          	/* Set PMIC output 6 to 2.5V (VDD_LED) */
    733          	if (!act8945a_set_regulator_voltage(&act8945a, 6, 2500))
   \       0x24   0xE300'29C4        MOVW     R2,#+2500
   \       0x28   0xE3A0'1006        MOV      R1,#+6
   \       0x2C   0xE284'0004        ADD      R0,R4,#+4
   \       0x30   0x....'....        BL       act8945a_set_regulator_voltage
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x0A00'0008        BEQ      ??board_cfg_pmic_1
    734          		goto Fail;
    735          	if (!act8945a_enable_regulator(&act8945a, 6, true))
   \       0x3C   0xE3A0'2001        MOV      R2,#+1
   \       0x40   0xE3A0'1006        MOV      R1,#+6
   \       0x44   0xE284'0004        ADD      R0,R4,#+4
   \       0x48   0x....'....        BL       act8945a_enable_regulator
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x0A00'0002        BEQ      ??board_cfg_pmic_1
    736          		goto Fail;
    737          #endif
    738          	act8945a_initialized = true;
   \       0x54   0xE3A0'0001        MOV      R0,#+1
   \       0x58   0xE5C4'0000        STRB     R0,[R4, #+0]
    739          	return;
   \       0x5C   0xE8BD'8010        POP      {R4,PC}
    740          
    741          Fail:
    742          	trace_error("Error initializing ACT8945A PMIC\r\n");
   \                     ??board_cfg_pmic_1:
   \       0x60   0x....'....        LDR      R1,??DataTable8_9
   \       0x64   0xE591'2000        LDR      R2,[R1, #+0]
   \       0x68   0xE352'0002        CMP      R2,#+2
   \       0x6C   0x3A00'0002        BCC      ??board_cfg_pmic_0
   \       0x70   0xE8BD'4010        POP      {R4,LR}
   \       0x74   0x....'....        LDR      R0,??DataTable8_10
   \       0x78   0x....'....        B        printf           ;; tailcall
    743          #endif
    744          }
   \                     ??board_cfg_pmic_0:
   \       0x7C   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x0010'0DE6        DC32     0x100de6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x0020'0DEE        DC32     0x200dee

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x0060'0DF6        DC32     0x600df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     l2cc_cfg

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     act8945a_initialized

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFF8'3FFF        DC32 4'294'459'391
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x45          DC8 "-E- Error initializing ACT8945A PMIC\015\012"

   \              0x2D 0x20    

   \              0x45 0x72    

   \              0x72 0x6F    

   \              0x72 0x20    

   \              0x69 0x6E    

   \              0x69 0x74    

   \              0x69 0x61    

   \              0x6C 0x69    

   \              0x7A 0x69    

   \              0x6E 0x67    

   \              0x20 0x41    

   \              0x43 0x54    

   \              0x38 0x39    

   \              0x34 0x35    

   \              0x41 0x20    

   \              0x50 0x4D    

   \              0x49 0x43    

   \              0x0D 0x0A    

   \              0x00
   \       0x27   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x73 0x61          DC8 "sama5d2-xult"

   \              0x6D 0x61    

   \              0x35 0x64    

   \              0x32 0x2D    

   \              0x78 0x75    

   \              0x6C 0x74    

   \              0x00
   \        0xD   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   board_cfg_clocks
        24   -> pmc_configure_plla
        24   -> pmc_disable_plla
        24   -> pmc_select_external_osc
        24   -> pmc_set_mck_divider
        24   -> pmc_set_mck_h32mxdiv
        24   -> pmc_set_mck_plladiv2
        24   -> pmc_set_mck_prescaler
        24   -> pmc_switch_mck_to_pll
        24   -> pmc_switch_mck_to_slck
      56   board_cfg_ddram
        56   -> board_cfg_matrix_for_ddr
        56   -> ddram_configure
        56   -> ddram_init_descriptor
       0   board_cfg_l2cc
         0   -> l2cc_configure
      64   board_cfg_lowlevel
        64   -> board_cfg_clocks
        64   -> board_cfg_matrix_for_ddr
        64   -> board_cfg_mmu
        64   -> board_cfg_timer
        64   -> ddram_configure
        64   -> ddram_init_descriptor
        64   -> irq_initialize
        64   -> matrix_set_default_config
        64   -> pio_reset_all_it
        64   -> pmc_set_main_oscillator_freq
        64   -> wdt_disable
      16   board_cfg_matrix_for_ddr
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
         0   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
      16   board_cfg_matrix_for_nand
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
         0   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
      16   board_cfg_mmu
        16   -> __aeabi_memclr4
        16   -> dcache_enable
        16   -> icache_enable
         0   -> l2cc_configure
        16   -> mmu_configure
        16   -> mmu_enable
        16   -> mmu_is_enabled
       8   board_cfg_pmic
         8   -> act8945a_configure
         8   -> act8945a_enable_regulator
         8   -> act8945a_set_regulator_voltage
         0   -> printf
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_audio
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_bias
        16   -> pmc_disable_upll_clock
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable8
        4  ??DataTable8_1
        4  ??DataTable8_10
        4  ??DataTable8_2
        4  ??DataTable8_3
        4  ??DataTable8_4
        4  ??DataTable8_5
        4  ??DataTable8_6
        4  ??DataTable8_7
        4  ??DataTable8_8
        4  ??DataTable8_9
        8  ?Subroutine0
       64  ?_0
       40  ?_1
       16  ?_2
       12  ?_3
       64  act8945a_initialized
           act8945a
      124  board_cfg_clocks
       40  board_cfg_ddram
        4  board_cfg_l2cc
      116  board_cfg_lowlevel
      640  board_cfg_matrix_for_ddr
      164  board_cfg_matrix_for_nand
      932  board_cfg_mmu
      128  board_cfg_pmic
        4  board_name
       76  board_restore_pio_reset_state
      148  board_save_misc_power
        8  get_board_name
        4  l2cc_cfg
   16'384  tlb

 
 16'384 bytes in section .bss
     68 bytes in section .data
    136 bytes in section .rodata
  2'432 bytes in section SOFTPACK
 
  2'432 bytes of CODE  memory
    136 bytes of CONST memory
 16'452 bytes of DATA  memory

Errors: none
Warnings: none
