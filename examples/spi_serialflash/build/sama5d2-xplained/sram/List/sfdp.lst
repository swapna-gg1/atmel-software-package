###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         19/Aug/2020  13:39:17
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
#    Command line                 =
#        -f C:\Users\c40450\AppData\Local\Temp\EW65E4.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D
#        CONFIG_HAVE_SPI_FIFO -D CONFIG_HAVE_SPI_AT25 -D CONFIG_DRV_AT25 -D
#        CONFIG_HAVE_SPI_NOR -D CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D
#        CONFIG_HAVE_L2CACHE -D CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D
#        CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\build\sama5d2-xplained\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\build\sama5d2-xplained\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\build\sama5d2-xplained\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                       =  C
#    List file                    =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\build\sama5d2-xplained\sram\List\sfdp.lst
#    Object file                  =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\spi_serialflash\build\sama5d2-xplained\sram\Obj\sfdp.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\nvm\spi-nor\sfdp.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2017, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           */
     28          
     29          /*----------------------------------------------------------------------------
     30           *        Headers
     31           *----------------------------------------------------------------------------*/
     32          
     33          #include "errno.h"
     34          #include "nvm/spi-nor/sfdp.h"
     35          #include "nvm/spi-nor/spi-nor.h"
     36          #include "string.h"
     37          
     38          /*----------------------------------------------------------------------------
     39           *        Local Functions
     40           *----------------------------------------------------------------------------*/
     41          
     42          static int spi_flash_read_sfdp(struct spi_flash *flash, size_t from, size_t len, void *buf)
     43          {
     44          	struct spi_flash_command cmd;
     45          
     46          	spi_flash_command_init(&cmd, SFLASH_INST_READ_SFDP, 3, SFLASH_TYPE_READ);
     47          	cmd.proto = flash->read_proto;
     48          	cmd.addr = from;
     49          	cmd.num_wait_states = 8;
     50          	cmd.data_len = len;
     51          	cmd.rx_data = buf;
     52          	return spi_flash_exec(flash, &cmd);
     53          }
     54          
     55          struct sfdp_parameter_header {
     56          	uint8_t id_lsb;
     57          	uint8_t minor;
     58          	uint8_t major;
     59          	uint8_t length; /* in double words */
     60          	uint8_t parameter_table_pointer[3]; /* byte address */
     61          	uint8_t id_msb;
     62          };
     63          
     64          #define SFDP_PARAM_HEADER_ID(p)	((uint16_t)(((p)->id_msb << 8) | (p)->id_lsb))
     65          #define SFDP_PARAM_HEADER_PTP(p)				\
     66          	((uint32_t)(((p)->parameter_table_pointer[2] << 16) |	\
     67          	       ((p)->parameter_table_pointer[1] <<  8) |	\
     68          	       ((p)->parameter_table_pointer[0] <<  0)))
     69          
     70          
     71          #define SFDP_BFPT_ID		0xff00u	/* Basic Flash Parameter Table */
     72          #define SFDP_4BAIT_ID		0xff84u	/* 4-byte Address Instruction Table */
     73          
     74          #define SFDP_SIGNATURE		0x50444653u
     75          #define SFDP_JESD216_MAJOR	1
     76          #define SFDP_JESD216_MINOR	0
     77          #define SFDP_JESD216A_MINOR	5
     78          #define SFDP_JESD216B_MINOR	6
     79          
     80          struct sfdp_header {
     81          	uint32_t signature; /* Ox50444653 <=> "SFDP" */
     82          	uint8_t minor;
     83          	uint8_t major;
     84          	uint8_t nph; /* 0-base number of parameter headers */
     85          	uint8_t unused;
     86          
     87          	/* Basic Flash Parameter Table. */
     88          	struct sfdp_parameter_header bfpt_header;
     89          };
     90          
     91          /* Basic Flash Parameter Table */
     92          
     93          /*
     94           * JESD216B defines a Basic Flash Parameter Table of 16 DWORDs.
     95           * They are indexed from 1 but C arrays are indexed from 0.
     96           */
     97          enum sfdp_bfpt_dword {
     98          	BFPT_DWORD1 = 0,
     99          	BFPT_DWORD2,
    100          	BFPT_DWORD3,
    101          	BFPT_DWORD4,
    102          	BFPT_DWORD5,
    103          	BFPT_DWORD6,
    104          	BFPT_DWORD7,
    105          	BFPT_DWORD8,
    106          	BFPT_DWORD9,
    107          	BFPT_DWORD10,
    108          	BFPT_DWORD11,
    109          	BFPT_DWORD12,
    110          	BFPT_DWORD13,
    111          	BFPT_DWORD14,
    112          	BFPT_DWORD15,
    113          	BFPT_DWORD16,
    114          
    115          	BFPT_DWORD_MAX
    116          };
    117          
    118          /* The first revision of JESB216 defined only 9 DWORDs. */
    119          #define BFPT_DWORD_MAX_JESD216			9
    120          
    121          /* 1st DWORD. */
    122          #define BFPT_DWORD1_FAST_READ_1_1_2      (0x1UL << 16)
    123          #define BFPT_DWORD1_ADDRESS_BYTES_MASK   (0x3UL << 17)
    124          #define BFPT_DWORD1_ADDRESS_BYTES_3_ONLY (0x0UL << 17)
    125          #define BFPT_DWORD1_ADDRESS_BYTES_3_OR_4 (0x1UL << 17)
    126          #define BFPT_DWORD1_ADDRESS_BYTES_4_ONLY (0x2UL << 17)
    127          #define BFPT_DWORD1_DTR                  (0x1UL << 19)
    128          #define BFPT_DWORD1_FAST_READ_1_2_2      (0x1UL << 20)
    129          #define BFPT_DWORD1_FAST_READ_1_4_4      (0x1UL << 21)
    130          #define BFPT_DWORD1_FAST_READ_1_1_4      (0x1UL << 22)
    131          
    132          /* 5th DWORD. */
    133          #define BFPT_DWORD5_FAST_READ_2_2_2      (0x1UL << 0)
    134          #define BFPT_DWORD5_FAST_READ_4_4_4      (0x1UL << 4)
    135          
    136          /* 11th DWORD. */
    137          #define BFPT_DWORD11_PAGE_SIZE_SHIFT     4
    138          #define BFPT_DWORD11_PAGE_SIZE_MASK      (0xFUL << 4)
    139          
    140          /* 15th DWORD. */
    141          
    142          /*
    143           * (from JESD216B)
    144           * Quad Enable Requirements (QER):
    145           * - 000b: Device does not have a QE bit. Device detects 1-1-4 and 1-4-4
    146           *         reads based on instruction. DQ3/HOLD# functions are hold during
    147           *         instruction pahse.
    148           * - 001b: QE is bit 1 of status register 2. It is set via Write Status with
    149           *         two data bytes where bit 1 of the second byte is one.
    150           *         [...]
    151           *         Writing only one byte to the status register has the side-effect of
    152           *         clearing status register 2, including the QE bit. The 100b code is
    153           *         used if writing one byte to the status register does not modify
    154           *         status register 2.
    155           * - 010b: QE is bit 6 of status register 1. It is set via Write Status with
    156           *         one data byte where bit 6 is one.
    157           *         [...]
    158           * - 011b: QE is bit 7 of status register 2. It is set via Write status
    159           *         register 2 instruction 3Eh with one data byte where bit 7 is one.
    160           *         [...]
    161           *         The status register 2 is read using instruction 3Fh.
    162           * - 100b: QE is bit 1 of status register 2. It is set via Write Status with
    163           *         two data bytes where bit 1 of the second byte is one.
    164           *         [...]
    165           *         In contrast to the 001b code, writing one byte to the status
    166           *         register does not modify status register 2.
    167           * - 101b: QE is bit 1 of status register 2. Status register 1 is read using
    168           *         Read Status instruction 05h. Status register2 is read using
    169           *         instruction 35h. QE is set via Writ Status instruction 01h with
    170           *         two data bytes where bit 1 of the second byte is one.
    171           *         [...]
    172           */
    173          #define BFPT_DWORD15_QER_MASK           (0x7UL << 20)
    174          #define BFPT_DWORD15_QER_NONE           (0x0UL << 20) /* Micron */
    175          #define BFPT_DWORD15_QER_SR2_BIT1_BUGGY	(0x1UL << 20)
    176          #define BFPT_DWORD15_QER_SR1_BIT6       (0x2UL << 20) /* Macronix */
    177          #define BFPT_DWORD15_QER_SR2_BIT7       (0x3UL << 20)
    178          #define BFPT_DWORD15_QER_SR2_BIT1_NO_RD (0x4UL << 20)
    179          #define BFPT_DWORD15_QER_SR2_BIT1       (0x5UL << 20) /* Spansion */
    180          
    181          /*
    182           * (from JESD216B)
    183           * 0-4-4 Mode Entry Method:
    184           * - xxx1b: Mode Bits[7:0] = A5h Note: QE must be set prior to using the mode
    185           * - xx1xb: Read the 8-bit volatile configuration register with 85h, set XIP
    186           *          bit[3] in the data read, and write the modified data using the
    187           *          instruction 81h, then Mode Bits[7:0] = 01h
    188           * - x1xxb: Mode Bit[7:0] = AXh
    189           * - 1xxxb: Reserved
    190           */
    191          #define BFPT_DWORD15_0_4_4_MASK          (0xFUL << 16)
    192          #define BFPT_DWORD15_0_4_4_A5            (0x1UL << 16)
    193          #define BFPT_DWORD15_0_4_4_MICRON        (0x1UL << 17)
    194          #define BFPT_DWORD15_0_4_4_AX            (0x1UL << 18)
    195          
    196          struct sfdp_bfpt {
    197          	uint32_t dwords[BFPT_DWORD_MAX];
    198          };
    199          
    200          /* Fast Read settings. */
    201          
    202          static inline void
    203          spi_flash_set_read_settings_from_bfpt(struct spi_flash_read_command *read, uint16_t half, enum spi_flash_protocol proto)
    204          {
    205          	read->num_mode_cycles = (half >> 5) & 0x07u;
    206          	read->num_wait_states = (half >> 0) & 0x1Fu;
    207          	read->inst = (half >> 8) & 0xFFu;
    208          	read->proto = proto;
    209          }
    210          
    211          struct sfdp_bfpt_read {
    212          	/* The Fast Read x-y-z hardware capability in params->hwcaps.mask. */
    213          	uint32_t hwcaps;
    214          
    215          	/*
    216          	 * The <supported_bit> bit in <supported_dword> BFPT DWORD tells us
    217          	 * whether the Fast Read x-y-z command is supported.
    218          	 */
    219          	enum sfdp_bfpt_dword supported_dword;
    220          	uint32_t supported_bit;
    221          
    222          	/*
    223          	 * The half-word at offset <setting_shift> in <setting_dword> BFPT DWORD
    224          	 * encodes the op code, the number of mode clocks and the number of wait
    225          	 * states to be used by Fast Read x-y-z command.
    226          	 */
    227          	enum sfdp_bfpt_dword settings_dword;
    228          	int settings_shift;
    229          
    230          	/* The SPI protocol for this Fast Read x-y-z command. */
    231          	enum spi_flash_protocol proto;
    232          };
    233          

   \                                 In section .rodata, align 4
    234          static const struct sfdp_bfpt_read sfdp_bfpt_reads[] = {
   \                     sfdp_bfpt_reads:
   \        0x0   0x0000'0004        DC32 4
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x8   0x0001'0000        DC32 65'536
   \        0xC   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x10   0x0000'0000        DC32 0, 65'794, 8

   \              0x0001'0102  

   \              0x0000'0008
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x20   0x0010'0000        DC32 1'048'576
   \       0x24   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x28   0x0000'0010        DC32 16, 66'050, 16

   \              0x0001'0202  

   \              0x0000'0010
   \       0x34   0x04 0x00          DC8 4, 0, 0, 0

   \              0x00 0x00
   \       0x38   0x0000'0001        DC32 1
   \       0x3C   0x05 0x00          DC8 5, 0, 0, 0

   \              0x00 0x00
   \       0x40   0x0000'0010        DC32 16, 131'586, 32

   \              0x0002'0202  

   \              0x0000'0020
   \       0x4C   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x50   0x0040'0000        DC32 4'194'304
   \       0x54   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x58   0x0000'0010        DC32 16, 65'796, 64

   \              0x0001'0104  

   \              0x0000'0040
   \       0x64   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x68   0x0020'0000        DC32 2'097'152
   \       0x6C   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x70   0x0000'0000        DC32 0, 66'564, 128

   \              0x0001'0404  

   \              0x0000'0080
   \       0x7C   0x04 0x00          DC8 4, 0, 0, 0

   \              0x00 0x00
   \       0x80   0x0000'0010        DC32 16
   \       0x84   0x06 0x00          DC8 6, 0, 0, 0

   \              0x00 0x00
   \       0x88   0x0000'0010        DC32 16, 263'172

   \              0x0004'0404
    235          	/* Fast Read 1-1-2 */
    236          	{
    237          		SFLASH_HWCAPS_READ_1_1_2,
    238          		BFPT_DWORD1, (0x1UL << 16),
    239          		BFPT_DWORD4, 0,
    240          		SFLASH_PROTO_1_1_2,
    241          	},
    242          
    243          	/* Fast Read 1-2-2 */
    244          	{
    245          		SFLASH_HWCAPS_READ_1_2_2,
    246          		BFPT_DWORD1, (0x1UL << 20),
    247          		BFPT_DWORD4, 16,
    248          		SFLASH_PROTO_1_2_2,
    249          	},
    250          
    251          	/* Fast Read 2-2-2 */
    252          	{
    253          		SFLASH_HWCAPS_READ_2_2_2,
    254          		BFPT_DWORD5, (0x1UL << 0),
    255          		BFPT_DWORD6, 16,
    256          		SFLASH_PROTO_2_2_2,
    257          	},
    258          
    259          	/* Fast Read 1-1-4 */
    260          	{
    261          		SFLASH_HWCAPS_READ_1_1_4,
    262          		BFPT_DWORD1, (0x1UL << 22),
    263          		BFPT_DWORD3, 16,
    264          		SFLASH_PROTO_1_1_4,
    265          	},
    266          
    267          	/* Fast Read 1-4-4 */
    268          	{
    269          		SFLASH_HWCAPS_READ_1_4_4,
    270          		BFPT_DWORD1, (0x1UL << 21),
    271          		BFPT_DWORD3, 0,
    272          		SFLASH_PROTO_1_4_4,
    273          	},
    274          
    275          	/* Fast Read 4-4-4 */
    276          	{
    277          		SFLASH_HWCAPS_READ_4_4_4,
    278          		BFPT_DWORD5, (0x1UL << 4),
    279          		BFPT_DWORD7, 16,
    280          		SFLASH_PROTO_4_4_4,
    281          	},
    282          };
    283          
    284          
    285          /* Sector Erase settings. */
    286          
    287          static inline void spi_flash_set_erase_command_from_bfpt(struct spi_flash_erase_command *cmd, uint16_t half)
    288          {
    289          	uint32_t size = (half >> 0) & 0xff;
    290          	uint8_t inst = (half >> 8) & 0xff;
    291          
    292          	/* size == 0 means this Erase Type is not supported. */
    293          	if (size)
    294          		size = (0x1UL << size);
    295          	spi_flash_set_erase_command(cmd, size, inst);
    296          }
    297          
    298          struct sfdp_bfpt_erase {
    299          	/*
    300          	 * The half-word at offset <shift> in DWORD <dword> encodes the
    301          	 * op code and erase sector size to be used by Sector Erase commands.
    302          	 */
    303          	enum sfdp_bfpt_dword	dword;
    304          	int			shift;
    305          };
    306          

   \                                 In section SOFTPACK, align 4, keep-with-next
    307          static const struct sfdp_bfpt_erase sfdp_bfpt_erases[SFLASH_CMD_ERASE_MAX] = {
   \                     sfdp_bfpt_erases:
   \        0x0   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'0000        DC32 0
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16
   \       0x10   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0000'0000        DC32 0
   \       0x18   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0010        DC32 16
    308          	/* Erase Type 1 in DWORD8 bits[15:0] */
    309          	{BFPT_DWORD8, 0},
    310          
    311          	/* Erase Type 2 in DWORD8 bits[31:16] */
    312          	{BFPT_DWORD8, 16},
    313          
    314          	/* Erase Type 3 in DWORD9 bits[15:0] */
    315          	{BFPT_DWORD9, 0},
    316          
    317          	/* Erase Type 4: in DWORD9 bits[31:16] */
    318          	{BFPT_DWORD9, 16},
    319          };
    320          
    321          static int spi_flash_parse_bfpt(struct spi_flash *flash,
    322          				const struct sfdp_parameter_header *bfpt_header,
    323          				struct spi_flash_parameters *params)
    324          {
    325          	struct spi_flash_erase_map *map = &flash->erase_map;
    326          	struct sfdp_bfpt bfpt;
    327          	size_t len;
    328          	int i, cmd, rc;
    329          	uint32_t addr, erase_mask;
    330          	uint16_t half;
    331          
    332          	/* JESD216 Basic Flash Parameter Table length is at least 9 DWORDs. */
    333          	if (bfpt_header->length < BFPT_DWORD_MAX_JESD216)
    334          		return -EINVAL;
    335          
    336          	/* Read the Basic Flash Parameter Table. */
    337          	len = min_u32(sizeof(bfpt), sizeof(uint32_t) * bfpt_header->length);
    338          	addr = SFDP_PARAM_HEADER_PTP(bfpt_header);
    339          	memset(&bfpt, 0, sizeof(bfpt));
    340          	rc = spi_flash_read_sfdp(flash,  addr, len, &bfpt);
    341          	if (rc < 0)
    342          		return rc;
    343          
    344          	/* Flash Memory Density (in bits). */
    345          	params->size = bfpt.dwords[BFPT_DWORD2];
    346          	if (params->size & (0x1UL << 31)) {
    347          		params->size &= ~(0x1UL << 31);
    348          		params->size = 1UL << params->size;
    349          	} else {
    350          		params->size++;
    351          	}
    352          	params->size >>= 3; /* Convert to bytes. */
    353          
    354          	/* Fast Read settings. */
    355          	for (i = 0; i < ARRAY_SIZE(sfdp_bfpt_reads); i++) {
    356          		const struct sfdp_bfpt_read *rd = &sfdp_bfpt_reads[i];
    357          		struct spi_flash_read_command *read;
    358          
    359          		if (!(bfpt.dwords[rd->supported_dword] & rd->supported_bit))
    360          			continue;
    361          
    362          		params->hwcaps.mask |= rd->hwcaps;
    363          		cmd = spi_flash_hwcaps2cmd(rd->hwcaps);
    364          		read = &params->reads[cmd];
    365          		half = bfpt.dwords[rd->settings_dword] >> rd->settings_shift;
    366          		spi_flash_set_read_settings_from_bfpt(read, half, rd->proto);
    367          	}
    368          
    369          	/* Sector Erase settings. */
    370          	erase_mask = 0;
    371          	for (i = 0; i < SFLASH_CMD_ERASE_MAX; i++) {
    372          		const struct sfdp_bfpt_erase *er = &sfdp_bfpt_erases[i];
    373          
    374          		half = bfpt.dwords[er->dword] >> er->shift;
    375          		spi_flash_set_erase_command_from_bfpt(&map->commands[i], half);
    376          
    377          		if (map->commands[i].size)
    378          			erase_mask |= (0x1UL << i);
    379          	}
    380          	spi_flash_init_uniform_erase_map(map, erase_mask, params->size);
    381          
    382          	/* Stop here if not JESD216 rev A or later. */
    383          	if (bfpt_header->length < BFPT_DWORD_MAX)
    384          		return 0;
    385          
    386          	/* Page size: this field specifies 'N' so the page size = 2^N bytes. */
    387          	params->page_size = bfpt.dwords[BFPT_DWORD11];
    388          	params->page_size &= BFPT_DWORD11_PAGE_SIZE_MASK;
    389          	params->page_size >>= BFPT_DWORD11_PAGE_SIZE_SHIFT;
    390          	params->page_size = (0x1UL << params->page_size);
    391          
    392          	/* Enable Quad I/O. */
    393          	switch (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_QER_MASK) {
    394          	default:
    395          	case BFPT_DWORD15_QER_NONE:
    396          		params->quad_enable = NULL;
    397          		break;
    398          
    399          	case BFPT_DWORD15_QER_SR2_BIT1_BUGGY:
    400          	case BFPT_DWORD15_QER_SR2_BIT1_NO_RD:
    401          		params->quad_enable = spansion_quad_enable;
    402          		break;
    403          
    404          	case BFPT_DWORD15_QER_SR1_BIT6:
    405          		params->quad_enable = macronix_quad_enable;
    406          		break;
    407          
    408          	case BFPT_DWORD15_QER_SR2_BIT7:
    409          		params->quad_enable = sr2_bit7_quad_enable;
    410          		break;
    411          
    412          	case BFPT_DWORD15_QER_SR2_BIT1:
    413          		params->quad_enable = spansion_new_quad_enable;
    414          		break;
    415          	}
    416          
    417          	/* 0-4-4 Mode Entry Method. */
    418          	flash->enable_0_4_4 = NULL;
    419          	if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_MICRON) {
    420          		flash->enable_0_4_4 = micron_enable_0_4_4;
    421          		flash->xip_mode = 0x00u;
    422          	} else if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_A5) {
    423          		flash->xip_mode = 0xA5u;
    424          	} else if (bfpt.dwords[BFPT_DWORD15] & BFPT_DWORD15_0_4_4_AX) {
    425          		flash->xip_mode = 0xA0u;
    426          	}
    427          
    428          	return 0;
    429          }
    430          

   \                                 In section .bss, align 4
    431          static struct sfdp_header header;
    432          static struct sfdp_parameter_header param_header;
   \                     param_header:
   \        0x0                      DS8 8
   \        0x8                      DS8 16
    433          
    434          /*----------------------------------------------------------------------------
    435           *        Exported Functions
    436           *----------------------------------------------------------------------------*/
    437          

   \                                 In section SOFTPACK, align 4, keep-with-next
    438          int spi_flash_parse_sfdp(struct spi_flash *flash, struct spi_flash_parameters *params)
    439          {
   \                     spi_flash_parse_sfdp:
   \        0x0   0xE92D'4FF0        PUSH     {R4-R11,LR}
   \        0x4   0xE24D'D074        SUB      SP,SP,#+116
   \        0x8   0xE1A0'8000        MOV      R8,R0
   \        0xC   0xE1A0'6001        MOV      R6,R1
    440          	struct sfdp_parameter_header bfpt_header;
    441          	int i, rc;
    442          
    443          	/* Get the SFDP header. */
    444          	rc = spi_flash_read_sfdp(flash, 0, sizeof(header), &header);
   \       0x10   0xE3A0'3000        MOV      R3,#+0
   \       0x14   0xE3A0'2003        MOV      R2,#+3
   \       0x18   0xE3A0'105A        MOV      R1,#+90
   \       0x1C   0xE28D'0008        ADD      R0,SP,#+8
   \       0x20   0x....'....        LDR      R5,??DataTable1
   \       0x24   0x....'....        BL       spi_flash_command_init
   \       0x28   0xE598'0020        LDR      R0,[R8, #+32]
   \       0x2C   0xE3A0'1010        MOV      R1,#+16
   \       0x30   0xE3A0'7000        MOV      R7,#+0
   \       0x34   0xE3A0'4008        MOV      R4,#+8
   \       0x38   0xE58D'101C        STR      R1,[SP, #+28]
   \       0x3C   0xE58D'0008        STR      R0,[SP, #+8]
   \       0x40   0xE285'0008        ADD      R0,R5,#+8
   \       0x44   0xE58D'7018        STR      R7,[SP, #+24]
   \       0x48   0xE58D'0024        STR      R0,[SP, #+36]
   \       0x4C   0xE5CD'4013        STRB     R4,[SP, #+19]
   \       0x50   0xE28D'1008        ADD      R1,SP,#+8
   \       0x54   0xE1A0'0008        MOV      R0,R8
   \       0x58   0x....'....        BL       spi_flash_exec
    445          	if (rc < 0)
   \       0x5C   0xE350'0000        CMP      R0,#+0
   \       0x60   0x4A00'00FB        BMI      ??spi_flash_parse_sfdp_0
    446          		return rc;
    447          
    448          	/* Check the SFDP header version. */
    449          	if (header.signature != SFDP_SIGNATURE ||
    450          	    header.major != SFDP_JESD216_MAJOR ||
    451          	    header.minor < SFDP_JESD216_MINOR)
                 	                 ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \       0x64   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x68   0x....'....        LDR      R1,??DataTable1_1  ;; 0x50444653
   \       0x6C   0xE150'0001        CMP      R0,R1
   \       0x70   0x1A00'0040        BNE      ??spi_flash_parse_sfdp_1
   \       0x74   0xE5D5'200D        LDRB     R2,[R5, #+13]
   \       0x78   0xE352'0001        CMP      R2,#+1
   \       0x7C   0x1A00'003D        BNE      ??spi_flash_parse_sfdp_1
    452          		return -EINVAL;
    453          
    454          	/*
    455          	 * Verify that the first and only mandatory parameter header is a
    456          	 * Basic Flash Parameter Table header as specified in JESD216.
    457          	 */
    458          	memcpy(&bfpt_header, &header.bfpt_header, sizeof(bfpt_header));
   \       0x80   0xE285'0010        ADD      R0,R5,#+16
   \       0x84   0xE1A0'100D        MOV      R1,SP
   \       0x88   0xE890'000C        LDM      R0,{R2,R3}
   \       0x8C   0xE881'000C        STM      R1,{R2,R3}
    459          	if (SFDP_PARAM_HEADER_ID(&bfpt_header) != SFDP_BFPT_ID ||
    460          	    bfpt_header.major != SFDP_JESD216_MAJOR)
   \       0x90   0xE5DD'3007        LDRB     R3,[SP, #+7]
   \       0x94   0xE5DD'1000        LDRB     R1,[SP, #+0]
   \       0x98   0xE181'1403        ORR      R1,R1,R3, LSL #+8
   \       0x9C   0xE351'0CFF        CMP      R1,#+65280
   \       0xA0   0x1A00'0034        BNE      ??spi_flash_parse_sfdp_1
   \       0xA4   0xE5DD'0002        LDRB     R0,[SP, #+2]
   \       0xA8   0xE350'0001        CMP      R0,#+1
   \       0xAC   0x1A00'0031        BNE      ??spi_flash_parse_sfdp_1
    461          		return -EINVAL;
    462          
    463          	/*
    464          	 * Check other parameter headers to get the latest revision of
    465          	 * the basic flash parameter table.
    466          	 */
    467          	for (i = 0; i < header.nph; i++) {
   \       0xB0   0xE3A0'9000        MOV      R9,#+0
   \       0xB4   0xEA00'0027        B        ??spi_flash_parse_sfdp_2
    468          		rc = spi_flash_read_sfdp(flash, sizeof(header) +
    469          					 i * sizeof(param_header),
    470          					 sizeof(param_header),
    471          					 &param_header);
   \                     ??spi_flash_parse_sfdp_3:
   \       0xB8   0xE3A0'3000        MOV      R3,#+0
   \       0xBC   0xE3A0'2003        MOV      R2,#+3
   \       0xC0   0xE3A0'105A        MOV      R1,#+90
   \       0xC4   0xE28D'0008        ADD      R0,SP,#+8
   \       0xC8   0x....'....        BL       spi_flash_command_init
   \       0xCC   0xE598'0020        LDR      R0,[R8, #+32]
   \       0xD0   0xE3A0'2010        MOV      R2,#+16
   \       0xD4   0xE5CD'4013        STRB     R4,[SP, #+19]
   \       0xD8   0xE082'2189        ADD      R2,R2,R9, LSL #+3
   \       0xDC   0xE58D'401C        STR      R4,[SP, #+28]
   \       0xE0   0xE58D'0008        STR      R0,[SP, #+8]
   \       0xE4   0xE58D'2018        STR      R2,[SP, #+24]
   \       0xE8   0xE58D'5024        STR      R5,[SP, #+36]
   \       0xEC   0xE28D'1008        ADD      R1,SP,#+8
   \       0xF0   0xE1A0'0008        MOV      R0,R8
   \       0xF4   0x....'....        BL       spi_flash_exec
    472          		if (rc < 0)
   \       0xF8   0xE350'0000        CMP      R0,#+0
   \       0xFC   0x4A00'00D4        BMI      ??spi_flash_parse_sfdp_0
    473          			goto exit;
    474          
    475          		if (SFDP_PARAM_HEADER_ID(&param_header) == SFDP_BFPT_ID &&
    476          		    param_header.major == SFDP_JESD216_MAJOR &&
    477          		    (param_header.minor > bfpt_header.minor ||
    478          		     (param_header.minor == bfpt_header.minor &&
    479          		      param_header.length > bfpt_header.length)))
   \      0x100   0xE5D5'0007        LDRB     R0,[R5, #+7]
   \      0x104   0xE5D5'1000        LDRB     R1,[R5, #+0]
   \      0x108   0xE181'1400        ORR      R1,R1,R0, LSL #+8
   \      0x10C   0xE351'0CFF        CMP      R1,#+65280
   \      0x110   0x1A00'000F        BNE      ??spi_flash_parse_sfdp_4
   \      0x114   0xE5D5'0002        LDRB     R0,[R5, #+2]
   \      0x118   0xE350'0001        CMP      R0,#+1
   \      0x11C   0x1A00'000C        BNE      ??spi_flash_parse_sfdp_4
   \      0x120   0xE5D5'0001        LDRB     R0,[R5, #+1]
   \      0x124   0xE5DD'1001        LDRB     R1,[SP, #+1]
   \      0x128   0xE151'0000        CMP      R1,R0
   \      0x12C   0x3A00'0005        BCC      ??spi_flash_parse_sfdp_5
   \      0x130   0xE150'0001        CMP      R0,R1
   \      0x134   0x1A00'0006        BNE      ??spi_flash_parse_sfdp_4
   \      0x138   0xE5DD'1003        LDRB     R1,[SP, #+3]
   \      0x13C   0xE5D5'2003        LDRB     R2,[R5, #+3]
   \      0x140   0xE151'0002        CMP      R1,R2
   \      0x144   0x2A00'0002        BCS      ??spi_flash_parse_sfdp_4
    480          			memcpy(&bfpt_header, &param_header, sizeof(bfpt_header));
   \                     ??spi_flash_parse_sfdp_5:
   \      0x148   0xE895'0006        LDM      R5,{R1,R2}
   \      0x14C   0xE1A0'000D        MOV      R0,SP
   \      0x150   0xE880'0006        STM      R0,{R1,R2}
    481          	}
   \                     ??spi_flash_parse_sfdp_4:
   \      0x154   0xE289'9001        ADD      R9,R9,#+1
   \                     ??spi_flash_parse_sfdp_2:
   \      0x158   0xE5D5'100E        LDRB     R1,[R5, #+14]
   \      0x15C   0xE159'0001        CMP      R9,R1
   \      0x160   0xBAFF'FFD4        BLT      ??spi_flash_parse_sfdp_3
    482          	rc = spi_flash_parse_bfpt(flash, &bfpt_header, params);
   \      0x164   0xE5DD'1003        LDRB     R1,[SP, #+3]
   \      0x168   0xE58D'8008        STR      R8,[SP, #+8]
   \      0x16C   0xE351'0008        CMP      R1,#+8
   \      0x170   0xE58D'100C        STR      R1,[SP, #+12]
   \      0x174   0xCA00'0001        BGT      ??spi_flash_parse_sfdp_6
   \                     ??spi_flash_parse_sfdp_1:
   \      0x178   0xE3E0'001B        MVN      R0,#+27
    483          	if (rc < 0)
    484          		goto exit;
    485          
    486          	/* Parse other parameter headers. */
    487          	for (i = 0; i < header.nph; i++) {
    488          		rc = spi_flash_read_sfdp(flash,
    489          					 sizeof(header) +
    490          					 i * sizeof(param_header),
    491          					 sizeof(param_header),
    492          					 &param_header);
    493          		if (rc < 0)
    494          			goto exit;
    495          
    496          		switch (SFDP_PARAM_HEADER_ID(&param_header)) {
    497          		default:
    498          			break;
    499          		}
    500          
    501          		if (rc < 0)
    502          			goto exit;
    503          	}
    504          
    505          exit:
    506          	return rc;
   \      0x17C   0x....'....        B        ?Subroutine0
   \                     ??spi_flash_parse_sfdp_6:
   \      0x180   0xE5DD'0003        LDRB     R0,[SP, #+3]
   \      0x184   0xE3A0'1040        MOV      R1,#+64
   \      0x188   0xE1A0'8100        LSL      R8,R0,#+2
   \      0x18C   0xE28D'0010        ADD      R0,SP,#+16
   \      0x190   0xE358'0040        CMP      R8,#+64
   \      0x194   0x83A0'8040        MOVHI    R8,#+64
   \      0x198   0x....'....        BL       __aeabi_memclr4
   \      0x19C   0xE3A0'3000        MOV      R3,#+0
   \      0x1A0   0xE3A0'2003        MOV      R2,#+3
   \      0x1A4   0xE3A0'105A        MOV      R1,#+90
   \      0x1A8   0xE28D'0050        ADD      R0,SP,#+80
   \      0x1AC   0x....'....        BL       spi_flash_command_init
   \      0x1B0   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x1B4   0xE5DD'0006        LDRB     R0,[SP, #+6]
   \      0x1B8   0xE591'2020        LDR      R2,[R1, #+32]
   \      0x1BC   0xE5DD'1004        LDRB     R1,[SP, #+4]
   \      0x1C0   0xE5CD'405B        STRB     R4,[SP, #+91]
   \      0x1C4   0xE58D'2050        STR      R2,[SP, #+80]
   \      0x1C8   0xE5DD'2005        LDRB     R2,[SP, #+5]
   \      0x1CC   0xE58D'8064        STR      R8,[SP, #+100]
   \      0x1D0   0xE1A0'3402        LSL      R3,R2,#+8
   \      0x1D4   0xE183'3800        ORR      R3,R3,R0, LSL #+16
   \      0x1D8   0xE59D'0008        LDR      R0,[SP, #+8]
   \      0x1DC   0xE181'1003        ORR      R1,R1,R3
   \      0x1E0   0xE58D'1060        STR      R1,[SP, #+96]
   \      0x1E4   0xE28D'1010        ADD      R1,SP,#+16
   \      0x1E8   0xE58D'106C        STR      R1,[SP, #+108]
   \      0x1EC   0xE28D'1050        ADD      R1,SP,#+80
   \      0x1F0   0x....'....        BL       spi_flash_exec
   \      0x1F4   0xE350'0000        CMP      R0,#+0
   \      0x1F8   0x4A00'0095        BMI      ??spi_flash_parse_sfdp_0
   \      0x1FC   0xE59D'0014        LDR      R0,[SP, #+20]
   \      0x200   0x....'....        LDR      R8,??DataTable1_2
   \      0x204   0xE3A0'9006        MOV      R9,#+6
   \      0x208   0xE310'0480        TST      R0,#0x80000000
   \      0x20C   0xE586'0000        STR      R0,[R6, #+0]
   \      0x210   0x13A0'1001        MOVNE    R1,#+1
   \      0x214   0x0280'2001        ADDEQ    R2,R0,#+1
   \      0x218   0x11A0'0011        LSLNE    R0,R1,R0
   \      0x21C   0x0586'2000        STREQ    R2,[R6, #+0]
   \      0x220   0x1586'0000        STRNE    R0,[R6, #+0]
   \      0x224   0xE596'3000        LDR      R3,[R6, #+0]
   \      0x228   0xE1A0'C1A3        LSR      R12,R3,#+3
   \      0x22C   0xE586'C000        STR      R12,[R6, #+0]
   \                     ??spi_flash_parse_sfdp_7:
   \      0x230   0xE5D8'1004        LDRB     R1,[R8, #+4]
   \      0x234   0xE28D'0010        ADD      R0,SP,#+16
   \      0x238   0xE790'2101        LDR      R2,[R0, +R1, LSL #+2]
   \      0x23C   0xE598'0008        LDR      R0,[R8, #+8]
   \      0x240   0xE110'0002        TST      R0,R2
   \      0x244   0x0A00'0014        BEQ      ??spi_flash_parse_sfdp_8
   \      0x248   0xE598'0000        LDR      R0,[R8, #+0]
   \      0x24C   0xE596'1008        LDR      R1,[R6, #+8]
   \      0x250   0xE180'1001        ORR      R1,R0,R1
   \      0x254   0xE586'1008        STR      R1,[R6, #+8]
   \      0x258   0x....'....        BL       spi_flash_hwcaps2cmd
   \      0x25C   0xE5D8'300C        LDRB     R3,[R8, #+12]
   \      0x260   0xE28D'2010        ADD      R2,SP,#+16
   \      0x264   0xE598'1014        LDR      R1,[R8, #+20]
   \      0x268   0xE086'0180        ADD      R0,R6,R0, LSL #+3
   \      0x26C   0xE792'C103        LDR      R12,[R2, +R3, LSL #+2]
   \      0x270   0xE598'2010        LDR      R2,[R8, #+16]
   \      0x274   0xE1A0'223C        LSR      R2,R12,R2
   \      0x278   0xE1A0'3C02        LSL      R3,R2,#+24
   \      0x27C   0xE202'C01F        AND      R12,R2,#0x1F
   \      0x280   0xE1A0'EEA3        LSR      LR,R3,#+29
   \      0x284   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x288   0xE5E0'E00C        STRB     LR,[R0, #+12]!
   \      0x28C   0xE1A0'2C22        LSR      R2,R2,#+24
   \      0x290   0xE5C0'C001        STRB     R12,[R0, #+1]
   \      0x294   0xE5C0'2002        STRB     R2,[R0, #+2]
   \      0x298   0xE580'1004        STR      R1,[R0, #+4]
   \                     ??spi_flash_parse_sfdp_8:
   \      0x29C   0xE259'9001        SUBS     R9,R9,#+1
   \      0x2A0   0xE288'8018        ADD      R8,R8,#+24
   \      0x2A4   0x1AFF'FFE1        BNE      ??spi_flash_parse_sfdp_7
   \      0x2A8   0xE59D'1008        LDR      R1,[SP, #+8]
   \      0x2AC   0xE3A0'A000        MOV      R10,#+0
   \      0x2B0   0xE3A0'B000        MOV      R11,#+0
   \      0x2B4   0x....'....        ADR      R8,sfdp_bfpt_erases
   \      0x2B8   0xE281'9048        ADD      R9,R1,#+72
   \                     ??spi_flash_parse_sfdp_9:
   \      0x2BC   0xE5D8'3000        LDRB     R3,[R8, #+0]
   \      0x2C0   0xE28D'2010        ADD      R2,SP,#+16
   \      0x2C4   0xE598'1004        LDR      R1,[R8, #+4]
   \      0x2C8   0xE288'8008        ADD      R8,R8,#+8
   \      0x2CC   0xE792'0103        LDR      R0,[R2, +R3, LSL #+2]
   \      0x2D0   0xE1A0'0130        LSR      R0,R0,R1
   \      0x2D4   0xE6FF'1070        UXTH     R1,R0
   \      0x2D8   0xE1A0'0800        LSL      R0,R0,#+16
   \      0x2DC   0xE211'10FF        ANDS     R1,R1,#0xFF
   \      0x2E0   0xE1A0'2C20        LSR      R2,R0,#+24
   \      0x2E4   0x13A0'0001        MOVNE    R0,#+1
   \      0x2E8   0x11A0'1110        LSLNE    R1,R0,R1
   \      0x2EC   0xE1A0'0009        MOV      R0,R9
   \      0x2F0   0x....'....        BL       spi_flash_set_erase_command
   \      0x2F4   0xE599'1000        LDR      R1,[R9, #+0]
   \      0x2F8   0xE289'9010        ADD      R9,R9,#+16
   \      0x2FC   0xE351'0000        CMP      R1,#+0
   \      0x300   0x13A0'0001        MOVNE    R0,#+1
   \      0x304   0x118A'AB10        ORRNE    R10,R10,R0, LSL R11
   \      0x308   0xE28B'B001        ADD      R11,R11,#+1
   \      0x30C   0xE35B'0004        CMP      R11,#+4
   \      0x310   0xBAFF'FFE9        BLT      ??spi_flash_parse_sfdp_9
   \      0x314   0xE59D'E008        LDR      LR,[SP, #+8]
   \      0x318   0xE596'2000        LDR      R2,[R6, #+0]
   \      0x31C   0xE1A0'100A        MOV      R1,R10
   \      0x320   0xE3A0'3000        MOV      R3,#+0
   \      0x324   0xE28E'0048        ADD      R0,LR,#+72
   \      0x328   0x....'....        BL       spi_flash_init_uniform_erase_map
   \      0x32C   0xE59D'300C        LDR      R3,[SP, #+12]
   \      0x330   0xE353'0010        CMP      R3,#+16
   \      0x334   0xBA00'002D        BLT      ??spi_flash_parse_sfdp_10
   \      0x338   0xE59D'2038        LDR      R2,[SP, #+56]
   \      0x33C   0xE3A0'0001        MOV      R0,#+1
   \      0x340   0xE7E3'1252        UBFX     R1,R2,#+4,#+4
   \      0x344   0xE1A0'0110        LSL      R0,R0,R1
   \      0x348   0xE586'0004        STR      R0,[R6, #+4]
   \      0x34C   0xE59D'1048        LDR      R1,[SP, #+72]
   \      0x350   0xE201'2870        AND      R2,R1,#0x700000
   \      0x354   0xE352'0940        CMP      R2,#+1048576
   \      0x358   0x0A00'000F        BEQ      ??spi_flash_parse_sfdp_11
   \      0x35C   0xE352'0980        CMP      R2,#+2097152
   \      0x360   0x0A00'000A        BEQ      ??spi_flash_parse_sfdp_12
   \      0x364   0xE352'09C0        CMP      R2,#+3145728
   \      0x368   0x0A00'0006        BEQ      ??spi_flash_parse_sfdp_13
   \      0x36C   0xE352'0840        CMP      R2,#+4194304
   \      0x370   0x0A00'0009        BEQ      ??spi_flash_parse_sfdp_11
   \      0x374   0xE352'0850        CMP      R2,#+5242880
   \      0x378   0x....'....        LDREQ    R12,??DataTable1_3
   \      0x37C   0x0586'C06C        STREQ    R12,[R6, #+108]
   \      0x380   0x1586'706C        STRNE    R7,[R6, #+108]
   \      0x384   0xEA00'0006        B        ??spi_flash_parse_sfdp_14
   \                     ??spi_flash_parse_sfdp_13:
   \      0x388   0x....'....        LDR      R0,??DataTable1_4
   \      0x38C   0xEA00'0003        B        ??spi_flash_parse_sfdp_15
   \                     ??spi_flash_parse_sfdp_12:
   \      0x390   0x....'....        LDR      R1,??DataTable1_5
   \      0x394   0xE586'106C        STR      R1,[R6, #+108]
   \      0x398   0xEA00'0001        B        ??spi_flash_parse_sfdp_14
   \                     ??spi_flash_parse_sfdp_11:
   \      0x39C   0x....'....        LDR      R0,??DataTable1_6
   \                     ??spi_flash_parse_sfdp_15:
   \      0x3A0   0xE586'006C        STR      R0,[R6, #+108]
   \                     ??spi_flash_parse_sfdp_14:
   \      0x3A4   0xE59D'0008        LDR      R0,[SP, #+8]
   \      0x3A8   0xE580'70B0        STR      R7,[R0, #+176]
   \      0x3AC   0xE59D'0048        LDR      R0,[SP, #+72]
   \      0x3B0   0xE310'0B80        TST      R0,#0x20000
   \      0x3B4   0x0A00'0005        BEQ      ??spi_flash_parse_sfdp_16
   \      0x3B8   0xE59D'2008        LDR      R2,[SP, #+8]
   \      0x3BC   0x....'....        LDR      R0,??DataTable1_7
   \      0x3C0   0xE582'00B0        STR      R0,[R2, #+176]
   \      0x3C4   0xE59D'C008        LDR      R12,[SP, #+8]
   \      0x3C8   0xE5CC'7030        STRB     R7,[R12, #+48]
   \      0x3CC   0xEA00'0007        B        ??spi_flash_parse_sfdp_10
   \                     ??spi_flash_parse_sfdp_16:
   \      0x3D0   0xE310'0B40        TST      R0,#0x10000
   \      0x3D4   0x13A0'00A5        MOVNE    R0,#+165
   \      0x3D8   0x1A00'0002        BNE      ??spi_flash_parse_sfdp_17
   \      0x3DC   0xE310'0A40        TST      R0,#0x40000
   \      0x3E0   0x0A00'0002        BEQ      ??spi_flash_parse_sfdp_10
   \      0x3E4   0xE3A0'00A0        MOV      R0,#+160
   \                     ??spi_flash_parse_sfdp_17:
   \      0x3E8   0xE59D'2008        LDR      R2,[SP, #+8]
   \      0x3EC   0xE5C2'0030        STRB     R0,[R2, #+48]
   \                     ??spi_flash_parse_sfdp_10:
   \      0x3F0   0xE59D'6008        LDR      R6,[SP, #+8]
   \      0x3F4   0xE3A0'0000        MOV      R0,#+0
   \      0x3F8   0xEA00'0000        B        ??spi_flash_parse_sfdp_18
   \                     ??spi_flash_parse_sfdp_19:
   \      0x3FC   0xE287'7001        ADD      R7,R7,#+1
   \                     ??spi_flash_parse_sfdp_18:
   \      0x400   0xE5D5'100E        LDRB     R1,[R5, #+14]
   \      0x404   0xE157'0001        CMP      R7,R1
   \      0x408   0xAA00'0011        BGE      ??spi_flash_parse_sfdp_0
   \      0x40C   0xE3A0'3000        MOV      R3,#+0
   \      0x410   0xE3A0'2003        MOV      R2,#+3
   \      0x414   0xE3A0'105A        MOV      R1,#+90
   \      0x418   0xE28D'0008        ADD      R0,SP,#+8
   \      0x41C   0x....'....        BL       spi_flash_command_init
   \      0x420   0xE596'0020        LDR      R0,[R6, #+32]
   \      0x424   0xE3A0'2010        MOV      R2,#+16
   \      0x428   0xE5CD'4013        STRB     R4,[SP, #+19]
   \      0x42C   0xE082'2187        ADD      R2,R2,R7, LSL #+3
   \      0x430   0xE58D'401C        STR      R4,[SP, #+28]
   \      0x434   0xE58D'0008        STR      R0,[SP, #+8]
   \      0x438   0xE58D'2018        STR      R2,[SP, #+24]
   \      0x43C   0xE58D'5024        STR      R5,[SP, #+36]
   \      0x440   0xE28D'1008        ADD      R1,SP,#+8
   \      0x444   0xE1A0'0006        MOV      R0,R6
   \      0x448   0x....'....        BL       spi_flash_exec
   \      0x44C   0xE350'0000        CMP      R0,#+0
   \      0x450   0x5AFF'FFE9        BPL      ??spi_flash_parse_sfdp_19
   \                     ??spi_flash_parse_sfdp_0:
   \      0x454                      REQUIRE ?Subroutine0
   \      0x454                      ;; // Fall through to label ?Subroutine0
    507          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE28D'D074        ADD      SP,SP,#+116
   \        0x4   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     param_header

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x5044'4653        DC32     0x50444653

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     sfdp_bfpt_reads

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     spansion_new_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     sr2_bit7_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     macronix_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x....'....        DC32     spansion_quad_enable

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x....'....        DC32     micron_enable_0_4_4

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     152   spi_flash_parse_sfdp
       152   -> __aeabi_memclr4
       152   -> spi_flash_command_init
       152   -> spi_flash_exec
       152   -> spi_flash_hwcaps2cmd
       152   -> spi_flash_init_uniform_erase_map
       152   -> spi_flash_set_erase_command


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       8  ?Subroutine0
      24  param_header
          header
      32  sfdp_bfpt_erases
     144  sfdp_bfpt_reads
   1'108  spi_flash_parse_sfdp

 
    24 bytes in section .bss
   144 bytes in section .rodata
 1'180 bytes in section SOFTPACK
 
 1'180 bytes of CODE  memory
   144 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: 1
