###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         08/Dec/2020  16:30:45
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5A6C.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_PDMIC -D CONFIG_HAVE_AUDIO_AD1934 -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D CONFIG_HAVE_SPI_FIFO -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D
#        CONFIG_HAVE_USART -D CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List\classd.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj\classd.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  int_specials
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\classd.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <assert.h>
     35          #include <stdio.h>
     36          #include <string.h>
     37          
     38          #include "audio/classd.h"
     39          #include "callback.h"
     40          #include "chip.h"
     41          #include "errno.h"
     42          #include "io.h"
     43          #include "mm/cache.h"
     44          #include "peripherals/pmc.h"
     45          #include "trace.h"
     46          
     47          /*----------------------------------------------------------------------------
     48           *        Local constants
     49           *----------------------------------------------------------------------------*/
     50          
     51          static const struct {
     52          	uint32_t rate;
     53          	uint32_t sample_rate;
     54          	uint32_t dsp_clk;

   \                                 In section .rodata, align 4
     55          } audio_info[] = {
   \                     audio_info:
   \        0x0   0x0000'1F40        DC32 8'000, 0, 0, 16'000, 1'048'576, 0, 32'000, 2'097'152, 0, 48'000

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'3E80  

   \              0x0010'0000  

   \              0x0000'0000  

   \              0x0000'7D00  

   \              0x0020'0000  

   \              0x0000'0000  

   \              0x0000'BB80
   \       0x28   0x0030'0000        DC32 3'145'728, 0, 96'000, 4'194'304, 0, 22'050, 5'242'880, 65'536

   \              0x0000'0000  

   \              0x0001'7700  

   \              0x0040'0000  

   \              0x0000'0000  

   \              0x0000'5622  

   \              0x0050'0000  

   \              0x0001'0000
   \       0x48   0x0000'AC44        DC32 44'100, 6'291'456, 65'536, 88'200, 7'340'032, 65'536

   \              0x0060'0000  

   \              0x0001'0000  

   \              0x0001'5888  

   \              0x0070'0000  

   \              0x0001'0000
     56          	{ 8000,  CLASSD_INTPMR_FRAME_FRAME_8K,  CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     57          	{ 16000, CLASSD_INTPMR_FRAME_FRAME_16K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     58          	{ 32000, CLASSD_INTPMR_FRAME_FRAME_32K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     59          	{ 48000, CLASSD_INTPMR_FRAME_FRAME_48K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     60          	{ 96000, CLASSD_INTPMR_FRAME_FRAME_96K, CLASSD_INTPMR_DSPCLKFREQ_12M288 },
     61          	{ 22050, CLASSD_INTPMR_FRAME_FRAME_22K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     62          	{ 44100, CLASSD_INTPMR_FRAME_FRAME_44K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     63          	{ 88200, CLASSD_INTPMR_FRAME_FRAME_88K, CLASSD_INTPMR_DSPCLKFREQ_11M2896 },
     64          };
     65          
     66          /*----------------------------------------------------------------------------
     67           *        Local functions
     68           *----------------------------------------------------------------------------*/
     69          
     70          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK

   \                                 In section SOFTPACK, align 4, keep-with-next
     71          static bool _dspclk_configure(uint32_t dsp_clk)
     72          {
   \                     _dspclk_configure:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE24D'D014        SUB      SP,SP,#+20
   \        0x8   0xE1B0'4000        MOVS     R4,R0
     73          	struct _pmc_audio_cfg cfg;
     74          
     75          	/* Pad Clock: not used */
     76          	cfg.div = 0;
   \        0xC   0xE3A0'0000        MOV      R0,#+0
   \       0x10   0xE58D'000C        STR      R0,[SP, #+12]
     77          	cfg.qdaudio = 0;
   \       0x14   0xE58D'0010        STR      R0,[SP, #+16]
     78          
     79          	/* PMC Clock: */
     80          	/* 12Mhz * (ND + 1 + FRACR/2^22) / (QDPMC + 1) = 8 * DSPCLK */
     81          	switch (dsp_clk) {
   \       0x18   0xE1B0'0004        MOVS     R0,R4
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x0A00'0002        BEQ      ??_dspclk_configure_0
   \       0x24   0xE350'0B40        CMP      R0,#+65536
   \       0x28   0x0A00'0007        BEQ      ??_dspclk_configure_1
   \       0x2C   0xEA00'000D        B        ??_dspclk_configure_2
     82          	case CLASSD_INTPMR_DSPCLKFREQ_12M288:
     83          		/* 12Mhz * (56 + 1 + 1442841/2^22) / (6 + 1) = 8 * 12.288Mhz */
     84          		cfg.nd = 56;
   \                     ??_dspclk_configure_0:
   \       0x30   0xE3A0'0038        MOV      R0,#+56
   \       0x34   0xE58D'0000        STR      R0,[SP, #+0]
     85          		cfg.fracr = 1442841;
   \       0x38   0x....'....        LDR      R0,??DataTable3  ;; 0x160419
   \       0x3C   0xE58D'0004        STR      R0,[SP, #+4]
     86          		cfg.qdpmc = 6;
   \       0x40   0xE3A0'0006        MOV      R0,#+6
   \       0x44   0xE58D'0008        STR      R0,[SP, #+8]
     87          		break;
   \       0x48   0xEA00'0008        B        ??_dspclk_configure_3
     88          	case CLASSD_INTPMR_DSPCLKFREQ_11M2896:
     89          		/* 12Mhz * (59 + 1 + 885837/2^22) / (7 + 1) = 8 * 11.2896Mhz */
     90          		cfg.nd = 59;
   \                     ??_dspclk_configure_1:
   \       0x4C   0xE3A0'003B        MOV      R0,#+59
   \       0x50   0xE58D'0000        STR      R0,[SP, #+0]
     91          		cfg.fracr = 885837;
   \       0x54   0x....'....        LDR      R0,??DataTable3_1  ;; 0xd844d
   \       0x58   0xE58D'0004        STR      R0,[SP, #+4]
     92          		cfg.qdpmc = 7;
   \       0x5C   0xE3A0'0007        MOV      R0,#+7
   \       0x60   0xE58D'0008        STR      R0,[SP, #+8]
     93          		break;
   \       0x64   0xEA00'0001        B        ??_dspclk_configure_3
     94          	default:
     95          		return false;
   \                     ??_dspclk_configure_2:
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xEA00'000F        B        ??_dspclk_configure_4
     96          	}
     97          
     98          	pmc_configure_audio(&cfg);
   \                     ??_dspclk_configure_3:
   \       0x70   0xE1B0'000D        MOVS     R0,SP
   \       0x74   0x....'....        BL       pmc_configure_audio
     99          	pmc_enable_audio(true, false);
   \       0x78   0xE3A0'1000        MOV      R1,#+0
   \       0x7C   0xE3A0'0001        MOV      R0,#+1
   \       0x80   0x....'....        BL       pmc_enable_audio
    100          
    101          #if (TRACE_LEVEL >= TRACE_LEVEL_DEBUG)
    102          	{
    103          		uint32_t clk;
    104          		clk = pmc_get_audio_pmc_clock();
   \       0x84   0x....'....        BL       pmc_get_audio_pmc_clock
   \       0x88   0xE1B0'5000        MOVS     R5,R0
    105          		trace_debug("Configured Audio PLL PMC Clock: %u (= 8 * %u)\r\n",
    106          			    (unsigned)clk, (unsigned)(clk >> 3));
   \       0x8C   0x....'....        LDR      R0,??DataTable3_2
   \       0x90   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x94   0xE350'0005        CMP      R0,#+5
   \       0x98   0x3A00'0003        BCC      ??_dspclk_configure_5
   \       0x9C   0xE1B0'21A5        LSRS     R2,R5,#+3
   \       0xA0   0xE1B0'1005        MOVS     R1,R5
   \       0xA4   0x....'....        LDR      R0,??DataTable3_3
   \       0xA8   0x....'....        BL       printf
    107          	}
    108          #endif
    109          	return true;
   \                     ??_dspclk_configure_5:
   \       0xAC   0xE3A0'0001        MOV      R0,#+1
   \                     ??_dspclk_configure_4:
   \       0xB0   0xE28D'D014        ADD      SP,SP,#+20
   \       0xB4   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    110          }
    111          #endif
    112          

   \                                 In section SOFTPACK, align 4, keep-with-next
    113          static bool _set_eqcfg_bits(enum _classd_eqcfg eqcfg, volatile uint32_t *intpmr)
    114          {
   \                     _set_eqcfg_bits:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    115          	uint32_t mask = CLASSD_INTPMR_EQCFG_Msk;
   \        0xC   0xE3A0'66F0        MOV      R6,#+251658240
    116          	uint32_t bits = 0;
   \       0x10   0xE3A0'7000        MOV      R7,#+0
    117          
    118          	switch (eqcfg) {
   \       0x14   0xE1B0'0004        MOVS     R0,R4
   \       0x18   0xE6EF'0070        UXTB     R0,R0
   \       0x1C   0xE350'000C        CMP      R0,#+12
   \       0x20   0x8A00'001F        BHI      ??_set_eqcfg_bits_1
   \       0x24   0xE7DF'1000        LDRB     R1,[PC, R0]
   \       0x28   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??_set_eqcfg_bits_0:
   \       0x2C   0x03 0x05          DC8      0x3,0x5,0x7,0x9

   \              0x07 0x09
   \       0x30   0x0B 0x0D          DC8      0xB,0xD,0xF,0x11

   \              0x0F 0x11
   \       0x34   0x13 0x15          DC8      0x13,0x15,0x17,0x19

   \              0x17 0x19
   \       0x38   0x1B 0x00          DC8      0x1B,0x0,0x0,0x0

   \              0x00 0x00
    119          	case CLASSD_EQCFG_FLAT:
    120          		bits = CLASSD_INTPMR_EQCFG_FLAT;
   \                     ??_set_eqcfg_bits_2:
   \       0x3C   0xE3A0'1000        MOV      R1,#+0
    121          		break;
   \       0x40   0xEA00'0021        B        ??_set_eqcfg_bits_3
    122          	case CLASSD_EQCFG_BBOOST12:
    123          		bits = CLASSD_INTPMR_EQCFG_BBOOST12;
   \                     ??_set_eqcfg_bits_4:
   \       0x44   0xE3A0'1740        MOV      R1,#+16777216
    124          		break;
   \       0x48   0xEA00'001F        B        ??_set_eqcfg_bits_3
    125          	case CLASSD_EQCFG_BBOOST6:
    126          		bits = CLASSD_INTPMR_EQCFG_BBOOST6;
   \                     ??_set_eqcfg_bits_5:
   \       0x4C   0xE3A0'1780        MOV      R1,#+33554432
    127          		break;
   \       0x50   0xEA00'001D        B        ??_set_eqcfg_bits_3
    128          	case CLASSD_EQCFG_BCUT12:
    129          		bits = CLASSD_INTPMR_EQCFG_BCUT12;
   \                     ??_set_eqcfg_bits_6:
   \       0x54   0xE3A0'17C0        MOV      R1,#+50331648
    130          		break;
   \       0x58   0xEA00'001B        B        ??_set_eqcfg_bits_3
    131          	case CLASSD_EQCFG_BCUT6:
    132          		bits = CLASSD_INTPMR_EQCFG_BCUT6;
   \                     ??_set_eqcfg_bits_7:
   \       0x5C   0xE3A0'1640        MOV      R1,#+67108864
    133          		break;
   \       0x60   0xEA00'0019        B        ??_set_eqcfg_bits_3
    134          	case CLASSD_EQCFG_MBOOST3:
    135          		bits = CLASSD_INTPMR_EQCFG_MBOOST3;
   \                     ??_set_eqcfg_bits_8:
   \       0x64   0xE3A0'1650        MOV      R1,#+83886080
    136          		break;
   \       0x68   0xEA00'0017        B        ??_set_eqcfg_bits_3
    137          	case CLASSD_EQCFG_MBOOST8:
    138          		bits = CLASSD_INTPMR_EQCFG_MBOOST8;
   \                     ??_set_eqcfg_bits_9:
   \       0x6C   0xE3A0'1660        MOV      R1,#+100663296
    139          		break;
   \       0x70   0xEA00'0015        B        ??_set_eqcfg_bits_3
    140          	case CLASSD_EQCFG_MCUT3:
    141          		bits = CLASSD_INTPMR_EQCFG_MCUT3;
   \                     ??_set_eqcfg_bits_10:
   \       0x74   0xE3A0'1670        MOV      R1,#+117440512
    142          		break;
   \       0x78   0xEA00'0013        B        ??_set_eqcfg_bits_3
    143          	case CLASSD_EQCFG_MCUT8:
    144          		bits = CLASSD_INTPMR_EQCFG_MCUT8;
   \                     ??_set_eqcfg_bits_11:
   \       0x7C   0xE3A0'1680        MOV      R1,#+134217728
    145          		break;
   \       0x80   0xEA00'0011        B        ??_set_eqcfg_bits_3
    146          	case CLASSD_EQCFG_TBOOST12:
    147          		bits = CLASSD_INTPMR_EQCFG_TBOOST12;
   \                     ??_set_eqcfg_bits_12:
   \       0x84   0xE3A0'1690        MOV      R1,#+150994944
    148          		break;
   \       0x88   0xEA00'000F        B        ??_set_eqcfg_bits_3
    149          	case CLASSD_EQCFG_TBOOST6:
    150          		bits = CLASSD_INTPMR_EQCFG_TBOOST6;
   \                     ??_set_eqcfg_bits_13:
   \       0x8C   0xE3A0'16A0        MOV      R1,#+167772160
    151          		break;
   \       0x90   0xEA00'000D        B        ??_set_eqcfg_bits_3
    152          	case CLASSD_EQCFG_TCUT12:
    153          		bits = CLASSD_INTPMR_EQCFG_TCUT12;
   \                     ??_set_eqcfg_bits_14:
   \       0x94   0xE3A0'16B0        MOV      R1,#+184549376
    154          		break;
   \       0x98   0xEA00'000B        B        ??_set_eqcfg_bits_3
    155          	case CLASSD_EQCFG_TCUT6:
    156          		bits = CLASSD_INTPMR_EQCFG_TCUT6;
   \                     ??_set_eqcfg_bits_15:
   \       0x9C   0xE3A0'16C0        MOV      R1,#+201326592
    157          		break;
   \       0xA0   0xEA00'0009        B        ??_set_eqcfg_bits_3
    158          	default:
    159          		trace_warning("classd: invalid equalizer config %u\r\n",
    160          			      (unsigned)eqcfg);
   \                     ??_set_eqcfg_bits_1:
   \       0xA4   0x....'....        LDR      R0,??DataTable3_2
   \       0xA8   0xE590'0000        LDR      R0,[R0, #+0]
   \       0xAC   0xE350'0003        CMP      R0,#+3
   \       0xB0   0x3A00'0003        BCC      ??_set_eqcfg_bits_16
   \       0xB4   0xE1B0'1004        MOVS     R1,R4
   \       0xB8   0xE6EF'1071        UXTB     R1,R1
   \       0xBC   0x....'....        LDR      R0,??DataTable3_4
   \       0xC0   0x....'....        BL       printf
    161          		return false;
   \                     ??_set_eqcfg_bits_16:
   \       0xC4   0xE3A0'0000        MOV      R0,#+0
   \       0xC8   0xEA00'0004        B        ??_set_eqcfg_bits_17
    162          	};
    163          
    164          	*intpmr = (*intpmr & ~mask) | bits;
   \                     ??_set_eqcfg_bits_3:
   \       0xCC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xD0   0xE1D0'0006        BICS     R0,R0,R6
   \       0xD4   0xE191'0000        ORRS     R0,R1,R0
   \       0xD8   0xE585'0000        STR      R0,[R5, #+0]
    165          	return true;
   \       0xDC   0xE3A0'0001        MOV      R0,#+1
   \                     ??_set_eqcfg_bits_17:
   \       0xE0   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    166          }
    167          

   \                                 In section SOFTPACK, align 4, keep-with-next
    168          static bool _set_mono_bits(bool mono, enum _classd_mono mono_mode, volatile uint32_t *intpmr)
    169          {
   \                     _set_mono_bits:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    170          	uint32_t mask = CLASSD_INTPMR_MONO_ENABLED | CLASSD_INTPMR_MONOMODE_Msk;
   \       0x10   0xE3A0'7470        MOV      R7,#+1879048192
    171          	uint32_t bits = 0;
   \       0x14   0xE3A0'1000        MOV      R1,#+0
    172          
    173          	if (mono) {
   \       0x18   0xE1B0'0004        MOVS     R0,R4
   \       0x1C   0xE6EF'0070        UXTB     R0,R0
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x0A00'0019        BEQ      ??_set_mono_bits_1
    174          		bits = CLASSD_INTPMR_MONO_ENABLED;
   \       0x28   0xE3A0'8540        MOV      R8,#+268435456
    175          		switch (mono_mode) {
   \       0x2C   0xE1B0'0005        MOVS     R0,R5
   \       0x30   0xE6EF'0070        UXTB     R0,R0
   \       0x34   0xE350'0003        CMP      R0,#+3
   \       0x38   0x8A00'000A        BHI      ??_set_mono_bits_2
   \       0x3C   0xE7DF'2000        LDRB     R2,[PC, R0]
   \       0x40   0xE08F'F102        ADD      PC,PC,R2, LSL #+2
   \                     ??_set_mono_bits_0:
   \       0x44   0x00 0x02          DC8      0x0,0x2,0x4,0x6

   \              0x04 0x06
    176          		case CLASSD_MONO_MIXED:
    177          			bits |= CLASSD_INTPMR_MONOMODE_MONOMIX;
   \                     ??_set_mono_bits_3:
   \       0x48   0xE1B0'1008        MOVS     R1,R8
    178          			break;
   \       0x4C   0xEA00'000F        B        ??_set_mono_bits_1
    179          		case CLASSD_MONO_SAT:
    180          			bits |= CLASSD_INTPMR_MONOMODE_MONOSAT;
   \                     ??_set_mono_bits_4:
   \       0x50   0xE398'1580        ORRS     R1,R8,#0x20000000
    181          			break;
   \       0x54   0xEA00'000D        B        ??_set_mono_bits_1
    182          		case CLASSD_MONO_LEFT:
    183          			bits |= CLASSD_INTPMR_MONOMODE_MONOLEFT;
   \                     ??_set_mono_bits_5:
   \       0x58   0xE398'1440        ORRS     R1,R8,#0x40000000
    184          			break;
   \       0x5C   0xEA00'000B        B        ??_set_mono_bits_1
    185          		case CLASSD_MONO_RIGHT:
    186          			bits |= CLASSD_INTPMR_MONOMODE_MONORIGHT;
   \                     ??_set_mono_bits_6:
   \       0x60   0xE398'1460        ORRS     R1,R8,#0x60000000
    187          			break;
   \       0x64   0xEA00'0009        B        ??_set_mono_bits_1
    188          		default:
    189          			trace_warning("classd: invalid mono mode %u\r\n",
    190          				      (unsigned)mono_mode);
   \                     ??_set_mono_bits_2:
   \       0x68   0x....'....        LDR      R0,??DataTable3_2
   \       0x6C   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x70   0xE350'0003        CMP      R0,#+3
   \       0x74   0x3A00'0003        BCC      ??_set_mono_bits_7
   \       0x78   0xE1B0'1005        MOVS     R1,R5
   \       0x7C   0xE6EF'1071        UXTB     R1,R1
   \       0x80   0x....'....        LDR      R0,??DataTable3_5
   \       0x84   0x....'....        BL       printf
    191          			return false;
   \                     ??_set_mono_bits_7:
   \       0x88   0xE3A0'0000        MOV      R0,#+0
   \       0x8C   0xEA00'0004        B        ??_set_mono_bits_8
    192          		}
    193          	}
    194          
    195          	*intpmr = (*intpmr & ~mask) | bits;
   \                     ??_set_mono_bits_1:
   \       0x90   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x94   0xE1D0'0007        BICS     R0,R0,R7
   \       0x98   0xE191'0000        ORRS     R0,R1,R0
   \       0x9C   0xE586'0000        STR      R0,[R6, #+0]
    196          	return true;
   \       0xA0   0xE3A0'0001        MOV      R0,#+1
   \                     ??_set_mono_bits_8:
   \       0xA4   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    197          }
    198          

   \                                 In section SOFTPACK, align 4, keep-with-next
    199          static int _classd_dma_transfer_callback(void* arg, void* arg2)
    200          {
   \                     _classd_dma_transfer_callback:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    201          	struct _classd_desc* desc = (struct _classd_desc*)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
    202          
    203          	dma_reset_channel(desc->tx.dma.channel);
   \       0x10   0xE596'002C        LDR      R0,[R6, #+44]
   \       0x14   0x....'....        BL       dma_reset_channel
    204          
    205          	mutex_unlock(&desc->tx.mutex);
   \       0x18   0xE296'0010        ADDS     R0,R6,#+16
   \       0x1C   0x....'....        BL       mutex_unlock
    206          
    207          	return callback_call(&desc->tx.callback, NULL);
   \       0x20   0xE3A0'1000        MOV      R1,#+0
   \       0x24   0xE296'0024        ADDS     R0,R6,#+36
   \       0x28   0x....'....        BL       callback_call
   \       0x2C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    208          }
    209          

   \                                 In section SOFTPACK, align 4, keep-with-next
    210          static void _classd_dma_transfer(struct _classd_desc* desc, struct _buffer* buffer)
    211          {
   \                     _classd_dma_transfer:
   \        0x0   0xE92D'41FC        PUSH     {R2-R8,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    212          	struct _callback _cb;
    213          
    214          	memset(&desc->tx.dma.cfg, 0x0, sizeof(desc->tx.dma.cfg));
   \        0xC   0xE3A0'600C        MOV      R6,#+12
   \       0x10   0xE3A0'7000        MOV      R7,#+0
   \       0x14   0xE294'803C        ADDS     R8,R4,#+60
   \       0x18   0xE1B0'2007        MOVS     R2,R7
   \       0x1C   0xE1B0'1006        MOVS     R1,R6
   \       0x20   0xE1B0'0008        MOVS     R0,R8
   \       0x24   0x....'....        BL       __aeabi_memset
   \       0x28   0xE1B0'0008        MOVS     R0,R8
    215          
    216          	desc->tx.dma.cfg.saddr = buffer->data;
   \       0x2C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x30   0xE584'003C        STR      R0,[R4, #+60]
    217          	desc->tx.dma.cfg.daddr = (void*)&desc->addr->CLASSD_THR;
   \       0x34   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x38   0xE290'0010        ADDS     R0,R0,#+16
   \       0x3C   0xE584'0040        STR      R0,[R4, #+64]
    218          
    219          	if (desc->left_enable && desc->right_enable) {
   \       0x40   0xE5D4'000E        LDRB     R0,[R4, #+14]
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x0A00'0008        BEQ      ??_classd_dma_transfer_0
   \       0x4C   0xE5D4'000F        LDRB     R0,[R4, #+15]
   \       0x50   0xE350'0000        CMP      R0,#+0
   \       0x54   0x0A00'0005        BEQ      ??_classd_dma_transfer_0
    220          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
   \       0x58   0xE3A0'0002        MOV      R0,#+2
   \       0x5C   0xE584'0030        STR      R0,[R4, #+48]
    221          		desc->tx.dma.cfg.len = buffer->size / 4;
   \       0x60   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x64   0xE1B0'0120        LSRS     R0,R0,#+2
   \       0x68   0xE584'0044        STR      R0,[R4, #+68]
   \       0x6C   0xEA00'0004        B        ??_classd_dma_transfer_1
    222          	} else {
    223          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
   \                     ??_classd_dma_transfer_0:
   \       0x70   0xE3A0'0001        MOV      R0,#+1
   \       0x74   0xE584'0030        STR      R0,[R4, #+48]
    224          		desc->tx.dma.cfg.len = buffer->size / 2;
   \       0x78   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x7C   0xE1B0'00A0        LSRS     R0,R0,#+1
   \       0x80   0xE584'0044        STR      R0,[R4, #+68]
    225          	}
    226          	dma_configure_transfer(desc->tx.dma.channel, &desc->tx.dma.cfg_dma, &desc->tx.dma.cfg, 1);
   \                     ??_classd_dma_transfer_1:
   \       0x84   0xE3A0'3001        MOV      R3,#+1
   \       0x88   0xE294'203C        ADDS     R2,R4,#+60
   \       0x8C   0xE294'1030        ADDS     R1,R4,#+48
   \       0x90   0xE594'002C        LDR      R0,[R4, #+44]
   \       0x94   0x....'....        BL       dma_configure_transfer
    227          	callback_set(&_cb, _classd_dma_transfer_callback, (void*)desc);
   \       0x98   0xE1B0'2004        MOVS     R2,R4
   \       0x9C   0x....'....        ADR      R1,_classd_dma_transfer_callback
   \       0xA0   0xE1B0'000D        MOVS     R0,SP
   \       0xA4   0x....'....        BL       callback_set
    228          	dma_set_callback(desc->tx.dma.channel, &_cb);
   \       0xA8   0xE1B0'100D        MOVS     R1,SP
   \       0xAC   0xE594'002C        LDR      R0,[R4, #+44]
   \       0xB0   0x....'....        BL       dma_set_callback
    229          	cache_clean_region(desc->tx.dma.cfg.saddr, desc->tx.dma.cfg.len);
   \       0xB4   0xE594'1044        LDR      R1,[R4, #+68]
   \       0xB8   0xE594'003C        LDR      R0,[R4, #+60]
   \       0xBC   0x....'....        BL       cache_clean_region
    230          	dma_start_transfer(desc->tx.dma.channel);
   \       0xC0   0xE594'002C        LDR      R0,[R4, #+44]
   \       0xC4   0x....'....        BL       dma_start_transfer
    231          }
   \       0xC8   0xE8BD'81F3        POP      {R0,R1,R4-R8,PC}  ;; return
    232          

   \                                 In section SOFTPACK, align 4, keep-with-next
    233          static void _classd_polling_transfer(struct _classd_desc* desc, struct _buffer* buffer)
    234          {
   \                     _classd_polling_transfer:
   \        0x0   0xE92D'43F8        PUSH     {R3-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    235          	uint16_t* start = (uint16_t*)buffer->data;
   \        0xC   0xE595'6000        LDR      R6,[R5, #+0]
    236          	uint32_t  length = buffer->size / sizeof(uint16_t);
   \       0x10   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x14   0xE1B0'70A0        LSRS     R7,R0,#+1
    237          	uint16_t* end = start + length;
   \       0x18   0xE1B0'0087        LSLS     R0,R7,#+1
   \       0x1C   0xE096'8000        ADDS     R8,R6,R0
    238          	uint16_t* current = start;
   \       0x20   0xE1B0'9006        MOVS     R9,R6
    239          
    240          	while (1) {
    241          		if (desc->addr->CLASSD_ISR & CLASSD_ISR_DATRDY) {
   \                     ??_classd_polling_transfer_0:
   \       0x24   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x28   0xE590'0020        LDR      R0,[R0, #+32]
   \       0x2C   0xE310'0001        TST      R0,#0x1
   \       0x30   0x0A00'0012        BEQ      ??_classd_polling_transfer_1
    242          			uint16_t left = 0, right = 0;
   \       0x34   0xE3A0'1000        MOV      R1,#+0
   \       0x38   0xE1B0'0001        MOVS     R0,R1
    243          			if (desc->left_enable)
   \       0x3C   0xE5D4'200E        LDRB     R2,[R4, #+14]
   \       0x40   0xE352'0000        CMP      R2,#+0
   \       0x44   0x0A00'0002        BEQ      ??_classd_polling_transfer_2
    244          				left = *current++;
   \       0x48   0xE1D9'20B0        LDRH     R2,[R9, #+0]
   \       0x4C   0xE1B0'0002        MOVS     R0,R2
   \       0x50   0xE299'9002        ADDS     R9,R9,#+2
    245          			if (desc->right_enable)
   \                     ??_classd_polling_transfer_2:
   \       0x54   0xE5D4'200F        LDRB     R2,[R4, #+15]
   \       0x58   0xE352'0000        CMP      R2,#+0
   \       0x5C   0x0A00'0002        BEQ      ??_classd_polling_transfer_3
    246          				right = *current++;
   \       0x60   0xE1D9'20B0        LDRH     R2,[R9, #+0]
   \       0x64   0xE1B0'1002        MOVS     R1,R2
   \       0x68   0xE299'9002        ADDS     R9,R9,#+2
    247          			desc->addr->CLASSD_THR = CLASSD_THR_RDATA(right)
    248          			                       | CLASSD_THR_LDATA(left);
   \                     ??_classd_polling_transfer_3:
   \       0x6C   0xE6FF'1071        UXTH     R1,R1
   \       0x70   0xE6FF'0070        UXTH     R0,R0
   \       0x74   0xE190'0801        ORRS     R0,R0,R1, LSL #+16
   \       0x78   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x7C   0xE581'0010        STR      R0,[R1, #+16]
    249          		}
    250          		if (current >= end)
   \                     ??_classd_polling_transfer_1:
   \       0x80   0xE159'0008        CMP      R9,R8
   \       0x84   0x3AFF'FFE6        BCC      ??_classd_polling_transfer_0
    251          			break;
    252          	}
    253          
    254          	mutex_unlock(&desc->tx.mutex);
   \       0x88   0xE294'0010        ADDS     R0,R4,#+16
   \       0x8C   0x....'....        BL       mutex_unlock
    255          
    256          	callback_call(&desc->tx.callback, NULL);
   \       0x90   0xE3A0'1000        MOV      R1,#+0
   \       0x94   0xE294'0024        ADDS     R0,R4,#+36
   \       0x98   0x....'....        BL       callback_call
    257          }
   \       0x9C   0xE8BD'83F1        POP      {R0,R4-R9,PC}    ;; return
    258          
    259          /*----------------------------------------------------------------------------
    260           *        Exported functions
    261           *----------------------------------------------------------------------------*/
    262          

   \                                 In section SOFTPACK, align 4, keep-with-next
    263          int classd_configure(struct _classd_desc *desc)
    264          {
   \                     classd_configure:
   \        0x0   0xE92D'4FFE        PUSH     {R1-R11,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    265          	uint8_t i;
    266          	uint32_t mr, intpmr, dsp_clk_set, frame_set;
    267          	uint32_t id = get_classd_id_from_addr(desc->addr);
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       get_classd_id_from_addr
   \       0x10   0xE1B0'7000        MOVS     R7,R0
    268          
    269          	if (!desc->left_enable && !desc->right_enable)
   \       0x14   0xE5D4'000E        LDRB     R0,[R4, #+14]
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0004        BNE      ??classd_configure_2
   \       0x20   0xE5D4'000F        LDRB     R0,[R4, #+15]
   \       0x24   0xE350'0000        CMP      R0,#+0
   \       0x28   0x1A00'0001        BNE      ??classd_configure_2
    270          		return -EINVAL;
   \       0x2C   0xE3E0'001B        MVN      R0,#+27
   \       0x30   0xEA00'00A3        B        ??classd_configure_3
    271          
    272          	for (i = 0; i < ARRAY_SIZE(audio_info); i++) {
   \                     ??classd_configure_2:
   \       0x34   0xE3A0'9000        MOV      R9,#+0
   \       0x38   0xE1B0'8009        MOVS     R8,R9
   \                     ??classd_configure_4:
   \       0x3C   0xE1B0'0008        MOVS     R0,R8
   \       0x40   0xE6EF'0070        UXTB     R0,R0
   \       0x44   0xE350'0008        CMP      R0,#+8
   \       0x48   0x2A00'0016        BCS      ??classd_configure_5
    273          		if (audio_info[i].rate == desc->sample_rate) {
   \       0x4C   0x....'....        LDR      R0,??DataTable3_6
   \       0x50   0xE1B0'1008        MOVS     R1,R8
   \       0x54   0xE6EF'1071        UXTB     R1,R1
   \       0x58   0xE081'2081        ADD      R2,R1,R1, LSL #+1
   \       0x5C   0xE790'1102        LDR      R1,[R0, +R2, LSL #+2]
   \       0x60   0xE594'2004        LDR      R2,[R4, #+4]
   \       0x64   0xE151'0002        CMP      R1,R2
   \       0x68   0x1A00'000C        BNE      ??classd_configure_6
    274          			dsp_clk_set  = audio_info[i].dsp_clk;
   \       0x6C   0xE1B0'1008        MOVS     R1,R8
   \       0x70   0xE6EF'1071        UXTB     R1,R1
   \       0x74   0xE081'2081        ADD      R2,R1,R1, LSL #+1
   \       0x78   0xE090'1102        ADDS     R1,R0,R2, LSL #+2
   \       0x7C   0xE591'1008        LDR      R1,[R1, #+8]
   \       0x80   0xE1B0'5001        MOVS     R5,R1
    275          			frame_set = audio_info[i].sample_rate;
   \       0x84   0xE1B0'1008        MOVS     R1,R8
   \       0x88   0xE6EF'1071        UXTB     R1,R1
   \       0x8C   0xE081'2081        ADD      R2,R1,R1, LSL #+1
   \       0x90   0xE090'0102        ADDS     R0,R0,R2, LSL #+2
   \       0x94   0xE590'0004        LDR      R0,[R0, #+4]
   \       0x98   0xE1B0'6000        MOVS     R6,R0
    276          			break;
   \       0x9C   0xEA00'0001        B        ??classd_configure_5
    277          		}
    278          	}
   \                     ??classd_configure_6:
   \       0xA0   0xE298'8001        ADDS     R8,R8,#+1
   \       0xA4   0xEAFF'FFE4        B        ??classd_configure_4
    279          	if (i == ARRAY_SIZE(audio_info))
   \                     ??classd_configure_5:
   \       0xA8   0xE1B0'0008        MOVS     R0,R8
   \       0xAC   0xE6EF'0070        UXTB     R0,R0
   \       0xB0   0xE350'0008        CMP      R0,#+8
   \       0xB4   0x1A00'0001        BNE      ??classd_configure_7
    280          		return -EINVAL;
   \       0xB8   0xE3E0'001B        MVN      R0,#+27
   \       0xBC   0xEA00'0080        B        ??classd_configure_3
    281          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    282          	if (!_dspclk_configure(dsp_clk_set))
   \                     ??classd_configure_7:
   \       0xC0   0xE1B0'0005        MOVS     R0,R5
   \       0xC4   0x....'....        BL       _dspclk_configure
   \       0xC8   0xE350'0000        CMP      R0,#+0
   \       0xCC   0x1A00'0001        BNE      ??classd_configure_8
    283          		return -EINVAL;
   \       0xD0   0xE3E0'001B        MVN      R0,#+27
   \       0xD4   0xEA00'007A        B        ??classd_configure_3
    284          #endif
    285          	struct _pmc_periph_cfg cfg = {
    286          		.gck = {
    287          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    288          			.css = PMC_PCR_GCKCSS_AUDIO_CLK,
    289          			.div = 1,
    290          #else
    291          			.css = PMC_PCR_GCKCSS_MCK_CLK,
    292          			.div = 2,
    293          #endif	
    294          		},
    295          	};
   \                     ??classd_configure_8:
   \       0xD8   0x....'....        LDR      R2,??DataTable3_7
   \       0xDC   0xE892'0003        LDM      R2,{R0,R1}
   \       0xE0   0xE28D'2004        ADD      R2,SP,#+4
   \       0xE4   0xE1C2'00F0        STRD     R0,R1,[R2, #+0]
    296          	pmc_configure_peripheral(id, &cfg, true);
   \       0xE8   0xE3A0'2001        MOV      R2,#+1
   \       0xEC   0xE28D'1004        ADD      R1,SP,#+4
   \       0xF0   0xE1B0'0007        MOVS     R0,R7
   \       0xF4   0x....'....        BL       pmc_configure_peripheral
    297          
    298          	/* perform soft reset */
    299          	desc->addr->CLASSD_CR  = CLASSD_CR_SWRST;
   \       0xF8   0xE3A0'A001        MOV      R10,#+1
   \       0xFC   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x100   0xE580'A000        STR      R10,[R0, #+0]
    300          	desc->addr->CLASSD_IDR = CLASSD_IDR_DATRDY;
   \      0x104   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x108   0xE580'A018        STR      R10,[R0, #+24]
    301          
    302          	/* initial MR/INTPMR values */
    303          	mr = 0;
   \      0x10C   0xE1B0'B009        MOVS     R11,R9
    304          	intpmr = dsp_clk_set | frame_set;
   \      0x110   0xE196'0005        ORRS     R0,R6,R5
   \      0x114   0xE58D'0000        STR      R0,[SP, #+0]
    305          
    306          	/* configure output mode */
    307          	switch (desc->mode) {
   \      0x118   0xE5D4'0009        LDRB     R0,[R4, #+9]
   \      0x11C   0xE350'0003        CMP      R0,#+3
   \      0x120   0x8A00'000A        BHI      ??classd_configure_9
   \      0x124   0xE7DF'1000        LDRB     R1,[PC, R0]
   \      0x128   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??classd_configure_0:
   \      0x12C   0x00 0x01          DC8      0x0,0x1,0x3,0x5

   \              0x03 0x05
    308          	case CLASSD_OUTPUT_SINGLE_ENDED:
    309          		break;
   \                     ??classd_configure_10:
   \      0x130   0xEA00'000F        B        ??classd_configure_11
    310          	case CLASSD_OUTPUT_DIFFERENTIAL:
    311          		mr |= CLASSD_MR_PWMTYP;
   \                     ??classd_configure_12:
   \      0x134   0xE39B'BF40        ORRS     R11,R11,#0x100
    312          		break;
   \      0x138   0xEA00'000D        B        ??classd_configure_11
    313          	case CLASSD_OUTPUT_HALF_BRIDGE:
    314          		mr |= CLASSD_MR_NON_OVERLAP;
   \                     ??classd_configure_13:
   \      0x13C   0xE39B'BB40        ORRS     R11,R11,#0x10000
    315          		break;
   \      0x140   0xEA00'000B        B        ??classd_configure_11
    316          	case CLASSD_OUTPUT_FULL_BRIDGE:
    317          		mr |= CLASSD_MR_PWMTYP | CLASSD_MR_NON_OVERLAP;
   \                     ??classd_configure_14:
   \      0x144   0xE39B'BF40        ORRS     R11,R11,#0x100
   \      0x148   0xE39B'BB40        ORRS     R11,R11,#0x10000
    318          		break;
   \      0x14C   0xEA00'0008        B        ??classd_configure_11
    319          	default:
    320          		trace_warning("classd: invalid mode %u\n", (unsigned)desc->mode);
   \                     ??classd_configure_9:
   \      0x150   0x....'....        LDR      R0,??DataTable3_2
   \      0x154   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x158   0xE350'0003        CMP      R0,#+3
   \      0x15C   0x3A00'0002        BCC      ??classd_configure_15
   \      0x160   0xE5D4'1009        LDRB     R1,[R4, #+9]
   \      0x164   0x....'....        LDR      R0,??DataTable3_8
   \      0x168   0x....'....        BL       printf
    321          		return -EINVAL;
   \                     ??classd_configure_15:
   \      0x16C   0xE3E0'001B        MVN      R0,#+27
   \      0x170   0xEA00'0053        B        ??classd_configure_3
    322          	}
    323          
    324          	/* configure non-overlapping time */
    325          	if (mr & CLASSD_MR_NON_OVERLAP) {
   \                     ??classd_configure_11:
   \      0x174   0xE31B'0B40        TST      R11,#0x10000
   \      0x178   0x0A00'0015        BEQ      ??classd_configure_16
    326          		switch (desc->non_ovr) {
   \      0x17C   0xE5D4'000A        LDRB     R0,[R4, #+10]
   \      0x180   0xE350'0003        CMP      R0,#+3
   \      0x184   0x8A00'0009        BHI      ??classd_configure_17
   \      0x188   0xE7DF'1000        LDRB     R1,[PC, R0]
   \      0x18C   0xE08F'F101        ADD      PC,PC,R1, LSL #+2
   \                     ??classd_configure_1:
   \      0x190   0x00 0x01          DC8      0x0,0x1,0x3,0x5

   \              0x03 0x05
    327          		case CLASSD_NONOVR_5NS:
    328          			mr |= CLASSD_MR_NOVRVAL_5NS;
    329          			break;
   \                     ??classd_configure_18:
   \      0x194   0xEA00'000E        B        ??classd_configure_16
    330          		case CLASSD_NONOVR_10NS:
    331          			mr |= CLASSD_MR_NOVRVAL_10NS;
   \                     ??classd_configure_19:
   \      0x198   0xE39B'B940        ORRS     R11,R11,#0x100000
    332          			break;
   \      0x19C   0xEA00'000C        B        ??classd_configure_16
    333          		case CLASSD_NONOVR_15NS:
    334          			mr |= CLASSD_MR_NOVRVAL_15NS;
   \                     ??classd_configure_20:
   \      0x1A0   0xE39B'B980        ORRS     R11,R11,#0x200000
    335          			break;
   \      0x1A4   0xEA00'000A        B        ??classd_configure_16
    336          		case CLASSD_NONOVR_20NS:
    337          			mr |= CLASSD_MR_NOVRVAL_20NS;
   \                     ??classd_configure_21:
   \      0x1A8   0xE39B'B9C0        ORRS     R11,R11,#0x300000
    338          			break;
   \      0x1AC   0xEA00'0008        B        ??classd_configure_16
    339          		default:
    340          			trace_warning("classd: invalid non overlap value %u\r\n",
    341          				      (unsigned)desc->non_ovr);
   \                     ??classd_configure_17:
   \      0x1B0   0x....'....        LDR      R0,??DataTable3_2
   \      0x1B4   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x1B8   0xE350'0003        CMP      R0,#+3
   \      0x1BC   0x3A00'0002        BCC      ??classd_configure_22
   \      0x1C0   0xE5D4'100A        LDRB     R1,[R4, #+10]
   \      0x1C4   0x....'....        LDR      R0,??DataTable3_9
   \      0x1C8   0x....'....        BL       printf
    342          			return -EINVAL;
   \                     ??classd_configure_22:
   \      0x1CC   0xE3E0'001B        MVN      R0,#+27
   \      0x1D0   0xEA00'003B        B        ??classd_configure_3
    343          		}
    344          	}
    345          
    346          	/* configure mono/stereo */
    347          	if (desc->swap_channels)
   \                     ??classd_configure_16:
   \      0x1D4   0xE5D4'000B        LDRB     R0,[R4, #+11]
   \      0x1D8   0xE350'0000        CMP      R0,#+0
   \      0x1DC   0x0A00'0002        BEQ      ??classd_configure_23
    348          		intpmr |= CLASSD_INTPMR_SWAP;
   \      0x1E0   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x1E4   0xE390'0A80        ORRS     R0,R0,#0x80000
   \      0x1E8   0xE58D'0000        STR      R0,[SP, #+0]
    349          	if (!_set_mono_bits(desc->mono, desc->mono_mode, &intpmr))
   \                     ??classd_configure_23:
   \      0x1EC   0xE1B0'200D        MOVS     R2,SP
   \      0x1F0   0xE5D4'100D        LDRB     R1,[R4, #+13]
   \      0x1F4   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \      0x1F8   0x....'....        BL       _set_mono_bits
   \      0x1FC   0xE350'0000        CMP      R0,#+0
   \      0x200   0x1A00'0001        BNE      ??classd_configure_24
    350          		return -EINVAL;
   \      0x204   0xE3E0'001B        MVN      R0,#+27
   \      0x208   0xEA00'002D        B        ??classd_configure_3
    351          
    352          	/* configure left channel (muted, max attn) */
    353          	if (desc->left_enable)
   \                     ??classd_configure_24:
   \      0x20C   0xE5D4'000E        LDRB     R0,[R4, #+14]
   \      0x210   0xE350'0000        CMP      R0,#+0
   \      0x214   0x0A00'0000        BEQ      ??classd_configure_25
    354          		mr |= CLASSD_MR_LEN;
   \      0x218   0xE39B'B001        ORRS     R11,R11,#0x1
    355          	mr |= CLASSD_MR_LMUTE;
   \                     ??classd_configure_25:
   \      0x21C   0xE39B'0002        ORRS     R0,R11,#0x2
    356          	intpmr |= CLASSD_INTPMR_ATTL(CLASSD_INTPMR_ATTL_Msk);
   \      0x220   0xE59D'1000        LDR      R1,[SP, #+0]
   \      0x224   0xE391'107F        ORRS     R1,R1,#0x7F
   \      0x228   0xE58D'1000        STR      R1,[SP, #+0]
    357          
    358          	/* configure right channel (muted, max attn)  */
    359          	if (desc->right_enable)
   \      0x22C   0xE5D4'100F        LDRB     R1,[R4, #+15]
   \      0x230   0xE351'0000        CMP      R1,#+0
   \      0x234   0x0A00'0000        BEQ      ??classd_configure_26
    360          		mr |= CLASSD_MR_REN;
   \      0x238   0xE390'0010        ORRS     R0,R0,#0x10
    361          	mr |= CLASSD_MR_RMUTE;
   \                     ??classd_configure_26:
   \      0x23C   0xE390'B020        ORRS     R11,R0,#0x20
    362          	intpmr |= CLASSD_INTPMR_ATTR(CLASSD_INTPMR_ATTL_Msk);
   \      0x240   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x244   0xE390'0C7F        ORRS     R0,R0,#0x7F00
   \      0x248   0xE58D'0000        STR      R0,[SP, #+0]
    363          
    364          	/* write configuration */
    365          	desc->addr->CLASSD_MR = mr;
   \      0x24C   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x250   0xE580'B004        STR      R11,[R0, #+4]
    366          	desc->addr->CLASSD_INTPMR = intpmr;
   \      0x254   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x258   0xE594'1000        LDR      R1,[R4, #+0]
   \      0x25C   0xE581'0008        STR      R0,[R1, #+8]
    367          
    368          	desc->tx.dma.channel = dma_allocate_channel(DMA_PERIPH_MEMORY, id);
   \      0x260   0xE1B0'1007        MOVS     R1,R7
   \      0x264   0xE6EF'1071        UXTB     R1,R1
   \      0x268   0xE3A0'00FF        MOV      R0,#+255
   \      0x26C   0x....'....        BL       dma_allocate_channel
   \      0x270   0xE584'002C        STR      R0,[R4, #+44]
    369          	assert(desc->tx.dma.channel != NULL);
   \      0x274   0xE594'002C        LDR      R0,[R4, #+44]
   \      0x278   0xE350'0000        CMP      R0,#+0
   \      0x27C   0x1A00'0004        BNE      ??classd_configure_27
   \      0x280   0xE300'2171        MOVW     R2,#+369
   \      0x284   0x....'....        LDR      R1,??DataTable3_10
   \      0x288   0x....'....        LDR      R0,??DataTable3_11
   \      0x28C   0x....'....        BL       __aeabi_assert
   \      0x290   0x....'....        BL       __iar_EmptyStepPoint
    370          
    371          	desc->tx.dma.cfg_dma.incr_saddr = true;
   \                     ??classd_configure_27:
   \      0x294   0xE5C4'A038        STRB     R10,[R4, #+56]
    372          	desc->tx.dma.cfg_dma.incr_daddr = false;
   \      0x298   0xE5C4'9039        STRB     R9,[R4, #+57]
    373          	desc->tx.dma.cfg_dma.loop = false;
   \      0x29C   0xE5C4'903A        STRB     R9,[R4, #+58]
    374          	desc->tx.dma.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x2A0   0xE584'9034        STR      R9,[R4, #+52]
    375          
    376          	desc->tx.mutex = 0;
   \      0x2A4   0xE584'9010        STR      R9,[R4, #+16]
    377          
    378          	if ((desc->addr->CLASSD_INTSR & CLASSD_INTSR_CFGERR) != 0)
   \      0x2A8   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x2AC   0xE590'000C        LDR      R0,[R0, #+12]
   \      0x2B0   0xE310'0001        TST      R0,#0x1
   \      0x2B4   0x0A00'0001        BEQ      ??classd_configure_28
    379          		return -ENODEV;
   \      0x2B8   0xE3E0'002B        MVN      R0,#+43
   \      0x2BC   0xEA00'0000        B        ??classd_configure_3
    380          
    381          	return 0;
   \                     ??classd_configure_28:
   \      0x2C0   0xE3A0'0000        MOV      R0,#+0
   \                     ??classd_configure_3:
   \      0x2C4   0xE8BD'8FFE        POP      {R1-R11,PC}      ;; return
    382          }

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x0000'0500        DC32 1'280, 1

   \              0x0000'0001
    383          

   \                                 In section SOFTPACK, align 4, keep-with-next
    384          void classd_disable(struct _classd_desc *desc)
    385          {
   \                     classd_disable:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    386          	uint32_t id = get_classd_id_from_addr(desc->addr);
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       get_classd_id_from_addr
   \       0x10   0xE1B0'5000        MOVS     R5,R0
    387          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    388          	pmc_disable_audio();
   \       0x14   0x....'....        BL       pmc_disable_audio
    389          #endif
    390          	pmc_disable_gck(id);
   \       0x18   0xE1B0'0005        MOVS     R0,R5
   \       0x1C   0x....'....        BL       pmc_disable_gck
    391          	pmc_disable_peripheral(id);
   \       0x20   0xE1B0'0005        MOVS     R0,R5
   \       0x24   0x....'....        BL       pmc_disable_peripheral
    392          }
   \       0x28   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    393          

   \                                 In section SOFTPACK, align 4, keep-with-next
    394          void classd_swap_channels(struct _classd_desc *desc, bool swap)
    395          {
    396          	if (swap) {
   \                     classd_swap_channels:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE6EF'2072        UXTB     R2,R2
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x0A00'0005        BEQ      ??classd_swap_channels_0
    397          		desc->addr->CLASSD_INTPMR |= CLASSD_INTPMR_SWAP;
   \       0x10   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x14   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x18   0xE392'2A80        ORRS     R2,R2,#0x80000
   \       0x1C   0xE590'3000        LDR      R3,[R0, #+0]
   \       0x20   0xE583'2008        STR      R2,[R3, #+8]
   \       0x24   0xEA00'0004        B        ??classd_swap_channels_1
    398          	} else {
    399          		desc->addr->CLASSD_INTPMR &= ~CLASSD_INTPMR_SWAP;
   \                     ??classd_swap_channels_0:
   \       0x28   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x2C   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x30   0xE3D2'2A80        BICS     R2,R2,#0x80000
   \       0x34   0xE590'3000        LDR      R3,[R0, #+0]
   \       0x38   0xE583'2008        STR      R2,[R3, #+8]
    400          	}
    401          }
   \                     ??classd_swap_channels_1:
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
    402          

   \                                 In section SOFTPACK, align 4, keep-with-next
    403          void classd_set_equalizer(struct _classd_desc *desc, enum _classd_eqcfg eqcfg)
    404          {
   \                     classd_set_equalizer:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    405          	_set_eqcfg_bits(eqcfg, &desc->addr->CLASSD_INTPMR);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0xE290'1008        ADDS     R1,R0,#+8
   \       0x14   0xE1B0'0005        MOVS     R0,R5
   \       0x18   0xE6EF'0070        UXTB     R0,R0
   \       0x1C   0x....'....        BL       _set_eqcfg_bits
    406          }
   \       0x20   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    407          

   \                                 In section SOFTPACK, align 4, keep-with-next
    408          void classd_enable_channels(struct _classd_desc *desc, bool left, bool right)
    409          {
   \                     classd_enable_channels:
   \        0x0   0xE92D'4000        PUSH     {LR}
    410          	uint32_t bits = 0;
   \        0x4   0xE3A0'3000        MOV      R3,#+0
    411          	if (left)
   \        0x8   0xE1B0'C001        MOVS     R12,R1
   \        0xC   0xE6EF'C07C        UXTB     R12,R12
   \       0x10   0xE35C'0000        CMP      R12,#+0
   \       0x14   0x0A00'0000        BEQ      ??classd_enable_channels_0
    412          		bits |= CLASSD_MR_LEN;
   \       0x18   0xE393'3001        ORRS     R3,R3,#0x1
    413          	if (right)
   \                     ??classd_enable_channels_0:
   \       0x1C   0xE1B0'C002        MOVS     R12,R2
   \       0x20   0xE6EF'C07C        UXTB     R12,R12
   \       0x24   0xE35C'0000        CMP      R12,#+0
   \       0x28   0x0A00'0000        BEQ      ??classd_enable_channels_1
    414          		bits |= CLASSD_MR_REN;
   \       0x2C   0xE393'3010        ORRS     R3,R3,#0x10
    415          	desc->addr->CLASSD_MR |= bits;
   \                     ??classd_enable_channels_1:
   \       0x30   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x34   0xE59C'C004        LDR      R12,[R12, #+4]
   \       0x38   0xE193'C00C        ORRS     R12,R3,R12
   \       0x3C   0xE590'E000        LDR      LR,[R0, #+0]
   \       0x40   0xE58E'C004        STR      R12,[LR, #+4]
    416          }
   \       0x44   0xE8BD'8000        POP      {PC}             ;; return
    417          

   \                                 In section SOFTPACK, align 4, keep-with-next
    418          void classd_disable_channels(struct _classd_desc *desc, bool left, bool right)
    419          {
   \                     classd_disable_channels:
   \        0x0   0xE92D'4000        PUSH     {LR}
    420          	uint32_t bits = 0;
   \        0x4   0xE3A0'3000        MOV      R3,#+0
    421          	if (left)
   \        0x8   0xE1B0'C001        MOVS     R12,R1
   \        0xC   0xE6EF'C07C        UXTB     R12,R12
   \       0x10   0xE35C'0000        CMP      R12,#+0
   \       0x14   0x0A00'0000        BEQ      ??classd_disable_channels_0
    422          		bits |= CLASSD_MR_LEN;
   \       0x18   0xE393'3001        ORRS     R3,R3,#0x1
    423          	if (right)
   \                     ??classd_disable_channels_0:
   \       0x1C   0xE1B0'C002        MOVS     R12,R2
   \       0x20   0xE6EF'C07C        UXTB     R12,R12
   \       0x24   0xE35C'0000        CMP      R12,#+0
   \       0x28   0x0A00'0000        BEQ      ??classd_disable_channels_1
    424          		bits |= CLASSD_MR_REN;
   \       0x2C   0xE393'3010        ORRS     R3,R3,#0x10
    425          	desc->addr->CLASSD_MR &= ~bits;
   \                     ??classd_disable_channels_1:
   \       0x30   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x34   0xE59C'C004        LDR      R12,[R12, #+4]
   \       0x38   0xE1DC'C003        BICS     R12,R12,R3
   \       0x3C   0xE590'E000        LDR      LR,[R0, #+0]
   \       0x40   0xE58E'C004        STR      R12,[LR, #+4]
    426          }
   \       0x44   0xE8BD'8000        POP      {PC}             ;; return
    427          

   \                                 In section SOFTPACK, align 4, keep-with-next
    428          void classd_set_left_attenuation(struct _classd_desc *desc, uint8_t attn)
    429          {
    430          	if (attn > (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos))
   \                     classd_set_left_attenuation:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE6EF'2072        UXTB     R2,R2
   \        0x8   0xE352'0080        CMP      R2,#+128
   \        0xC   0x3A00'0001        BCC      ??classd_set_left_attenuation_0
    431          		attn = (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos);
   \       0x10   0xE3A0'207F        MOV      R2,#+127
   \       0x14   0xE1B0'1002        MOVS     R1,R2
    432          
    433          	uint32_t intpmr = desc->addr->CLASSD_INTPMR & ~CLASSD_INTPMR_ATTL_Msk;
   \                     ??classd_set_left_attenuation_0:
   \       0x18   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x1C   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x20   0xE3D2'207F        BICS     R2,R2,#0x7F
    434          	desc->addr->CLASSD_INTPMR = intpmr | CLASSD_INTPMR_ATTL(attn);
   \       0x24   0xE1B0'3001        MOVS     R3,R1
   \       0x28   0xE6EF'3073        UXTB     R3,R3
   \       0x2C   0xE213'307F        ANDS     R3,R3,#0x7F
   \       0x30   0xE193'3002        ORRS     R3,R3,R2
   \       0x34   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x38   0xE58C'3008        STR      R3,[R12, #+8]
    435          }
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
    436          

   \                                 In section SOFTPACK, align 4, keep-with-next
    437          void classd_set_right_attenuation(struct _classd_desc *desc, uint8_t attn)
    438          {
    439          	if (attn > (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos))
   \                     classd_set_right_attenuation:
   \        0x0   0xE1B0'2001        MOVS     R2,R1
   \        0x4   0xE6EF'2072        UXTB     R2,R2
   \        0x8   0xE352'0080        CMP      R2,#+128
   \        0xC   0x3A00'0001        BCC      ??classd_set_right_attenuation_0
    440          		attn = (CLASSD_INTPMR_ATTL_Msk >> CLASSD_INTPMR_ATTL_Pos);
   \       0x10   0xE3A0'207F        MOV      R2,#+127
   \       0x14   0xE1B0'1002        MOVS     R1,R2
    441          
    442          	uint32_t intpmr = desc->addr->CLASSD_INTPMR & ~CLASSD_INTPMR_ATTR_Msk;
   \                     ??classd_set_right_attenuation_0:
   \       0x18   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x1C   0xE592'2008        LDR      R2,[R2, #+8]
   \       0x20   0xE3D2'2C7F        BICS     R2,R2,#0x7F00
    443          	desc->addr->CLASSD_INTPMR = intpmr | CLASSD_INTPMR_ATTR(attn);
   \       0x24   0xE1B0'3001        MOVS     R3,R1
   \       0x28   0xE6EF'3073        UXTB     R3,R3
   \       0x2C   0xE3A0'CC7F        MOV      R12,#+32512
   \       0x30   0xE01C'3403        ANDS     R3,R12,R3, LSL #+8
   \       0x34   0xE193'3002        ORRS     R3,R3,R2
   \       0x38   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x3C   0xE58C'3008        STR      R3,[R12, #+8]
    444          }
   \       0x40   0xE12F'FF1E        BX       LR               ;; return
    445          

   \                                 In section SOFTPACK, align 4, keep-with-next
    446          void classd_volume_mute(struct _classd_desc *desc, bool left, bool right)
    447          {
   \                     classd_volume_mute:
   \        0x0   0xE92D'4000        PUSH     {LR}
    448          	uint32_t bits = 0;
   \        0x4   0xE3A0'3000        MOV      R3,#+0
    449          	if (left)
   \        0x8   0xE1B0'C001        MOVS     R12,R1
   \        0xC   0xE6EF'C07C        UXTB     R12,R12
   \       0x10   0xE35C'0000        CMP      R12,#+0
   \       0x14   0x0A00'0000        BEQ      ??classd_volume_mute_0
    450          		bits |= CLASSD_MR_LMUTE;
   \       0x18   0xE393'3002        ORRS     R3,R3,#0x2
    451          	if (right)
   \                     ??classd_volume_mute_0:
   \       0x1C   0xE1B0'C002        MOVS     R12,R2
   \       0x20   0xE6EF'C07C        UXTB     R12,R12
   \       0x24   0xE35C'0000        CMP      R12,#+0
   \       0x28   0x0A00'0000        BEQ      ??classd_volume_mute_1
    452          		bits |= CLASSD_MR_RMUTE;
   \       0x2C   0xE393'3020        ORRS     R3,R3,#0x20
    453          	desc->addr->CLASSD_MR |= bits;
   \                     ??classd_volume_mute_1:
   \       0x30   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x34   0xE59C'C004        LDR      R12,[R12, #+4]
   \       0x38   0xE193'C00C        ORRS     R12,R3,R12
   \       0x3C   0xE590'E000        LDR      LR,[R0, #+0]
   \       0x40   0xE58E'C004        STR      R12,[LR, #+4]
    454          }
   \       0x44   0xE8BD'8000        POP      {PC}             ;; return
    455          

   \                                 In section SOFTPACK, align 4, keep-with-next
    456          void classd_volume_unmute(struct _classd_desc *desc, bool left, bool right)
    457          {
   \                     classd_volume_unmute:
   \        0x0   0xE92D'4000        PUSH     {LR}
    458          	uint32_t bits = 0;
   \        0x4   0xE3A0'3000        MOV      R3,#+0
    459          	if (left)
   \        0x8   0xE1B0'C001        MOVS     R12,R1
   \        0xC   0xE6EF'C07C        UXTB     R12,R12
   \       0x10   0xE35C'0000        CMP      R12,#+0
   \       0x14   0x0A00'0000        BEQ      ??classd_volume_unmute_0
    460          		bits |= CLASSD_MR_LMUTE;
   \       0x18   0xE393'3002        ORRS     R3,R3,#0x2
    461          	if (right)
   \                     ??classd_volume_unmute_0:
   \       0x1C   0xE1B0'C002        MOVS     R12,R2
   \       0x20   0xE6EF'C07C        UXTB     R12,R12
   \       0x24   0xE35C'0000        CMP      R12,#+0
   \       0x28   0x0A00'0000        BEQ      ??classd_volume_unmute_1
    462          		bits |= CLASSD_MR_RMUTE;
   \       0x2C   0xE393'3020        ORRS     R3,R3,#0x20
    463          	desc->addr->CLASSD_MR &= ~bits;
   \                     ??classd_volume_unmute_1:
   \       0x30   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x34   0xE59C'C004        LDR      R12,[R12, #+4]
   \       0x38   0xE1DC'C003        BICS     R12,R12,R3
   \       0x3C   0xE590'E000        LDR      LR,[R0, #+0]
   \       0x40   0xE58E'C004        STR      R12,[LR, #+4]
    464          }
   \       0x44   0xE8BD'8000        POP      {PC}             ;; return
    465          

   \                                 In section SOFTPACK, align 4, keep-with-next
    466          int classd_transfer(struct _classd_desc* desc, struct _buffer* buf, struct _callback* cb)
    467          {
   \                     classd_transfer:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    468          	uint8_t tmode;
    469          
    470          	tmode = desc->transfer_mode;
   \       0x10   0xE5D4'7008        LDRB     R7,[R4, #+8]
    471          
    472          	if ((buf == NULL) || (buf->size == 0))
   \       0x14   0xE355'0000        CMP      R5,#+0
   \       0x18   0x0A00'0002        BEQ      ??classd_transfer_0
   \       0x1C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x20   0xE350'0000        CMP      R0,#+0
   \       0x24   0x1A00'0001        BNE      ??classd_transfer_1
    473          		return -EINVAL;
   \                     ??classd_transfer_0:
   \       0x28   0xE3E0'001B        MVN      R0,#+27
   \       0x2C   0xEA00'001F        B        ??classd_transfer_2
    474          
    475          	if (buf->attr & CLASSD_BUF_ATTR_WRITE) {
   \                     ??classd_transfer_1:
   \       0x30   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \       0x34   0xE310'0001        TST      R0,#0x1
   \       0x38   0x0A00'001B        BEQ      ??classd_transfer_3
    476          		mutex_lock(&desc->tx.mutex);
   \       0x3C   0xE294'0010        ADDS     R0,R4,#+16
   \       0x40   0x....'....        BL       mutex_lock
    477          
    478          		desc->tx.transferred = 0;
   \       0x44   0xE3A0'0000        MOV      R0,#+0
   \       0x48   0xE1C4'02B0        STRH     R0,[R4, #+32]
    479          		desc->tx.buffer.data = buf->data;
   \       0x4C   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x50   0xE584'0014        STR      R0,[R4, #+20]
    480          		desc->tx.buffer.size = buf->size;
   \       0x54   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x58   0xE584'0018        STR      R0,[R4, #+24]
    481          		desc->tx.buffer.attr = buf->attr;
   \       0x5C   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x60   0xE584'001C        STR      R0,[R4, #+28]
    482          
    483          		callback_copy(&desc->tx.callback, cb);
   \       0x64   0xE1B0'1006        MOVS     R1,R6
   \       0x68   0xE294'0024        ADDS     R0,R4,#+36
   \       0x6C   0x....'....        BL       callback_copy
    484          
    485          		if (tmode == CLASSD_MODE_DMA)
   \       0x70   0xE1B0'0007        MOVS     R0,R7
   \       0x74   0xE6EF'0070        UXTB     R0,R0
   \       0x78   0xE350'0001        CMP      R0,#+1
   \       0x7C   0x1A00'0003        BNE      ??classd_transfer_4
    486          			_classd_dma_transfer(desc, buf);
   \       0x80   0xE1B0'1005        MOVS     R1,R5
   \       0x84   0xE1B0'0004        MOVS     R0,R4
   \       0x88   0x....'....        BL       _classd_dma_transfer
   \       0x8C   0xEA00'0006        B        ??classd_transfer_3
    487          		else if (tmode == CLASSD_MODE_POLLING)
   \                     ??classd_transfer_4:
   \       0x90   0xE1B0'0007        MOVS     R0,R7
   \       0x94   0xE6EF'0070        UXTB     R0,R0
   \       0x98   0xE350'0000        CMP      R0,#+0
   \       0x9C   0x1A00'0002        BNE      ??classd_transfer_3
    488          			_classd_polling_transfer(desc, buf);
   \       0xA0   0xE1B0'1005        MOVS     R1,R5
   \       0xA4   0xE1B0'0004        MOVS     R0,R4
   \       0xA8   0x....'....        BL       _classd_polling_transfer
    489          	}
    490          	return 0;
   \                     ??classd_transfer_3:
   \       0xAC   0xE3A0'0000        MOV      R0,#+0
   \                     ??classd_transfer_2:
   \       0xB0   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    491          }
    492          

   \                                 In section SOFTPACK, align 4, keep-with-next
    493          bool classd_tx_transfer_is_done(struct _classd_desc* desc)
    494          {
   \                     classd_tx_transfer_is_done:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    495          	return (!mutex_is_locked(&desc->tx.mutex));
   \        0x8   0xE294'0010        ADDS     R0,R4,#+16
   \        0xC   0x....'....        BL       mutex_is_locked
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0001        BNE      ??classd_tx_transfer_is_done_0
   \       0x18   0xE3A0'0001        MOV      R0,#+1
   \       0x1C   0xEA00'0000        B        ??classd_tx_transfer_is_done_1
   \                     ??classd_tx_transfer_is_done_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \                     ??classd_tx_transfer_is_done_1:
   \       0x24   0xE6EF'0070        UXTB     R0,R0
   \       0x28   0xE8BD'8010        POP      {R4,PC}          ;; return
    496          }
    497          

   \                                 In section SOFTPACK, align 4, keep-with-next
    498          void classd_tx_stop(struct _classd_desc* desc)
    499          {
   \                     classd_tx_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    500          	if (desc->transfer_mode == CLASSD_MODE_DMA) {
   \        0x8   0xE5D4'0008        LDRB     R0,[R4, #+8]
   \        0xC   0xE350'0001        CMP      R0,#+1
   \       0x10   0x1A00'0006        BNE      ??classd_tx_stop_0
    501          		if (desc->tx.dma.channel){
   \       0x14   0xE594'002C        LDR      R0,[R4, #+44]
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x0A00'0003        BEQ      ??classd_tx_stop_0
    502          			dma_stop_transfer(desc->tx.dma.channel);
   \       0x20   0xE594'002C        LDR      R0,[R4, #+44]
   \       0x24   0x....'....        BL       dma_stop_transfer
    503          			mutex_unlock(&desc->tx.mutex);
   \       0x28   0xE294'0010        ADDS     R0,R4,#+16
   \       0x2C   0x....'....        BL       mutex_unlock
    504          		}
    505          	}
    506          }
   \                     ??classd_tx_stop_0:
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x0016'0419        DC32     0x160419

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x000D'844D        DC32     0xd844d

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x....'....        DC32     audio_info

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_11:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x61, 0x75

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x61 0x75
   \       0x40   0x64 0x69          DC8 0x64, 0x69, 0x6F, 0x5C, 0x63, 0x6C, 0x61, 0x73

   \              0x6F 0x5C    

   \              0x63 0x6C    

   \              0x61 0x73
   \       0x48   0x73 0x64          DC8 0x73, 0x64, 0x2E, 0x63, 0x3A, 0x31, 0x30, 0x36

   \              0x2E 0x63    

   \              0x3A 0x31    

   \              0x30 0x36
   \       0x50   0x20 0x43          DC8 0x20, 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75

   \              0x6F 0x6E    

   \              0x66 0x69    

   \              0x67 0x75
   \       0x58   0x72 0x65          DC8 0x72, 0x65, 0x64, 0x20, 0x41, 0x75, 0x64, 0x69

   \              0x64 0x20    

   \              0x41 0x75    

   \              0x64 0x69
   \       0x60   0x6F 0x20          DC8 0x6F, 0x20, 0x50, 0x4C, 0x4C, 0x20, 0x50, 0x4D

   \              0x50 0x4C    

   \              0x4C 0x20    

   \              0x50 0x4D
   \       0x68   0x43 0x20          DC8 0x43, 0x20, 0x43, 0x6C, 0x6F, 0x63, 0x6B, 0x3A

   \              0x43 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x3A
   \       0x70   0x20 0x25          DC8 0x20, 0x25, 0x75, 0x20, 0x28, 0x3D, 0x20, 0x38

   \              0x75 0x20    

   \              0x28 0x3D    

   \              0x20 0x38
   \       0x78   0x20 0x2A          DC8 0x20, 0x2A, 0x20, 0x25, 0x75, 0x29, 0x0D, 0x0A

   \              0x20 0x25    

   \              0x75 0x29    

   \              0x0D 0x0A
   \       0x80   0x00               DC8 0
   \       0x81   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid equalizer config %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x65 0x71    

   \              0x75 0x61    

   \              0x6C 0x69    

   \              0x7A 0x65    

   \              0x72 0x20    

   \              0x63 0x6F    

   \              0x6E 0x66    

   \              0x69 0x67    

   \              0x20 0x25    

   \              0x75 0x0D    

   \              0x0A 0x00
   \       0x2A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid mono mode %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6D 0x6F    

   \              0x6E 0x6F    

   \              0x20 0x6D    

   \              0x6F 0x64    

   \              0x65 0x20    

   \              0x25 0x75    

   \              0x0D 0x0A    

   \              0x00
   \       0x23   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid mode %u\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6D 0x6F    

   \              0x64 0x65    

   \              0x20 0x25    

   \              0x75 0x0A    

   \              0x00
   \       0x1D   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x57          DC8 "-W- classd: invalid non overlap value %u\015\012"

   \              0x2D 0x20    

   \              0x63 0x6C    

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x3A 0x20    

   \              0x69 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x6E 0x6F    

   \              0x6E 0x20    

   \              0x6F 0x76    

   \              0x65 0x72    

   \              0x6C 0x61    

   \              0x70 0x20    

   \              0x76 0x61    

   \              0x6C 0x75    

   \              0x65 0x20    

   \              0x25 0x75    

   \              0x0D 0x0A    

   \              0x00
   \       0x2B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x64 0x65          DC8 "desc->tx.dma.channel != 0"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x74 0x78    

   \              0x2E 0x64    

   \              0x6D 0x61    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x20 0x21    

   \              0x3D 0x20    

   \              0x30 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x61, 0x75, 0x64, 0x69, 0x6F, 0x5C

   \              0x61 0x75    

   \              0x64 0x69    

   \              0x6F 0x5C
   \       0x40   0x63 0x6C          DC8 0x63, 0x6C, 0x61, 0x73, 0x73, 0x64, 0x2E, 0x63

   \              0x61 0x73    

   \              0x73 0x64    

   \              0x2E 0x63
   \       0x48   0x00               DC8 0
   \       0x49   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   _classd_dma_transfer
        32   -> __aeabi_memset
        32   -> cache_clean_region
        32   -> callback_set
        32   -> dma_configure_transfer
        32   -> dma_set_callback
        32   -> dma_start_transfer
      16   _classd_dma_transfer_callback
        16   -> callback_call
        16   -> dma_reset_channel
        16   -> mutex_unlock
      32   _classd_polling_transfer
        32   -> callback_call
        32   -> mutex_unlock
      32   _dspclk_configure
        32   -> pmc_configure_audio
        32   -> pmc_enable_audio
        32   -> pmc_get_audio_pmc_clock
        32   -> printf
      24   _set_eqcfg_bits
        24   -> printf
      24   _set_mono_bits
        24   -> printf
      48   classd_configure
        48   -> __aeabi_assert
        48   -> __iar_EmptyStepPoint
        48   -> _dspclk_configure
        48   -> _set_mono_bits
        48   -> dma_allocate_channel
        48   -> get_classd_id_from_addr
        48   -> pmc_configure_peripheral
        48   -> printf
      16   classd_disable
        16   -> get_classd_id_from_addr
        16   -> pmc_disable_audio
        16   -> pmc_disable_gck
        16   -> pmc_disable_peripheral
       4   classd_disable_channels
       4   classd_enable_channels
      16   classd_set_equalizer
        16   -> _set_eqcfg_bits
       0   classd_set_left_attenuation
       0   classd_set_right_attenuation
       0   classd_swap_channels
      24   classd_transfer
        24   -> _classd_dma_transfer
        24   -> _classd_polling_transfer
        24   -> callback_copy
        24   -> mutex_lock
       8   classd_tx_stop
         8   -> dma_stop_transfer
         8   -> mutex_unlock
       8   classd_tx_transfer_is_done
         8   -> mutex_is_locked
       4   classd_volume_mute
       4   classd_volume_unmute


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
     132  ?_0
      44  ?_1
      36  ?_2
      32  ?_3
      44  ?_4
      28  ?_5
      76  ?_6
       8  ?_7
     204  _classd_dma_transfer
      48  _classd_dma_transfer_callback
     160  _classd_polling_transfer
     184  _dspclk_configure
     228  _set_eqcfg_bits
     168  _set_mono_bits
      96  audio_info
     712  classd_configure
      44  classd_disable
      72  classd_disable_channels
      72  classd_enable_channels
      36  classd_set_equalizer
      64  classd_set_left_attenuation
      68  classd_set_right_attenuation
      64  classd_swap_channels
     180  classd_transfer
      52  classd_tx_stop
      44  classd_tx_transfer_is_done
      72  classd_volume_mute
      72  classd_volume_unmute

 
   496 bytes in section .rodata
 2'592 bytes in section SOFTPACK
 
 2'592 bytes of CODE  memory
   496 bytes of CONST memory

Errors: none
Warnings: none
