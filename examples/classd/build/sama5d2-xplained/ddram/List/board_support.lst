###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         08/Dec/2020  16:30:43
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5610.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_PDMIC -D CONFIG_HAVE_AUDIO_AD1934 -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D CONFIG_HAVE_SPI_FIFO -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D
#        CONFIG_HAVE_USART -D CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sama5d2\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015-2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          #include "string.h"
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "trace.h"
     44          #include "intmath.h"
     45          
     46          #include "irq/irq.h"
     47          #ifdef CONFIG_HAVE_ISC
     48          #include "video/isc.h"
     49          #endif
     50          #include "peripherals/matrix.h"
     51          #include "gpio/pio.h"
     52          #include "peripherals/pmc.h"
     53          #include "sdmmc/sdmmc.h"
     54          #include "extram/smc.h"
     55          #include "peripherals/wdt.h"
     56          
     57          #include "extram/ddram.h"
     58          
     59          #include "arm/mmu_cp15.h"
     60          #include "mm/l1cache.h"
     61          #include "mm/l2cache_l2cc.h"
     62          
     63          #include "board_support.h"
     64          
     65          #ifdef CONFIG_HAVE_PMIC_ACT8945A
     66          #include "power/act8945a.h"
     67          #endif
     68          
     69          /*----------------------------------------------------------------------------
     70           *        Local constants
     71           *----------------------------------------------------------------------------*/
     72          

   \                                 In section .rodata, align 4
     73          static const struct _l2cc_config l2cc_cfg = {
   \                     l2cc_cfg:
   \        0x0   0x00 0x3B          DC8 0, 59, 216, 1

   \              0xD8 0x01
     74          	.instruct_prefetch = true,	// Instruction prefetch enable
     75          	.data_prefetch = true,	// Data prefetch enable
     76          	.double_linefill = true,
     77          	.incr_double_linefill = true,
     78          	/* Disable Write back (enables write through, Use this setting
     79          	   if DDR2 mem is not write-back) */
     80          	//cfg.no_write_back = true,
     81          	.non_sec_lockdown = true,
     82          	.cache_replacement = true,
     83          	.force_write_alloc = L2CC_FWA_DEFAULT,
     84          	.offset = 1,
     85          	.prefetch_drop = true,
     86          	.standby_mode = true,
     87          	.dyn_clock_gating = true
     88          };
     89          

   \                                 In section .data, align 4
     90          static const char* board_name = BOARD_NAME;
   \                     board_name:
   \        0x0   0x....'....        DC32 ?_0
     91          
     92          /*----------------------------------------------------------------------------
     93           *        Local variables
     94           *----------------------------------------------------------------------------*/
     95          

   \                                 In section .bss, align 16384
     96          ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     97          
     98          #ifdef CONFIG_HAVE_PMIC_ACT8945A
     99          static struct _act8945a act8945a = {
    100          	.bus = BOARD_ACT8945A_TWI_BUS,
    101          	.addr = BOARD_ACT8945A_TWI_ADDR,
    102          	.desc = {
    103          		.pin_chglev = BOARD_ACT8945A_PIN_CHGLEV,
    104          		.pin_irq = BOARD_ACT8945A_PIN_IRQ,
    105          		.pin_lbo = BOARD_ACT8945A_PIN_LBO
    106          	}
    107          };
    108          
    109          static bool act8945a_initialized = false;
    110          #endif /* CONFIG_HAVE_PMIC_ACT8945A */
    111          
    112          /*----------------------------------------------------------------------------
    113           *        Local functions
    114           *----------------------------------------------------------------------------*/
    115          

   \                                 In section SOFTPACK, align 4, keep-with-next
    116          static void board_cfg_matrix_default(void)
    117          {
   \                     board_cfg_matrix_default:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    118          	matrix_set_default_config();
   \        0x4   0x....'....        BL       matrix_set_default_config
    119          }
   \        0x8   0xE8BD'8001        POP      {R0,PC}          ;; return
    120          
    121          /*----------------------------------------------------------------------------
    122           *        Exported functions
    123           *----------------------------------------------------------------------------*/

   \                                 In section SOFTPACK, align 4, keep-with-next
    124          const char* get_board_name(void)
    125          {
    126          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable5
   \        0x4   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    127          }
    128          

   \                                 In section SOFTPACK, align 4, keep-with-next
    129          void board_cfg_clocks(void)
    130          {
   \                     board_cfg_clocks:
   \        0x0   0xE92D'5C00        PUSH     {R10-R12,LR}
    131          	struct _pmc_plla_cfg plla_config = {
    132          		.count = 0x3f,
    133          	};
   \        0x4   0xE1B0'000D        MOVS     R0,SP
   \        0x8   0x....'....        LDR      R1,??DataTable5_1
   \        0xC   0xE891'100C        LDM      R1,{R2,R3,R12}
   \       0x10   0xE880'100C        STM      R0,{R2,R3,R12}
    134          
    135          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
    136          	plla_config.mul = BOARD_PMC_PLLA_MUL;
   \       0x14   0xE3A0'0052        MOV      R0,#+82
   \       0x18   0xE58D'0000        STR      R0,[SP, #+0]
    137          	plla_config.div = BOARD_PMC_PLLA_DIV;
   \       0x1C   0xE3A0'0001        MOV      R0,#+1
   \       0x20   0xE58D'0004        STR      R0,[SP, #+4]
    138          #else
    139          	switch (pmc_get_main_oscillator_freq()) {
    140          	case 24000000:
    141          		plla_config.mul = 40;
    142          		plla_config.div = 1;
    143          		break;
    144          	case 16000000:
    145          		plla_config.mul = 61;
    146          		plla_config.div = 1;
    147          		break;
    148          	case 12000000:
    149          		plla_config.mul = 82;
    150          		plla_config.div = 1;
    151          		break;
    152          	}
    153          #endif
    154          	pmc_switch_mck_to_slck();
   \       0x24   0x....'....        BL       pmc_switch_mck_to_slck
    155          	pmc_set_mck_h32mxdiv(true);
   \       0x28   0xE3A0'0001        MOV      R0,#+1
   \       0x2C   0x....'....        BL       pmc_set_mck_h32mxdiv
    156          	pmc_set_mck_plladiv2(true);
   \       0x30   0xE3A0'0001        MOV      R0,#+1
   \       0x34   0x....'....        BL       pmc_set_mck_plladiv2
    157          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x38   0xE3A0'0000        MOV      R0,#+0
   \       0x3C   0x....'....        BL       pmc_set_mck_prescaler
    158          	pmc_set_mck_divider(PMC_MCKR_MDIV_EQ_PCK);
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \       0x44   0x....'....        BL       pmc_set_mck_divider
    159          	pmc_disable_plla();
   \       0x48   0x....'....        BL       pmc_disable_plla
    160          	pmc_select_external_osc(false);
   \       0x4C   0xE3A0'0000        MOV      R0,#+0
   \       0x50   0x....'....        BL       pmc_select_external_osc
    161          	pmc_configure_plla(&plla_config);
   \       0x54   0xE1B0'000D        MOVS     R0,SP
   \       0x58   0x....'....        BL       pmc_configure_plla
    162          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV3);
   \       0x5C   0xE3A0'0FC0        MOV      R0,#+768
   \       0x60   0x....'....        BL       pmc_set_mck_divider
    163          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0x64   0xE3A0'0000        MOV      R0,#+0
   \       0x68   0x....'....        BL       pmc_set_mck_prescaler
    164          	pmc_switch_mck_to_pll();
   \       0x6C   0x....'....        BL       pmc_switch_mck_to_pll
    165          }
   \       0x70   0xE8BD'8007        POP      {R0-R2,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0, 0, 63

   \              0x0000'0000  

   \              0x0000'003F
    166          

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    168          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    169          	/* Disable Watchdog */
    170          	wdt_disable();
   \       0x10   0x....'....        BL       wdt_disable
    171          
    172          	/* Disable all PIO interrupts */
    173          	pio_reset_all_it();
   \       0x14   0x....'....        BL       pio_reset_all_it
    174          
    175          	/* Set the external oscillator frequency */
    176          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x18   0xE3A0'08B7        MOV      R0,#+11993088
   \       0x1C   0xE380'0D6C        ORR      R0,R0,#0x1B00
   \       0x20   0x....'....        BL       pmc_set_main_oscillator_freq
    177          
    178          	if (clocks) {
   \       0x24   0xE1B0'0004        MOVS     R0,R4
   \       0x28   0xE6EF'0070        UXTB     R0,R0
   \       0x2C   0xE350'0000        CMP      R0,#+0
   \       0x30   0x0A00'0000        BEQ      ??board_cfg_lowlevel_0
    179          		/* Configure system clocks */
    180          		board_cfg_clocks();
   \       0x34   0x....'....        BL       board_cfg_clocks
    181          	}
    182          
    183          	/* Setup default interrupt handlers */
    184          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0x38   0x....'....        BL       irq_initialize
    185          
    186          	/* Configure system timer */
    187          	board_cfg_timer();
   \       0x3C   0x....'....        BL       board_cfg_timer
    188          
    189          	board_cfg_matrix_default();
   \       0x40   0x....'....        BL       board_cfg_matrix_default
    190          
    191          	if (ddram) {
   \       0x44   0xE1B0'0005        MOVS     R0,R5
   \       0x48   0xE6EF'0070        UXTB     R0,R0
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x0A00'0000        BEQ      ??board_cfg_lowlevel_1
    192          		/* Configure DDRAM */
    193          		board_cfg_ddram();
   \       0x54   0x....'....        BL       board_cfg_ddram
    194          	}
    195          
    196          	if (mmu) {
   \                     ??board_cfg_lowlevel_1:
   \       0x58   0xE1B0'0006        MOVS     R0,R6
   \       0x5C   0xE6EF'0070        UXTB     R0,R0
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x0A00'0000        BEQ      ??board_cfg_lowlevel_2
    197          		/* Setup MMU */
    198          		board_cfg_mmu();
   \       0x68   0x....'....        BL       board_cfg_mmu
    199          	}
    200          }
   \                     ??board_cfg_lowlevel_2:
   \       0x6C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    201          

   \                                 In section SOFTPACK, align 4, keep-with-next
    202          void board_restore_pio_reset_state(void)
    203          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    204          	int i;
    205          
    206          	/* all pins, excluding JTAG and NTRST */
    207          	struct _pin pins[] = {
    208          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    209          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    210          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    211          		{ PIO_GROUP_D, 0xFFFFFFFF ^ PIN_JTAG, PIO_INPUT, PIO_PULLUP },
    212          	};
   \        0x8   0xE1B0'000D        MOVS     R0,SP
   \        0xC   0x....'....        LDR      R1,??DataTable5_2
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    213          
    214          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1B0'000D        MOVS     R0,SP
   \       0x20   0x....'....        BL       pio_configure
    215          	for (i = 0; i < ARRAY_SIZE(pins); i++)
   \       0x24   0xE3A0'4000        MOV      R4,#+0
   \                     ??board_restore_pio_reset_state_0:
   \       0x28   0xE354'0004        CMP      R4,#+4
   \       0x2C   0x2A00'0005        BCS      ??board_restore_pio_reset_state_1
    216          		pio_clear(&pins[i]);
   \       0x30   0xE1B0'000D        MOVS     R0,SP
   \       0x34   0xE1B0'1204        LSLS     R1,R4,#+4
   \       0x38   0xE090'0001        ADDS     R0,R0,R1
   \       0x3C   0x....'....        BL       pio_clear
   \       0x40   0xE294'4001        ADDS     R4,R4,#+1
   \       0x44   0xEAFF'FFF7        B        ??board_restore_pio_reset_state_0
    217          }
   \                     ??board_restore_pio_reset_state_1:
   \       0x48   0xE28D'D040        ADD      SP,SP,#+64
   \       0x4C   0xE8BD'8010        POP      {R4,PC}          ;; return
    218          

   \                                 In section SOFTPACK, align 4, keep-with-next
    219          void board_save_misc_power(void)
    220          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    221          	int i;
    222          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'1000        MOV      R1,#+0
   \        0x8   0xE3A0'04F8        MOV      R0,#-134217728
   \        0xC   0xE380'0B40        ORR      R0,R0,#0x10000
   \       0x10   0x....'....        BL       get_tc_id_from_addr
   \       0x14   0xE1B0'5000        MOVS     R5,R0
    223          
    224          	/* disable USB clock */
    225          	pmc_disable_upll_clock();
   \       0x18   0x....'....        BL       pmc_disable_upll_clock
    226          	pmc_disable_upll_bias();
   \       0x1C   0x....'....        BL       pmc_disable_upll_bias
    227          
    228          	/* Disable audio clock */
    229          	pmc_disable_audio();
   \       0x20   0x....'....        BL       pmc_disable_audio
    230          
    231          	/* disable system clocks */
    232          #ifdef VARIANT_SRAM
    233          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    234          #endif
    235          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_LCD);
   \       0x24   0xE3A0'0001        MOV      R0,#+1
   \       0x28   0x....'....        BL       pmc_disable_system_clock
    236          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x2C   0xE3A0'0003        MOV      R0,#+3
   \       0x30   0x....'....        BL       pmc_disable_system_clock
    237          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UDP);
   \       0x34   0xE3A0'0004        MOV      R0,#+4
   \       0x38   0x....'....        BL       pmc_disable_system_clock
    238          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x3C   0xE3A0'0005        MOV      R0,#+5
   \       0x40   0x....'....        BL       pmc_disable_system_clock
    239          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x44   0xE3A0'0006        MOV      R0,#+6
   \       0x48   0x....'....        BL       pmc_disable_system_clock
    240          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK2);
   \       0x4C   0xE3A0'0007        MOV      R0,#+7
   \       0x50   0x....'....        BL       pmc_disable_system_clock
    241          #ifdef CONFIG_HAVE_ISC
    242          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_ISC);
    243          #endif
    244          
    245          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    246          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x54   0xE3A0'4003        MOV      R4,#+3
   \                     ??board_save_misc_power_0:
   \       0x58   0xE354'004F        CMP      R4,#+79
   \       0x5C   0xAA00'000B        BGE      ??board_save_misc_power_1
    247          		if (i == ID_PIOA)
   \       0x60   0xE354'0012        CMP      R4,#+18
   \       0x64   0x0A00'0007        BEQ      ??board_save_misc_power_2
    248          			continue;
    249          		if (i == tc_id)
   \                     ??board_save_misc_power_3:
   \       0x68   0xE154'0005        CMP      R4,R5
   \       0x6C   0x0A00'0005        BEQ      ??board_save_misc_power_2
    250          			continue;
    251          #ifdef VARIANT_DDRAM
    252          		if (i == ID_MPDDRC)
   \                     ??board_save_misc_power_4:
   \       0x70   0xE354'000D        CMP      R4,#+13
   \       0x74   0x0A00'0003        BEQ      ??board_save_misc_power_2
    253          			continue;
    254          		if (i == ID_SFRBU)
   \                     ??board_save_misc_power_5:
   \       0x78   0xE354'004D        CMP      R4,#+77
   \       0x7C   0x0A00'0001        BEQ      ??board_save_misc_power_2
    255          			continue;
    256          #endif
    257          		pmc_disable_peripheral(i);
   \                     ??board_save_misc_power_6:
   \       0x80   0xE1B0'0004        MOVS     R0,R4
   \       0x84   0x....'....        BL       pmc_disable_peripheral
    258          	}
   \                     ??board_save_misc_power_2:
   \       0x88   0xE294'4001        ADDS     R4,R4,#+1
   \       0x8C   0xEAFF'FFF1        B        ??board_save_misc_power_0
    259          }
   \                     ??board_save_misc_power_1:
   \       0x90   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    260          

   \                                 In section SOFTPACK, align 4, keep-with-next
    261          void board_cfg_mmu(void)
    262          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    263          	uint32_t addr;
    264          
    265          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'0094        BNE      ??board_cfg_mmu_0
    266          		return;
    267          
    268          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    269          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    270          	   be verified for correct operation when write-back is enabled */
    271          
    272          	/* Reset table entries */
    273          	for (addr = 0; addr < 4096; addr++)
   \                     ??board_cfg_mmu_1:
   \       0x10   0xE3A0'0000        MOV      R0,#+0
   \       0x14   0xE1B0'1000        MOVS     R1,R0
   \                     ??board_cfg_mmu_2:
   \       0x18   0xE351'0D40        CMP      R1,#+4096
   \       0x1C   0x2A00'0004        BCS      ??board_cfg_mmu_3
    274          		tlb[addr] = 0;
   \       0x20   0x....'....        LDR      R2,??DataTable5_3
   \       0x24   0xE1B0'3101        LSLS     R3,R1,#+2
   \       0x28   0xE782'0003        STR      R0,[R2, +R3]
   \       0x2C   0xE291'1001        ADDS     R1,R1,#+1
   \       0x30   0xEAFF'FFF8        B        ??board_cfg_mmu_2
    275          
    276          	/* 0x00000000: ROM */
    277          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    278          	           | TTB_SECT_AP_READ_ONLY
    279          	           | TTB_SECT_DOMAIN(0xf)
    280          	           | TTB_SECT_EXEC
    281          	           | TTB_SECT_CACHEABLE_WB
    282          	           | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0x34   0x....'....        LDR      R0,??DataTable5_3
   \       0x38   0xE308'29EE        MOVW     R2,#+35310
   \       0x3C   0xE580'2000        STR      R2,[R0, #+0]
    283          
    284          	/* 0x00100000: NFC SRAM */
    285          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    286          	           | TTB_SECT_AP_FULL_ACCESS
    287          	           | TTB_SECT_DOMAIN(0xf)
    288          	           | TTB_SECT_EXEC
    289          	           | TTB_SECT_SHAREABLE_DEVICE
    290          	           | TTB_TYPE_SECT;
   \       0x40   0x....'....        LDR      R2,??DataTable5_4  ;; 0x100de6
   \       0x44   0xE580'2004        STR      R2,[R0, #+4]
    291          
    292          	/* 0x00200000: SRAM */
    293          	tlb[0x002] = TTB_SECT_ADDR(0x00200000)
    294          	           | TTB_SECT_AP_FULL_ACCESS
    295          	           | TTB_SECT_DOMAIN(0xf)
    296          	           | TTB_SECT_EXEC
    297          	           | TTB_SECT_CACHEABLE_WB
    298          	           | TTB_TYPE_SECT;
   \       0x48   0x....'....        LDR      R2,??DataTable5_5  ;; 0x200dee
   \       0x4C   0xE580'2008        STR      R2,[R0, #+8]
    299          
    300          #ifdef CONFIG_HAVE_UDPHS
    301          	/* 0x00300000: UDPHS (RAM) */
    302          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    303          	           | TTB_SECT_AP_FULL_ACCESS
    304          	           | TTB_SECT_DOMAIN(0xf)
    305          	           | TTB_SECT_EXEC_NEVER
    306          	           | TTB_SECT_SHAREABLE_DEVICE
    307          	           | TTB_TYPE_SECT;
    308          
    309          	/* 0x00400000: UHPHS (OHCI) */
    310          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    311          	           | TTB_SECT_AP_FULL_ACCESS
    312          	           | TTB_SECT_DOMAIN(0xf)
    313          	           | TTB_SECT_EXEC_NEVER
    314          	           | TTB_SECT_SHAREABLE_DEVICE
    315          	           | TTB_TYPE_SECT;
    316          
    317          	/* 0x00500000: UDPHS (EHCI) */
    318          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    319          	           | TTB_SECT_AP_FULL_ACCESS
    320          	           | TTB_SECT_DOMAIN(0xf)
    321          	           | TTB_SECT_EXEC_NEVER
    322          	           | TTB_SECT_SHAREABLE_DEVICE
    323          	           | TTB_TYPE_SECT;
    324          #endif /* CONFIG_HAVE_UDPHS */
    325          
    326          	/* 0x00600000: AXIMX */
    327          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    328          	           | TTB_SECT_AP_FULL_ACCESS
    329          	           | TTB_SECT_DOMAIN(0xf)
    330          	           | TTB_SECT_EXEC_NEVER
    331          	           | TTB_SECT_SHAREABLE_DEVICE
    332          	           | TTB_TYPE_SECT;
   \       0x50   0x....'....        LDR      R2,??DataTable5_6  ;; 0x600df6
   \       0x54   0xE580'2018        STR      R2,[R0, #+24]
    333          
    334          	/* 0x00700000: DAP */
    335          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    336          	           | TTB_SECT_AP_FULL_ACCESS
    337          	           | TTB_SECT_DOMAIN(0xf)
    338          	           | TTB_SECT_EXEC_NEVER
    339          	           | TTB_SECT_SHAREABLE_DEVICE
    340          	           | TTB_TYPE_SECT;
   \       0x58   0x....'....        LDR      R2,??DataTable5_7  ;; 0x700df6
   \       0x5C   0xE580'201C        STR      R2,[R0, #+28]
    341          #ifdef CONFIG_HAVE_PPP
    342          	/* 0x00800000: pPP */
    343          	tlb[0x008] = TTB_SECT_ADDR(0x00800000)
    344          	           | TTB_SECT_AP_FULL_ACCESS
    345          	           | TTB_SECT_DOMAIN(0xf)
    346          	           | TTB_SECT_EXEC_NEVER
    347          	           | TTB_SECT_SHAREABLE_DEVICE
    348          	           | TTB_TYPE_SECT;
    349          #endif
    350          #ifdef CONFIG_HAVE_L2CC
    351          	/* 0x00a00000: L2CC */
    352          	tlb[0x00a] = TTB_SECT_ADDR(0x00a00000)
    353          	           | TTB_SECT_AP_FULL_ACCESS
    354          	           | TTB_SECT_DOMAIN(0xf)
    355          	           | TTB_SECT_EXEC_NEVER
    356          	           | TTB_SECT_SHAREABLE_DEVICE
    357          	           | TTB_TYPE_SECT;
   \       0x60   0x....'....        LDR      R2,??DataTable5_8  ;; 0xa00df6
   \       0x64   0xE580'2028        STR      R2,[R0, #+40]
    358          	tlb[0x00b] = TTB_SECT_ADDR(0x00b00000)
    359          	           | TTB_SECT_AP_FULL_ACCESS
    360          	           | TTB_SECT_DOMAIN(0xf)
    361          	           | TTB_SECT_EXEC_NEVER
    362          	           | TTB_SECT_SHAREABLE_DEVICE
    363          	           | TTB_TYPE_SECT;
   \       0x68   0x....'....        LDR      R2,??DataTable5_9  ;; 0xb00df6
   \       0x6C   0xE580'202C        STR      R2,[R0, #+44]
    364          #endif
    365          
    366          	/* 0x10000000: EBI Chip Select 0 */
    367          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x70   0xE3A0'2F40        MOV      R2,#+256
   \                     ??board_cfg_mmu_4:
   \       0x74   0xE352'0F80        CMP      R2,#+512
   \       0x78   0x2A00'0005        BCS      ??board_cfg_mmu_5
    368          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    369          	                  | TTB_SECT_AP_FULL_ACCESS
    370          	                  | TTB_SECT_DOMAIN(0xf)
    371          	                  | TTB_SECT_EXEC_NEVER
    372          	                  | TTB_SECT_STRONGLY_ORDERED
    373          	                  | TTB_TYPE_SECT;
   \       0x7C   0xE300'1DF2        MOVW     R1,#+3570
   \       0x80   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \       0x84   0xE1B0'3102        LSLS     R3,R2,#+2
   \       0x88   0xE780'1003        STR      R1,[R0, +R3]
   \       0x8C   0xE292'2001        ADDS     R2,R2,#+1
   \       0x90   0xEAFF'FFF7        B        ??board_cfg_mmu_4
    374          
    375          	/* 0x20000000: DDR Chip Select */
    376          	/* (64MB cacheable, 448MB strongly ordered) */
    377          	for (addr = 0x200; addr < 0x240; addr++)
   \                     ??board_cfg_mmu_5:
   \       0x94   0xE3A0'1F80        MOV      R1,#+512
   \                     ??board_cfg_mmu_6:
   \       0x98   0xE351'0F90        CMP      R1,#+576
   \       0x9C   0x2A00'0005        BCS      ??board_cfg_mmu_7
    378          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    379          	                  | TTB_SECT_AP_FULL_ACCESS
    380          	                  | TTB_SECT_DOMAIN(0xf)
    381          	                  | TTB_SECT_EXEC
    382          	                  | TTB_SECT_CACHEABLE_WB
    383          	                  | TTB_TYPE_SECT;
   \       0xA0   0xE300'2DEE        MOVW     R2,#+3566
   \       0xA4   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \       0xA8   0xE1B0'3101        LSLS     R3,R1,#+2
   \       0xAC   0xE780'2003        STR      R2,[R0, +R3]
   \       0xB0   0xE291'1001        ADDS     R1,R1,#+1
   \       0xB4   0xEAFF'FFF7        B        ??board_cfg_mmu_6
    384          	for (addr = 0x240; addr < 0x400; addr++)
   \                     ??board_cfg_mmu_7:
   \       0xB8   0xE3A0'2F90        MOV      R2,#+576
   \                     ??board_cfg_mmu_8:
   \       0xBC   0xE352'0E40        CMP      R2,#+1024
   \       0xC0   0x2A00'0005        BCS      ??board_cfg_mmu_9
    385          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    386          	                  | TTB_SECT_AP_FULL_ACCESS
    387          	                  | TTB_SECT_DOMAIN(0xf)
    388          	                  | TTB_SECT_EXEC
    389          	                  | TTB_SECT_STRONGLY_ORDERED
    390          	                  | TTB_TYPE_SECT;
   \       0xC4   0xE300'1DE2        MOVW     R1,#+3554
   \       0xC8   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \       0xCC   0xE1B0'3102        LSLS     R3,R2,#+2
   \       0xD0   0xE780'1003        STR      R1,[R0, +R3]
   \       0xD4   0xE292'2001        ADDS     R2,R2,#+1
   \       0xD8   0xEAFF'FFF7        B        ??board_cfg_mmu_8
    391          
    392          	/* 0x40000000: DDR AESB Chip Select */
    393          	for (addr = 0x400; addr < 0x600; addr++)
   \                     ??board_cfg_mmu_9:
   \       0xDC   0xE3A0'1E40        MOV      R1,#+1024
   \                     ??board_cfg_mmu_10:
   \       0xE0   0xE351'0E60        CMP      R1,#+1536
   \       0xE4   0x2A00'0005        BCS      ??board_cfg_mmu_11
    394          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    395          	                  | TTB_SECT_AP_FULL_ACCESS
    396          	                  | TTB_SECT_DOMAIN(0xf)
    397          	                  | TTB_SECT_EXEC
    398          	                  | TTB_SECT_CACHEABLE_WB
    399          	                  | TTB_TYPE_SECT;
   \       0xE8   0xE300'2DEE        MOVW     R2,#+3566
   \       0xEC   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \       0xF0   0xE1B0'3101        LSLS     R3,R1,#+2
   \       0xF4   0xE780'2003        STR      R2,[R0, +R3]
   \       0xF8   0xE291'1001        ADDS     R1,R1,#+1
   \       0xFC   0xEAFF'FFF7        B        ??board_cfg_mmu_10
    400          
    401          	/* 0x60000000: EBI Chip Select 1 */
    402          	for (addr = 0x600; addr < 0x700; addr++)
   \                     ??board_cfg_mmu_11:
   \      0x100   0xE3A0'2E60        MOV      R2,#+1536
   \                     ??board_cfg_mmu_12:
   \      0x104   0xE352'0E70        CMP      R2,#+1792
   \      0x108   0x2A00'0005        BCS      ??board_cfg_mmu_13
    403          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    404          	                  | TTB_SECT_AP_FULL_ACCESS
    405          	                  | TTB_SECT_DOMAIN(0xf)
    406          	                  | TTB_SECT_EXEC_NEVER
    407          	                  | TTB_SECT_STRONGLY_ORDERED
    408          	                  | TTB_TYPE_SECT;
   \      0x10C   0xE300'1DF2        MOVW     R1,#+3570
   \      0x110   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x114   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x118   0xE780'1003        STR      R1,[R0, +R3]
   \      0x11C   0xE292'2001        ADDS     R2,R2,#+1
   \      0x120   0xEAFF'FFF7        B        ??board_cfg_mmu_12
    409          
    410          	/* 0x70000000: EBI Chip Select 2 */
    411          	for (addr = 0x700; addr < 0x800; addr++)
   \                     ??board_cfg_mmu_13:
   \      0x124   0xE3A0'1E70        MOV      R1,#+1792
   \                     ??board_cfg_mmu_14:
   \      0x128   0xE351'0E80        CMP      R1,#+2048
   \      0x12C   0x2A00'0005        BCS      ??board_cfg_mmu_15
    412          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    413          	                  | TTB_SECT_AP_FULL_ACCESS
    414          	                  | TTB_SECT_DOMAIN(0xf)
    415          	                  | TTB_SECT_EXEC_NEVER
    416          	                  | TTB_SECT_STRONGLY_ORDERED
    417          	                  | TTB_TYPE_SECT;
   \      0x130   0xE300'2DF2        MOVW     R2,#+3570
   \      0x134   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \      0x138   0xE1B0'3101        LSLS     R3,R1,#+2
   \      0x13C   0xE780'2003        STR      R2,[R0, +R3]
   \      0x140   0xE291'1001        ADDS     R1,R1,#+1
   \      0x144   0xEAFF'FFF7        B        ??board_cfg_mmu_14
    418          
    419          	/* 0x80000000: EBI Chip Select 3 */
    420          	for (addr = 0x800; addr < 0x900; addr++)
   \                     ??board_cfg_mmu_15:
   \      0x148   0xE3A0'2E80        MOV      R2,#+2048
   \                     ??board_cfg_mmu_16:
   \      0x14C   0xE352'0E90        CMP      R2,#+2304
   \      0x150   0x2A00'0005        BCS      ??board_cfg_mmu_17
    421          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    422          	                  | TTB_SECT_AP_FULL_ACCESS
    423          	                  | TTB_SECT_DOMAIN(0xf)
    424          	                  | TTB_SECT_EXEC_NEVER
    425          	                  | TTB_SECT_STRONGLY_ORDERED
    426          	                  | TTB_TYPE_SECT;
   \      0x154   0xE300'1DF2        MOVW     R1,#+3570
   \      0x158   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x15C   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x160   0xE780'1003        STR      R1,[R0, +R3]
   \      0x164   0xE292'2001        ADDS     R2,R2,#+1
   \      0x168   0xEAFF'FFF7        B        ??board_cfg_mmu_16
    427          
    428          	/* 0x90000000: QSPI0/1 AESB MEM */
    429          	for (addr = 0x900; addr < 0xa00; addr++)
   \                     ??board_cfg_mmu_17:
   \      0x16C   0xE3A0'1E90        MOV      R1,#+2304
   \                     ??board_cfg_mmu_18:
   \      0x170   0xE351'0EA0        CMP      R1,#+2560
   \      0x174   0x2A00'0005        BCS      ??board_cfg_mmu_19
    430          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    431          	                  | TTB_SECT_AP_FULL_ACCESS
    432          	                  | TTB_SECT_DOMAIN(0xf)
    433          	                  | TTB_SECT_EXEC
    434          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    435          	                  | TTB_SECT_CACHEABLE_WB
    436          #else
    437          	                  | TTB_SECT_STRONGLY_ORDERED
    438          #endif
    439          	                  | TTB_TYPE_SECT;
   \      0x178   0xE300'2DE2        MOVW     R2,#+3554
   \      0x17C   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \      0x180   0xE1B0'3101        LSLS     R3,R1,#+2
   \      0x184   0xE780'2003        STR      R2,[R0, +R3]
   \      0x188   0xE291'1001        ADDS     R1,R1,#+1
   \      0x18C   0xEAFF'FFF7        B        ??board_cfg_mmu_18
    440          
    441          	/* 0xa0000000: SDMMC0 */
    442          	for (addr = 0xa00; addr < 0xb00; addr++)
   \                     ??board_cfg_mmu_19:
   \      0x190   0xE3A0'2EA0        MOV      R2,#+2560
   \                     ??board_cfg_mmu_20:
   \      0x194   0xE352'0EB0        CMP      R2,#+2816
   \      0x198   0x2A00'0005        BCS      ??board_cfg_mmu_21
    443          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    444          	                  | TTB_SECT_AP_FULL_ACCESS
    445          	                  | TTB_SECT_DOMAIN(0xf)
    446          	                  | TTB_SECT_EXEC_NEVER
    447          	                  //| TTB_SECT_SHAREABLE_DEVICE
    448          	                  | TTB_SECT_STRONGLY_ORDERED
    449          	                  | TTB_TYPE_SECT;
   \      0x19C   0xE300'1DF2        MOVW     R1,#+3570
   \      0x1A0   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x1A4   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x1A8   0xE780'1003        STR      R1,[R0, +R3]
   \      0x1AC   0xE292'2001        ADDS     R2,R2,#+1
   \      0x1B0   0xEAFF'FFF7        B        ??board_cfg_mmu_20
    450          
    451          	/* 0xb0000000: SDMMC1 */
    452          	for (addr = 0xb00; addr < 0xc00; addr++)
   \                     ??board_cfg_mmu_21:
   \      0x1B4   0xE3A0'1EB0        MOV      R1,#+2816
   \                     ??board_cfg_mmu_22:
   \      0x1B8   0xE351'0EC0        CMP      R1,#+3072
   \      0x1BC   0x2A00'0005        BCS      ??board_cfg_mmu_23
    453          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    454          	                  | TTB_SECT_AP_FULL_ACCESS
    455          	                  | TTB_SECT_DOMAIN(0xf)
    456          	                  | TTB_SECT_EXEC_NEVER
    457          	                  //| TTB_SECT_SHAREABLE_DEVICE
    458          	                  | TTB_SECT_STRONGLY_ORDERED
    459          	                  | TTB_TYPE_SECT;
   \      0x1C0   0xE300'2DF2        MOVW     R2,#+3570
   \      0x1C4   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \      0x1C8   0xE1B0'3101        LSLS     R3,R1,#+2
   \      0x1CC   0xE780'2003        STR      R2,[R0, +R3]
   \      0x1D0   0xE291'1001        ADDS     R1,R1,#+1
   \      0x1D4   0xEAFF'FFF7        B        ??board_cfg_mmu_22
    460          
    461          	/* 0xc0000000: NFC Command Register */
    462          	for (addr = 0xc00; addr < 0xd00; addr++)
   \                     ??board_cfg_mmu_23:
   \      0x1D8   0xE3A0'2EC0        MOV      R2,#+3072
   \                     ??board_cfg_mmu_24:
   \      0x1DC   0xE352'0ED0        CMP      R2,#+3328
   \      0x1E0   0x2A00'0005        BCS      ??board_cfg_mmu_25
    463          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    464          	                  | TTB_SECT_AP_FULL_ACCESS
    465          	                  | TTB_SECT_DOMAIN(0xf)
    466          	                  | TTB_SECT_EXEC_NEVER
    467          	                  //| TTB_SECT_SHAREABLE_DEVICE
    468          	                  | TTB_SECT_STRONGLY_ORDERED
    469          	                  | TTB_TYPE_SECT;
   \      0x1E4   0xE300'1DF2        MOVW     R1,#+3570
   \      0x1E8   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x1EC   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x1F0   0xE780'1003        STR      R1,[R0, +R3]
   \      0x1F4   0xE292'2001        ADDS     R2,R2,#+1
   \      0x1F8   0xEAFF'FFF7        B        ??board_cfg_mmu_24
    470          
    471          	/* 0xd0000000: QSPI0/1 MEM */
    472          	for (addr = 0xd00; addr < 0xe00; addr++)
   \                     ??board_cfg_mmu_25:
   \      0x1FC   0xE3A0'4ED0        MOV      R4,#+3328
   \                     ??board_cfg_mmu_26:
   \      0x200   0xE354'0EE0        CMP      R4,#+3584
   \      0x204   0x2A00'0005        BCS      ??board_cfg_mmu_27
    473          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    474          	                  | TTB_SECT_AP_FULL_ACCESS
    475          	                  | TTB_SECT_DOMAIN(0xf)
    476          	                  | TTB_SECT_EXEC
    477          #if defined(VARIANT_QSPI0) || defined(VARIANT_QSPI1)
    478          	                  | TTB_SECT_CACHEABLE_WB
    479          #else
    480          	                  | TTB_SECT_STRONGLY_ORDERED
    481          #endif
    482          	                  | TTB_TYPE_SECT;
   \      0x208   0xE300'1DE2        MOVW     R1,#+3554
   \      0x20C   0xE191'1A04        ORRS     R1,R1,R4, LSL #+20
   \      0x210   0xE1B0'2104        LSLS     R2,R4,#+2
   \      0x214   0xE780'1002        STR      R1,[R0, +R2]
   \      0x218   0xE294'4001        ADDS     R4,R4,#+1
   \      0x21C   0xEAFF'FFF7        B        ??board_cfg_mmu_26
    483          
    484          	/* 0xf0000000: Internal Peripherals */
    485          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    486          	           | TTB_SECT_AP_FULL_ACCESS
    487          	           | TTB_SECT_DOMAIN(0xf)
    488          	           | TTB_SECT_EXEC
    489          	           | TTB_SECT_STRONGLY_ORDERED
    490          	           | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_27:
   \      0x220   0xE3A0'13BC        MOV      R1,#-268435454
   \      0x224   0xE381'1EDE        ORR      R1,R1,#0xDE0
   \      0x228   0xE290'2DF0        ADDS     R2,R0,#+15360
   \      0x22C   0xE582'1000        STR      R1,[R2, #+0]
    491          
    492          	/* 0xf8000000: Internal Peripherals */
    493          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    494          	           | TTB_SECT_AP_FULL_ACCESS
    495          	           | TTB_SECT_DOMAIN(0xf)
    496          	           | TTB_SECT_EXEC
    497          	           | TTB_SECT_STRONGLY_ORDERED
    498          	           | TTB_TYPE_SECT;
   \      0x230   0xE3A0'13BE        MOV      R1,#-134217726
   \      0x234   0xE381'1EDE        ORR      R1,R1,#0xDE0
   \      0x238   0xE290'2DF8        ADDS     R2,R0,#+15872
   \      0x23C   0xE582'1000        STR      R1,[R2, #+0]
    499          
    500          	/* 0xfc000000: Internal Peripherals */
    501          	tlb[0xfc0] = TTB_SECT_ADDR(0xfc000000)
    502          	           | TTB_SECT_AP_FULL_ACCESS
    503          	           | TTB_SECT_DOMAIN(0xf)
    504          	           | TTB_SECT_EXEC
    505          	           | TTB_SECT_STRONGLY_ORDERED
    506          	           | TTB_TYPE_SECT;
   \      0x240   0xE3A0'13BF        MOV      R1,#-67108862
   \      0x244   0xE381'1EDE        ORR      R1,R1,#0xDE0
   \      0x248   0xE290'2DFC        ADDS     R2,R0,#+16128
   \      0x24C   0xE582'1000        STR      R1,[R2, #+0]
    507          
    508          	/* Enable MMU, I-Cache and D-Cache */
    509          	mmu_configure(tlb);
   \      0x250   0x....'....        BL       mmu_configure
    510          	icache_enable();
   \      0x254   0x....'....        BL       icache_enable
    511          	mmu_enable();
   \      0x258   0x....'....        BL       mmu_enable
    512          	dcache_enable();
   \      0x25C   0x....'....        BL       dcache_enable
    513          
    514          	board_cfg_l2cc();
   \      0x260   0x....'....        BL       board_cfg_l2cc
    515          }
   \                     ??board_cfg_mmu_0:
   \      0x264   0xE8BD'8010        POP      {R4,PC}          ;; return
    516          

   \                                 In section SOFTPACK, align 4, keep-with-next
    517          void board_cfg_l2cc(void)
    518          {
   \                     board_cfg_l2cc:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    519          	l2cc_configure(&l2cc_cfg);
   \        0x4   0x....'....        LDR      R0,??DataTable5_10
   \        0x8   0x....'....        BL       l2cc_configure
    520          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
    521          

   \                                 In section SOFTPACK, align 4, keep-with-next
    522          void board_cfg_matrix_for_ddr(void)
    523          {
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    524          	int i;
    525          
    526          	/* Disable write protection */
    527          	matrix_remove_write_protection(MATRIX0);
   \        0x4   0xE3A0'54F0        MOV      R5,#-268435456
   \        0x8   0xE385'5B60        ORR      R5,R5,#0x18000
   \        0xC   0xE1B0'0005        MOVS     R0,R5
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    528          
    529          	/* 128 KiB internal SRAM: Non-secure */
    530          	matrix_configure_slave_sec(MATRIX0, H64MX_SLAVE_SRAM, 0x1, 0, 0);
   \       0x14   0xE3A0'0000        MOV      R0,#+0
   \       0x18   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x1C   0xE3A0'3000        MOV      R3,#+0
   \       0x20   0xE3A0'2001        MOV      R2,#+1
   \       0x24   0xE3A0'100A        MOV      R1,#+10
   \       0x28   0xE1B0'0005        MOVS     R0,R5
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    531          	matrix_set_slave_region_size(MATRIX0, H64MX_SLAVE_SRAM,
    532          			MATRIX_AREA_128K, 0x1);
   \       0x30   0xE3A0'3001        MOV      R3,#+1
   \       0x34   0xE3A0'2005        MOV      R2,#+5
   \       0x38   0xE3A0'100A        MOV      R1,#+10
   \       0x3C   0xE1B0'0005        MOVS     R0,R5
   \       0x40   0x....'....        BL       matrix_set_slave_region_size
    533          	matrix_set_slave_split_addr(MATRIX0, H64MX_SLAVE_SRAM,
    534          			MATRIX_AREA_128K, 0x1);
   \       0x44   0xE3A0'3001        MOV      R3,#+1
   \       0x48   0xE3A0'2005        MOV      R2,#+5
   \       0x4C   0xE3A0'100A        MOV      R1,#+10
   \       0x50   0xE1B0'0005        MOVS     R0,R5
   \       0x54   0x....'....        BL       matrix_set_slave_split_addr
    535          
    536          	/* External DDR */
    537          	for (i = H64MX_SLAVE_DDR_PORT0; i <= H64MX_SLAVE_DDR_PORT7; i++) {
   \       0x58   0xE3A0'4002        MOV      R4,#+2
   \                     ??board_cfg_matrix_for_ddr_0:
   \       0x5C   0xE354'000A        CMP      R4,#+10
   \       0x60   0xAA00'0018        BGE      ??board_cfg_matrix_for_ddr_1
    538          		matrix_configure_slave_sec(MATRIX0, i, 0xff, 0xff, 0xff);
   \       0x64   0xE3A0'00FF        MOV      R0,#+255
   \       0x68   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x6C   0xE3A0'30FF        MOV      R3,#+255
   \       0x70   0xE3A0'20FF        MOV      R2,#+255
   \       0x74   0xE1B0'0004        MOVS     R0,R4
   \       0x78   0xE1B0'1000        MOVS     R1,R0
   \       0x7C   0xE6EF'1071        UXTB     R1,R1
   \       0x80   0xE1B0'0005        MOVS     R0,R5
   \       0x84   0x....'....        BL       matrix_configure_slave_sec
    539          		matrix_set_slave_split_addr(MATRIX0, i, MATRIX_AREA_128M, 0xf);
   \       0x88   0xE3A0'300F        MOV      R3,#+15
   \       0x8C   0xE3A0'200F        MOV      R2,#+15
   \       0x90   0xE1B0'0004        MOVS     R0,R4
   \       0x94   0xE1B0'1000        MOVS     R1,R0
   \       0x98   0xE6EF'1071        UXTB     R1,R1
   \       0x9C   0xE1B0'0005        MOVS     R0,R5
   \       0xA0   0x....'....        BL       matrix_set_slave_split_addr
    540          		matrix_set_slave_region_size(MATRIX0, i, MATRIX_AREA_128M, 0x1);
   \       0xA4   0xE3A0'3001        MOV      R3,#+1
   \       0xA8   0xE3A0'200F        MOV      R2,#+15
   \       0xAC   0xE1B0'0004        MOVS     R0,R4
   \       0xB0   0xE1B0'1000        MOVS     R1,R0
   \       0xB4   0xE6EF'1071        UXTB     R1,R1
   \       0xB8   0xE1B0'0005        MOVS     R0,R5
   \       0xBC   0x....'....        BL       matrix_set_slave_region_size
    541          	}
   \       0xC0   0xE294'4001        ADDS     R4,R4,#+1
   \       0xC4   0xEAFF'FFE4        B        ??board_cfg_matrix_for_ddr_0
    542          }
   \                     ??board_cfg_matrix_for_ddr_1:
   \       0xC8   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    543          

   \                                 In section SOFTPACK, align 4, keep-with-next
    544          void board_cfg_matrix_for_nand(void)
    545          {
   \                     board_cfg_matrix_for_nand:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    546          	/* Disable write protection */
    547          	matrix_remove_write_protection(MATRIX1);
   \        0x4   0xE3A0'44FC        MOV      R4,#-67108864
   \        0x8   0xE384'4BF0        ORR      R4,R4,#0x3C000
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       matrix_remove_write_protection
    548          
    549          	/* NFC Command Register */
    550          	matrix_configure_slave_sec(MATRIX1,
    551          			H32MX_SLAVE_NFC_CMD, 0xc0, 0xc0, 0xc0);
   \       0x14   0xE3A0'00C0        MOV      R0,#+192
   \       0x18   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x1C   0xE3A0'30C0        MOV      R3,#+192
   \       0x20   0xE3A0'20C0        MOV      R2,#+192
   \       0x24   0xE3A0'1003        MOV      R1,#+3
   \       0x28   0xE1B0'0004        MOVS     R0,R4
   \       0x2C   0x....'....        BL       matrix_configure_slave_sec
    552          	matrix_set_slave_split_addr(MATRIX1,
    553          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x30   0xE3A0'30C0        MOV      R3,#+192
   \       0x34   0xE3A0'200F        MOV      R2,#+15
   \       0x38   0xE3A0'1003        MOV      R1,#+3
   \       0x3C   0xE1B0'0004        MOVS     R0,R4
   \       0x40   0x....'....        BL       matrix_set_slave_split_addr
    554          	matrix_set_slave_region_size(MATRIX1,
    555          			H32MX_SLAVE_NFC_CMD, MATRIX_AREA_128M, 0xc0);
   \       0x44   0xE3A0'30C0        MOV      R3,#+192
   \       0x48   0xE3A0'200F        MOV      R2,#+15
   \       0x4C   0xE3A0'1003        MOV      R1,#+3
   \       0x50   0xE1B0'0004        MOVS     R0,R4
   \       0x54   0x....'....        BL       matrix_set_slave_region_size
    556          
    557          	/* NFC SRAM */
    558          	matrix_configure_slave_sec(MATRIX1,
    559          			H32MX_SLAVE_NFC_SRAM, 0x1, 0x1, 0x1);
   \       0x58   0xE3A0'0001        MOV      R0,#+1
   \       0x5C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x60   0xE3A0'3001        MOV      R3,#+1
   \       0x64   0xE3A0'2001        MOV      R2,#+1
   \       0x68   0xE3A0'1004        MOV      R1,#+4
   \       0x6C   0xE1B0'0004        MOVS     R0,R4
   \       0x70   0x....'....        BL       matrix_configure_slave_sec
    560          	matrix_set_slave_split_addr(MATRIX1,
    561          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x74   0xE3A0'3001        MOV      R3,#+1
   \       0x78   0xE3A0'2001        MOV      R2,#+1
   \       0x7C   0xE3A0'1004        MOV      R1,#+4
   \       0x80   0xE1B0'0004        MOVS     R0,R4
   \       0x84   0x....'....        BL       matrix_set_slave_split_addr
    562          	matrix_set_slave_region_size(MATRIX1,
    563          			H32MX_SLAVE_NFC_SRAM, MATRIX_AREA_8K, 0x1);
   \       0x88   0xE3A0'3001        MOV      R3,#+1
   \       0x8C   0xE3A0'2001        MOV      R2,#+1
   \       0x90   0xE3A0'1004        MOV      R1,#+4
   \       0x94   0xE1B0'0004        MOVS     R0,R4
   \       0x98   0x....'....        BL       matrix_set_slave_region_size
    564          }
   \       0x9C   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
    565          

   \                                 In section SOFTPACK, align 4, keep-with-next
    566          void board_cfg_ddram(void)
    567          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
    568          #ifdef BOARD_DDRAM_TYPE
    569          	board_cfg_matrix_for_ddr();
   \        0x8   0x....'....        BL       board_cfg_matrix_for_ddr
    570          	struct _mpddrc_desc desc;
    571          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \        0xC   0xE3A0'1001        MOV      R1,#+1
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        BL       ddram_init_descriptor
    572          	ddram_configure(&desc);
   \       0x18   0xE1B0'000D        MOVS     R0,SP
   \       0x1C   0x....'....        BL       ddram_configure
    573          #endif
    574          }
   \       0x20   0xE28D'D034        ADD      SP,SP,#+52
   \       0x24   0xE8BD'8000        POP      {PC}             ;; return
    575          
    576          #ifdef CONFIG_HAVE_NAND_FLASH
    577          void board_cfg_nand_flash(void)
    578          {
    579          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    580          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    581          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
    582          	board_cfg_matrix_for_nand();
    583          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
    584          #else
    585          	trace_fatal("Cannot configure NAND: target board has no NAND definitions!");
    586          #endif
    587          }
    588          #endif /* CONFIG_HAVE_NAND_FLASH */
    589          
    590          #ifdef CONFIG_HAVE_SDMMC
    591          #if defined(BOARD_SDMMC0_PINS) || defined(BOARD_SDMMC1_PINS)
    592          static void board_cfg_sd_clk_caps(uint32_t periph_id, uint32_t *caps0,
    593              uint32_t *caps1)
    594          {
    595          		uint32_t base_freq, mult_freq, val;
    596          
    597          		/* Retrieve the frequency of BASECLK and TEOCLK.
    598          		 * Usual values of this frequency are 12 MHz, 24 MHz. */
    599          		base_freq = pmc_get_main_clock();
    600          		base_freq = ROUND_INT_DIV(base_freq, 1000000lu);
    601          		val = base_freq > (SDMMC_CA0R_BASECLKF_Msk >> SDMMC_CA0R_BASECLKF_Pos)
    602          		    ? 0 : base_freq;
    603          		*caps0 |= SDMMC_CA0R_BASECLKF(val);
    604          		val = base_freq > (SDMMC_CA0R_TEOCLKF_Msk >> SDMMC_CA0R_TEOCLKF_Pos)
    605          		    ? 0 : base_freq;
    606          		*caps0 |= SDMMC_CA0R_TEOCLKF(val) | SDMMC_CA0R_TEOCLKU;
    607          
    608          		/* Retrieve the frequency of MULTCLK.
    609          		 * Usual values of this frequency are 100 MHz, 104 MHz. */
    610          		mult_freq = pmc_get_gck_clock(periph_id);
    611          		base_freq *= 1000000lu;
    612          		val = ROUND_INT_DIV(mult_freq, base_freq);
    613          		val = val < 2 ? 1 : val - 1;
    614          		val = min_u32(val, SDMMC_CA1R_CLKMULT_Msk >> SDMMC_CA1R_CLKMULT_Pos);
    615          		*caps1 |= SDMMC_CA1R_CLKMULT(val);
    616          }
    617          #endif
    618          
    619          bool board_cfg_sdmmc(uint32_t periph_id)
    620          {
    621          	switch (periph_id) {
    622          #ifdef SDMMC0
    623          	case ID_SDMMC0:
    624          	{
    625          #if defined(BOARD_SDMMC0_CAPS0) && defined(BOARD_SDMMC0_PINS)
    626          		struct _pin pins[] = BOARD_SDMMC0_PINS;
    627          		uint32_t caps0 = BOARD_SDMMC0_CAPS0, caps1 = 0;
    628          
    629          #ifdef CONFIG_BOARD_SAMA5D2_XPLAINED
    630          		struct _pin vsel_pin = PIN_SDMMC0_VDDSEL_IOS1;
    631          		int vsel_ix;
    632          
    633          #ifndef SDMMC_TRIM_LOW_VOLTAGE
    634          		/* Set PMIC output 7 to 1.8V (VDDSDHC1V8) */
    635          		if (!act8945a_initialized) {
    636          			board_cfg_pmic();
    637          			if (!act8945a_initialized)
    638          				return false;
    639          		}
    640          		if (!act8945a_set_regulator_voltage(&act8945a, 7, 1800))
    641          			return false;
    642          		if (!act8945a_enable_regulator(&act8945a, 7, true))
    643          			return false;
    644          #endif
    645          
    646          		/* The PIOs of SDMMC0 normally include SDMMC0_VDDSEL. On regular
    647          		 * SAMA5D2-XULT, the SDMMC0_VDDSEL line has a pull-down resistor
    648          		 * hence at power-on time VCCQ is 3.3V. In this default config
    649          		 * we enable SDMMC0_VDDSEL, which can switch VCCQ to 1.8V.
    650          		 * Changing VCCQ on the fly is required with UHS-I SD cards. It
    651          		 * is illegal with e.MMC devices. Detect if the board has been
    652          		 * modified to supply 1.8V VCCQ at power-on time.
    653          		 * First, search for the SDMMC0_VDDSEL PIO on this board. */
    654          		for (vsel_ix = 0; vsel_ix < ARRAY_SIZE(pins); vsel_ix++)
    655          			if (pins[vsel_ix].mask == vsel_pin.mask
    656          			    && pins[vsel_ix].group == vsel_pin.group)
    657          				break;
    658          		if (vsel_ix < ARRAY_SIZE(pins)) {
    659          			/* Second, sense whether the SDMMC0_VDDSEL line is
    660          			 * pulled up or down */
    661          			vsel_pin.type = PIO_INPUT;
    662          			vsel_pin.attribute = PIO_PULLUP;
    663          			pio_configure(&vsel_pin, 1);
    664          			if (pio_get(&vsel_pin)) {
    665          				/* The line is pulled up => at power-on time
    666          				 * VCCQ is 1.8V. If the SDMMC0_VDDSEL function
    667          				 * was enabled, then everytime SRR:SWRSTALL was
    668          				 * triggered, VCCQ would switch to 3.3V. */
    669          				pins[vsel_ix].type = PIO_OUTPUT_1;
    670          				pins[vsel_ix].attribute = PIO_DEFAULT;
    671          				/* Deviation from the specification: we use the
    672          				 * Voltage Support capabilities to indicate the
    673          				 * supported signaling levels (VCCQ). */
    674          				caps0 &= ~SDMMC_CA0R_V33VSUP;
    675          				caps0 &= ~SDMMC_CA0R_V30VSUP;
    676          				caps0 |= SDMMC_CA0R_V18VSUP;
    677          			}
    678          		}
    679          #endif
    680          		/* Program capabilities for SDMMC0 */
    681          		board_cfg_sd_clk_caps(ID_SDMMC0, &caps0, &caps1);
    682          		sdmmc_set_capabilities(SDMMC0, caps0, SDMMC_CA0R_SLTYPE_Msk |
    683          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    684          		    SDMMC_CA0R_ED8SUP | SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    685          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    686          
    687          		/* Configure SDMMC0 pins */
    688          		pio_configure(pins, ARRAY_SIZE(pins));
    689          		return true;
    690          #else
    691          		trace_fatal("Cannot configure SDMMC0: target board has no SDMMC0 definitions!");
    692          		return false;
    693          #endif
    694          	}
    695          #endif
    696          	case ID_SDMMC1:
    697          	{
    698          #if defined(BOARD_SDMMC1_CAPS0) && defined(BOARD_SDMMC1_PINS)
    699          		const struct _pin pins[] = BOARD_SDMMC1_PINS;
    700          		uint32_t caps0 = BOARD_SDMMC1_CAPS0, caps1 = 0;
    701          
    702          		/* Program capabilities for SDMMC1 */
    703          		board_cfg_sd_clk_caps(ID_SDMMC1, &caps0, &caps1);
    704          		sdmmc_set_capabilities(SDMMC1, caps0, SDMMC_CA0R_SLTYPE_Msk |
    705          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    706          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    707          		    SDMMC_CA0R_TEOCLKF_Msk, caps1, SDMMC_CA1R_CLKMULT_Msk);
    708          
    709          		/* Configure SDMMC1 pins */
    710          		pio_configure(pins, ARRAY_SIZE(pins));
    711          		return true;
    712          #else
    713          		trace_fatal("Cannot configure SDMMC1: target board has no SDMMC1 definitions!");
    714          		return false;
    715          #endif
    716          	}
    717          	default:
    718          		return false;
    719          	}
    720          }
    721          #endif /* CONFIG_HAVE_SDMMC */
    722          

   \                                 In section SOFTPACK, align 4, keep-with-next
    723          void board_cfg_pmic(void)
    724          {
    725          #ifdef CONFIG_HAVE_PMIC_ACT8945A
    726          	if (act8945a_initialized)
    727          		return;
    728          
    729          	if (!act8945a_configure(&act8945a))
    730          		goto Fail;
    731          #if defined(CONFIG_BOARD_SAMA5D2_XPLAINED)
    732          	/* Set PMIC output 6 to 2.5V (VDD_LED) */
    733          	if (!act8945a_set_regulator_voltage(&act8945a, 6, 2500))
    734          		goto Fail;
    735          	if (!act8945a_enable_regulator(&act8945a, 6, true))
    736          		goto Fail;
    737          #endif
    738          	act8945a_initialized = true;
    739          	return;
    740          
    741          Fail:
    742          	trace_error("Error initializing ACT8945A PMIC\r\n");
    743          #endif
    744          }
   \                     board_cfg_pmic:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     board_name

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x0010'0DE6        DC32     0x100de6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x0020'0DEE        DC32     0x200dee

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x0060'0DF6        DC32     0x600df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_7:
   \        0x0   0x0070'0DF6        DC32     0x700df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_8:
   \        0x0   0x00A0'0DF6        DC32     0xa00df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_9:
   \        0x0   0x00B0'0DF6        DC32     0xb00df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_10:
   \        0x0   0x....'....        DC32     l2cc_cfg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x61          DC8 "sama5d2-xult"

   \              0x6D 0x61    

   \              0x35 0x64    

   \              0x32 0x2D    

   \              0x78 0x75    

   \              0x6C 0x74    

   \              0x00
   \        0xD   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFF8'3FFF        DC32 4'294'459'391
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   board_cfg_clocks
        16   -> pmc_configure_plla
        16   -> pmc_disable_plla
        16   -> pmc_select_external_osc
        16   -> pmc_set_mck_divider
        16   -> pmc_set_mck_h32mxdiv
        16   -> pmc_set_mck_plladiv2
        16   -> pmc_set_mck_prescaler
        16   -> pmc_switch_mck_to_pll
        16   -> pmc_switch_mck_to_slck
      56   board_cfg_ddram
        56   -> board_cfg_matrix_for_ddr
        56   -> ddram_configure
        56   -> ddram_init_descriptor
       8   board_cfg_l2cc
         8   -> l2cc_configure
      16   board_cfg_lowlevel
        16   -> board_cfg_clocks
        16   -> board_cfg_ddram
        16   -> board_cfg_matrix_default
        16   -> board_cfg_mmu
        16   -> board_cfg_timer
        16   -> irq_initialize
        16   -> pio_reset_all_it
        16   -> pmc_set_main_oscillator_freq
        16   -> wdt_disable
       8   board_cfg_matrix_default
         8   -> matrix_set_default_config
      16   board_cfg_matrix_for_ddr
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
      16   board_cfg_matrix_for_nand
        16   -> matrix_configure_slave_sec
        16   -> matrix_remove_write_protection
        16   -> matrix_set_slave_region_size
        16   -> matrix_set_slave_split_addr
       8   board_cfg_mmu
         8   -> board_cfg_l2cc
         8   -> dcache_enable
         8   -> icache_enable
         8   -> mmu_configure
         8   -> mmu_enable
         8   -> mmu_is_enabled
       0   board_cfg_pmic
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_audio
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_bias
        16   -> pmc_disable_upll_clock
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable5
        4  ??DataTable5_1
        4  ??DataTable5_10
        4  ??DataTable5_2
        4  ??DataTable5_3
        4  ??DataTable5_4
        4  ??DataTable5_5
        4  ??DataTable5_6
        4  ??DataTable5_7
        4  ??DataTable5_8
        4  ??DataTable5_9
       16  ?_0
       64  ?_1
       12  ?_2
      116  board_cfg_clocks
       40  board_cfg_ddram
       16  board_cfg_l2cc
      112  board_cfg_lowlevel
       12  board_cfg_matrix_default
      204  board_cfg_matrix_for_ddr
      160  board_cfg_matrix_for_nand
      616  board_cfg_mmu
        4  board_cfg_pmic
        4  board_name
       80  board_restore_pio_reset_state
      148  board_save_misc_power
       12  get_board_name
        4  l2cc_cfg
   16'384  tlb

 
 16'384 bytes in section .bss
      4 bytes in section .data
     96 bytes in section .rodata
  1'564 bytes in section SOFTPACK
 
  1'564 bytes of CODE  memory
     96 bytes of CONST memory
 16'388 bytes of DATA  memory

Errors: none
Warnings: none
