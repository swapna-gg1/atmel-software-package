###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         08/Dec/2020  16:30:49
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\ssc.c
#    Command line      =
#        -f C:\Users\c40450\AppData\Local\Temp\EW6CA0.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\ssc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D2_XPLAINED -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR3_MT41K128M16 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_PDMIC -D CONFIG_HAVE_AUDIO_AD1934 -D
#        CONFIG_HAVE_SHDWC -D CONFIG_HAVE_SPI -D CONFIG_HAVE_SPI_FIFO -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_SPI_BUS -D CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D
#        CONFIG_HAVE_USART -D CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-A5 -e --fpu=VFPv4_D16 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale            =  C
#    List file         =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\List\ssc.lst
#    Object file       =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sama5d2-xplained\ddram\Obj\ssc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\audio\ssc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup ssc_module Working with SSC
     31           * \section Purpose
     32           * The SSC driver provides the interface to configure and use the SSC
     33           * peripheral.
     34           *
     35           * \section Usage
     36           * -# Enable the SSC interface pins.
     37           * -# Configure the SSC to operate at a specific frequency by calling
     38           *    SSC_Configure(). This function enables the peripheral clock of the SSC,
     39           *    but not its PIOs.
     40           * -# Configure the transmitter and/or the receiver using the
     41           *    SSC_ConfigureTransmitter() and SSC_ConfigureEmitter() functions.
     42           * -# Enable the PIOs or the transmitter and/or the received.
     43           * -# Enable the transmitter and/or the receiver using SSC_EnableTransmitter()
     44           *    and SSC_EnableReceiver()
     45           * -# Send data through the transmitter using SSC_Write()
     46           * -# Receive data from the receiver using SSC_Read()
     47           * -# Disable the transmitter and/or the receiver using SSC_DisableTransmitter()
     48           *    and SSC_DisableReceiver()
     49           *
     50           * For more accurate information, please look at the SSC section of the
     51           * Datasheet.
     52           *
     53           * Related files :\n
     54           * \ref ssc.c\n
     55           * \ref ssc.h.\n
     56          */
     57          /*@{*/
     58          /*@}*/
     59          
     60          /**
     61           * \file
     62           *
     63           * Implementation of Synchronous Serial (SSC) controller.
     64           *
     65           */
     66          
     67          /*----------------------------------------------------------------------------
     68           *        Headers
     69           *----------------------------------------------------------------------------*/
     70          
     71          #include <assert.h>
     72          #include <string.h>
     73          
     74          #include "audio/ssc.h"
     75          #include "chip.h"
     76          #include "errno.h"
     77          #include "mm/cache.h"
     78          #include "peripherals/pmc.h"
     79          
     80          /*----------------------------------------------------------------------------
     81           *       Local functions
     82           *----------------------------------------------------------------------------*/
     83          

   \                                 In section SOFTPACK, align 4, keep-with-next
     84          static int _ssc_dma_rx_callback(void* arg, void* arg2)
     85          {
   \                     _ssc_dma_rx_callback:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     86          	struct _ssc_desc* desc = (struct _ssc_desc*)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
     87          
     88          	cache_invalidate_region(desc->rx.dma.cfg.daddr, desc->rx.dma.cfg.len);
   \       0x10   0xE596'1048        LDR      R1,[R6, #+72]
   \       0x14   0xE596'0044        LDR      R0,[R6, #+68]
   \       0x18   0x....'....        BL       cache_invalidate_region
     89          
     90          	dma_reset_channel(desc->rx.dma.channel);
   \       0x1C   0xE596'0030        LDR      R0,[R6, #+48]
   \       0x20   0x....'....        BL       dma_reset_channel
     91          
     92          	mutex_unlock(&desc->rx.mutex);
   \       0x24   0xE296'0014        ADDS     R0,R6,#+20
   \       0x28   0x....'....        BL       mutex_unlock
     93          
     94          	return callback_call(&desc->rx.callback, NULL);
   \       0x2C   0xE3A0'1000        MOV      R1,#+0
   \       0x30   0xE296'0028        ADDS     R0,R6,#+40
   \       0x34   0x....'....        BL       callback_call
   \       0x38   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
     95          }
     96          

   \                                 In section SOFTPACK, align 4, keep-with-next
     97          static void _ssc_dma_rx_transfer(struct _ssc_desc* desc, struct _buffer* buffer)
     98          {
   \                     _ssc_dma_rx_transfer:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
     99          	uint32_t id = get_ssc_id_from_addr(desc->addr);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_ssc_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    100          	struct _callback _cb;
    101          
    102          	assert(id < ID_PERIPH_COUNT);
   \       0x18   0xE356'004F        CMP      R6,#+79
   \       0x1C   0x3A00'0004        BCC      ??_ssc_dma_rx_transfer_0
   \       0x20   0xE3A0'2066        MOV      R2,#+102
   \       0x24   0x....'....        LDR      R1,??DataTable3
   \       0x28   0x....'....        LDR      R0,??DataTable3_1
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
    103          
    104          	desc->rx.dma.cfg.saddr = (void*)&desc->addr->SSC_RHR;
   \                     ??_ssc_dma_rx_transfer_0:
   \       0x34   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x38   0xE290'0020        ADDS     R0,R0,#+32
   \       0x3C   0xE584'0040        STR      R0,[R4, #+64]
    105          	desc->rx.dma.cfg.daddr = buffer->data;
   \       0x40   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x44   0xE584'0044        STR      R0,[R4, #+68]
    106          
    107          	if (desc->slot_length == 8) {
   \       0x48   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x4C   0xE350'0008        CMP      R0,#+8
   \       0x50   0x1A00'0004        BNE      ??_ssc_dma_rx_transfer_1
    108          		desc->rx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0xE584'0034        STR      R0,[R4, #+52]
    109          		desc->rx.dma.cfg.len  = buffer->size;
   \       0x5C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x60   0xE584'0048        STR      R0,[R4, #+72]
   \       0x64   0xEA00'0010        B        ??_ssc_dma_rx_transfer_2
    110          	} else if (desc->slot_length == 16) {
   \                     ??_ssc_dma_rx_transfer_1:
   \       0x68   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x6C   0xE350'0010        CMP      R0,#+16
   \       0x70   0x1A00'0005        BNE      ??_ssc_dma_rx_transfer_3
    111          		desc->rx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
   \       0x74   0xE3A0'0001        MOV      R0,#+1
   \       0x78   0xE584'0034        STR      R0,[R4, #+52]
    112          		desc->rx.dma.cfg.len  = buffer->size/2;
   \       0x7C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x80   0xE1B0'00A0        LSRS     R0,R0,#+1
   \       0x84   0xE584'0048        STR      R0,[R4, #+72]
   \       0x88   0xEA00'0007        B        ??_ssc_dma_rx_transfer_2
    113          	} else if (desc->slot_length == 32) {
   \                     ??_ssc_dma_rx_transfer_3:
   \       0x8C   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x90   0xE350'0020        CMP      R0,#+32
   \       0x94   0x1A00'0004        BNE      ??_ssc_dma_rx_transfer_2
    114          		desc->rx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
   \       0x98   0xE3A0'0002        MOV      R0,#+2
   \       0x9C   0xE584'0034        STR      R0,[R4, #+52]
    115          		desc->rx.dma.cfg.len  = buffer->size/4;
   \       0xA0   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xA4   0xE1B0'0120        LSRS     R0,R0,#+2
   \       0xA8   0xE584'0048        STR      R0,[R4, #+72]
    116          	}
    117          	dma_configure_transfer(desc->rx.dma.channel, &desc->rx.dma.cfg_dma, &desc->rx.dma.cfg, 1);
   \                     ??_ssc_dma_rx_transfer_2:
   \       0xAC   0xE3A0'3001        MOV      R3,#+1
   \       0xB0   0xE294'2040        ADDS     R2,R4,#+64
   \       0xB4   0xE294'1034        ADDS     R1,R4,#+52
   \       0xB8   0xE594'0030        LDR      R0,[R4, #+48]
   \       0xBC   0x....'....        BL       dma_configure_transfer
    118          	callback_set(&_cb, _ssc_dma_rx_callback, (void*)desc);
   \       0xC0   0xE1B0'2004        MOVS     R2,R4
   \       0xC4   0x....'....        ADR      R1,_ssc_dma_rx_callback
   \       0xC8   0xE1B0'000D        MOVS     R0,SP
   \       0xCC   0x....'....        BL       callback_set
    119          	dma_set_callback(desc->rx.dma.channel, &_cb);
   \       0xD0   0xE1B0'100D        MOVS     R1,SP
   \       0xD4   0xE594'0030        LDR      R0,[R4, #+48]
   \       0xD8   0x....'....        BL       dma_set_callback
    120          	dma_start_transfer(desc->rx.dma.channel);
   \       0xDC   0xE594'0030        LDR      R0,[R4, #+48]
   \       0xE0   0x....'....        BL       dma_start_transfer
    121          }
   \       0xE4   0xE8BD'8073        POP      {R0,R1,R4-R6,PC}  ;; return
    122          

   \                                 In section SOFTPACK, align 4, keep-with-next
    123          static int _ssc_dma_tx_callback(void* arg, void* arg2)
    124          {
   \                     _ssc_dma_tx_callback:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    125          	struct _ssc_desc* desc = (struct _ssc_desc*)arg;
   \        0xC   0xE1B0'6004        MOVS     R6,R4
    126          
    127          	dma_reset_channel(desc->tx.dma.channel);
   \       0x10   0xE596'0068        LDR      R0,[R6, #+104]
   \       0x14   0x....'....        BL       dma_reset_channel
    128          
    129          	mutex_unlock(&desc->tx.mutex);
   \       0x18   0xE296'004C        ADDS     R0,R6,#+76
   \       0x1C   0x....'....        BL       mutex_unlock
    130          
    131          	return callback_call(&desc->tx.callback, NULL);
   \       0x20   0xE3A0'1000        MOV      R1,#+0
   \       0x24   0xE296'0060        ADDS     R0,R6,#+96
   \       0x28   0x....'....        BL       callback_call
   \       0x2C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    132          }
    133          

   \                                 In section SOFTPACK, align 4, keep-with-next
    134          static void _ssc_dma_tx_transfer(struct _ssc_desc* desc, struct _buffer* buffer)
    135          {
   \                     _ssc_dma_tx_transfer:
   \        0x0   0xE92D'43FE        PUSH     {R1-R9,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    136          	uint32_t id = get_ssc_id_from_addr(desc->addr);
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       get_ssc_id_from_addr
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    137          	struct _callback _cb;
    138          
    139          	assert(id < ID_PERIPH_COUNT);
   \       0x18   0xE356'004F        CMP      R6,#+79
   \       0x1C   0x3A00'0004        BCC      ??_ssc_dma_tx_transfer_0
   \       0x20   0xE3A0'208B        MOV      R2,#+139
   \       0x24   0x....'....        LDR      R1,??DataTable3
   \       0x28   0x....'....        LDR      R0,??DataTable3_1
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
    140          
    141          	memset(&desc->tx.dma.cfg, 0x0, sizeof(desc->tx.dma.cfg));
   \                     ??_ssc_dma_tx_transfer_0:
   \       0x34   0xE3A0'700C        MOV      R7,#+12
   \       0x38   0xE3A0'8000        MOV      R8,#+0
   \       0x3C   0xE294'9078        ADDS     R9,R4,#+120
   \       0x40   0xE1B0'2008        MOVS     R2,R8
   \       0x44   0xE1B0'1007        MOVS     R1,R7
   \       0x48   0xE1B0'0009        MOVS     R0,R9
   \       0x4C   0x....'....        BL       __aeabi_memset
   \       0x50   0xE1B0'0009        MOVS     R0,R9
    142          
    143          	desc->tx.dma.cfg.saddr = buffer->data;
   \       0x54   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x58   0xE584'0078        STR      R0,[R4, #+120]
    144          	desc->tx.dma.cfg.daddr = (void*)&desc->addr->SSC_THR;
   \       0x5C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x60   0xE290'0024        ADDS     R0,R0,#+36
   \       0x64   0xE584'007C        STR      R0,[R4, #+124]
    145          
    146          	if (desc->slot_length == 8) {
   \       0x68   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x6C   0xE350'0008        CMP      R0,#+8
   \       0x70   0x1A00'0004        BNE      ??_ssc_dma_tx_transfer_1
    147          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_BYTE;
   \       0x74   0xE3A0'0000        MOV      R0,#+0
   \       0x78   0xE584'006C        STR      R0,[R4, #+108]
    148          		desc->tx.dma.cfg.len  = buffer->size;
   \       0x7C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x80   0xE584'0080        STR      R0,[R4, #+128]
   \       0x84   0xEA00'0010        B        ??_ssc_dma_tx_transfer_2
    149          	} else if (desc->slot_length == 16) {
   \                     ??_ssc_dma_tx_transfer_1:
   \       0x88   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x8C   0xE350'0010        CMP      R0,#+16
   \       0x90   0x1A00'0005        BNE      ??_ssc_dma_tx_transfer_3
    150          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_HALF_WORD;
   \       0x94   0xE3A0'0001        MOV      R0,#+1
   \       0x98   0xE584'006C        STR      R0,[R4, #+108]
    151          		desc->tx.dma.cfg.len  = buffer->size/2;
   \       0x9C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xA0   0xE1B0'00A0        LSRS     R0,R0,#+1
   \       0xA4   0xE584'0080        STR      R0,[R4, #+128]
   \       0xA8   0xEA00'0007        B        ??_ssc_dma_tx_transfer_2
    152          	} else if (desc->slot_length == 32) {
   \                     ??_ssc_dma_tx_transfer_3:
   \       0xAC   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0xB0   0xE350'0020        CMP      R0,#+32
   \       0xB4   0x1A00'0004        BNE      ??_ssc_dma_tx_transfer_2
    153          		desc->tx.dma.cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
   \       0xB8   0xE3A0'0002        MOV      R0,#+2
   \       0xBC   0xE584'006C        STR      R0,[R4, #+108]
    154          		desc->tx.dma.cfg.len  = buffer->size/4;
   \       0xC0   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xC4   0xE1B0'0120        LSRS     R0,R0,#+2
   \       0xC8   0xE584'0080        STR      R0,[R4, #+128]
    155          	}
    156          	dma_configure_transfer(desc->tx.dma.channel, &desc->tx.dma.cfg_dma, &desc->tx.dma.cfg, 1);
   \                     ??_ssc_dma_tx_transfer_2:
   \       0xCC   0xE3A0'3001        MOV      R3,#+1
   \       0xD0   0xE294'2078        ADDS     R2,R4,#+120
   \       0xD4   0xE294'106C        ADDS     R1,R4,#+108
   \       0xD8   0xE594'0068        LDR      R0,[R4, #+104]
   \       0xDC   0x....'....        BL       dma_configure_transfer
    157          	callback_set(&_cb, _ssc_dma_tx_callback, (void*)desc);
   \       0xE0   0xE1B0'2004        MOVS     R2,R4
   \       0xE4   0x....'....        ADR      R1,_ssc_dma_tx_callback
   \       0xE8   0xE1B0'000D        MOVS     R0,SP
   \       0xEC   0x....'....        BL       callback_set
    158          	dma_set_callback(desc->tx.dma.channel, &_cb);
   \       0xF0   0xE1B0'100D        MOVS     R1,SP
   \       0xF4   0xE594'0068        LDR      R0,[R4, #+104]
   \       0xF8   0x....'....        BL       dma_set_callback
    159          	cache_clean_region(desc->tx.dma.cfg.saddr, desc->tx.dma.cfg.len);
   \       0xFC   0xE594'1080        LDR      R1,[R4, #+128]
   \      0x100   0xE594'0078        LDR      R0,[R4, #+120]
   \      0x104   0x....'....        BL       cache_clean_region
    160          	dma_start_transfer(desc->tx.dma.channel);
   \      0x108   0xE594'0068        LDR      R0,[R4, #+104]
   \      0x10C   0x....'....        BL       dma_start_transfer
    161          }
   \      0x110   0xE8BD'83F7        POP      {R0-R2,R4-R9,PC}  ;; return
    162          
    163          /*----------------------------------------------------------------------------
    164           *       Exported functions
    165           *----------------------------------------------------------------------------*/
    166          

   \                                 In section SOFTPACK, align 4, keep-with-next
    167          void ssc_configure(struct _ssc_desc* desc)
    168          {
   \                     ssc_configure:
   \        0x0   0xE92D'47F0        PUSH     {R4-R10,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    169          	uint32_t id;
    170          	uint32_t clock;
    171          	uint32_t rcmr, rfmr, tcmr, tfmr;
    172          
    173          	id = get_ssc_id_from_addr(desc->addr);
   \        0x8   0xE594'0000        LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       get_ssc_id_from_addr
   \       0x10   0xE1B0'5000        MOVS     R5,R0
    174          	clock = pmc_get_peripheral_clock(id);
   \       0x14   0xE1B0'0005        MOVS     R0,R5
   \       0x18   0x....'....        BL       pmc_get_peripheral_clock
   \       0x1C   0xE1B0'6000        MOVS     R6,R0
    175          
    176          	/* Reset, disable receiver & transmitter */
    177          	desc->addr->SSC_CR = SSC_CR_RXDIS | SSC_CR_TXDIS | SSC_CR_SWRST;
   \       0x20   0xE308'0202        MOVW     R0,#+33282
   \       0x24   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x28   0xE581'0000        STR      R0,[R1, #+0]
    178          
    179          	/* Configure clock frequency */
    180          	if (desc->bit_rate != 0)
   \       0x2C   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x0A00'0006        BEQ      ??ssc_configure_0
    181          		desc->addr->SSC_CMR = clock / (2 * desc->bit_rate);
   \       0x38   0xE1B0'0006        MOVS     R0,R6
   \       0x3C   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x40   0xE1B0'1081        LSLS     R1,R1,#+1
   \       0x44   0x....'....        BL       __aeabi_uidiv
   \       0x48   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x4C   0xE581'0004        STR      R0,[R1, #+4]
   \       0x50   0xEA00'0002        B        ??ssc_configure_1
    182          	else
    183          		desc->addr->SSC_CMR = 0;
   \                     ??ssc_configure_0:
   \       0x54   0xE3A0'0000        MOV      R0,#+0
   \       0x58   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x5C   0xE581'0004        STR      R0,[R1, #+4]
    184          
    185          	if (desc->rx_cfg_cks_rk) {
   \                     ??ssc_configure_1:
   \       0x60   0xE5D4'000F        LDRB     R0,[R4, #+15]
   \       0x64   0xE350'0000        CMP      R0,#+0
   \       0x68   0x0A00'0003        BEQ      ??ssc_configure_2
    186          		rcmr = SSC_RCMR_CKS_RK |
    187          		       SSC_RCMR_CKO_NONE |
    188          		       SSC_RCMR_CKI |
    189          		       desc->rx_start_selection |
    190          		       SSC_RCMR_STTDLY(1) |
    191          		       SSC_RCMR_PERIOD(0);
   \       0x6C   0xE1D4'01B2        LDRH     R0,[R4, #+18]
   \       0x70   0xE390'7022        ORRS     R7,R0,#0x22
   \       0x74   0xE397'7B40        ORRS     R7,R7,#0x10000
   \       0x78   0xEA00'0002        B        ??ssc_configure_3
    192          	} else {
    193          		rcmr = SSC_RCMR_CKS_TK |
    194          		       SSC_RCMR_CKO_NONE |
    195          		       SSC_RCMR_CKI |
    196          		       desc->rx_start_selection |
    197          		       SSC_RCMR_STTDLY(1) |
    198          		       SSC_RCMR_PERIOD(0);
   \                     ??ssc_configure_2:
   \       0x7C   0xE1D4'01B2        LDRH     R0,[R4, #+18]
   \       0x80   0xE390'7021        ORRS     R7,R0,#0x21
   \       0x84   0xE397'7B40        ORRS     R7,R7,#0x10000
    199          	}
    200          
    201          	rfmr = SSC_RFMR_DATLEN(desc->slot_length - 1) |
    202          	       SSC_RFMR_MSBF |
    203          	       SSC_RFMR_DATNB(desc->slot_num - 1) |
    204          	       SSC_RFMR_FSOS_NONE;
   \                     ??ssc_configure_3:
   \       0x88   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0x8C   0xE250'0001        SUBS     R0,R0,#+1
   \       0x90   0xE210'001F        ANDS     R0,R0,#0x1F
   \       0x94   0xE5D4'100D        LDRB     R1,[R4, #+13]
   \       0x98   0xE251'1001        SUBS     R1,R1,#+1
   \       0x9C   0xE3A0'2EF0        MOV      R2,#+3840
   \       0xA0   0xE012'1401        ANDS     R1,R2,R1, LSL #+8
   \       0xA4   0xE191'0000        ORRS     R0,R1,R0
   \       0xA8   0xE390'8080        ORRS     R8,R0,#0x80
    205          
    206          	ssc_configure_receiver(desc, rcmr, rfmr);
   \       0xAC   0xE1B0'2008        MOVS     R2,R8
   \       0xB0   0xE1B0'1007        MOVS     R1,R7
   \       0xB4   0xE1B0'0004        MOVS     R0,R4
   \       0xB8   0x....'....        BL       ssc_configure_receiver
    207          
    208          	if (desc->tx_cfg_cks_tk) {
   \       0xBC   0xE5D4'000E        LDRB     R0,[R4, #+14]
   \       0xC0   0xE350'0000        CMP      R0,#+0
   \       0xC4   0x0A00'0003        BEQ      ??ssc_configure_4
    209          		tcmr = SSC_TCMR_CKS_TK |
    210          		       SSC_TCMR_CKO_NONE |
    211          		       desc->tx_start_selection |
    212          		       SSC_TCMR_STTDLY(1) |
    213          		       SSC_TCMR_PERIOD(0);
   \       0xC8   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0xCC   0xE390'9002        ORRS     R9,R0,#0x2
   \       0xD0   0xE399'9B40        ORRS     R9,R9,#0x10000
   \       0xD4   0xEA00'0002        B        ??ssc_configure_5
    214          
    215          	} else {
    216          		tcmr = SSC_TCMR_CKS_RK |
    217          		       SSC_TCMR_CKO_NONE |
    218          		       desc->tx_start_selection |
    219          		       SSC_TCMR_STTDLY(1) |
    220          		       SSC_TCMR_PERIOD(0);
   \                     ??ssc_configure_4:
   \       0xD8   0xE1D4'01B0        LDRH     R0,[R4, #+16]
   \       0xDC   0xE390'9001        ORRS     R9,R0,#0x1
   \       0xE0   0xE399'9B40        ORRS     R9,R9,#0x10000
    221          	}
    222          
    223          	tfmr = SSC_TFMR_DATLEN(desc->slot_length - 1) |
    224          	       SSC_TFMR_MSBF |
    225          	       SSC_TFMR_DATNB(desc->slot_num - 1) |
    226          	       SSC_TFMR_FSOS_NONE;
   \                     ??ssc_configure_5:
   \       0xE4   0xE5D4'000C        LDRB     R0,[R4, #+12]
   \       0xE8   0xE250'0001        SUBS     R0,R0,#+1
   \       0xEC   0xE210'001F        ANDS     R0,R0,#0x1F
   \       0xF0   0xE5D4'100D        LDRB     R1,[R4, #+13]
   \       0xF4   0xE251'1001        SUBS     R1,R1,#+1
   \       0xF8   0xE3A0'2EF0        MOV      R2,#+3840
   \       0xFC   0xE012'1401        ANDS     R1,R2,R1, LSL #+8
   \      0x100   0xE191'0000        ORRS     R0,R1,R0
   \      0x104   0xE390'A080        ORRS     R10,R0,#0x80
    227          
    228          	ssc_configure_transmitter(desc, tcmr, tfmr);
   \      0x108   0xE1B0'200A        MOVS     R2,R10
   \      0x10C   0xE1B0'1009        MOVS     R1,R9
   \      0x110   0xE1B0'0004        MOVS     R0,R4
   \      0x114   0x....'....        BL       ssc_configure_transmitter
    229          
    230          	/* Enable SSC peripheral clock */
    231          	pmc_configure_peripheral(id, NULL, true);
   \      0x118   0xE3A0'2001        MOV      R2,#+1
   \      0x11C   0xE3A0'1000        MOV      R1,#+0
   \      0x120   0xE1B0'0005        MOVS     R0,R5
   \      0x124   0x....'....        BL       pmc_configure_peripheral
    232          
    233          	desc->rx.dma.cfg_dma.incr_saddr = false;
   \      0x128   0xE3A0'0000        MOV      R0,#+0
   \      0x12C   0xE5C4'003C        STRB     R0,[R4, #+60]
    234          	desc->rx.dma.cfg_dma.incr_daddr = true;
   \      0x130   0xE3A0'1001        MOV      R1,#+1
   \      0x134   0xE5C4'103D        STRB     R1,[R4, #+61]
    235          	desc->rx.dma.cfg_dma.loop = false;
   \      0x138   0xE5C4'003E        STRB     R0,[R4, #+62]
    236          	desc->rx.dma.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x13C   0xE584'0038        STR      R0,[R4, #+56]
    237          	desc->tx.dma.cfg_dma.incr_saddr = true;
   \      0x140   0xE5C4'1074        STRB     R1,[R4, #+116]
    238          	desc->tx.dma.cfg_dma.incr_daddr = false;
   \      0x144   0xE5C4'0075        STRB     R0,[R4, #+117]
    239          	desc->tx.dma.cfg_dma.loop = false;
   \      0x148   0xE5C4'0076        STRB     R0,[R4, #+118]
    240          	desc->tx.dma.cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
   \      0x14C   0xE584'0070        STR      R0,[R4, #+112]
    241          
    242          	desc->tx.dma.channel = dma_allocate_channel(DMA_PERIPH_MEMORY, id);
   \      0x150   0xE1B0'1005        MOVS     R1,R5
   \      0x154   0xE6EF'1071        UXTB     R1,R1
   \      0x158   0xE3A0'00FF        MOV      R0,#+255
   \      0x15C   0x....'....        BL       dma_allocate_channel
   \      0x160   0xE584'0068        STR      R0,[R4, #+104]
    243          	assert(desc->tx.dma.channel);
   \      0x164   0xE594'0068        LDR      R0,[R4, #+104]
   \      0x168   0xE350'0000        CMP      R0,#+0
   \      0x16C   0x1A00'0004        BNE      ??ssc_configure_6
   \      0x170   0xE3A0'20F3        MOV      R2,#+243
   \      0x174   0x....'....        LDR      R1,??DataTable3
   \      0x178   0x....'....        LDR      R0,??DataTable3_2
   \      0x17C   0x....'....        BL       __aeabi_assert
   \      0x180   0x....'....        BL       __iar_EmptyStepPoint
    244          	desc->rx.dma.channel = dma_allocate_channel(id, DMA_PERIPH_MEMORY);
   \                     ??ssc_configure_6:
   \      0x184   0xE3A0'10FF        MOV      R1,#+255
   \      0x188   0xE1B0'0005        MOVS     R0,R5
   \      0x18C   0xE6EF'0070        UXTB     R0,R0
   \      0x190   0x....'....        BL       dma_allocate_channel
   \      0x194   0xE584'0030        STR      R0,[R4, #+48]
    245          	assert(desc->rx.dma.channel);
   \      0x198   0xE594'0030        LDR      R0,[R4, #+48]
   \      0x19C   0xE350'0000        CMP      R0,#+0
   \      0x1A0   0x1A00'0004        BNE      ??ssc_configure_7
   \      0x1A4   0xE3A0'20F5        MOV      R2,#+245
   \      0x1A8   0x....'....        LDR      R1,??DataTable3
   \      0x1AC   0x....'....        LDR      R0,??DataTable3_3
   \      0x1B0   0x....'....        BL       __aeabi_assert
   \      0x1B4   0x....'....        BL       __iar_EmptyStepPoint
    246          }
   \                     ??ssc_configure_7:
   \      0x1B8   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    247          

   \                                 In section SOFTPACK, align 4, keep-with-next
    248          void ssc_configure_transmitter(struct _ssc_desc* desc, uint32_t tcmr, uint32_t tfmr)
    249          {
    250          	desc->addr->SSC_TCMR = tcmr;
   \                     ssc_configure_transmitter:
   \        0x0   0xE590'3000        LDR      R3,[R0, #+0]
   \        0x4   0xE583'1018        STR      R1,[R3, #+24]
    251          	desc->addr->SSC_TFMR = tfmr;
   \        0x8   0xE590'3000        LDR      R3,[R0, #+0]
   \        0xC   0xE583'201C        STR      R2,[R3, #+28]
    252          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    253          

   \                                 In section SOFTPACK, align 4, keep-with-next
    254          void ssc_configure_receiver(struct _ssc_desc* desc, uint32_t rcmr, uint32_t rfmr)
    255          {
    256          	desc->addr->SSC_RCMR = rcmr;
   \                     ssc_configure_receiver:
   \        0x0   0xE590'3000        LDR      R3,[R0, #+0]
   \        0x4   0xE583'1010        STR      R1,[R3, #+16]
    257          	desc->addr->SSC_RFMR = rfmr;
   \        0x8   0xE590'3000        LDR      R3,[R0, #+0]
   \        0xC   0xE583'2014        STR      R2,[R3, #+20]
    258          }
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    259          

   \                                 In section SOFTPACK, align 4, keep-with-next
    260          void ssc_enable_transmitter(struct _ssc_desc* desc)
    261          {
    262          	desc->addr->SSC_CR = SSC_CR_TXEN;
   \                     ssc_enable_transmitter:
   \        0x0   0xE3A0'1F40        MOV      R1,#+256
   \        0x4   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x8   0xE582'1000        STR      R1,[R2, #+0]
    263          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    264          

   \                                 In section SOFTPACK, align 4, keep-with-next
    265          void ssc_disable_transmitter(struct _ssc_desc* desc)
    266          {
    267          	desc->addr->SSC_CR = SSC_CR_TXDIS;
   \                     ssc_disable_transmitter:
   \        0x0   0xE3A0'1F80        MOV      R1,#+512
   \        0x4   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x8   0xE582'1000        STR      R1,[R2, #+0]
    268          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    269          

   \                                 In section SOFTPACK, align 4, keep-with-next
    270          void ssc_enable_receiver(struct _ssc_desc* desc)
    271          {
    272          	desc->addr->SSC_CR = SSC_CR_RXEN;
   \                     ssc_enable_receiver:
   \        0x0   0xE3A0'1001        MOV      R1,#+1
   \        0x4   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x8   0xE582'1000        STR      R1,[R2, #+0]
    273          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    274          

   \                                 In section SOFTPACK, align 4, keep-with-next
    275          void ssc_disable_receiver(struct _ssc_desc* desc)
    276          {
    277          	desc->addr->SSC_CR = SSC_CR_RXDIS;
   \                     ssc_disable_receiver:
   \        0x0   0xE3A0'1002        MOV      R1,#+2
   \        0x4   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x8   0xE582'1000        STR      R1,[R2, #+0]
    278          }
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
    279          

   \                                 In section SOFTPACK, align 4, keep-with-next
    280          void ssc_enable_interrupts(struct _ssc_desc* desc, uint32_t sources)
    281          {
    282          	desc->addr->SSC_IER = sources;
   \                     ssc_enable_interrupts:
   \        0x0   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x4   0xE582'1044        STR      R1,[R2, #+68]
    283          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    284          

   \                                 In section SOFTPACK, align 4, keep-with-next
    285          void ssc_disable_interrupts(struct _ssc_desc* desc, uint32_t sources)
    286          {
    287          	desc->addr->SSC_IDR = sources;
   \                     ssc_disable_interrupts:
   \        0x0   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x4   0xE582'1048        STR      R1,[R2, #+72]
    288          }
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
    289          

   \                                 In section SOFTPACK, align 4, keep-with-next
    290          void ssc_write(struct _ssc_desc* desc, uint32_t frame)
    291          {
    292          	while ((desc->addr->SSC_SR & SSC_SR_TXRDY) == 0) ;
   \                     ssc_write:
   \                     ??ssc_write_0:
   \        0x0   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x4   0xE592'2040        LDR      R2,[R2, #+64]
   \        0x8   0xE312'0001        TST      R2,#0x1
   \        0xC   0x0AFF'FFFB        BEQ      ??ssc_write_0
    293          	desc->addr->SSC_THR = frame;
   \       0x10   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x14   0xE582'1024        STR      R1,[R2, #+36]
    294          }
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    295          

   \                                 In section SOFTPACK, align 4, keep-with-next
    296          uint32_t ssc_read(struct _ssc_desc* desc)
    297          {
    298          	while ((desc->addr->SSC_SR & SSC_SR_RXRDY) == 0) ;
   \                     ssc_read:
   \                     ??ssc_read_0:
   \        0x0   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x4   0xE591'1040        LDR      R1,[R1, #+64]
   \        0x8   0xE311'0010        TST      R1,#0x10
   \        0xC   0x0AFF'FFFB        BEQ      ??ssc_read_0
    299          	return desc->addr->SSC_RHR;
   \       0x10   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x14   0xE590'0020        LDR      R0,[R0, #+32]
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    300          }
    301          

   \                                 In section SOFTPACK, align 4, keep-with-next
    302          bool ssc_is_rx_ready(struct _ssc_desc* desc)
    303          {
    304          	return ((desc->addr->SSC_SR & SSC_SR_RXRDY) == SSC_SR_RXRDY);
   \                     ssc_is_rx_ready:
   \        0x0   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x4   0xE590'0040        LDR      R0,[R0, #+64]
   \        0x8   0xE1B0'0220        LSRS     R0,R0,#+4
   \        0xC   0xE210'0001        ANDS     R0,R0,#0x1
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    305          }
    306          

   \                                 In section SOFTPACK, align 4, keep-with-next
    307          int ssc_transfer(struct _ssc_desc* desc, struct _buffer* buf, struct _callback* cb)
    308          {
   \                     ssc_transfer:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    309          	if ((buf == NULL) || (buf->size == 0))
   \       0x10   0xE355'0000        CMP      R5,#+0
   \       0x14   0x0A00'0002        BEQ      ??ssc_transfer_0
   \       0x18   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x1A00'0001        BNE      ??ssc_transfer_1
    310          		return -EINVAL;
   \                     ??ssc_transfer_0:
   \       0x24   0xE3E0'001B        MVN      R0,#+27
   \       0x28   0xEA00'0027        B        ??ssc_transfer_2
    311          
    312          	if (buf->attr & SSC_BUF_ATTR_READ) {
   \                     ??ssc_transfer_1:
   \       0x2C   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \       0x30   0xE310'0002        TST      R0,#0x2
   \       0x34   0x0A00'0010        BEQ      ??ssc_transfer_3
    313          		mutex_lock(&desc->rx.mutex);
   \       0x38   0xE294'0014        ADDS     R0,R4,#+20
   \       0x3C   0x....'....        BL       mutex_lock
    314          
    315          		callback_copy(&desc->rx.callback, cb);
   \       0x40   0xE1B0'1006        MOVS     R1,R6
   \       0x44   0xE294'0028        ADDS     R0,R4,#+40
   \       0x48   0x....'....        BL       callback_copy
    316          
    317          		desc->rx.transferred = 0;
   \       0x4C   0xE3A0'0000        MOV      R0,#+0
   \       0x50   0xE1C4'02B4        STRH     R0,[R4, #+36]
    318          		desc->rx.buffer.data = buf->data;
   \       0x54   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x58   0xE584'0018        STR      R0,[R4, #+24]
    319          		desc->rx.buffer.size = buf->size;
   \       0x5C   0xE595'0004        LDR      R0,[R5, #+4]
   \       0x60   0xE584'001C        STR      R0,[R4, #+28]
    320          		desc->rx.buffer.attr = buf->attr;
   \       0x64   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x68   0xE584'0020        STR      R0,[R4, #+32]
    321          		_ssc_dma_rx_transfer(desc, buf);
   \       0x6C   0xE1B0'1005        MOVS     R1,R5
   \       0x70   0xE1B0'0004        MOVS     R0,R4
   \       0x74   0x....'....        BL       _ssc_dma_rx_transfer
   \       0x78   0xEA00'0012        B        ??ssc_transfer_4
    322          	} else if (buf->attr & SSC_BUF_ATTR_WRITE) {
   \                     ??ssc_transfer_3:
   \       0x7C   0xE5D5'0008        LDRB     R0,[R5, #+8]
   \       0x80   0xE310'0001        TST      R0,#0x1
   \       0x84   0x0A00'000F        BEQ      ??ssc_transfer_4
    323          		mutex_lock(&desc->tx.mutex);
   \       0x88   0xE294'004C        ADDS     R0,R4,#+76
   \       0x8C   0x....'....        BL       mutex_lock
    324          
    325          		callback_copy(&desc->tx.callback, cb);
   \       0x90   0xE1B0'1006        MOVS     R1,R6
   \       0x94   0xE294'0060        ADDS     R0,R4,#+96
   \       0x98   0x....'....        BL       callback_copy
    326          
    327          		desc->tx.transferred = 0;
   \       0x9C   0xE3A0'0000        MOV      R0,#+0
   \       0xA0   0xE1C4'05BC        STRH     R0,[R4, #+92]
    328          		desc->tx.buffer.data = buf->data;
   \       0xA4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xA8   0xE584'0050        STR      R0,[R4, #+80]
    329          		desc->tx.buffer.size = buf->size;
   \       0xAC   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xB0   0xE584'0054        STR      R0,[R4, #+84]
    330          		desc->tx.buffer.attr = buf->attr;
   \       0xB4   0xE595'0008        LDR      R0,[R5, #+8]
   \       0xB8   0xE584'0058        STR      R0,[R4, #+88]
    331          		_ssc_dma_tx_transfer(desc, buf);
   \       0xBC   0xE1B0'1005        MOVS     R1,R5
   \       0xC0   0xE1B0'0004        MOVS     R0,R4
   \       0xC4   0x....'....        BL       _ssc_dma_tx_transfer
    332          	}
    333          
    334          	return 0;
   \                     ??ssc_transfer_4:
   \       0xC8   0xE3A0'0000        MOV      R0,#+0
   \                     ??ssc_transfer_2:
   \       0xCC   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    335          }
    336          

   \                                 In section SOFTPACK, align 4, keep-with-next
    337          bool ssc_tx_transfer_is_done(struct _ssc_desc* desc)
    338          {
   \                     ssc_tx_transfer_is_done:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    339          	return (!mutex_is_locked(&desc->tx.mutex));
   \        0x8   0xE294'004C        ADDS     R0,R4,#+76
   \        0xC   0x....'....        BL       mutex_is_locked
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0001        BNE      ??ssc_tx_transfer_is_done_0
   \       0x18   0xE3A0'0001        MOV      R0,#+1
   \       0x1C   0xEA00'0000        B        ??ssc_tx_transfer_is_done_1
   \                     ??ssc_tx_transfer_is_done_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \                     ??ssc_tx_transfer_is_done_1:
   \       0x24   0xE6EF'0070        UXTB     R0,R0
   \       0x28   0xE8BD'8010        POP      {R4,PC}          ;; return
    340          }
    341          

   \                                 In section SOFTPACK, align 4, keep-with-next
    342          bool ssc_rx_transfer_is_done(struct _ssc_desc* desc)
    343          {
   \                     ssc_rx_transfer_is_done:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    344          	return (!mutex_is_locked(&desc->rx.mutex));
   \        0x8   0xE294'0014        ADDS     R0,R4,#+20
   \        0xC   0x....'....        BL       mutex_is_locked
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0001        BNE      ??ssc_rx_transfer_is_done_0
   \       0x18   0xE3A0'0001        MOV      R0,#+1
   \       0x1C   0xEA00'0000        B        ??ssc_rx_transfer_is_done_1
   \                     ??ssc_rx_transfer_is_done_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \                     ??ssc_rx_transfer_is_done_1:
   \       0x24   0xE6EF'0070        UXTB     R0,R0
   \       0x28   0xE8BD'8010        POP      {R4,PC}          ;; return
    345          }
    346          

   \                                 In section SOFTPACK, align 4, keep-with-next
    347          void ssc_tx_stop(struct _ssc_desc* desc)
    348          {
   \                     ssc_tx_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    349          	if (desc->tx.dma.channel) {
   \        0x8   0xE594'0068        LDR      R0,[R4, #+104]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x0A00'0003        BEQ      ??ssc_tx_stop_0
    350          		dma_stop_transfer(desc->tx.dma.channel);
   \       0x14   0xE594'0068        LDR      R0,[R4, #+104]
   \       0x18   0x....'....        BL       dma_stop_transfer
    351          		mutex_unlock(&desc->tx.mutex);
   \       0x1C   0xE294'004C        ADDS     R0,R4,#+76
   \       0x20   0x....'....        BL       mutex_unlock
    352          	}
    353          }
   \                     ??ssc_tx_stop_0:
   \       0x24   0xE8BD'8010        POP      {R4,PC}          ;; return
    354          

   \                                 In section SOFTPACK, align 4, keep-with-next
    355          void ssc_rx_stop(struct _ssc_desc* desc)
    356          {
   \                     ssc_rx_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    357          	if (desc->rx.dma.channel) {
   \        0x8   0xE594'0030        LDR      R0,[R4, #+48]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x0A00'0003        BEQ      ??ssc_rx_stop_0
    358          		dma_stop_transfer(desc->rx.dma.channel);
   \       0x14   0xE594'0030        LDR      R0,[R4, #+48]
   \       0x18   0x....'....        BL       dma_stop_transfer
    359          		mutex_unlock(&desc->rx.mutex);
   \       0x1C   0xE294'0014        ADDS     R0,R4,#+20
   \       0x20   0x....'....        BL       mutex_unlock
    360          	}
    361          }
   \                     ??ssc_rx_stop_0:
   \       0x24   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x64          DC8 "id < (79)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x37 0x39    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x61, 0x75, 0x64, 0x69, 0x6F, 0x5C

   \              0x61 0x75    

   \              0x64 0x69    

   \              0x6F 0x5C
   \       0x40   0x73 0x73          DC8 0x73, 0x73, 0x63, 0x2E, 0x63, 0

   \              0x63 0x2E    

   \              0x63 0x00
   \       0x46   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x64 0x65          DC8 "desc->tx.dma.channel"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x74 0x78    

   \              0x2E 0x64    

   \              0x6D 0x61    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x64 0x65          DC8 "desc->rx.dma.channel"

   \              0x73 0x63    

   \              0x2D 0x3E    

   \              0x72 0x78    

   \              0x2E 0x64    

   \              0x6D 0x61    

   \              0x2E 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0

   \              0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _ssc_dma_rx_callback
        16   -> cache_invalidate_region
        16   -> callback_call
        16   -> dma_reset_channel
        16   -> mutex_unlock
      24   _ssc_dma_rx_transfer
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> callback_set
        24   -> dma_configure_transfer
        24   -> dma_set_callback
        24   -> dma_start_transfer
        24   -> get_ssc_id_from_addr
      16   _ssc_dma_tx_callback
        16   -> callback_call
        16   -> dma_reset_channel
        16   -> mutex_unlock
      40   _ssc_dma_tx_transfer
        40   -> __aeabi_assert
        40   -> __aeabi_memset
        40   -> __iar_EmptyStepPoint
        40   -> cache_clean_region
        40   -> callback_set
        40   -> dma_configure_transfer
        40   -> dma_set_callback
        40   -> dma_start_transfer
        40   -> get_ssc_id_from_addr
      32   ssc_configure
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
        32   -> dma_allocate_channel
        32   -> get_ssc_id_from_addr
        32   -> pmc_configure_peripheral
        32   -> pmc_get_peripheral_clock
        32   -> ssc_configure_receiver
        32   -> ssc_configure_transmitter
        32 __aeabi_uidiv
       0   ssc_configure_receiver
       0   ssc_configure_transmitter
       0   ssc_disable_interrupts
       0   ssc_disable_receiver
       0   ssc_disable_transmitter
       0   ssc_enable_interrupts
       0   ssc_enable_receiver
       0   ssc_enable_transmitter
       0   ssc_is_rx_ready
       0   ssc_read
       8   ssc_rx_stop
         8   -> dma_stop_transfer
         8   -> mutex_unlock
       8   ssc_rx_transfer_is_done
         8   -> mutex_is_locked
      16   ssc_transfer
        16   -> _ssc_dma_rx_transfer
        16   -> _ssc_dma_tx_transfer
        16   -> callback_copy
        16   -> mutex_lock
       8   ssc_tx_stop
         8   -> dma_stop_transfer
         8   -> mutex_unlock
       8   ssc_tx_transfer_is_done
         8   -> mutex_is_locked
       0   ssc_write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      12  ?_0
      72  ?_1
      24  ?_2
      24  ?_3
      60  _ssc_dma_rx_callback
     232  _ssc_dma_rx_transfer
      48  _ssc_dma_tx_callback
     276  _ssc_dma_tx_transfer
     444  ssc_configure
      20  ssc_configure_receiver
      20  ssc_configure_transmitter
      12  ssc_disable_interrupts
      16  ssc_disable_receiver
      16  ssc_disable_transmitter
      12  ssc_enable_interrupts
      16  ssc_enable_receiver
      16  ssc_enable_transmitter
      20  ssc_is_rx_ready
      28  ssc_read
      40  ssc_rx_stop
      44  ssc_rx_transfer_is_done
     208  ssc_transfer
      40  ssc_tx_stop
      44  ssc_tx_transfer_is_done
      28  ssc_write

 
   132 bytes in section .rodata
 1'656 bytes in section SOFTPACK
 
 1'656 bytes of CODE  memory
   132 bytes of CONST memory

Errors: none
Warnings: none
