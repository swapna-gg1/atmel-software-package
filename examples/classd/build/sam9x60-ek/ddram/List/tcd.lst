###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         23/Nov/2020  15:08:26
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\tcd.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWDA83.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\tcd.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_AUDIO -D CONFIG_HAVE_SSC -D
#        CONFIG_HAVE_CLASSD -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_MMU -D
#        CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D CONFIG_HAVE_DBGU -D
#        CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sam9x60-ek\ddram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sam9x60-ek\ddram\List\tcd.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\classd\build\sam9x60-ek\ddram\Obj\tcd.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\tcd.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2017, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /*----------------------------------------------------------------------------
     31           *        Headers
     32           *----------------------------------------------------------------------------*/
     33          
     34          #include <stddef.h>
     35          #include <stdint.h>
     36          #include <assert.h>
     37          #include <string.h>
     38          
     39          #include "dma/dma.h"
     40          #include "errno.h"
     41          #include "irq/irq.h"
     42          #include "mm/cache.h"
     43          #include "peripherals/pmc.h"
     44          #include "peripherals/tc.h"
     45          #include "peripherals/tcd.h"
     46          #include "trace.h"
     47          
     48          /*----------------------------------------------------------------------------
     49           *        Local functions
     50           *----------------------------------------------------------------------------*/
     51          
     52          #ifdef CONFIG_HAVE_TC_DMA_MODE
     53          static int _tcd_dma_transfer_callback(void* args, void* arg2)
     54          {
     55          	struct _tcd_desc* desc = (struct _tcd_desc *)args;
     56          
     57          	cache_invalidate_region((uint32_t*)desc->capture.buffer.data, desc->capture.buffer.size);
     58          
     59          	dma_reset_channel(desc->capture.dma.channel);
     60          	mutex_unlock(&desc->mutex);
     61          
     62          	return callback_call(&desc->callback, NULL);
     63          }
     64          #endif

   \                                 In section .bss, align 8
     65          volatile uint64_t timetick=0;
   \                     timetick:
   \        0x0                      DS8 8
     66          /**
     67           * \brief Interrupt handler for the TC capture.
     68           */

   \                                 In section SOFTPACK, align 4, keep-with-next
     69          static void _tcd_counter_handler(uint32_t source, void* user_arg)
     70          {
   \                     _tcd_counter_handler:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4001        MOV      R4,R1
     71          	struct _tcd_desc* desc = (struct _tcd_desc *)user_arg;
     72          	uint32_t status = tc_get_status(desc->addr, desc->channel);
   \        0x8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       tc_get_status
     73          
     74          	if (desc->mode == TCD_MODE_COUNTER)
   \       0x14   0xE5D4'1005        LDRB     R1,[R4, #+5]
   \       0x18   0xE351'0000        CMP      R1,#+0
   \       0x1C   0x1A00'0006        BNE      ??_tcd_counter_handler_0
     75          		if ((status & TC_SR_CPCS) == TC_SR_CPCS)
   \       0x20   0xE310'0010        TST      R0,#0x10
   \       0x24   0x0A00'0004        BEQ      ??_tcd_counter_handler_0
     76                              timetick++;
   \       0x28   0x....'....        LDR      R2,??DataTable0
   \       0x2C   0xE1C2'00D0        LDRD     R0,R1,[R2, #+0]
   \       0x30   0xE290'4001        ADDS     R4,R0,#+1
   \       0x34   0xE2A1'5000        ADC      R5,R1,#+0
   \       0x38   0xE1C2'40F0        STRD     R4,R5,[R2, #+0]
     77          			//callback_call(&desc->callback, NULL);
     78          }
   \                     ??_tcd_counter_handler_0:
   \       0x3C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
     79          
     80          #ifdef CONFIG_HAVE_TC_DMA_MODE
     81          static int _tcd_capture_dma(struct _tcd_desc* desc)
     82          {
     83          	struct _dma_transfer_cfg cfg;
     84          	struct _dma_cfg cfg_dma;
     85          	struct _callback _cb;
     86          
     87          	memset(&cfg_dma, 0, sizeof(cfg_dma));
     88          	cfg_dma.incr_saddr = false;
     89          	cfg_dma.incr_daddr = true;
     90          	cfg_dma.data_width = DMA_DATA_WIDTH_WORD;
     91          	cfg_dma.chunk_size = DMA_CHUNK_SIZE_1;
     92          
     93          	memset(&cfg, 0, sizeof(cfg));
     94          	cfg.saddr = (uint32_t*)&(desc->addr->TC_CHANNEL[desc->channel].TC_RAB);
     95          	cfg.daddr = desc->capture.buffer.data;
     96          	cfg.len = desc->capture.buffer.size / sizeof(uint32_t);
     97          	dma_configure_transfer(desc->capture.dma.channel, &cfg_dma, &cfg, 1);
     98          
     99          	callback_set(&_cb, _tcd_dma_transfer_callback, (void*)desc);
    100          	dma_set_callback(desc->capture.dma.channel, &_cb);
    101          
    102          	tc_get_status(desc->addr, desc->channel);
    103          	tc_start(desc->addr, desc->channel);
    104          
    105          	dma_start_transfer(desc->capture.dma.channel);
    106          
    107          	return -EAGAIN;
    108          }
    109          #endif
    110          
    111          static int _tcd_capture_polling(struct _tcd_desc* desc)
    112          {
    113          	uint32_t i;
    114          	uint32_t* rab_data = (uint32_t*)desc->capture.buffer.data;
    115          
    116          	tc_start(desc->addr, desc->channel);
    117          	for (i = 0; i < desc->capture.buffer.size / sizeof(uint32_t); i += 2) {
    118          		while ((tc_get_status(desc->addr, desc->channel) & TC_SR_LDRBS) != TC_SR_LDRBS);
    119          		tc_get_ra_rb_rc(desc->addr, desc->channel, &rab_data[i], &rab_data[i + 1], 0);
    120          	}
    121          	tc_stop(desc->addr, desc->channel);
    122          
    123          	mutex_unlock(&desc->mutex);
    124          
    125          	return callback_call(&desc->callback, NULL);
    126          }
    127          
    128          /*----------------------------------------------------------------------------
    129           *        Public functions
    130           *----------------------------------------------------------------------------*/
    131          

   \                                 In section SOFTPACK, align 4, keep-with-next
    132          int tcd_configure_counter(struct _tcd_desc* desc, uint32_t min_timer_freq, uint32_t frequency)
    133          {
   \                     tcd_configure_counter:
   \        0x0   0xE92D'40FE        PUSH     {R1-R7,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
    134          	uint32_t tc_id = get_tc_id_from_addr(desc->addr, desc->channel);
   \       0x10   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x14   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       get_tc_id_from_addr
   \       0x1C   0xE1A0'7000        MOV      R7,R0
    135          	uint32_t tc_clks, config, rc, chan_freq;
    136          
    137          	desc->mutex = 0;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE584'0008        STR      R0,[R4, #+8]
    138          	desc->mode = TCD_MODE_COUNTER;
   \       0x28   0xE5C4'0005        STRB     R0,[R4, #+5]
    139          	callback_set(&desc->callback, NULL, NULL);
   \       0x2C   0xE3A0'2000        MOV      R2,#+0
   \       0x30   0xE3A0'1000        MOV      R1,#+0
   \       0x34   0xE284'000C        ADD      R0,R4,#+12
   \       0x38   0x....'....        BL       callback_set
    140          	desc->cfg.counter.min_timer_freq = min_timer_freq;
   \       0x3C   0xE584'5014        STR      R5,[R4, #+20]
    141          	desc->cfg.counter.frequency = frequency;
   \       0x40   0xE584'6018        STR      R6,[R4, #+24]
    142          
    143          	if (!pmc_is_peripheral_enabled(tc_id))
   \       0x44   0xE1A0'0007        MOV      R0,R7
   \       0x48   0x....'....        BL       pmc_is_peripheral_enabled
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x1A00'0003        BNE      ??tcd_configure_counter_0
    144          		pmc_configure_peripheral(tc_id, NULL, true);
   \       0x54   0xE3A0'2001        MOV      R2,#+1
   \       0x58   0xE3A0'1000        MOV      R1,#+0
   \       0x5C   0xE1A0'0007        MOV      R0,R7
   \       0x60   0x....'....        BL       pmc_configure_peripheral
    145          
    146          	if (min_timer_freq < frequency)
   \                     ??tcd_configure_counter_0:
   \       0x64   0xE1A0'2006        MOV      R2,R6
   \       0x68   0xE156'0005        CMP      R6,R5
   \       0x6C   0x31A0'2005        MOVCC    R2,R5
    147          		min_timer_freq = frequency;
    148          
    149          	tc_clks = tc_find_best_clock_source(desc->addr, desc->channel, min_timer_freq);
   \       0x70   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x74   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x78   0x....'....        BL       tc_find_best_clock_source
    150          	config = tc_clks | TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC;
    151          	tc_configure(desc->addr, desc->channel, config);
   \       0x7C   0xE380'2CC0        ORR      R2,R0,#0xC000
   \       0x80   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x84   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x88   0x....'....        BL       tc_configure
    152          	chan_freq = tc_get_channel_freq(desc->addr, desc->channel);
   \       0x8C   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x90   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x94   0x....'....        BL       tc_get_channel_freq
   \       0x98   0xE1A0'5000        MOV      R5,R0
    153          
    154          	rc = chan_freq / frequency;
   \       0x9C   0xE1A0'1006        MOV      R1,R6
   \       0xA0   0x....'....        BL       __aeabi_uidiv
   \       0xA4   0xE58D'0004        STR      R0,[SP, #+4]
    155          	tc_set_ra_rb_rc(desc->addr, desc->channel, NULL, NULL, &rc);
   \       0xA8   0xE28D'0004        ADD      R0,SP,#+4
   \       0xAC   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xB0   0xE3A0'3000        MOV      R3,#+0
   \       0xB4   0xE3A0'2000        MOV      R2,#+0
   \       0xB8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xBC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xC0   0x....'....        BL       tc_set_ra_rb_rc
    156          
    157          	return chan_freq / rc;
   \       0xC4   0xE59D'1004        LDR      R1,[SP, #+4]
   \       0xC8   0xE1A0'0005        MOV      R0,R5
   \       0xCC   0xE28D'D00C        ADD      SP,SP,#+12
   \       0xD0   0xE8BD'40F0        POP      {R4-R7,LR}
   \       0xD4   0x....'....        B        __aeabi_uidiv
    158          }
    159          

   \                                 In section SOFTPACK, align 4, keep-with-next
    160          int tcd_configure_waveform(struct _tcd_desc* desc, uint32_t min_timer_freq, uint32_t frequency, uint16_t duty_cycle)
    161          {
   \                     tcd_configure_waveform:
   \        0x0   0xE92D'41F8        PUSH     {R3-R8,LR}
   \        0x4   0xE24D'D00C        SUB      SP,SP,#+12
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE1A0'8001        MOV      R8,R1
   \       0x10   0xE1A0'7002        MOV      R7,R2
   \       0x14   0xE1A0'6003        MOV      R6,R3
    162          	uint32_t tc_id = get_tc_id_from_addr(desc->addr, desc->channel);
   \       0x18   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x1C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x20   0x....'....        BL       get_tc_id_from_addr
    163          	uint32_t tc_clks, config, ra, rc, duty, chan_freq;
    164          
    165          	if (duty_cycle > 1000)
   \       0x24   0xE3A0'10E9        MOV      R1,#+233
   \       0x28   0xE381'1FC0        ORR      R1,R1,#0x300
   \       0x2C   0xE1A0'5000        MOV      R5,R0
   \       0x30   0xE156'0001        CMP      R6,R1
    166          		return -EINVAL;
   \       0x34   0xA3E0'001B        MVNGE    R0,#+27
   \       0x38   0xAA00'003A        BGE      ??tcd_configure_waveform_0
    167          
    168          	desc->mutex = 0;
   \       0x3C   0xE3A0'0000        MOV      R0,#+0
   \       0x40   0xE584'0008        STR      R0,[R4, #+8]
    169          	desc->mode = TCD_MODE_WAVEFORM;
   \       0x44   0xE3A0'1001        MOV      R1,#+1
   \       0x48   0xE5C4'1005        STRB     R1,[R4, #+5]
    170          	callback_set(&desc->callback, NULL, NULL);
   \       0x4C   0xE3A0'2000        MOV      R2,#+0
   \       0x50   0xE3A0'1000        MOV      R1,#+0
   \       0x54   0xE284'000C        ADD      R0,R4,#+12
   \       0x58   0x....'....        BL       callback_set
    171          	desc->cfg.waveform.min_timer_freq = min_timer_freq;
   \       0x5C   0xE584'8014        STR      R8,[R4, #+20]
    172          	desc->cfg.waveform.frequency = frequency;
   \       0x60   0xE584'7018        STR      R7,[R4, #+24]
    173          	desc->cfg.waveform.duty_cycle = duty_cycle;
   \       0x64   0xE584'601C        STR      R6,[R4, #+28]
    174          	
    175          	if (!pmc_is_peripheral_enabled(tc_id))
   \       0x68   0xE1A0'0005        MOV      R0,R5
   \       0x6C   0x....'....        BL       pmc_is_peripheral_enabled
   \       0x70   0xE350'0000        CMP      R0,#+0
   \       0x74   0x1A00'0003        BNE      ??tcd_configure_waveform_1
    176          		pmc_configure_peripheral(tc_id, NULL, true);
   \       0x78   0xE3A0'2001        MOV      R2,#+1
   \       0x7C   0xE3A0'1000        MOV      R1,#+0
   \       0x80   0xE1A0'0005        MOV      R0,R5
   \       0x84   0x....'....        BL       pmc_configure_peripheral
    177          
    178          	if (min_timer_freq < frequency)
   \                     ??tcd_configure_waveform_1:
   \       0x88   0xE1A0'2007        MOV      R2,R7
   \       0x8C   0xE157'0008        CMP      R7,R8
   \       0x90   0x31A0'2008        MOVCC    R2,R8
    179          		min_timer_freq = frequency;
    180          
    181          	tc_clks = tc_find_best_clock_source(desc->addr, desc->channel, min_timer_freq);
   \       0x94   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x98   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x9C   0x....'....        BL       tc_find_best_clock_source
    182          	config = tc_clks | TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET | TC_CMR_ASWTRG_SET;
    183          	tc_configure(desc->addr, desc->channel, config);
   \       0xA0   0xE380'2A6C        ORR      R2,R0,#0x6C000
   \       0xA4   0xE382'2840        ORR      R2,R2,#0x400000
   \       0xA8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xAC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xB0   0x....'....        BL       tc_configure
    184          	chan_freq = tc_get_channel_freq(desc->addr, desc->channel);
   \       0xB4   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xB8   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xBC   0x....'....        BL       tc_get_channel_freq
   \       0xC0   0xE1A0'5000        MOV      R5,R0
    185          
    186          	rc = chan_freq / frequency;
   \       0xC4   0xE1A0'1007        MOV      R1,R7
   \       0xC8   0x....'....        BL       __aeabi_uidiv
   \       0xCC   0xE58D'0004        STR      R0,[SP, #+4]
    187          	duty = ((uint64_t)duty_cycle * ((1ull << TC_CHANNEL_SIZE) - 1)) / 1000;
    188          	ra = (uint32_t)(((uint64_t)duty * rc + (1ull << (TC_CHANNEL_SIZE - 1))) >> TC_CHANNEL_SIZE);
   \       0xD0   0xE3E0'E000        MVN      LR,#+0
   \       0xD4   0xE081'0E96        UMULL    R0,R1,R6,LR
   \       0xD8   0xE3A0'2FFA        MOV      R2,#+1000
   \       0xDC   0xE3A0'3000        MOV      R3,#+0
   \       0xE0   0x....'....        BL       __aeabi_uldivmod
   \       0xE4   0xE59D'C004        LDR      R12,[SP, #+4]
   \       0xE8   0xE3A0'6480        MOV      R6,#-2147483648
   \       0xEC   0xE3A0'7000        MOV      R7,#+0
   \       0xF0   0xE0A7'6C90        UMLAL    R6,R7,R0,R12
    189          	tc_set_ra_rb_rc(desc->addr, desc->channel, &ra, NULL, &rc);
   \       0xF4   0xE28D'1004        ADD      R1,SP,#+4
   \       0xF8   0xE58D'7008        STR      R7,[SP, #+8]
   \       0xFC   0xE58D'1000        STR      R1,[SP, #+0]
   \      0x100   0xE3A0'3000        MOV      R3,#+0
   \      0x104   0xE28D'2008        ADD      R2,SP,#+8
   \      0x108   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \      0x10C   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x110   0x....'....        BL       tc_set_ra_rb_rc
    190          
    191          	return chan_freq / rc;
   \      0x114   0xE59D'1004        LDR      R1,[SP, #+4]
   \      0x118   0xE1A0'0005        MOV      R0,R5
   \      0x11C   0xE28D'D010        ADD      SP,SP,#+16
   \      0x120   0xE8BD'41F0        POP      {R4-R8,LR}
   \      0x124   0x....'....        B        __aeabi_uidiv
   \                     ??tcd_configure_waveform_0:
   \      0x128   0xE28D'D010        ADD      SP,SP,#+16
   \      0x12C   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
    192          }
    193          

   \                                 In section SOFTPACK, align 4, keep-with-next
    194          int tcd_configure_capture(struct _tcd_desc* desc, uint32_t frequency, struct _buffer* buffer)
    195          {
   \                     tcd_configure_capture:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   \        0xC   0xE1A0'6002        MOV      R6,R2
    196          	uint32_t tc_id = get_tc_id_from_addr(desc->addr, desc->channel);
   \       0x10   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x14   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       get_tc_id_from_addr
   \       0x1C   0xE1A0'7000        MOV      R7,R0
    197          	uint32_t tc_clks, config, chan_freq;
    198          
    199          	desc->mutex = 0;
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE584'0008        STR      R0,[R4, #+8]
    200          	desc->mode = TCD_MODE_CAPTURE;
   \       0x28   0xE3A0'1002        MOV      R1,#+2
   \       0x2C   0xE5C4'1005        STRB     R1,[R4, #+5]
    201          	callback_set(&desc->callback, NULL, NULL);
   \       0x30   0xE3A0'2000        MOV      R2,#+0
   \       0x34   0xE3A0'1000        MOV      R1,#+0
   \       0x38   0xE284'000C        ADD      R0,R4,#+12
   \       0x3C   0x....'....        BL       callback_set
    202          	desc->cfg.capture.frequency = frequency;
   \       0x40   0xE584'501C        STR      R5,[R4, #+28]
    203          	desc->capture.buffer.data = buffer->data;
   \       0x44   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x48   0xE584'0024        STR      R0,[R4, #+36]
    204          	desc->capture.buffer.size = buffer->size;
   \       0x4C   0xE596'1004        LDR      R1,[R6, #+4]
    205          
    206          #ifdef CONFIG_HAVE_TC_DMA_MODE
    207          	/* Allocate one DMA channel for TC capture */
    208          	desc->capture.dma.channel = dma_allocate_channel(tc_id, DMA_PERIPH_MEMORY);
    209          	assert(desc->capture.dma.channel);
    210          #endif
    211          
    212          	if (!pmc_is_peripheral_enabled(tc_id))
   \       0x50   0xE1A0'0007        MOV      R0,R7
   \       0x54   0xE584'1028        STR      R1,[R4, #+40]
   \       0x58   0x....'....        BL       pmc_is_peripheral_enabled
   \       0x5C   0xE350'0000        CMP      R0,#+0
   \       0x60   0x1A00'0003        BNE      ??tcd_configure_capture_0
    213          		pmc_configure_peripheral(tc_id, NULL, true);
   \       0x64   0xE3A0'2001        MOV      R2,#+1
   \       0x68   0xE3A0'1000        MOV      R1,#+0
   \       0x6C   0xE1A0'0007        MOV      R0,R7
   \       0x70   0x....'....        BL       pmc_configure_peripheral
    214          	if (desc->cfg.capture.use_ext_clk) {
   \                     ??tcd_configure_capture_0:
   \       0x74   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \       0x78   0xE3A0'6A90        MOV      R6,#+589824
   \       0x7C   0xE386'6E60        ORR      R6,R6,#0x600
   \       0x80   0xE350'0000        CMP      R0,#+0
    215          		config = desc->cfg.capture.ext_clk_sel | TC_CMR_LDRA_RISING |
    216          		         TC_CMR_LDRB_FALLING | TC_CMR_ABETRG | TC_CMR_ETRGEDG_FALLING;
   \       0x84   0x1594'0018        LDRNE    R0,[R4, #+24]
    217          	}
    218          	else {
    219          		tc_clks = tc_find_best_clock_source(desc->addr, desc->channel, frequency);
    220          		config = tc_clks | TC_CMR_LDRA_RISING | TC_CMR_LDRB_FALLING | TC_CMR_ABETRG | TC_CMR_ETRGEDG_FALLING;
   \       0x88   0x01A0'2005        MOVEQ    R2,R5
   \       0x8C   0x05D4'1004        LDRBEQ   R1,[R4, #+4]
   \       0x90   0x0594'0000        LDREQ    R0,[R4, #+0]
   \       0x94   0x....'....        BLEQ     tc_find_best_clock_source
   \       0x98   0xE186'2000        ORR      R2,R6,R0
    221          	}
    222          	tc_configure(desc->addr, desc->channel, config);
   \       0x9C   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xA0   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xA4   0x....'....        BL       tc_configure
    223          	if (desc->cfg.capture.use_ext_clk)
   \       0xA8   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \       0xAC   0xE350'0000        CMP      R0,#+0
   \       0xB0   0x1A00'0003        BNE      ??tcd_configure_capture_1
    224          		chan_freq = frequency;
    225          	else
    226          		chan_freq = tc_get_channel_freq(desc->addr, desc->channel);
   \       0xB4   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xB8   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xBC   0x....'....        BL       tc_get_channel_freq
   \       0xC0   0xE1A0'5000        MOV      R5,R0
    227          	return chan_freq;
   \                     ??tcd_configure_capture_1:
   \       0xC4   0xE1A0'0005        MOV      R0,R5
   \       0xC8   0xE8BD'80F2        POP      {R1,R4-R7,PC}    ;; return
    228          }
    229          

   \                                 In section SOFTPACK, align 4, keep-with-next
    230          int tcd_start(struct _tcd_desc* desc, struct _callback* cb)
    231          {
   \                     tcd_start:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
    232          	uint32_t tc_id = get_tc_id_from_addr(desc->addr, desc->channel);
   \        0xC   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x10   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x14   0x....'....        BL       get_tc_id_from_addr
   \       0x18   0xE1A0'6000        MOV      R6,R0
    233          
    234          	if (!mutex_try_lock(&desc->mutex))
   \       0x1C   0xE284'0008        ADD      R0,R4,#+8
   \       0x20   0x....'....        BL       mutex_try_lock
   \       0x24   0xE350'0000        CMP      R0,#+0
   \       0x28   0x1A00'0001        BNE      ??tcd_start_0
    235          		return -EBUSY;
   \       0x2C   0xE3E0'0009        MVN      R0,#+9
   \       0x30   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}
    236          
    237          	callback_copy(&desc->callback, cb);
   \                     ??tcd_start_0:
   \       0x34   0xE1A0'1005        MOV      R1,R5
   \       0x38   0xE284'000C        ADD      R0,R4,#+12
   \       0x3C   0x....'....        BL       callback_copy
    238          
    239          	switch (desc->mode) {
   \       0x40   0xE5D4'0005        LDRB     R0,[R4, #+5]
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x0A00'0003        BEQ      ??tcd_start_1
   \       0x4C   0xE350'0002        CMP      R0,#+2
   \       0x50   0x0A00'0010        BEQ      ??tcd_start_2
   \       0x54   0x3A00'000A        BCC      ??tcd_start_3
   \       0x58   0xEA00'0033        B        ??tcd_start_4
    240          	case TCD_MODE_COUNTER:
    241          		irq_add_handler(tc_id, _tcd_counter_handler, (void*)desc);
   \                     ??tcd_start_1:
   \       0x5C   0xE1A0'2004        MOV      R2,R4
   \       0x60   0x....'....        ADR      R1,_tcd_counter_handler
   \       0x64   0xE1A0'0006        MOV      R0,R6
   \       0x68   0x....'....        BL       irq_add_handler
    242          		irq_enable(tc_id);
   \       0x6C   0xE1A0'0006        MOV      R0,R6
   \       0x70   0x....'....        BL       irq_enable
    243          		tc_enable_it(desc->addr, desc->channel, TC_IER_CPCS);
   \       0x74   0xE3A0'2010        MOV      R2,#+16
   \       0x78   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x7C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x80   0x....'....        BL       tc_enable_it
    244                          //tc_enable_it(desc->addr, desc->channel, TC_IER_COVFS);
    245          		tc_start(desc->addr, desc->channel);
   \                     ??tcd_start_3:
   \       0x84   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0x88   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x8C   0x....'....        BL       tc_start
    246          		break;
    247          	case TCD_MODE_WAVEFORM:
    248          		tc_start(desc->addr, desc->channel);
    249          		break;
    250          	case TCD_MODE_CAPTURE:
    251          		switch (desc->cfg.capture.transfer_mode) {
    252          		case TCD_TRANSFER_MODE_POLLING:
    253          			_tcd_capture_polling(desc);
    254          			break;
    255          #ifdef CONFIG_HAVE_TC_DMA_MODE
    256          		case TCD_TRANSFER_MODE_DMA:
    257          			_tcd_capture_dma(desc);
    258          			break;
    259          #endif
    260          		default:
    261          			return -EINVAL;
    262          		}
    263          		break;
    264          	default:
    265          		return -ENOTSUP;
    266          	}
    267          
    268          	return 0;
   \                     ??tcd_start_5:
   \       0x90   0xE3A0'0000        MOV      R0,#+0
   \       0x94   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??tcd_start_2:
   \       0x98   0xE5D4'0020        LDRB     R0,[R4, #+32]
   \       0x9C   0xE350'0000        CMP      R0,#+0
   \       0xA0   0x1A00'001F        BNE      ??tcd_start_6
   \       0xA4   0xE594'6024        LDR      R6,[R4, #+36]
   \       0xA8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xAC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xB0   0x....'....        BL       tc_start
   \       0xB4   0xE3A0'5000        MOV      R5,#+0
   \       0xB8   0xEA00'000D        B        ??tcd_start_7
   \                     ??tcd_start_8:
   \       0xBC   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xC0   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xC4   0x....'....        BL       tc_get_status
   \       0xC8   0xE310'0040        TST      R0,#0x40
   \       0xCC   0x0AFF'FFFA        BEQ      ??tcd_start_8
   \       0xD0   0xE3A0'0000        MOV      R0,#+0
   \       0xD4   0xE58D'0000        STR      R0,[SP, #+0]
   \       0xD8   0xE286'3004        ADD      R3,R6,#+4
   \       0xDC   0xE1A0'2006        MOV      R2,R6
   \       0xE0   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \       0xE4   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xE8   0x....'....        BL       tc_get_ra_rb_rc
   \       0xEC   0xE285'5002        ADD      R5,R5,#+2
   \       0xF0   0xE286'6008        ADD      R6,R6,#+8
   \                     ??tcd_start_7:
   \       0xF4   0xE594'0028        LDR      R0,[R4, #+40]
   \       0xF8   0xE155'0120        CMP      R5,R0, LSR #+2
   \       0xFC   0x3AFF'FFEE        BCC      ??tcd_start_8
   \      0x100   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \      0x104   0xE594'0000        LDR      R0,[R4, #+0]
   \      0x108   0x....'....        BL       tc_stop
   \      0x10C   0xE284'0008        ADD      R0,R4,#+8
   \      0x110   0x....'....        BL       mutex_unlock
   \      0x114   0xE3A0'1000        MOV      R1,#+0
   \      0x118   0xE284'000C        ADD      R0,R4,#+12
   \      0x11C   0x....'....        BL       callback_call
   \      0x120   0xEAFF'FFDA        B        ??tcd_start_5
   \                     ??tcd_start_6:
   \      0x124   0xE3E0'001B        MVN      R0,#+27
   \      0x128   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}
   \                     ??tcd_start_4:
   \      0x12C   0xE3E0'003C        MVN      R0,#+60
   \      0x130   0xE8BD'8076        POP      {R1,R2,R4-R6,PC}
    269          }
    270          

   \                                 In section SOFTPACK, align 4, keep-with-next
    271          int tcd_stop(struct _tcd_desc* desc)
    272          {
   \                     tcd_stop:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    273          	tc_stop(desc->addr, desc->channel);
   \        0x8   0xE5D4'1004        LDRB     R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       tc_stop
    274          	if (mutex_is_locked(&desc->mutex))
   \       0x14   0xE284'0008        ADD      R0,R4,#+8
   \       0x18   0x....'....        BL       mutex_is_locked
   \       0x1C   0xE350'0000        CMP      R0,#+0
   \       0x20   0x0A00'0002        BEQ      ??tcd_stop_0
    275          		mutex_unlock(&desc->mutex);
   \       0x24   0xE284'0008        ADD      R0,R4,#+8
   \       0x28   0x....'....        BL       mutex_unlock
    276          
    277          	return 0;
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \                     ??tcd_stop_0:
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    278          }
    279          

   \                                 In section SOFTPACK, align 4, keep-with-next
    280          void tcd_wait(struct _tcd_desc* desc)
    281          {
   \                     tcd_wait:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    282          	while (mutex_is_locked(&desc->mutex)) {
   \                     ??tcd_wait_0:
   \        0x8   0xE284'0008        ADD      R0,R4,#+8
   \        0xC   0x....'....        BL       mutex_is_locked
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1AFF'FFFB        BNE      ??tcd_wait_0
    283          #ifdef CONFIG_HAVE_TC_DMA_MODE
    284          		if (desc->mode == TCD_MODE_CAPTURE){
    285          			if (desc->cfg.capture.transfer_mode == TCD_TRANSFER_MODE_DMA)
    286          				dma_poll();
    287          		}
    288          #endif
    289          	}
    290          }
   \       0x18   0xE8BD'8010        POP      {R4,PC}          ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     timetick

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _tcd_counter_handler
        16   -> tc_get_status
      24   tcd_configure_capture
        24   -> callback_set
        24   -> get_tc_id_from_addr
        24   -> pmc_configure_peripheral
        24   -> pmc_is_peripheral_enabled
        24   -> tc_configure
        24   -> tc_find_best_clock_source
        24   -> tc_get_channel_freq
      32   tcd_configure_counter
        32   -> callback_set
        32   -> get_tc_id_from_addr
        32   -> pmc_configure_peripheral
        32   -> pmc_is_peripheral_enabled
        32   -> tc_configure
        32   -> tc_find_best_clock_source
        32   -> tc_get_channel_freq
        32   -> tc_set_ra_rb_rc
         0 __aeabi_uidiv
        32 __aeabi_uidiv
      40   tcd_configure_waveform
        40   -> callback_set
        40   -> get_tc_id_from_addr
        40   -> pmc_configure_peripheral
        40   -> pmc_is_peripheral_enabled
        40   -> tc_configure
        40   -> tc_find_best_clock_source
        40   -> tc_get_channel_freq
        40   -> tc_set_ra_rb_rc
         0 __aeabi_uidiv
        40 __aeabi_uidiv
        40 __aeabi_uldivmod
      24   tcd_start
        24   -> callback_call
        24   -> callback_copy
        24   -> get_tc_id_from_addr
        24   -> irq_add_handler
        24   -> irq_enable
        24   -> mutex_try_lock
        24   -> mutex_unlock
        24   -> tc_enable_it
        24   -> tc_get_ra_rb_rc
        24   -> tc_get_status
        24   -> tc_start
        24   -> tc_stop
       8   tcd_stop
         8   -> mutex_is_locked
         8   -> mutex_unlock
         8   -> tc_stop
       8   tcd_wait
         8   -> mutex_is_locked


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      64  _tcd_counter_handler
     204  tcd_configure_capture
     216  tcd_configure_counter
     304  tcd_configure_waveform
     308  tcd_start
      52  tcd_stop
      28  tcd_wait
       8  timetick

 
     8 bytes in section .bss
 1'180 bytes in section SOFTPACK
 
 1'180 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
