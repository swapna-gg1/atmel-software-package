###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         03/Jun/2020  07:55:07
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\dma\dma.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EWEBC.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\dma\dma.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D2 -D
#        CONFIG_CHIP_SAMA5D27 -D CONFIG_PACKAGE_289PIN -D
#        CONFIG_BOARD_SAMA5D27_SOM1_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO4 -D CONFIG_HAVE_PIO4_SECURE -D
#        CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D CONFIG_HAVE_SMC -D
#        CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_GMAC_QUEUES -D
#        CONFIG_HAVE_MPDDRC -D CONFIG_HAVE_MPDDRC_DATA_PATH -D
#        CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D CONFIG_HAVE_MPDDRC_DDR2 -D
#        CONFIG_HAVE_MPDDRC_LPDDR2 -D CONFIG_HAVE_MPDDRC_DDR3 -D
#        CONFIG_HAVE_MPDDRC_LPDDR3 -D CONFIG_HAVE_ADC_SETTLING_TIME -D
#        CONFIG_HAVE_ADC_DIFF_INPUT -D CONFIG_HAVE_ADC_SEQ_R2 -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_PMC_AUDIO_CLOCK -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_DMA -D
#        CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D CONFIG_HAVE_PWMC_EXTERNAL_TRIGGER
#        -D CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR
#        -D CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_SFRBU -D CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D
#        CONFIG_HAVE_XDMAC -D CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D
#        CONFIG_HAVE_SECUMOD -D CONFIG_HAVE_SFC -D CONFIG_HAVE_PWMC -D
#        CONFIG_HAVE_SECURE_MATRIX -D CONFIG_HAVE_DDR2_W971GG6SB -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D CONFIG_HAVE_TC_FAULT_MODE
#        -D CONFIG_HAVE_TC_DMA_MODE -D CONFIG_HAVE_RTC_CALIBRATION -D
#        CONFIG_HAVE_RTC_MODE_PERSIAN -D CONFIG_HAVE_RTC_MODE_UTC -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_UART -D CONFIG_HAVE_SERIALD_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sama5d27-som1-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sama5d27-som1-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sama5d27-som1-ek\ddram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\target\sama5d2\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sama5d27-som1-ek\ddram\List\dma.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sama5d27-som1-ek\ddram\Obj\dma.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\dma\dma.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2016, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \file
     31           *
     32           * The DMA API features a generic layer on top of the supported DMA peripherals.
     33           * The generic layer is device independent and provides the common API for
     34           * low level driver and generic functionality.
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          
     41          #include <assert.h>
     42          #include <stdio.h>
     43          #include <string.h>
     44          
     45          #include "callback.h"
     46          #include "compiler.h"
     47          #include "dma/dma.h"
     48          #include "irq/irq.h"
     49          #include "errno.h"
     50          #include "mm/cache.h"
     51          #include "mutex.h"
     52          #include "peripherals/pmc.h"
     53          
     54          /*----------------------------------------------------------------------------
     55           *        Macros
     56           *----------------------------------------------------------------------------*/
     57          
     58          #if defined(CONFIG_HAVE_XDMAC)
     59          #define DMA_MAX_BLOCK_LEN XDMAC_MAX_BLOCK_LEN
     60          
     61          #define DMA_SG_DESC_GET_NEXT(d) ((struct _dma_sg_desc*)(d)->desc.mbr_nda)
     62          #define DMA_SG_DESC_SET_NEXT(d, next) (d)->desc.mbr_nda = (void*)(next)
     63          #define DMA_SG_DESC_SET_SADDR(d, addr) (d)->desc.mbr_sa = (void*)(addr)
     64          #define DMA_SG_DESC_SET_DADDR(d, addr) (d)->desc.mbr_da = (void*)(addr)
     65          
     66          #define DMA_DESC_SET_SADDR(d, addr) (d)->sa = (void*)(addr)
     67          #define DMA_DESC_SET_DADDR(d, addr) (d)->da = (void*)(addr)
     68          
     69          #elif defined(CONFIG_HAVE_DMAC)
     70          #define DMA_MAX_BLOCK_LEN DMAC_MAX_BLOCK_LEN
     71          
     72          #define DMA_SG_DESC_GET_NEXT(d) ((struct _dma_sg_desc*)(d)->desc.dscr)
     73          #define DMA_SG_DESC_SET_NEXT(d, next) (d)->desc.dscr = (void*)(next)
     74          #define DMA_SG_DESC_SET_SADDR(d, addr) (d)->desc.saddr = (void*)(addr)
     75          #define DMA_SG_DESC_SET_DADDR(d, addr) (d)->desc.daddr = (void*)(addr)
     76          
     77          #define DMA_DESC_SET_SADDR(d, addr) (d)->saddr = (void*)(addr)
     78          #define DMA_DESC_SET_DADDR(d, addr) (d)->daddr = (void*)(addr)
     79          #endif
     80          
     81          /*----------------------------------------------------------------------------
     82           *        Local constants
     83           *----------------------------------------------------------------------------*/
     84          
     85          static uint32_t controllers[] = {
     86          #ifdef XDMAC0
     87          	ID_XDMAC0,
     88          #endif
     89          #ifdef XDMAC1
     90          	ID_XDMAC1,
     91          #endif
     92          #ifdef DMAC0
     93          	ID_DMAC0,
     94          #endif
     95          #ifdef DMAC1
     96          	ID_DMAC1,
     97          #endif
     98          };
     99          
    100          #define DMA_CONTROLLERS ARRAY_SIZE(controllers)
    101          
    102          /*----------------------------------------------------------------------------
    103           *        Local definitions
    104           *----------------------------------------------------------------------------*/
    105          
    106          /** Types for specifying a transfer of scattered data, or a transfer of
    107           * contiguous data that may be reconfigured on a block-by-block basis. */
    108          
    109          /** Elementary transfer descriptor, AKA linked list item.
    110           * Allocate the items, but do not access their members. Please use the dedicated
    111           * functions defined below. */
    112          struct _dma_sg_desc {
    113          #ifdef CONFIG_HAVE_XDMAC
    114          	struct _xdmac_desc_view1 desc;
    115          #elif defined(CONFIG_HAVE_DMAC)
    116          	struct _dmac_desc desc;
    117          #endif
    118          };
    119          
    120          struct _dma_sg_pool {
    121          	struct _dma_sg_desc desc[DMA_SG_ITEM_POOL_SIZE];
    122          	struct _dma_sg_desc* head;
    123          	struct _dma_sg_desc* tail;
    124          
    125          	uint16_t count; /* Count elements in list  */
    126          	mutex_t mutex;
    127          };
    128          
    129          
    130          /** DMA driver instance */
    131          struct _dma_ctrl {
    132          	struct _dma_controller controllers[DMA_CONTROLLERS];
    133          	bool polling;
    134          	uint8_t polling_timeout;
    135          };
    136          
    137          /*----------------------------------------------------------------------------
    138           *        Local variables
    139           *----------------------------------------------------------------------------*/
    140          

   \                                 In section .region_cache_aligned, align 32
    141          CACHE_ALIGNED static struct _dma_sg_pool _dma_sg_pool;
   \                     _dma_sg_pool:
   \        0x0                      DS8 1'040

   \                                 In section .data, align 4
    142          
    143          static struct _dma_ctrl _dma_ctrl;
   \                     _dma_ctrl:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x60   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x70   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x80   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x90   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xA0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xB0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xC0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xD0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xE0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xF0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x100   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x110   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x120   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x130   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x140   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x150   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x160   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x170   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x180   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x190   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1A0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1B0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1C0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1D0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1E0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x1F0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x200   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x210   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x220   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x230   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x240   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x250   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x260   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x270   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x280   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x290   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2A0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2B0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2C0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2D0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2E0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x2F0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x300   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x310   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x320   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x330   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x340   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x350   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x360   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x370   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x380   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x394   0x0000'0006        DC32 6, 7

   \              0x0000'0007
    144          
    145          /*----------------------------------------------------------------------------
    146           *        Local functions
    147           *----------------------------------------------------------------------------*/
    148          
    149          static inline bool is_source_periph(struct _dma_channel* channel)
    150          {
    151          	return ((channel->src_txif != 0xff) | (channel->src_rxif != 0xff));
    152          }
    153          
    154          static inline bool is_dest_periph(struct _dma_channel* channel)
    155          {
    156          	return ((channel->dest_txif != 0xff) | (channel->dest_rxif != 0xff));
    157          }
    158          
    159          /**
    160           * \brief Preinitialize all descriptors and pool and link them together
    161           */
    162          static void _dma_sg_init(void)
    163          {
    164          	uint32_t i;
    165          
    166          	memset(&_dma_sg_pool, 0, sizeof(_dma_sg_pool));
    167          
    168          	mutex_lock(&_dma_sg_pool.mutex);
    169          
    170          	for (i = 0; i < ARRAY_SIZE(_dma_sg_pool.desc); i++)
    171          		DMA_SG_DESC_SET_NEXT(&_dma_sg_pool.desc[i], &_dma_sg_pool.desc[i + 1]);
    172          	DMA_SG_DESC_SET_NEXT(&_dma_sg_pool.desc[i - 1], 0);
    173          
    174          	_dma_sg_pool.head = _dma_sg_pool.desc;
    175          	_dma_sg_pool.tail = &_dma_sg_pool.desc[i - 1];
    176          	_dma_sg_pool.count = ARRAY_SIZE(_dma_sg_pool.desc);
    177          
    178          	mutex_unlock(&_dma_sg_pool.mutex);
    179          }
    180          
    181          static struct _dma_sg_desc* _dma_sg_desc_alloc(uint8_t count)
    182          {
    183          	struct _dma_sg_desc* list_head;
    184          	struct _dma_sg_desc* curr;
    185          	struct _dma_sg_desc* next;
    186          	uint8_t i;
    187          
    188          	if (count == 0)
    189          		return NULL;
    190          	if (count > _dma_sg_pool.count)
    191          		return NULL;
    192          
    193          	mutex_lock(&_dma_sg_pool.mutex);
    194          
    195          	list_head = _dma_sg_pool.head;
    196          	curr = list_head;
    197          	for (i = 0; i < (count - 1); i++) {
    198          		curr = DMA_SG_DESC_GET_NEXT(curr);
    199          	}
    200          		next = DMA_SG_DESC_GET_NEXT(curr);
    201          	DMA_SG_DESC_SET_NEXT(curr, 0);
    202          
    203          	_dma_sg_pool.count -= count;
    204          	_dma_sg_pool.head = next;
    205          
    206          	if (_dma_sg_pool.count == 0) {
    207          		_dma_sg_pool.head = NULL;
    208          		_dma_sg_pool.tail = NULL;
    209          	}
    210          
    211          	mutex_unlock(&_dma_sg_pool.mutex);
    212          
    213          	return list_head;
    214          }
    215          

   \                                 In section SOFTPACK, align 4, keep-with-next
    216          static void _dma_sg_desc_free(struct _dma_sg_desc* list_head)
    217          {
   \                     _dma_sg_desc_free:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'5000        MOVS     R5,R0
    218          	struct _dma_sg_desc* curr = list_head;
    219          	struct _dma_sg_desc* tail;
    220          
    221          	if (list_head == NULL)
   \        0x8   0x0A00'0015        BEQ      ??_dma_sg_desc_free_0
    222          		return;
    223          
    224          	do {
    225          		tail = curr;
   \                     ??_dma_sg_desc_free_1:
   \        0xC   0xE1A0'6000        MOV      R6,R0
    226          		curr = DMA_SG_DESC_GET_NEXT(curr);
   \       0x10   0xE590'0000        LDR      R0,[R0, #+0]
    227          	} while ((curr != NULL) && (curr != list_head));
   \       0x14   0xE350'0000        CMP      R0,#+0
   \       0x18   0x1150'0005        CMPNE    R0,R5
   \       0x1C   0x1AFF'FFFA        BNE      ??_dma_sg_desc_free_1
    228          	curr = list_head;
    229          
    230          	mutex_lock(&_dma_sg_pool.mutex);
   \       0x20   0x....'....        LDR      R4,??DataTable5
   \       0x24   0xE300'040C        MOVW     R0,#+1036
   \       0x28   0xE084'0000        ADD      R0,R4,R0
   \       0x2C   0x....'....        BL       mutex_lock
    231          
    232          	if (_dma_sg_pool.head == NULL)
   \       0x30   0xE594'1400        LDR      R1,[R4, #+1024]
    233          		_dma_sg_pool.head = list_head;
    234          
    235          	if (_dma_sg_pool.tail != NULL)
   \       0x34   0xE594'0404        LDR      R0,[R4, #+1028]
    236          		DMA_SG_DESC_SET_NEXT(_dma_sg_pool.tail, list_head);
    237          	_dma_sg_pool.tail = tail;
    238          	DMA_SG_DESC_SET_NEXT(_dma_sg_pool.tail, 0);
    239          
    240          	mutex_unlock(&_dma_sg_pool.mutex);
   \       0x38   0xE300'240C        MOVW     R2,#+1036
   \       0x3C   0xE351'0000        CMP      R1,#+0
   \       0x40   0x0584'5400        STREQ    R5,[R4, #+1024]
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x1580'5000        STRNE    R5,[R0, #+0]
   \       0x4C   0xE584'6404        STR      R6,[R4, #+1028]
   \       0x50   0xE3A0'0000        MOV      R0,#+0
   \       0x54   0xE586'0000        STR      R0,[R6, #+0]
   \       0x58   0xE084'0002        ADD      R0,R4,R2
   \       0x5C   0xE8BD'4070        POP      {R4-R6,LR}
   \       0x60   0x....'....        B        mutex_unlock     ;; tailcall
   \                     ??_dma_sg_desc_free_0:
   \       0x64   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    241          }
    242          
    243          static int _dma_configure_transfer(struct _dma_channel* channel,
    244          				   struct _dma_cfg* cfg_dma,
    245          				   struct _dma_transfer_cfg *cfg)
    246          {
    247          	bool src_is_periph, dst_is_periph;
    248          	uint32_t divisor;
    249          
    250          #if defined(CONFIG_HAVE_XDMAC)
    251          	struct _xdmacd_cfg desc;
    252          #elif defined(CONFIG_HAVE_DMAC)
    253          	struct _dmac_desc desc;
    254          	struct _dmacd_cfg dma_cfg;
    255          #endif
    256          
    257          	memset(&desc, 0, sizeof(desc));
    258          
    259          	src_is_periph = is_source_periph(channel);
    260          	dst_is_periph = is_dest_periph(channel);
    261          
    262          	if (cfg->len <= DMA_MAX_BT_SIZE) {
    263          		/* If len is <= 16,777,215, the driver will transfer a
    264          		   single block, those size will be len data elements. */
    265          #if defined(CONFIG_HAVE_XDMAC)
    266          		desc.ubc = cfg->len;
    267          		desc.bc = 0;
    268          #elif defined(CONFIG_HAVE_DMAC)
    269          		desc.ctrla = cfg->len;
    270          #endif
    271          	} else {
    272          		/* If len exceeds 16,777,215, split the transfer in
    273          		   multiple blocks (microblocks), calculating and using the greatest block
    274          		   size possible for this transfer. */
    275          		for (divisor = DMA_MAX_BT_SIZE; divisor > 1; divisor--) {
    276          			if (cfg->len % divisor)
    277          				continue;
    278          			if ((cfg->len / divisor) <= DMA_MAX_BLOCK_LEN) {
    279          #if defined(CONFIG_HAVE_XDMAC)
    280          				desc.ubc = divisor;
    281          				desc.bc = (cfg->len / divisor) - 1;
    282          #elif defined(CONFIG_HAVE_DMAC)
    283          				desc.ctrla = divisor;
    284          				dma_cfg.blocks = (cfg->len / divisor) - 1;
    285          				dma_cfg.trans_auto = 1;
    286          				dma_cfg.sa_rep = src_is_periph ? 1 : 0 ;
    287          				dma_cfg.da_rep = dst_is_periph ? 1 : 0 ;
    288          #endif
    289          				break;
    290          			}
    291          		}
    292          		if (divisor == 1)
    293          			return -EINVAL;
    294          	}
    295          
    296          	DMA_DESC_SET_SADDR(&desc, cfg->saddr);
    297          	DMA_DESC_SET_DADDR(&desc, cfg->daddr);
    298          
    299          #if defined(CONFIG_HAVE_XDMAC)
    300          	if (src_is_periph || dst_is_periph)
    301          		desc.cfg = XDMAC_CC_TYPE_PER_TRAN;
    302          	else
    303          		desc.cfg = XDMAC_CC_TYPE_MEM_TRAN;
    304          	desc.cfg |= src_is_periph ? XDMAC_CC_DSYNC_PER2MEM : XDMAC_CC_DSYNC_MEM2PER;
    305          	desc.cfg |= XDMAC_CC_CSIZE(cfg_dma->chunk_size);
    306          	desc.cfg |= XDMAC_CC_DWIDTH(cfg_dma->data_width);
    307          	desc.cfg |= src_is_periph ? XDMAC_CC_SIF_AHB_IF1 : XDMAC_CC_SIF_AHB_IF0;
    308          	desc.cfg |= dst_is_periph ? XDMAC_CC_DIF_AHB_IF1 : XDMAC_CC_DIF_AHB_IF0;
    309          	desc.cfg |= cfg_dma->incr_saddr ? XDMAC_CC_SAM_INCREMENTED_AM : XDMAC_CC_SAM_FIXED_AM;
    310          	desc.cfg |= cfg_dma->incr_daddr ? XDMAC_CC_DAM_INCREMENTED_AM : XDMAC_CC_DAM_FIXED_AM;
    311          	desc.cfg |= (src_is_periph || dst_is_periph) ? 0 : XDMAC_CC_SWREQ_SWR_CONNECTED;
    312          	desc.ds = 0;
    313          	desc.sus = 0;
    314          	desc.dus = 0;
    315          
    316          	return xdmacd_configure_transfer(channel, &desc, 0, 0);
    317          #elif defined(CONFIG_HAVE_DMAC)
    318          	dma_cfg.s_decr_fetch = 1;
    319          	dma_cfg.d_decr_fetch = 1;
    320          	dma_cfg.sa_rep = 0;
    321          	dma_cfg.da_rep = 0;
    322          	dma_cfg.trans_auto = 0;
    323          	dma_cfg.blocks = 0;
    324          
    325          	dma_cfg.cfg = src_is_periph ? DMAC_CFG_SRC_H2SEL_HW : 0;
    326          	dma_cfg.cfg |= dst_is_periph ? DMAC_CFG_DST_H2SEL_HW : 0;
    327          
    328          	desc.ctrla |= (cfg_dma->data_width << DMAC_CTRLA_SRC_WIDTH_Pos)
    329          		| (cfg_dma->data_width << DMAC_CTRLA_DST_WIDTH_Pos)
    330          		| (cfg_dma->chunk_size << DMAC_CTRLA_SCSIZE_Pos)
    331          		| (cfg_dma->chunk_size << DMAC_CTRLA_DCSIZE_Pos);
    332          
    333          #if defined(CONFIG_SOC_SAMA5D3)
    334          	desc.ctrlb = src_is_periph ? DMAC_CTRLB_SIF_AHB_IF2 : DMAC_CTRLB_SIF_AHB_IF0;
    335          	desc.ctrlb |= dst_is_periph ? DMAC_CTRLB_DIF_AHB_IF2 : DMAC_CTRLB_DIF_AHB_IF0;
    336          #elif defined(CONFIG_SOC_SAM9XX5)
    337          	desc.ctrlb = src_is_periph ? DMAC_CTRLB_SIF_AHB_IF1 : DMAC_CTRLB_SIF_AHB_IF0;
    338          	desc.ctrlb |= dst_is_periph ? DMAC_CTRLB_DIF_AHB_IF1 : DMAC_CTRLB_DIF_AHB_IF0;
    339          #endif
    340          	if (src_is_periph)
    341          		desc.ctrlb |= DMAC_CTRLB_FC_PER2MEM_DMA_FC;
    342          	else if (dst_is_periph)
    343          		desc.ctrlb |= DMAC_CTRLB_FC_MEM2PER_DMA_FC;
    344          	else
    345          		desc.ctrlb |= DMAC_CTRLB_FC_MEM2MEM_DMA_FC;
    346          	desc.ctrlb |= cfg_dma->incr_saddr ? DMAC_CTRLB_SRC_INCR_INCREMENTING : DMAC_CTRLB_SRC_INCR_FIXED;
    347          	desc.ctrlb |= cfg_dma->incr_daddr ? DMAC_CTRLB_DST_INCR_INCREMENTING : DMAC_CTRLB_DST_INCR_FIXED;
    348          	desc.ctrlb |= DMAC_CTRLB_SRC_DSCR_FETCH_DISABLE | DMAC_CTRLB_DST_DSCR_FETCH_DISABLE;
    349          
    350          	return dmacd_configure_transfer(channel, &dma_cfg, &desc);
    351          #endif /* CONFIG_HAVE_DMAC */
    352          }
    353          
    354          static int _dma_sg_configure_transfer(struct _dma_channel* channel,
    355          				      struct _dma_cfg* cfg_dma,
    356          				      struct _dma_transfer_cfg* sg_list, uint8_t sg_list_size)
    357          {
    358          	struct _dma_sg_desc* _sg_head;
    359          	struct _dma_sg_desc* curr;
    360          	struct _dma_transfer_cfg* cfg;
    361          	bool src_is_periph, dst_is_periph;
    362          	uint8_t idx;
    363          
    364          	if ((sg_list == NULL) || (sg_list_size == 0))
    365          		return -EINVAL;
    366          
    367          	src_is_periph = is_source_periph(channel);
    368          	dst_is_periph = is_dest_periph(channel);
    369          
    370          	_sg_head = _dma_sg_desc_alloc(sg_list_size);
    371          	if (_sg_head == NULL)
    372          		return -ENOMEM;
    373          	curr = _sg_head;
    374          
    375          	src_is_periph = is_source_periph(channel);
    376          	dst_is_periph = is_dest_periph(channel);
    377          
    378          	/* Update linked list */
    379          	for (idx = 0; idx < sg_list_size; idx++) {
    380          		cfg = &sg_list[idx];
    381          
    382          		DMA_SG_DESC_SET_SADDR(curr, cfg->saddr);
    383          		DMA_SG_DESC_SET_DADDR(curr, cfg->daddr);
    384          
    385          #if defined(CONFIG_HAVE_XDMAC)
    386          		curr->desc.mbr_ubc = XDMA_UBC_NVIEW_NDV1
    387          			| XDMA_UBC_NSEN_UPDATED
    388          			| XDMA_UBC_NDEN_UPDATED
    389          			| XDMA_UBC_NDE_FETCH_EN
    390          			| XDMA_UBC_UBLEN(cfg->len);
    391          
    392          		if (!cfg_dma->loop) {
    393          			if (DMA_SG_DESC_GET_NEXT(curr) == 0)
    394          				curr->desc.mbr_ubc &= ~XDMA_UBC_NDE_FETCH_EN;
    395          		}
    396          
    397          #elif defined(CONFIG_HAVE_DMAC)
    398          		curr->desc.ctrla = (cfg_dma->data_width << DMAC_CTRLA_SRC_WIDTH_Pos)
    399          			| (cfg_dma->data_width << DMAC_CTRLA_DST_WIDTH_Pos)
    400          			| (cfg_dma->chunk_size << DMAC_CTRLA_SCSIZE_Pos)
    401          			| (cfg_dma->chunk_size << DMAC_CTRLA_DCSIZE_Pos)
    402          			| DMAC_CTRLA_BTSIZE(cfg->len);
    403          
    404          #if defined(CONFIG_SOC_SAMA5D3)
    405          		curr->desc.ctrlb = src_is_periph ? DMAC_CTRLB_SIF_AHB_IF2 : DMAC_CTRLB_SIF_AHB_IF0;
    406          		curr->desc.ctrlb |= dst_is_periph ? DMAC_CTRLB_DIF_AHB_IF2 : DMAC_CTRLB_DIF_AHB_IF0;
    407          #elif defined(CONFIG_SOC_SAM9XX5)
    408          		curr->desc.ctrlb = src_is_periph ? DMAC_CTRLB_SIF_AHB_IF1 : DMAC_CTRLB_SIF_AHB_IF0;
    409          		curr->desc.ctrlb |= dst_is_periph ? DMAC_CTRLB_DIF_AHB_IF1 : DMAC_CTRLB_DIF_AHB_IF0;
    410          #endif
    411          		if (src_is_periph)
    412          			curr->desc.ctrlb |= DMAC_CTRLB_FC_PER2MEM_DMA_FC;
    413          		else if (dst_is_periph)
    414          			curr->desc.ctrlb |= DMAC_CTRLB_FC_MEM2PER_DMA_FC;
    415          		else
    416          			curr->desc.ctrlb |= DMAC_CTRLB_FC_MEM2MEM_DMA_FC;
    417          
    418          		curr->desc.ctrlb |= cfg_dma->incr_saddr ? DMAC_CTRLB_SRC_INCR_INCREMENTING : DMAC_CTRLB_SRC_INCR_FIXED;
    419          		curr->desc.ctrlb |= cfg_dma->incr_daddr ? DMAC_CTRLB_DST_INCR_INCREMENTING : DMAC_CTRLB_DST_INCR_FIXED;
    420          
    421          		curr->desc.ctrlb |= DMAC_CTRLB_SRC_DSCR_FETCH_FROM_MEM | DMAC_CTRLB_DST_DSCR_FETCH_FROM_MEM;
    422          
    423          #endif
    424          		if (DMA_SG_DESC_GET_NEXT(curr) == 0)
    425          			if (cfg_dma->loop)
    426          				DMA_SG_DESC_SET_NEXT(curr, _sg_head);
    427          		curr = DMA_SG_DESC_GET_NEXT(curr);
    428          	}
    429          	channel->sg_list = _sg_head;
    430          
    431          	cache_clean_region(_dma_sg_pool.desc, sizeof(_dma_sg_pool.desc));
    432          
    433          	/* Update configuration */
    434          #if defined(CONFIG_HAVE_XDMAC)
    435          	struct _xdmacd_cfg xdmacd_cfg;
    436          	uint32_t desc_ctrl;
    437          
    438          	xdmacd_cfg.cfg = (src_is_periph | dst_is_periph) ? XDMAC_CC_TYPE_PER_TRAN : XDMAC_CC_TYPE_MEM_TRAN;
    439          	xdmacd_cfg.cfg |= src_is_periph ? XDMAC_CC_DSYNC_PER2MEM : XDMAC_CC_DSYNC_MEM2PER;
    440          	xdmacd_cfg.cfg |= XDMAC_CC_CSIZE(cfg_dma->chunk_size);
    441          	xdmacd_cfg.cfg |= XDMAC_CC_DWIDTH(cfg_dma->data_width);
    442          	xdmacd_cfg.cfg |= src_is_periph ? XDMAC_CC_SIF_AHB_IF1 : XDMAC_CC_SIF_AHB_IF0;
    443          	xdmacd_cfg.cfg |= dst_is_periph ? XDMAC_CC_DIF_AHB_IF1 : XDMAC_CC_DIF_AHB_IF0;
    444          	xdmacd_cfg.cfg |= cfg_dma->incr_saddr ? XDMAC_CC_SAM_INCREMENTED_AM : XDMAC_CC_SAM_FIXED_AM;
    445          	xdmacd_cfg.cfg |= cfg_dma->incr_daddr ? XDMAC_CC_DAM_INCREMENTED_AM : XDMAC_CC_DAM_FIXED_AM;
    446          	xdmacd_cfg.cfg |= (src_is_periph | dst_is_periph) ? 0 : XDMAC_CC_SWREQ_SWR_CONNECTED;
    447          	xdmacd_cfg.bc = 0;
    448          	xdmacd_cfg.ds = 0;
    449          	xdmacd_cfg.sus = 0;
    450          	xdmacd_cfg.dus = 0;
    451          
    452          	desc_ctrl = XDMAC_CNDC_NDVIEW_NDV1
    453          	           | XDMAC_CNDC_NDE_DSCR_FETCH_EN
    454          	           | XDMAC_CNDC_NDSUP_SRC_PARAMS_UPDATED
    455          	           | XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED;
    456          
    457          	return xdmacd_configure_transfer(channel, &xdmacd_cfg, desc_ctrl, (void *)_sg_head);
    458          #elif defined(CONFIG_HAVE_DMAC)
    459          	struct _dmacd_cfg dmacd_cfg;
    460          
    461          	dmacd_cfg.s_decr_fetch = 0;
    462          	dmacd_cfg.d_decr_fetch = 0;
    463          	dmacd_cfg.sa_rep = 0;
    464          	dmacd_cfg.da_rep = 0;
    465          	dmacd_cfg.trans_auto = 0;
    466          	dmacd_cfg.blocks = 0;
    467          	dmacd_cfg.s_pip = 0;
    468          	dmacd_cfg.d_pip = 0;
    469          	dmacd_cfg.cfg = src_is_periph ? DMAC_CFG_SRC_H2SEL_HW : 0;
    470          	dmacd_cfg.cfg |= dst_is_periph ? DMAC_CFG_DST_H2SEL_HW : 0;
    471          
    472          	return dmacd_configure_transfer(channel, &dmacd_cfg, (void*)_sg_head);
    473          #endif
    474          }
    475          
    476          /*----------------------------------------------------------------------------
    477           *        Exported functions
    478           *----------------------------------------------------------------------------*/
    479          

   \                                 In section SOFTPACK, align 4, keep-with-next
    480          void dma_initialize(bool polling)
    481          {
   \                     dma_initialize:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
   \        0x4   0xE1A0'7000        MOV      R7,R0
    482          	uint32_t ctrl, chan;
    483          
    484          	_dma_sg_init();
   \        0x8   0x....'....        LDR      R4,??DataTable5
   \        0xC   0xE3A0'1E41        MOV      R1,#+1040
   \       0x10   0xE1A0'0004        MOV      R0,R4
   \       0x14   0x....'....        BL       __aeabi_memclr4
   \       0x18   0xE300'040C        MOVW     R0,#+1036
   \       0x1C   0xE3A0'9000        MOV      R9,#+0
   \       0x20   0xE084'0000        ADD      R0,R4,R0
   \       0x24   0x....'....        BL       mutex_lock
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0xE1A0'1004        MOV      R1,R4
   \                     ??dma_initialize_0:
   \       0x30   0xE281'2010        ADD      R2,R1,#+16
   \       0x34   0xE280'0004        ADD      R0,R0,#+4
   \       0x38   0xE581'2000        STR      R2,[R1, #+0]
   \       0x3C   0xE281'3020        ADD      R3,R1,#+32
   \       0x40   0xE281'C030        ADD      R12,R1,#+48
   \       0x44   0xE281'E040        ADD      LR,R1,#+64
   \       0x48   0xE350'0040        CMP      R0,#+64
   \       0x4C   0xE581'3010        STR      R3,[R1, #+16]
   \       0x50   0xE581'C020        STR      R12,[R1, #+32]
   \       0x54   0xE581'E030        STR      LR,[R1, #+48]
   \       0x58   0xE281'1040        ADD      R1,R1,#+64
   \       0x5C   0x3AFF'FFF3        BCC      ??dma_initialize_0
   \       0x60   0xE084'0200        ADD      R0,R4,R0, LSL #+4
   \       0x64   0xE3E0'100F        MVN      R1,#+15
   \       0x68   0x....'....        LDR      R5,??DataTable5_1
   \       0x6C   0xE780'9001        STR      R9,[R0, +R1]
   \       0x70   0xE080'0001        ADD      R0,R0,R1
   \       0x74   0xE3A0'1040        MOV      R1,#+64
   \       0x78   0xE281'2FF2        ADD      R2,R1,#+968
   \       0x7C   0xE584'0404        STR      R0,[R4, #+1028]
   \       0x80   0xE184'10B2        STRH     R1,[R4, +R2]
   \       0x84   0xE281'3FF3        ADD      R3,R1,#+972
   \       0x88   0xE584'4400        STR      R4,[R4, #+1024]
   \       0x8C   0xE084'0003        ADD      R0,R4,R3
   \       0x90   0xE285'4FE5        ADD      R4,R5,#+916
   \       0x94   0x....'....        BL       mutex_unlock
    485          
    486          	_dma_ctrl.polling = polling;
   \       0x98   0xE5C5'7390        STRB     R7,[R5, #+912]
    487          
    488          	for (ctrl = 0; ctrl < DMA_CONTROLLERS; ctrl++) {
   \       0x9C   0xE3A0'6002        MOV      R6,#+2
   \       0xA0   0x....'....        LDR      R8,??DataTable5_2
    489          		struct _dma_controller* controller = &_dma_ctrl.controllers[ctrl];
    490          		controller->pid = controllers[ctrl];
   \                     ??dma_initialize_1:
   \       0xA4   0xE594'0000        LDR      R0,[R4, #+0]
   \       0xA8   0xE3A0'A000        MOV      R10,#+0
   \       0xAC   0xE285'B008        ADD      R11,R5,#+8
   \       0xB0   0xE585'0000        STR      R0,[R5, #+0]
    491          #if defined(CONFIG_HAVE_XDMAC)
    492          		controller->hw = get_xdmac_addr_from_id(controller->pid);
   \       0xB4   0x....'....        BL       get_xdmac_addr_from_id
   \       0xB8   0xE585'0004        STR      R0,[R5, #+4]
    493          #elif defined(CONFIG_HAVE_DMAC)
    494          		controller->hw = get_dmac_addr_from_id(controller->pid);
    495          #endif
    496          		for (chan = 0; chan < DMA_CHANNELS; chan++) {
    497          #if defined(CONFIG_HAVE_XDMAC)
    498          			xdmac_get_channel_isr(controller->hw, chan);
   \                     ??dma_initialize_2:
   \       0xBC   0xE595'0004        LDR      R0,[R5, #+4]
   \       0xC0   0xE6EF'107A        UXTB     R1,R10
   \       0xC4   0x....'....        BL       xdmac_get_channel_isr
    499          #endif
    500          			struct _dma_channel* channel = &controller->channels[chan];
    501          			channel->hw = controller->hw;
   \       0xC8   0xE595'0004        LDR      R0,[R5, #+4]
    502          			channel->id = chan;
    503          			callback_set(&channel->callback, NULL, NULL);
   \       0xCC   0xE3A0'2000        MOV      R2,#+0
   \       0xD0   0xE3A0'1000        MOV      R1,#+0
   \       0xD4   0xE58B'0000        STR      R0,[R11, #+0]
   \       0xD8   0xE58B'A004        STR      R10,[R11, #+4]
   \       0xDC   0xE28B'0008        ADD      R0,R11,#+8
   \       0xE0   0xE28A'A001        ADD      R10,R10,#+1
   \       0xE4   0x....'....        BL       callback_set
    504          			channel->src_txif = 0;
   \       0xE8   0xE5CB'9010        STRB     R9,[R11, #+16]
    505          			channel->src_rxif = 0;
   \       0xEC   0xE5CB'9011        STRB     R9,[R11, #+17]
    506          			channel->dest_txif = 0;
   \       0xF0   0xE5CB'9012        STRB     R9,[R11, #+18]
    507          			channel->dest_rxif = 0;
   \       0xF4   0xE5CB'9013        STRB     R9,[R11, #+19]
    508          			channel->state = DMA_STATE_FREE;
    509          		}
   \       0xF8   0xE35A'0010        CMP      R10,#+16
   \       0xFC   0xE5CB'9014        STRB     R9,[R11, #+20]
   \      0x100   0xE28B'B01C        ADD      R11,R11,#+28
   \      0x104   0x3AFF'FFEC        BCC      ??dma_initialize_2
    510          
    511          		if (!polling) {
   \      0x108   0xE1B0'0007        MOVS     R0,R7
   \      0x10C   0x1A00'0005        BNE      ??dma_initialize_3
    512          			/* enable interrupts */
    513          			irq_add_handler(controller->pid, dma_irq_handler, controller);
   \      0x110   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x114   0xE1A0'2005        MOV      R2,R5
   \      0x118   0xE1A0'1008        MOV      R1,R8
   \      0x11C   0x....'....        BL       irq_add_handler
    514          			irq_enable(controller->pid);
   \      0x120   0xE595'0000        LDR      R0,[R5, #+0]
   \      0x124   0x....'....        BL       irq_enable
    515          		}
    516          	}
   \                     ??dma_initialize_3:
   \      0x128   0xE256'6001        SUBS     R6,R6,#+1
   \      0x12C   0xE285'5F72        ADD      R5,R5,#+456
   \      0x130   0xE284'4004        ADD      R4,R4,#+4
   \      0x134   0x1AFF'FFDA        BNE      ??dma_initialize_1
    517          }
   \      0x138   0xE8BD'8FF1        POP      {R0,R4-R11,PC}   ;; return
    518          

   \                                 In section SOFTPACK, align 4, keep-with-next
    519          void dma_poll(void)
    520          {
   \                     dma_poll:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    521          	if (_dma_ctrl.polling) {
   \        0x4   0x....'....        LDR      R4,??DataTable5_1
   \        0x8   0xE5D4'1390        LDRB     R1,[R4, #+912]
   \        0xC   0xE351'0000        CMP      R1,#+0
   \       0x10   0x0A00'0006        BEQ      ??dma_poll_0
    522          		uint32_t ctrl;
    523          		for (ctrl = 0; ctrl < DMA_CONTROLLERS; ctrl++) {
    524          			struct _dma_controller* controller = &_dma_ctrl.controllers[ctrl];
    525          			dma_irq_handler(controller->pid, controller);
   \       0x14   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x18   0xE1A0'1004        MOV      R1,R4
   \       0x1C   0x....'....        BL       dma_irq_handler
   \       0x20   0xE594'01C8        LDR      R0,[R4, #+456]
   \       0x24   0xE284'1F72        ADD      R1,R4,#+456
   \       0x28   0xE8BD'4010        POP      {R4,LR}
   \       0x2C   0x....'....        B        dma_irq_handler  ;; tailcall
    526          		}
    527          	}
    528          }
   \                     ??dma_poll_0:
   \       0x30   0xE8BD'8010        POP      {R4,PC}          ;; return
    529          

   \                                 In section SOFTPACK, align 4, keep-with-next
    530          struct _dma_channel* dma_allocate_channel(uint8_t src, uint8_t dest)
    531          {
   \                     dma_allocate_channel:
   \        0x0   0xE92D'4F38        PUSH     {R3-R5,R8-R11,LR}
    532          	uint32_t chan, ctrl;
    533          
    534          	/* Reject peripheral to peripheral transfers */
    535          	if (src != DMA_PERIPH_MEMORY && dest != DMA_PERIPH_MEMORY)
   \        0x4   0xE350'00FF        CMP      R0,#+255
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE1A0'4001        MOV      R4,R1
   \       0x10   0x0A00'0001        BEQ      ??dma_allocate_channel_0
   \       0x14   0xE354'00FF        CMP      R4,#+255
   \       0x18   0x1A00'001B        BNE      ??dma_allocate_channel_1
    536          		return NULL;
    537          
    538          	for (ctrl = 0; ctrl < DMA_CONTROLLERS; ctrl++) {
   \                     ??dma_allocate_channel_0:
   \       0x1C   0x....'....        LDR      R8,??DataTable5_3
   \       0x20   0xE3A0'9002        MOV      R9,#+2
    539          		for (chan = 0; chan < DMA_CHANNELS; chan++) {
   \                     ??dma_allocate_channel_2:
   \       0x24   0xE3A0'A000        MOV      R10,#+0
   \       0x28   0xE1A0'B008        MOV      R11,R8
    540          			struct _dma_channel* channel = &_dma_ctrl.controllers[ctrl].channels[chan];
    541          
    542          			if (channel->state == DMA_STATE_FREE) {
   \                     ??dma_allocate_channel_3:
   \       0x2C   0xE5DB'0014        LDRB     R0,[R11, #+20]
   \       0x30   0xE350'0000        CMP      R0,#+0
   \       0x34   0x1A00'000D        BNE      ??dma_allocate_channel_4
    543          				/* Check if source peripheral matches this channel controller */
    544          				if (src != DMA_PERIPH_MEMORY)
   \       0x38   0xE1A0'0005        MOV      R0,R5
   \       0x3C   0xE350'00FF        CMP      R0,#+255
   \       0x40   0x0A00'0003        BEQ      ??dma_allocate_channel_5
    545          					if (!is_peripheral_on_dma_controller(src, channel->hw))
   \       0x44   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0x48   0x....'....        BL       is_peripheral_on_dma_controller
   \       0x4C   0xE350'0000        CMP      R0,#+0
   \       0x50   0x0A00'0006        BEQ      ??dma_allocate_channel_4
    546          						continue;
    547          
    548          				/* Check if destination peripheral matches this channel controller */
    549          				if (dest != DMA_PERIPH_MEMORY)
   \                     ??dma_allocate_channel_5:
   \       0x54   0xE1A0'0004        MOV      R0,R4
   \       0x58   0xE350'00FF        CMP      R0,#+255
   \       0x5C   0x0A00'000C        BEQ      ??dma_allocate_channel_6
    550          					if (!is_peripheral_on_dma_controller(dest, channel->hw))
   \       0x60   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0x64   0x....'....        BL       is_peripheral_on_dma_controller
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x1A00'0008        BNE      ??dma_allocate_channel_6
   \                     ??dma_allocate_channel_4:
   \       0x70   0xE28A'A001        ADD      R10,R10,#+1
   \       0x74   0xE28B'B01C        ADD      R11,R11,#+28
   \       0x78   0xE35A'0010        CMP      R10,#+16
   \       0x7C   0x3AFF'FFEA        BCC      ??dma_allocate_channel_3
   \       0x80   0xE259'9001        SUBS     R9,R9,#+1
   \       0x84   0xE288'8F72        ADD      R8,R8,#+456
   \       0x88   0x1AFF'FFE5        BNE      ??dma_allocate_channel_2
    551          						continue;
    552          
    553          				/* Allocate the channel */
    554          				channel->state = DMA_STATE_ALLOCATED;
    555          				channel->src_txif = get_peripheral_dma_channel(src, channel->hw, true);
    556          				channel->src_rxif = get_peripheral_dma_channel(src, channel->hw, false);
    557          				channel->dest_txif = get_peripheral_dma_channel(dest, channel->hw, true);
    558          				channel->dest_rxif = get_peripheral_dma_channel(dest, channel->hw, false);
    559          				dma_prepare_channel(channel);
    560          
    561          				channel->sg_list = NULL;
    562          
    563          				return channel;
    564          			}
    565          		}
    566          	}
    567          	return NULL;
   \                     ??dma_allocate_channel_1:
   \       0x8C   0xE3A0'0000        MOV      R0,#+0
   \       0x90   0xE8BD'8F32        POP      {R1,R4,R5,R8-R11,PC}  ;; return
   \                     ??dma_allocate_channel_6:
   \       0x94   0xE3A0'0001        MOV      R0,#+1
   \       0x98   0xE3A0'2001        MOV      R2,#+1
   \       0x9C   0xE5CB'0014        STRB     R0,[R11, #+20]
   \       0xA0   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0xA4   0xE1A0'0005        MOV      R0,R5
   \       0xA8   0x....'....        BL       get_peripheral_dma_channel
   \       0xAC   0xE5CB'0010        STRB     R0,[R11, #+16]
   \       0xB0   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0xB4   0xE3A0'2000        MOV      R2,#+0
   \       0xB8   0xE1A0'0005        MOV      R0,R5
   \       0xBC   0x....'....        BL       get_peripheral_dma_channel
   \       0xC0   0xE5CB'0011        STRB     R0,[R11, #+17]
   \       0xC4   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0xC8   0xE3A0'2001        MOV      R2,#+1
   \       0xCC   0xE1A0'0004        MOV      R0,R4
   \       0xD0   0x....'....        BL       get_peripheral_dma_channel
   \       0xD4   0xE5CB'0012        STRB     R0,[R11, #+18]
   \       0xD8   0xE59B'1000        LDR      R1,[R11, #+0]
   \       0xDC   0xE3A0'2000        MOV      R2,#+0
   \       0xE0   0xE1A0'0004        MOV      R0,R4
   \       0xE4   0x....'....        BL       get_peripheral_dma_channel
   \       0xE8   0xE5CB'0013        STRB     R0,[R11, #+19]
   \       0xEC   0xE1A0'000B        MOV      R0,R11
   \       0xF0   0x....'....        BL       dma_prepare_channel
   \       0xF4   0xE3A0'0000        MOV      R0,#+0
   \       0xF8   0xE58B'0018        STR      R0,[R11, #+24]
   \       0xFC   0xE1A0'000B        MOV      R0,R11
   \      0x100   0xE8BD'8F32        POP      {R1,R4,R5,R8-R11,PC}
    568          }
    569          

   \                                 In section SOFTPACK, align 4, keep-with-next
    570          int dma_reset_channel(struct _dma_channel* channel)
    571          {
   \                     dma_reset_channel:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    572          	if (channel->state == DMA_STATE_ALLOCATED)
   \        0x8   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \        0xC   0xE350'0001        CMP      R0,#+1
   \       0x10   0x1A00'0000        BNE      ??dma_reset_channel_0
    573          		return 0;
   \       0x14   0x....'....        B        ??Subroutine0_0
    574          
    575          	if (channel->state == DMA_STATE_STARTED)
   \                     ??dma_reset_channel_0:
   \       0x18   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \       0x1C   0xE350'0002        CMP      R0,#+2
   \       0x20   0x1A00'0000        BNE      ??dma_reset_channel_1
    576          		return -EBUSY;
   \       0x24   0x....'....        B        ?Subroutine1
    577          
    578          #if defined(CONFIG_HAVE_XDMAC)
    579          	/* Disable interrupts */
    580          	xdmac_disable_channel_it(channel->hw, channel->id, -1);
   \                     ??dma_reset_channel_1:
   \       0x28   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x2C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x30   0xE3E0'2000        MVN      R2,#+0
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0x....'....        BL       xdmac_disable_channel_it
    581          
    582          	/* Disable channel */
    583          	xdmac_disable_channel(channel->hw, channel->id);
   \       0x3C   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x40   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x44   0xE6EF'1071        UXTB     R1,R1
   \       0x48   0x....'....        BL       xdmac_disable_channel
    584          #elif defined(CONFIG_HAVE_DMAC)
    585          	/* Disable interrupts */
    586          	dmac_disable_global_it(channel->hw, (DMAC_EBCIDR_CBTC0 | DMAC_EBCIER_BTC0 | DMAC_EBCIER_ERR0) << channel->id);
    587          
    588          	/* Disable channel */
    589          	dmac_disable_channel(channel->hw, channel->id);
    590          #endif
    591          
    592          	_dma_sg_desc_free(channel->sg_list);
   \       0x4C   0xE594'0018        LDR      R0,[R4, #+24]
   \       0x50   0x....'....        BL       _dma_sg_desc_free
    593          	channel->sg_list = NULL;
   \       0x54   0xE3A0'0000        MOV      R0,#+0
    594          
    595          	/* Change state to 'allocated' */
    596          	channel->state = DMA_STATE_ALLOCATED;
   \       0x58   0xE3A0'1001        MOV      R1,#+1
   \       0x5C   0xE584'0018        STR      R0,[R4, #+24]
   \       0x60   0xE5C4'1014        STRB     R1,[R4, #+20]
    597          
    598          	return 0;
   \       0x64   0xE8BD'8010        POP      {R4,PC}          ;; return
    599          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE3E0'0009        MVN      R0,#+9
   \        0x4   0xE8BD'8010        POP      {R4,PC}

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE5C4'0014        STRB     R0,[R4, #+20]
   \                     ??Subroutine0_0:
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0xE8BD'8010        POP      {R4,PC}          ;; return
    600          

   \                                 In section SOFTPACK, align 4, keep-with-next
    601          int dma_free_channel(struct _dma_channel* channel)
    602          {
   \                     dma_free_channel:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    603          	switch (channel->state) {
   \        0x8   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \        0xC   0xE350'0001        CMP      R0,#+1
   \       0x10   0x0A00'0005        BEQ      ??dma_free_channel_0
   \       0x14   0x3A00'0009        BCC      ??dma_free_channel_1
   \       0x18   0xE350'0003        CMP      R0,#+3
   \       0x1C   0x0A00'0002        BEQ      ??dma_free_channel_0
   \       0x20   0x2A00'0006        BCS      ??dma_free_channel_1
    604          	case DMA_STATE_STARTED:
    605          		return -EBUSY;
   \       0x24   0xE3E0'0009        MVN      R0,#+9
   \       0x28   0xE8BD'8032        POP      {R1,R4,R5,PC}
    606          	case DMA_STATE_ALLOCATED:
    607          	case DMA_STATE_DONE:
    608          		channel->state = DMA_STATE_FREE;
   \                     ??dma_free_channel_0:
   \       0x2C   0xE3A0'5000        MOV      R5,#+0
   \       0x30   0xE5C4'5014        STRB     R5,[R4, #+20]
    609          		_dma_sg_desc_free(channel->sg_list);
   \       0x34   0xE594'0018        LDR      R0,[R4, #+24]
   \       0x38   0x....'....        BL       _dma_sg_desc_free
    610          		channel->sg_list = NULL;
   \       0x3C   0xE584'5018        STR      R5,[R4, #+24]
    611          		break;
    612          	}
    613          	return 0;
   \                     ??dma_free_channel_1:
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \       0x44   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    614          }
    615          

   \                                 In section SOFTPACK, align 4, keep-with-next
    616          int dma_start_transfer(struct _dma_channel* channel)
    617          {
   \                     dma_start_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    618          	if (channel->state == DMA_STATE_FREE)
   \        0x8   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'0001        BNE      ??dma_start_transfer_0
    619          		return -EPERM;
   \       0x14   0xE3E0'0042        MVN      R0,#+66
   \       0x18   0xE8BD'8010        POP      {R4,PC}
    620          	else if (channel->state == DMA_STATE_STARTED)
   \                     ??dma_start_transfer_0:
   \       0x1C   0xE5D4'0014        LDRB     R0,[R4, #+20]
   \       0x20   0xE350'0002        CMP      R0,#+2
   \       0x24   0x1A00'0000        BNE      ??dma_start_transfer_1
    621          		return -EBUSY;
   \       0x28   0x....'....        B        ?Subroutine1
    622          
    623          	/* Change state to 'started' */
    624          	channel->state = DMA_STATE_STARTED;
   \                     ??dma_start_transfer_1:
   \       0x2C   0xE3A0'1002        MOV      R1,#+2
    625          
    626          	/* Start DMA transfer */
    627          	if (!_dma_ctrl.polling) {
   \       0x30   0x....'....        LDR      R0,??DataTable5_1
   \       0x34   0xE5C4'1014        STRB     R1,[R4, #+20]
   \       0x38   0xE5D0'2390        LDRB     R2,[R0, #+912]
   \       0x3C   0xE352'0000        CMP      R2,#+0
   \       0x40   0x1A00'0004        BNE      ??dma_start_transfer_2
    628          #if defined(CONFIG_HAVE_XDMAC)
    629          		xdmac_enable_global_it(channel->hw, 1 << channel->id);
   \       0x44   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x48   0xE3A0'3001        MOV      R3,#+1
   \       0x4C   0xE1A0'1013        LSL      R1,R3,R0
   \       0x50   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x54   0x....'....        BL       xdmac_enable_global_it
    630          #elif defined(CONFIG_HAVE_DMAC)
    631          		dmac_enable_global_it(channel->hw, (DMAC_EBCIDR_CBTC0 | DMAC_EBCIER_BTC0 | DMAC_EBCIER_ERR0) << channel->id);
    632          #endif
    633          	}
    634          #if defined(CONFIG_HAVE_XDMAC)
    635          	xdmac_enable_channel(channel->hw, channel->id);
   \                     ??dma_start_transfer_2:
   \       0x58   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x5C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x60   0xE6EF'1071        UXTB     R1,R1
   \       0x64   0x....'....        BL       xdmac_enable_channel
    636          #elif defined(CONFIG_HAVE_DMAC)
    637          	dmac_enable_channel(channel->hw, channel->id);
    638          #endif
    639          	return 0;
   \       0x68   0x....'....        B        ??Subroutine0_0
    640          }
    641          

   \                                 In section SOFTPACK, align 4, keep-with-next
    642          int dma_stop_transfer(struct _dma_channel* channel)
    643          {
   \                     dma_stop_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    644          #if defined(CONFIG_HAVE_XDMAC)
    645          	/* Disable channel */
    646          	xdmac_disable_channel(channel->hw, channel->id);
   \        0x8   0xE594'1004        LDR      R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0xE6EF'1071        UXTB     R1,R1
   \       0x14   0x....'....        BL       xdmac_disable_channel
    647          	/* Disable interrupts */
    648          	xdmac_disable_channel_it(channel->hw, channel->id, -1);
   \       0x18   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x1C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x20   0xE3E0'2000        MVN      R2,#+0
   \       0x24   0xE6EF'1071        UXTB     R1,R1
   \       0x28   0x....'....        BL       xdmac_disable_channel_it
    649          	/* Clear pending status */
    650          	xdmac_get_channel_isr(channel->hw, channel->id);
   \       0x2C   0xE594'1004        LDR      R1,[R4, #+4]
   \       0x30   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x34   0xE6EF'1071        UXTB     R1,R1
   \       0x38   0x....'....        BL       xdmac_get_channel_isr
    651          	xdmac_get_global_channel_status(channel->hw);
   \       0x3C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x40   0x....'....        BL       xdmac_get_global_channel_status
    652          #elif defined(CONFIG_HAVE_DMAC)
    653          	/* Disable channel */
    654          	dmac_disable_channel(channel->hw, channel->id);
    655          	/* Clear pending status */
    656          	dmac_get_global_isr(channel->hw);
    657          #endif
    658          
    659          	/* Change state to 'allocated' */
    660          	channel->state = DMA_STATE_ALLOCATED;
   \       0x44   0xE3A0'0001        MOV      R0,#+1
   \       0x48   0x....'....        B        ?Subroutine0
    661          
    662          	return 0;
    663          }
    664          

   \                                 In section SOFTPACK, align 4, keep-with-next
    665          int dma_suspend_transfer(struct _dma_channel* channel)
    666          {
   \                     dma_suspend_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    667          	/* Suspend channel */
    668          #if defined(CONFIG_HAVE_XDMAC)
    669          	xdmac_suspend_channel(channel->hw, channel->id);
   \        0x8   0xE594'1004        LDR      R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0xE6EF'1071        UXTB     R1,R1
   \       0x14   0x....'....        BL       xdmac_suspend_channel
    670          #elif defined(CONFIG_HAVE_DMAC)
    671          	dmac_suspend_channel(channel->hw, channel->id);
    672          #endif
    673          	/* Change state to 'suspended' */
    674          	channel->state = DMA_STATE_SUSPENDED;
   \       0x18   0xE3A0'0004        MOV      R0,#+4
   \       0x1C                      REQUIRE ?Subroutine0
   \       0x1C                      ;; // Fall through to label ?Subroutine0
    675          
    676          	return 0;
    677          }
    678          

   \                                 In section SOFTPACK, align 4, keep-with-next
    679          int dma_resume_transfer(struct _dma_channel* channel)
    680          {
   \                     dma_resume_transfer:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
    681          	/* Resume channel */
    682          #if defined(CONFIG_HAVE_XDMAC)
    683          	xdmac_resume_read_write_channel(channel->hw, channel->id);
   \        0x8   0xE594'1004        LDR      R1,[R4, #+4]
   \        0xC   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x10   0xE6EF'1071        UXTB     R1,R1
   \       0x14   0x....'....        BL       xdmac_resume_read_write_channel
    684          #elif defined(CONFIG_HAVE_DMAC)
    685          	dmac_resume_channel(channel->hw, channel->id);
    686          #endif
    687          	/* Change state to 'started */
    688          	channel->state = DMA_STATE_STARTED;
   \       0x18   0xE3A0'0002        MOV      R0,#+2
   \       0x1C   0x....'....        B        ?Subroutine0
    689          
    690          	return 0;
    691          }
    692          

   \                                 In section SOFTPACK, align 4, keep-with-next
    693          void dma_fifo_flush(struct _dma_channel* channel)
    694          {
    695          #if defined(CONFIG_HAVE_XDMAC)
    696          	xdmac_fifo_flush(channel->hw, channel->id);
   \                     dma_fifo_flush:
   \        0x0   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x4   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x8   0xE6EF'1071        UXTB     R1,R1
   \        0xC   0x....'....        B        xdmac_fifo_flush  ;; tailcall
    697          #elif defined(CONFIG_HAVE_DMAC)
    698          	dmac_fifo_flush(channel->hw, channel->id);
    699          #endif
    700          }
    701          

   \                                 In section SOFTPACK, align 4, keep-with-next
    702          int dma_configure_transfer(struct _dma_channel* channel,
    703          			   struct _dma_cfg* cfg_dma,
    704          			   struct _dma_transfer_cfg* list, uint8_t list_size)
    705          {
   \                     dma_configure_transfer:
   \        0x0   0xE92D'4FF0        PUSH     {R4-R11,LR}
   \        0x4   0xE1B0'A003        MOVS     R10,R3
   \        0x8   0xE24D'D024        SUB      SP,SP,#+36
    706          	if (list_size == 0)
   \        0xC   0x0A00'00FB        BEQ      ??dma_configure_transfer_0
    707          		return -EINVAL;
    708          
    709          	if ((list_size == 1) && (!cfg_dma->loop))
   \       0x10   0xE35A'0001        CMP      R10,#+1
   \       0x14   0xE3A0'4000        MOV      R4,#+0
   \       0x18   0xE1A0'5000        MOV      R5,R0
   \       0x1C   0xE1A0'6001        MOV      R6,R1
   \       0x20   0xE1A0'B002        MOV      R11,R2
   \       0x24   0x1A00'006D        BNE      ??dma_configure_transfer_1
   \       0x28   0xE5D6'100A        LDRB     R1,[R6, #+10]
   \       0x2C   0xE351'0000        CMP      R1,#+0
   \       0x30   0x1A00'006A        BNE      ??dma_configure_transfer_1
    710          		return _dma_configure_transfer(channel, cfg_dma, list);
   \       0x34   0xE3A0'1020        MOV      R1,#+32
   \       0x38   0xE28D'0004        ADD      R0,SP,#+4
   \       0x3C   0x....'....        BL       __aeabi_memclr4
   \       0x40   0xE5D5'0010        LDRB     R0,[R5, #+16]
   \       0x44   0xE5D5'1011        LDRB     R1,[R5, #+17]
   \       0x48   0xE3A0'8001        MOV      R8,#+1
   \       0x4C   0xE350'00FF        CMP      R0,#+255
   \       0x50   0xE5D5'0012        LDRB     R0,[R5, #+18]
   \       0x54   0x13A0'7001        MOVNE    R7,#+1
   \       0x58   0x03A0'7000        MOVEQ    R7,#+0
   \       0x5C   0xE351'00FF        CMP      R1,#+255
   \       0x60   0xE5D5'1013        LDRB     R1,[R5, #+19]
   \       0x64   0x13A0'7001        MOVNE    R7,#+1
   \       0x68   0xE350'00FF        CMP      R0,#+255
   \       0x6C   0x13A0'0001        MOVNE    R0,#+1
   \       0x70   0x03A0'0000        MOVEQ    R0,#+0
   \       0x74   0xE351'00FF        CMP      R1,#+255
   \       0x78   0x13A0'0001        MOVNE    R0,#+1
   \       0x7C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x80   0xE59B'9008        LDR      R9,[R11, #+8]
   \       0x84   0xE3E0'04FF        MVN      R0,#-16777216
   \       0x88   0xE159'0000        CMP      R9,R0
   \       0x8C   0x8A00'000A        BHI      ??dma_configure_transfer_2
   \       0x90   0xE58D'9004        STR      R9,[SP, #+4]
   \       0x94   0xE58D'4008        STR      R4,[SP, #+8]
   \                     ??dma_configure_transfer_3:
   \       0x98   0xE59B'0000        LDR      R0,[R11, #+0]
   \       0x9C   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0xA0   0xE58D'0018        STR      R0,[SP, #+24]
   \       0xA4   0xE59B'1004        LDR      R1,[R11, #+4]
   \       0xA8   0xE193'0007        ORRS     R0,R3,R7
   \       0xAC   0x158D'8020        STRNE    R8,[SP, #+32]
   \       0xB0   0xE58D'101C        STR      R1,[SP, #+28]
   \       0xB4   0x058D'4020        STREQ    R4,[SP, #+32]
   \       0xB8   0xEA00'0017        B        ??dma_configure_transfer_4
   \                     ??dma_configure_transfer_2:
   \       0xBC   0xE1A0'A000        MOV      R10,R0
   \                     ??dma_configure_transfer_5:
   \       0xC0   0xE1A0'0009        MOV      R0,R9
   \       0xC4   0xE1A0'100A        MOV      R1,R10
   \       0xC8   0x....'....        BL       __aeabi_uidivmod
   \       0xCC   0xE351'0000        CMP      R1,#+0
   \       0xD0   0x1A00'0004        BNE      ??dma_configure_transfer_6
   \       0xD4   0xE1A0'0009        MOV      R0,R9
   \       0xD8   0xE1A0'100A        MOV      R1,R10
   \       0xDC   0x....'....        BL       __aeabi_uidiv
   \       0xE0   0xE350'0D40        CMP      R0,#+4096
   \       0xE4   0x3A00'0005        BCC      ??dma_configure_transfer_7
   \                     ??dma_configure_transfer_6:
   \       0xE8   0xE24A'A001        SUB      R10,R10,#+1
   \       0xEC   0xE35A'0001        CMP      R10,#+1
   \       0xF0   0x8AFF'FFF2        BHI      ??dma_configure_transfer_5
   \                     ??dma_configure_transfer_8:
   \       0xF4   0xE35A'0001        CMP      R10,#+1
   \       0xF8   0x1AFF'FFE6        BNE      ??dma_configure_transfer_3
   \       0xFC   0xEA00'00BF        B        ??dma_configure_transfer_0
   \                     ??dma_configure_transfer_7:
   \      0x100   0xE58D'A004        STR      R10,[SP, #+4]
   \      0x104   0xE59B'0008        LDR      R0,[R11, #+8]
   \      0x108   0xE1A0'100A        MOV      R1,R10
   \      0x10C   0x....'....        BL       __aeabi_uidiv
   \      0x110   0xE240'1001        SUB      R1,R0,#+1
   \      0x114   0xE58D'1008        STR      R1,[SP, #+8]
   \      0x118   0xEAFF'FFF5        B        ??dma_configure_transfer_8
   \                     ??dma_configure_transfer_4:
   \      0x11C   0xE59D'3020        LDR      R3,[SP, #+32]
   \      0x120   0xE357'0000        CMP      R7,#+0
   \      0x124   0xE59D'C000        LDR      R12,[SP, #+0]
   \      0x128   0x11A0'1004        MOVNE    R1,R4
   \      0x12C   0x03A0'1010        MOVEQ    R1,#+16
   \      0x130   0xE181'1003        ORR      R1,R1,R3
   \      0x134   0xE3A0'3E70        MOV      R3,#+1792
   \      0x138   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x13C   0xE596'2004        LDR      R2,[R6, #+4]
   \      0x140   0xE003'3402        AND      R3,R3,R2, LSL #+8
   \      0x144   0xE3A0'2D60        MOV      R2,#+6144
   \      0x148   0xE183'1001        ORR      R1,R3,R1
   \      0x14C   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x150   0xE596'E000        LDR      LR,[R6, #+0]
   \      0x154   0xE002'258E        AND      R2,R2,LR, LSL #+11
   \      0x158   0xE182'1001        ORR      R1,R2,R1
   \      0x15C   0x13A0'2D80        MOVNE    R2,#+8192
   \      0x160   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x164   0x03A0'2000        MOVEQ    R2,#+0
   \      0x168   0xE35C'0000        CMP      R12,#+0
   \      0x16C   0xE182'1001        ORR      R1,R2,R1
   \      0x170   0x13A0'2C40        MOVNE    R2,#+16384
   \      0x174   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x178   0x03A0'2000        MOVEQ    R2,#+0
   \      0x17C   0xE182'1001        ORR      R1,R2,R1
   \      0x180   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x184   0xE5D6'3008        LDRB     R3,[R6, #+8]
   \      0x188   0xE353'0000        CMP      R3,#+0
   \      0x18C   0x13A0'2B40        MOVNE    R2,#+65536
   \      0x190   0x03A0'2000        MOVEQ    R2,#+0
   \      0x194   0xE182'1001        ORR      R1,R2,R1
   \      0x198   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x19C   0xE5D6'3009        LDRB     R3,[R6, #+9]
   \      0x1A0   0xE58D'400C        STR      R4,[SP, #+12]
   \      0x1A4   0xE58D'4010        STR      R4,[SP, #+16]
   \      0x1A8   0xE58D'4014        STR      R4,[SP, #+20]
   \      0x1AC   0xE353'0000        CMP      R3,#+0
   \      0x1B0   0xE3A0'3000        MOV      R3,#+0
   \      0x1B4   0x13A0'2A40        MOVNE    R2,#+262144
   \      0x1B8   0x03A0'2000        MOVEQ    R2,#+0
   \      0x1BC   0xE350'0000        CMP      R0,#+0
   \      0x1C0   0xE182'1001        ORR      R1,R2,R1
   \      0x1C4   0x13A0'0000        MOVNE    R0,#+0
   \      0x1C8   0x03A0'0040        MOVEQ    R0,#+64
   \      0x1CC   0xE58D'1020        STR      R1,[SP, #+32]
   \      0x1D0   0xE180'0001        ORR      R0,R0,R1
   \      0x1D4   0xE3A0'2000        MOV      R2,#+0
   \      0x1D8   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x1DC   0xEA00'0083        B        ??dma_configure_transfer_9
    711          	else
    712          		return _dma_sg_configure_transfer(channel, cfg_dma, list, list_size);
   \                     ??dma_configure_transfer_1:
   \      0x1E0   0xE35B'0000        CMP      R11,#+0
   \      0x1E4   0x0A00'0085        BEQ      ??dma_configure_transfer_0
   \      0x1E8   0xE300'9408        MOVW     R9,#+1032
   \      0x1EC   0x....'....        LDR      R7,??DataTable5
   \      0x1F0   0xE197'00B9        LDRH     R0,[R7, +R9]
   \      0x1F4   0xE150'000A        CMP      R0,R10
   \      0x1F8   0x3A00'0019        BCC      ??dma_configure_transfer_10
   \      0x1FC   0xE389'2004        ORR      R2,R9,#0x4
   \      0x200   0xE087'0002        ADD      R0,R7,R2
   \      0x204   0x....'....        BL       mutex_lock
   \      0x208   0xE597'0400        LDR      R0,[R7, #+1024]
   \      0x20C   0xE25A'1001        SUBS     R1,R10,#+1
   \      0x210   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x214   0xDA00'0002        BLE      ??dma_configure_transfer_11
   \                     ??dma_configure_transfer_12:
   \      0x218   0xE251'1001        SUBS     R1,R1,#+1
   \      0x21C   0xE590'0000        LDR      R0,[R0, #+0]
   \      0x220   0x1AFF'FFFC        BNE      ??dma_configure_transfer_12
   \                     ??dma_configure_transfer_11:
   \      0x224   0xE590'1000        LDR      R1,[R0, #+0]
   \      0x228   0xE580'4000        STR      R4,[R0, #+0]
   \      0x22C   0xE197'00B9        LDRH     R0,[R7, +R9]
   \      0x230   0xE587'1400        STR      R1,[R7, #+1024]
   \      0x234   0xE040'000A        SUB      R0,R0,R10
   \      0x238   0xE187'00B9        STRH     R0,[R7, +R9]
   \      0x23C   0xE6FF'0070        UXTH     R0,R0
   \      0x240   0xE350'0000        CMP      R0,#+0
   \      0x244   0xE389'0004        ORR      R0,R9,#0x4
   \      0x248   0x0587'4400        STREQ    R4,[R7, #+1024]
   \      0x24C   0x0587'4404        STREQ    R4,[R7, #+1028]
   \      0x250   0xE087'0000        ADD      R0,R7,R0
   \      0x254   0x....'....        BL       mutex_unlock
   \      0x258   0xE59D'0000        LDR      R0,[SP, #+0]
   \      0x25C   0xE350'0000        CMP      R0,#+0
   \      0x260   0x1A00'0001        BNE      ??dma_configure_transfer_13
   \                     ??dma_configure_transfer_10:
   \      0x264   0xE3E0'0030        MVN      R0,#+48
   \      0x268   0x....'....        B        ?Subroutine2
   \                     ??dma_configure_transfer_13:
   \      0x26C   0xE5D5'2010        LDRB     R2,[R5, #+16]
   \      0x270   0xE5D5'3013        LDRB     R3,[R5, #+19]
   \      0x274   0xE1A0'1000        MOV      R1,R0
   \      0x278   0xE352'00FF        CMP      R2,#+255
   \      0x27C   0xE5D5'2011        LDRB     R2,[R5, #+17]
   \      0x280   0x13A0'9001        MOVNE    R9,#+1
   \      0x284   0x03A0'9000        MOVEQ    R9,#+0
   \      0x288   0xE352'00FF        CMP      R2,#+255
   \      0x28C   0xE5D5'2012        LDRB     R2,[R5, #+18]
   \      0x290   0x13A0'9001        MOVNE    R9,#+1
   \      0x294   0xE352'00FF        CMP      R2,#+255
   \      0x298   0x13A0'2001        MOVNE    R2,#+1
   \      0x29C   0x03A0'2000        MOVEQ    R2,#+0
   \      0x2A0   0xE353'00FF        CMP      R3,#+255
   \      0x2A4   0x13A0'2001        MOVNE    R2,#+1
   \      0x2A8   0xE58D'2000        STR      R2,[SP, #+0]
   \                     ??dma_configure_transfer_14:
   \      0x2AC   0xE59B'2000        LDR      R2,[R11, #+0]
   \      0x2B0   0xE581'2008        STR      R2,[R1, #+8]
   \      0x2B4   0xE59B'3004        LDR      R3,[R11, #+4]
   \      0x2B8   0xE581'300C        STR      R3,[R1, #+12]
   \      0x2BC   0xE59B'2008        LDR      R2,[R11, #+8]
   \      0x2C0   0xE3C2'C4FF        BIC      R12,R2,#0xFF000000
   \      0x2C4   0xE38C'26F0        ORR      R2,R12,#0xF000000
   \      0x2C8   0xE581'2004        STR      R2,[R1, #+4]
   \      0x2CC   0xE5D6'E00A        LDRB     LR,[R6, #+10]
   \      0x2D0   0xE591'3000        LDR      R3,[R1, #+0]
   \      0x2D4   0xE35E'0000        CMP      LR,#+0
   \      0x2D8   0x1A00'0004        BNE      ??dma_configure_transfer_15
   \      0x2DC   0xE353'0000        CMP      R3,#+0
   \      0x2E0   0x1A00'0004        BNE      ??dma_configure_transfer_16
   \      0x2E4   0xE3C2'2740        BIC      R2,R2,#0x1000000
   \      0x2E8   0xE581'2004        STR      R2,[R1, #+4]
   \      0x2EC   0xEA00'0001        B        ??dma_configure_transfer_16
   \                     ??dma_configure_transfer_15:
   \      0x2F0   0xE353'0000        CMP      R3,#+0
   \      0x2F4   0x0581'0000        STREQ    R0,[R1, #+0]
   \                     ??dma_configure_transfer_16:
   \      0x2F8   0xE25A'A001        SUBS     R10,R10,#+1
   \      0x2FC   0xE591'1000        LDR      R1,[R1, #+0]
   \      0x300   0xE28B'B00C        ADD      R11,R11,#+12
   \      0x304   0x1AFF'FFE8        BNE      ??dma_configure_transfer_14
   \      0x308   0xE1A0'A000        MOV      R10,R0
   \      0x30C   0xE3A0'1E40        MOV      R1,#+1024
   \      0x310   0xE585'A018        STR      R10,[R5, #+24]
   \      0x314   0xE1A0'0007        MOV      R0,R7
   \      0x318   0x....'....        BL       cache_clean_region
   \      0x31C   0xE59D'2000        LDR      R2,[SP, #+0]
   \      0x320   0xE359'0000        CMP      R9,#+0
   \      0x324   0xE3A0'3E70        MOV      R3,#+1792
   \      0x328   0x11A0'1004        MOVNE    R1,R4
   \      0x32C   0xE182'0009        ORR      R0,R2,R9
   \      0x330   0x03A0'1010        MOVEQ    R1,#+16
   \      0x334   0xE6EF'0070        UXTB     R0,R0
   \      0x338   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x33C   0xE181'0000        ORR      R0,R1,R0
   \      0x340   0x13A0'1D80        MOVNE    R1,#+8192
   \      0x344   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x348   0xE596'2004        LDR      R2,[R6, #+4]
   \      0x34C   0x03A0'1000        MOVEQ    R1,#+0
   \      0x350   0xE003'3402        AND      R3,R3,R2, LSL #+8
   \      0x354   0xE3A0'2D60        MOV      R2,#+6144
   \      0x358   0xE183'0000        ORR      R0,R3,R0
   \      0x35C   0xE59D'3000        LDR      R3,[SP, #+0]
   \      0x360   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x364   0xE596'C000        LDR      R12,[R6, #+0]
   \      0x368   0xE353'0000        CMP      R3,#+0
   \      0x36C   0xE59D'3000        LDR      R3,[SP, #+0]
   \      0x370   0xE002'258C        AND      R2,R2,R12, LSL #+11
   \      0x374   0xE182'0000        ORR      R0,R2,R0
   \      0x378   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x37C   0xE181'0000        ORR      R0,R1,R0
   \      0x380   0x13A0'1C40        MOVNE    R1,#+16384
   \      0x384   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x388   0x03A0'1000        MOVEQ    R1,#+0
   \      0x38C   0xE181'0000        ORR      R0,R1,R0
   \      0x390   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x394   0xE5D6'2008        LDRB     R2,[R6, #+8]
   \      0x398   0xE352'0000        CMP      R2,#+0
   \      0x39C   0x13A0'1B40        MOVNE    R1,#+65536
   \      0x3A0   0x03A0'1000        MOVEQ    R1,#+0
   \      0x3A4   0xE181'0000        ORR      R0,R1,R0
   \      0x3A8   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x3AC   0xE5D6'2009        LDRB     R2,[R6, #+9]
   \      0x3B0   0xE58D'4008        STR      R4,[SP, #+8]
   \      0x3B4   0xE58D'400C        STR      R4,[SP, #+12]
   \      0x3B8   0xE58D'4010        STR      R4,[SP, #+16]
   \      0x3BC   0xE352'0000        CMP      R2,#+0
   \      0x3C0   0xE58D'4014        STR      R4,[SP, #+20]
   \      0x3C4   0x13A0'1A40        MOVNE    R1,#+262144
   \      0x3C8   0xE3A0'200F        MOV      R2,#+15
   \      0x3CC   0x03A0'1000        MOVEQ    R1,#+0
   \      0x3D0   0xE193'3009        ORRS     R3,R3,R9
   \      0x3D4   0xE181'0000        ORR      R0,R1,R0
   \      0x3D8   0x13A0'1000        MOVNE    R1,#+0
   \      0x3DC   0xE58D'0020        STR      R0,[SP, #+32]
   \      0x3E0   0x03A0'1040        MOVEQ    R1,#+64
   \      0x3E4   0xE1A0'300A        MOV      R3,R10
   \      0x3E8   0xE181'0000        ORR      R0,R1,R0
   \      0x3EC   0xE58D'0020        STR      R0,[SP, #+32]
   \                     ??dma_configure_transfer_9:
   \      0x3F0   0xE28D'1004        ADD      R1,SP,#+4
   \      0x3F4   0xE1A0'0005        MOV      R0,R5
   \      0x3F8   0x....'....        BL       xdmacd_configure_transfer
   \      0x3FC   0x....'....        B        ?Subroutine2
   \                     ??dma_configure_transfer_0:
   \      0x400   0xE3E0'001B        MVN      R0,#+27
   \      0x404                      REQUIRE ?Subroutine2
   \      0x404                      ;; // Fall through to label ?Subroutine2
    713          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE28D'D024        ADD      SP,SP,#+36
   \        0x4   0xE8BD'8FF0        POP      {R4-R11,PC}      ;; return
    714          

   \                                 In section SOFTPACK, align 4, keep-with-next
    715          uint32_t dma_get_transferred_data_len(struct _dma_channel* channel, uint8_t chunk_size, uint32_t len)
    716          {
   \                     dma_get_transferred_data_len:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4001        MOV      R4,R1
    717          #if defined(CONFIG_HAVE_XDMAC)
    718          	return len - xdmac_get_microblock_control(channel->hw, channel->id) * (1 << chunk_size);
   \        0x8   0xE590'1004        LDR      R1,[R0, #+4]
   \        0xC   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x10   0xE1A0'5002        MOV      R5,R2
   \       0x14   0xE6EF'1071        UXTB     R1,R1
   \       0x18   0x....'....        BL       xdmac_get_microblock_control
   \       0x1C   0xE3A0'1001        MOV      R1,#+1
   \       0x20   0xE1A0'1411        LSL      R1,R1,R4
   \       0x24   0xE000'0091        MUL      R0,R1,R0
   \       0x28   0xE045'0000        SUB      R0,R5,R0
   \       0x2C   0xE8BD'8032        POP      {R1,R4,R5,PC}    ;; return
    719          #elif defined(CONFIG_HAVE_DMAC)
    720          	return dmac_get_btsize(channel->hw, channel->id) * (1 << chunk_size);
    721          #endif
    722          }
    723          

   \                                 In section SOFTPACK, align 4, keep-with-next
    724          int dma_set_callback(struct _dma_channel* channel, struct _callback* cb)
    725          {
   \                     dma_set_callback:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    726          	if (channel->state == DMA_STATE_FREE)
   \        0x4   0xE5D0'2014        LDRB     R2,[R0, #+20]
   \        0x8   0xE352'0000        CMP      R2,#+0
   \        0xC   0x1A00'0001        BNE      ??dma_set_callback_0
    727          		return -EPERM;
   \       0x10   0xE3E0'0042        MVN      R0,#+66
   \       0x14   0xE8BD'8002        POP      {R1,PC}
    728          	else if (channel->state == DMA_STATE_STARTED)
   \                     ??dma_set_callback_0:
   \       0x18   0xE5D0'2014        LDRB     R2,[R0, #+20]
   \       0x1C   0xE352'0002        CMP      R2,#+2
   \       0x20   0x1A00'0001        BNE      ??dma_set_callback_1
    729          		return -EBUSY;
   \       0x24   0xE3E0'0009        MVN      R0,#+9
   \       0x28   0xE8BD'8002        POP      {R1,PC}
    730          
    731          	callback_copy(&channel->callback, cb);
   \                     ??dma_set_callback_1:
   \       0x2C   0xE280'0008        ADD      R0,R0,#+8
   \       0x30   0x....'....        BL       callback_copy
    732          
    733          	return 0;
   \       0x34   0xE3A0'0000        MOV      R0,#+0
   \       0x38   0xE8BD'8002        POP      {R1,PC}          ;; return
    734          }
    735          

   \                                 In section SOFTPACK, align 4, keep-with-next
    736          bool dma_is_transfer_done(struct _dma_channel* channel)
    737          {
    738          	return ((channel->state != DMA_STATE_STARTED)
    739          		&& (channel->state != DMA_STATE_SUSPENDED));
   \                     dma_is_transfer_done:
   \        0x0   0xE5D0'1014        LDRB     R1,[R0, #+20]
   \        0x4   0xE351'0002        CMP      R1,#+2
   \        0x8   0x0A00'0004        BEQ      ??dma_is_transfer_done_0
   \        0xC   0xE5D0'0014        LDRB     R0,[R0, #+20]
   \       0x10   0xE350'0004        CMP      R0,#+4
   \       0x14   0x0A00'0001        BEQ      ??dma_is_transfer_done_0
   \       0x18   0xE3A0'0001        MOV      R0,#+1
   \       0x1C   0xE12F'FF1E        BX       LR
   \                     ??dma_is_transfer_done_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    740          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     _dma_sg_pool

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     _dma_ctrl

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     dma_irq_handler

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     _dma_ctrl+0x8
    741          
    742          /**@}*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _dma_sg_desc_free
        16   -> mutex_lock
         0   -> mutex_unlock
      32   dma_allocate_channel
        32   -> dma_prepare_channel
        32   -> get_peripheral_dma_channel
        32   -> is_peripheral_on_dma_controller
      72   dma_configure_transfer
        72   -> __aeabi_memclr4
        72   -> cache_clean_region
        72   -> mutex_lock
        72   -> mutex_unlock
        72   -> xdmacd_configure_transfer
        72 __aeabi_uidiv
        72 __aeabi_uidivmod
       0   dma_fifo_flush
         0   -> xdmac_fifo_flush
      16   dma_free_channel
        16   -> _dma_sg_desc_free
      16   dma_get_transferred_data_len
        16   -> xdmac_get_microblock_control
      40   dma_initialize
        40   -> __aeabi_memclr4
        40   -> callback_set
        40   -> get_xdmac_addr_from_id
        40   -> irq_add_handler
        40   -> irq_enable
        40   -> mutex_lock
        40   -> mutex_unlock
        40   -> xdmac_get_channel_isr
       0   dma_is_transfer_done
       8   dma_poll
         0   -> dma_irq_handler
         8   -> dma_irq_handler
       8   dma_reset_channel
         8   -> _dma_sg_desc_free
         8   -> xdmac_disable_channel
         8   -> xdmac_disable_channel_it
       8   dma_resume_transfer
         8   -> xdmac_resume_read_write_channel
       8   dma_set_callback
         8   -> callback_copy
       8   dma_start_transfer
         8   -> xdmac_enable_channel
         8   -> xdmac_enable_global_it
       8   dma_stop_transfer
         8   -> xdmac_disable_channel
         8   -> xdmac_disable_channel_it
         8   -> xdmac_get_channel_isr
         8   -> xdmac_get_global_channel_status
       8   dma_suspend_transfer
         8   -> xdmac_suspend_channel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
      12  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
     924  _dma_ctrl
          controllers
     104  _dma_sg_desc_free
   1'040  _dma_sg_pool
     260  dma_allocate_channel
   1'028  dma_configure_transfer
      16  dma_fifo_flush
      72  dma_free_channel
      48  dma_get_transferred_data_len
     316  dma_initialize
      40  dma_is_transfer_done
      52  dma_poll
     104  dma_reset_channel
      32  dma_resume_transfer
      60  dma_set_callback
     108  dma_start_transfer
      76  dma_stop_transfer
      28  dma_suspend_transfer

 
   924 bytes in section .data
 1'040 bytes in section .region_cache_aligned
 2'388 bytes in section SOFTPACK
 
 2'388 bytes of CODE memory
 1'964 bytes of DATA memory

Errors: none
Warnings: none
