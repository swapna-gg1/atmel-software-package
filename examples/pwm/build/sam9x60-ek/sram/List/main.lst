###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         26/May/2020  11:35:29
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\main.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW9E2C.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\main.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sam9x60-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sam9x60-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sam9x60-ek\sram\Obj
#        --debug --endian=little --cpu=ARM926EJ-S -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sam9x60-ek\sram\List\main.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\build\sam9x60-ek\sram\Obj\main.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  flags,int_specials,qualifiers,widths
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\pwm\main.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \page pwm PWM Example
     32           *
     33           * \section Purpose
     34           *
     35           * This example demonstrates how to use PWM module.
     36           *
     37           * \section Requirements
     38           *
     39           * This package can be used with SAMA5D4-XULT and SAMA5D2-XULT.
     40           *
     41           * Requirements before running this example on SAMA5D2-XULT:
     42           * Connect EXP/XPRO_PB5 (J20 pin 2) and EXP_PB22 (J22 pin 6) on the board to
     43           * capture the PWM output using TC.
     44           *
     45           * Requirements before running this example on SAMA5D27-SOM1-EK:
     46           * Connect PWM_mBUS1_PB1 (J25 pin 1) and PC9(ISC pin 18) on the board to
     47           * capture the PWM output using TC.
     48           *
     49           * Requirements before running this example on SAMA5D4-EK:
     50           * Connect EXP_PB28 (J19A pin 19) and USBC_EN5V_PE12 (J19C pin 44).
     51           *
     52           * Requirements before running this example on SAMA5D4-XULT:
     53           * Connect EXP_PB11 (J15 pin 26) and EXP_PE12 (J15 pin 9) on the board to
     54           * capture the PWM output using TC.
     55           *
     56           * \section Descriptions
     57           *
     58           * This example demonstrates how to configure a single PWM channel to generate
     59           * variable duty cycle signals; how to use DMA feature for synchronous channels;
     60           * and how to work with fault/override/dead-time modes. A TC is also used to
     61           * capture the signal PWM outputs for analyzing.
     62           *
     63           * The code can be roughly broken down as follows:
     64           * <ul>
     65           * <li>Configure TC to capture the signal PWM outputs. 'c' to start capture.
     66           * <li>Captured information would be dumped to console when finished.
     67           * <li>PWM outputs can also be watched with the help of an oscillator.
     68           * <li>PWM asynchronous channel operations. 'a' to configure the channel.
     69           * <li>PWM DMA operations for synchronous channels. 'd' to start DMA.
     70           * <li>PWM fault mode test. 'f' to launch the fault from TC, 'F' to clear it.
     71           * <li>PWM output overide/dead-time test. 'o' to configure the parameters.
     72           * </ul>
     73           *
     74           * \section Usage
     75           *
     76           * -# Build the program and download it inside the evaluation board. Please refer to the
     77           * <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6132.pdf">
     78           * SAM-BA User Guide</a>, the
     79           * <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6132.pdf">
     80           * GNU-Based Software Development</a> application note or to the
     81           * <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6132.pdf">
     82           * IAR EWARM User Guide</a>, depending on your chosen solution.
     83           * -# Optionally, on the computer, open and configure a terminal application
     84           *    (e.g. HyperTerminal on Microsoft Windows) with these settings:
     85           *   - 115200 bauds
     86           *   - 8 bits of data
     87           *   - No parity
     88           *   - 1 stop bit
     89           *   - No flow control
     90           * -# Start the application.
     91           * -# In the terminal window, the following text should appear:
     92           *    \code
     93           *     -- PWM Example xxx --
     94           *      -- SAMxxxxx-xx
     95           *     -- Compiled: xxx xx xxxx xx:xx:xx --
     96           *    \endcode
     97           *
     98           * \section References
     99           * - pwm/main.c
    100           * - pwmc.c
    101           * - pwmc.h
    102           */
    103          
    104          /**
    105           * \file
    106           *
    107           * This file contains all the specific code for the PWM example.
    108           */
    109          
    110          /*----------------------------------------------------------------------------
    111           *        Headers
    112           *----------------------------------------------------------------------------*/
    113          
    114          #include "board.h"
    115          #include "chip.h"
    116          
    117          #include "irq/irq.h"
    118          #include "peripherals/pmc.h"
    119          #include "peripherals/pwmc.h"
    120          #include "peripherals/pit.h"
    121          #include "gpio/pio.h"
    122          #include "peripherals/tc.h"
    123          
    124          #include "mm/cache.h"
    125          #include "serial/console.h"
    126          
    127          #include "timer.h"
    128          #include "trace.h"
    129          #include "compiler.h"
    130          
    131          #include <assert.h>
    132          #include <stdbool.h>
    133          #include <stdio.h>
    134          #include <stdint.h>
    135          #include <string.h>
    136          
    137          /*----------------------------------------------------------------------------
    138           *        Local definitions
    139           *----------------------------------------------------------------------------*/
    140          
    141          /** Timer Counter descriptor definition */
    142          struct _tc_desc {
    143          	Tc* addr;
    144          	uint8_t channel;
    145          };
    146          
    147          /** maximum captures */
    148          #define MAX_CAPTURES 32
    149          
    150          /** define IDLE status for capturing */
    151          #define TC_CAPTURE_IDLE ((uint32_t)-1)
    152          
    153          #if defined(CONFIG_BOARD_SAMA5D2_XPLAINED)
    154          	#include "config_sama5d2-xplained.h"
    155          #elif defined(CONFIG_BOARD_SAMA5D27_SOM1_EK)
    156          	#include "config_sama5d27-som1-ek.h"
    157          #elif defined(CONFIG_BOARD_SAMA5D4_EK)
    158          	#include "config_sama5d4-ek.h"
    159          #elif defined(CONFIG_BOARD_SAMA5D4_XPLAINED)
    160          	#include "config_sama5d4-xplained.h"
    161          #elif defined(CONFIG_BOARD_SAMA5D3_EK)
    162          	#include "config_sama5d3-ek.h"
    163          #elif defined(CONFIG_BOARD_SAM9G15_EK)
    164          	#include "config_sam9xx5-ek.h"
    165          #elif defined(CONFIG_BOARD_SAM9G25_EK)
    166          	#include "config_sam9xx5-ek.h"
    167          #elif defined(CONFIG_BOARD_SAM9G35_EK)
    168          	#include "config_sam9xx5-ek.h"
    169          #elif defined(CONFIG_BOARD_SAM9X25_EK)
    170          	#include "config_sam9xx5-ek.h"
    171          #elif defined(CONFIG_BOARD_SAM9X35_EK)
    172          	#include "config_sam9xx5-ek.h"
    173          #elif defined(CONFIG_BOARD_SAM9X60_EK)
    174          	#include "config_sam9x60-ek.h"
    175          #elif defined(CONFIG_BOARD_SAME70_XPLAINED)
    176          	#include "config_same70-xplained.h"
    177          #elif defined(CONFIG_BOARD_SAMV71_XPLAINED)
    178          	#include "config_samv71-xplained.h"
    179          
    180          #else
    181          #error Unsupported board!
    182          #endif
    183          
    184          /** Duty cycle buffer length for synchronous channels */
    185          #define DUTY_BUFFER_LENGTH 100
    186          
    187          /*----------------------------------------------------------------------------
    188           *        Local variables / constants
    189           *----------------------------------------------------------------------------*/
    190          
    191          /** Pio pins to configure. */

   \                                 In section SOFTPACK, align 4, keep-with-next
    192          static const struct _pin pins_pwm[] = { PIN_PWM };
   \                     pins_pwm:
   \        0x0   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'0800        DC32 2'048
   \        0x8   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
    193          
    194          /** PWM channel to use */
    195          static const uint8_t pwm_channel = CHANNEL_PWM;
    196          
    197          #ifdef CONFIG_HAVE_PWMC_DMA
    198          
    199          /** Duty cycle buffer synchronous channels */
    200          CACHE_ALIGNED static uint16_t duty_buffer[DUTY_BUFFER_LENGTH];
    201          
    202          #endif /* CONFIG_HAVE_PWMC_DMA */
    203          
    204          /** PIOs for TC capture, waveform */

   \                                 In section SOFTPACK, align 4, keep-with-next
    205          static const struct _pin pins_tc_capture[] = { PIN_TC_CAPTURE_IN };
   \                     pins_tc_capture:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0020'0000        DC32 2'097'152
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
    206          
    207          /** define Timer Counter descriptor for capture */
    208          static const struct _tc_desc tc_capture = {
    209          	.addr = TC_CAPTURE,
    210          	.channel = CHANNEL_TC_CAPTURE_IN,
    211          };
    212          
    213          /** Clock selection for capture channel */
    214          static const uint8_t capture_clock_sel = TC_CMR_TCCLKS_TIMER_CLOCK4;
    215          
    216          /** capture index */
    217          static uint32_t captured_pulses = TC_CAPTURE_IDLE;
    218          
    219          /** capturing buffer */
    220          static uint32_t captured_rarb[MAX_CAPTURES][2];
    221          
    222          #ifdef CONFIG_HAVE_TC_FAULT_MODE
    223          
    224          /** define Timer Counter descriptor for fault mode */
    225          static const struct _tc_desc tc_fault = {
    226          	.addr = TC1,
    227          	.channel = 0,
    228          };
    229          
    230          /** Fault input for PWM, must be in sync with tc_fault */
    231          static const uint32_t pwm_fault_input = PWM_FAULT_INPUT_TIMER1;
    232          
    233          #endif /* CONFIG_HAVE_TC_FAULT_MODE */
    234          
    235          /*----------------------------------------------------------------------------
    236           *        Local functions
    237           *----------------------------------------------------------------------------*/
    238          
    239          /**
    240           * \brief Displays the user menu.
    241           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    242          static void _display_menu(void)
    243          {
   \                     _display_menu:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    244          	printf("\n\rMenu :\n\r");
   \        0x4   0x....'....        LDR      R0,??DataTable11_1
   \        0x8   0x....'....        BL       printf
    245          	printf("  -------------------------------------------\n\r");
   \        0xC   0x....'....        LDR      R4,??DataTable11_2
   \       0x10   0xE1A0'0004        MOV      R0,R4
   \       0x14   0x....'....        BL       printf
    246          	printf("  a: PWM operations for asynchronous channels \n\r");
   \       0x18   0xE284'0030        ADD      R0,R4,#+48
   \       0x1C   0x....'....        BL       printf
    247          #ifdef CONFIG_HAVE_PWMC_DMA
    248          	printf("  d: PWM DMA operations with synchronous channels \n\r");
    249          #endif /* CONFIG_HAVE_PWMC_DMA */
    250          #ifdef CONFIG_HAVE_TC_FAULT_MODE
    251          	printf("  f: PWM fault mode initialize \n\r");
    252          	printf("  F: PWM fault mode clear and disable \n\r");
    253          #endif /* CONFIG_HAVE_TC_FAULT_MODE */
    254          #ifdef CONFIG_HAVE_PWMC_STEPPER_MOTOR
    255          	printf("  m: PWM 2-bit Gray Up/Down Counter for Stepper Motor \n\r");
    256          #endif /* CONFIG_HAVE_PWMC_STEPPER_MOTOR  */
    257          #ifdef CONFIG_HAVE_PWMC_DTIME
    258          	printf("  o: PWM output override / dead time settings \n\r");
    259          #endif /* CONFIG_HAVE_PWMC_DTIME */
    260          	printf("  c: Capture waveform from TC capture channel \n\r");
   \       0x20   0xE284'0064        ADD      R0,R4,#+100
   \       0x24   0x....'....        BL       printf
    261          	printf("  h: Display menu \n\r");
   \       0x28   0x....'....        LDR      R0,??DataTable11_3
   \       0x2C   0x....'....        BL       printf
    262          	printf("  -------------------------------------------\n\r\n\r");
   \       0x30   0xE284'0098        ADD      R0,R4,#+152
   \       0x34   0xE8BD'4010        POP      {R4,LR}
   \       0x38   0x....'....        B        printf           ;; tailcall
    263          }
    264          
    265          /**
    266           * \brief Interrupt handler for the TC capture.
    267           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    268          static void _tc_capture_handler(uint32_t source, void* user_arg)
    269          {
   \                     _tc_capture_handler:
   \        0x0   0xE92D'407C        PUSH     {R2-R6,LR}
    270          	uint32_t status = tc_get_status(tc_capture.addr, tc_capture.channel);
   \        0x4   0xE3A0'44F8        MOV      R4,#-134217728
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE384'4C80        ORR      R4,R4,#0x8000
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0xE1A0'0004        MOV      R0,R4
   \       0x18   0x....'....        BL       tc_get_status
   \       0x1C   0xE1A0'6000        MOV      R6,R0
    271          
    272          	assert(source == get_tc_id_from_addr(tc_capture.addr, tc_capture.channel));
   \       0x20   0xE3A0'1000        MOV      R1,#+0
   \       0x24   0xE1A0'0004        MOV      R0,R4
   \       0x28   0x....'....        BL       get_tc_id_from_addr
   \       0x2C   0xE155'0000        CMP      R5,R0
   \       0x30   0x0A00'0004        BEQ      ??_tc_capture_handler_0
   \       0x34   0x....'....        LDR      R0,??DataTable11_4
   \       0x38   0xE3A0'2F44        MOV      R2,#+272
   \       0x3C   0xE280'1044        ADD      R1,R0,#+68
   \       0x40   0x....'....        BL       __aeabi_assert
   \       0x44   0x....'....        BL       __iar_EmptyStepPoint
    273          
    274          	if ((status & TC_SR_LDRBS) == TC_SR_LDRBS) {
   \                     ??_tc_capture_handler_0:
   \       0x48   0xE316'0040        TST      R6,#0x40
   \       0x4C   0x0A00'0010        BEQ      ??_tc_capture_handler_1
    275          		tc_get_ra_rb_rc(tc_capture.addr, tc_capture.channel,
    276          			&captured_rarb[captured_pulses][0],
    277          			&captured_rarb[captured_pulses][1],
    278          			0);
   \       0x50   0x....'....        LDR      R5,??DataTable11_5
   \       0x54   0xE3A0'1000        MOV      R1,#+0
   \       0x58   0xE595'0100        LDR      R0,[R5, #+256]
   \       0x5C   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x60   0xE085'2180        ADD      R2,R5,R0, LSL #+3
   \       0x64   0xE282'3004        ADD      R3,R2,#+4
   \       0x68   0xE1A0'0004        MOV      R0,R4
   \       0x6C   0x....'....        BL       tc_get_ra_rb_rc
    279          		captured_pulses++;
   \       0x70   0xE595'0100        LDR      R0,[R5, #+256]
   \       0x74   0xE280'0001        ADD      R0,R0,#+1
   \       0x78   0xE585'0100        STR      R0,[R5, #+256]
    280          		if (captured_pulses >= MAX_CAPTURES)
   \       0x7C   0xE350'0020        CMP      R0,#+32
   \       0x80   0x3A00'0003        BCC      ??_tc_capture_handler_1
    281          			tc_stop(tc_capture.addr, tc_capture.channel);
   \       0x84   0xE1A0'0004        MOV      R0,R4
   \       0x88   0xE8BD'407C        POP      {R2-R6,LR}
   \       0x8C   0xE3A0'1000        MOV      R1,#+0
   \       0x90   0x....'....        B        tc_stop          ;; tailcall
    282          	}
    283          }
   \                     ??_tc_capture_handler_1:
   \       0x94   0xE8BD'8073        POP      {R0,R1,R4-R6,PC}  ;; return
    284          
    285          /**
    286           * \brief Configure a TC channel as capture operating mode.
    287           */
    288          static void _tc_capture_initialize(void)
    289          {
    290          	uint32_t tc_id = get_tc_id_from_addr(tc_capture.addr, tc_capture.channel);
    291          	uint32_t mode = TC_CMR_TCCLKS(capture_clock_sel)
    292          	              | TC_CMR_LDRA_RISING
    293          	              | TC_CMR_LDRB_FALLING
    294          	              | TC_CMR_ABETRG
    295          	              | TC_CMR_ETRGEDG_FALLING;
    296          
    297          	pmc_configure_peripheral(tc_id, NULL, true);
    298          	tc_configure(tc_capture.addr, tc_capture.channel, mode);
    299          	irq_add_handler(tc_id, _tc_capture_handler, NULL);
    300          	irq_enable(tc_id);
    301          }
    302          
    303          /**
    304           * \brief start capture
    305           */
    306          static void _start_capture(void)
    307          {
    308          	if (TC_CAPTURE_IDLE != captured_pulses) {
    309          		printf ("Capturing, can not start new capture\n\r");
    310          		return;
    311          	}
    312          	printf("Start capture, result will be dumped to console when finished.\n\r");
    313          	captured_pulses = 0;
    314          	/* Reset and enable the timer counter for TC capture channel */
    315          	tc_enable_it(tc_capture.addr, tc_capture.channel, TC_IER_LDRBS);
    316          	tc_start(tc_capture.addr, tc_capture.channel);
    317          }
    318          
    319          /**
    320           * \brief dump captured results to console
    321           */
    322          static void _show_captured_results(void)
    323          {
    324          	uint32_t i;
    325          	uint32_t frequency;
    326          	uint32_t duty_cycle;
    327          
    328          	if ((captured_pulses < MAX_CAPTURES)
    329          		|| (TC_CAPTURE_IDLE == captured_pulses)) {
    330          		return;
    331          	}
    332          
    333          	printf("\n\rCaptured %u pulses from TC capture channel:\n\r",
    334          			(unsigned int)captured_pulses);
    335          	for (i = 0; i < MAX_CAPTURES; ++i)
    336          	{
    337          		frequency = tc_get_available_freq(tc_capture.addr, tc_capture.channel, capture_clock_sel);
    338          		frequency /= captured_rarb[i][1];
    339          		duty_cycle = (captured_rarb[i][1] - captured_rarb[i][0]) * 100;
    340          		duty_cycle /= captured_rarb[i][1];
    341          		printf("Captured[%d] frequency = %d Hz, Duty cycle = %d%% \n\r",
    342          			(int)i, (int)frequency, (int)duty_cycle);
    343          	}
    344          	printf("\n\r");
    345          
    346          	captured_pulses = TC_CAPTURE_IDLE;
    347          }
    348          
    349          #ifdef CONFIG_HAVE_TC_FAULT_MODE
    350          
    351          /**
    352           * \brief Interrupt handler for the TC fault.
    353           */
    354          static void _tc_fault_handler(uint32_t source, void* user_arg)
    355          {
    356          	uint32_t status = tc_get_status(tc_fault.addr, tc_fault.channel);
    357          
    358          	assert(source == get_tc_id_from_addr(tc_fault.addr, tc_fault.channel));
    359          
    360          	if ((status & TC_SR_CPCS) == TC_SR_CPCS)
    361          		printf("TC fault triggered, press 'F' to clear fault\r\n");
    362          }
    363          
    364          /**
    365           * \brief Configure a TC channel to trigger faults
    366           */
    367          static void _tc_fault_initialize(void)
    368          {
    369          	uint32_t tc_id = get_tc_id_from_addr(tc_fault.addr, tc_fault.channel);
    370          	uint32_t mode = TC_CMR_TCCLKS(4)
    371          	              | TC_CMR_CPCSTOP
    372          	              //| TC_CMR_WAVSEL_UP_RC
    373          	              | TC_CMR_WAVE;
    374          	uint32_t rc = 2 * pmc_get_slow_clock();
    375          
    376          	pmc_configure_peripheral(tc_id, NULL, true);
    377          
    378          	/* disable all channels to avoid spurious interrupts */
    379          	tc_stop(tc_capture.addr, 0);
    380          	tc_stop(tc_capture.addr, 1);
    381          	tc_stop(tc_capture.addr, 2);
    382          
    383          	tc_configure(tc_fault.addr, tc_fault.channel, mode);
    384          	tc_set_fault_mode(tc_fault.addr, TC_FMR_ENCF0 << tc_fault.channel);
    385          	tc_set_ra_rb_rc(tc_fault.addr, tc_fault.channel, NULL, NULL, &rc);
    386          
    387          	tc_enable_it(tc_fault.addr, tc_fault.channel, TC_IER_CPCS);
    388          	irq_add_handler(tc_id, _tc_fault_handler, NULL);
    389          	irq_enable(tc_id);
    390          }
    391          
    392          /**
    393           * \brief start TC for fault
    394           */
    395          static void _tc_fault_start(void)
    396          {
    397          	tc_start(tc_fault.addr, tc_fault.channel);
    398          }
    399          
    400          #endif /* CONFIG_HAVE_TC_FAULT_MODE */
    401          
    402          /**
    403           * \brief Interrupt handler for the PWM.
    404           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    405          static void _pwm_handler(uint32_t source, void* user_arg)
    406          {
   \                     _pwm_handler:
   \        0x0   0x....'....        LDR      R0,??DataTable11_6
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE351'0005        CMP      R1,#+5
   \        0xC   0x2A00'0000        BCS      ??_pwm_handler_0
   \       0x10   0xE12F'FF1E        BX       LR
   \                     ??_pwm_handler_0:
   \       0x14   0xE92D'5000        PUSH     {R12,LR}
    407          #ifdef CONFIG_HAVE_PWMC_FMODE
    408          	trace_debug("PWM handler, interrupt status 0x%08x 0x%08x, "
    409          		"fault status 0x%08x\r\n",
    410          		(unsigned)pwmc_get_it_status1(PWM_ADDR),
    411          		(unsigned)pwmc_get_it_status2(PWM_ADDR),
    412          		(unsigned)pwmc_get_fault_status(PWM_ADDR));
    413          #else
    414          	trace_debug("PWM handler, interrupt status 0x%08x ",
    415          		(unsigned)pwmc_get_it_status1(PWM_ADDR));
   \       0x18   0xE3A0'04F8        MOV      R0,#-134217728
   \       0x1C   0xE380'0BD0        ORR      R0,R0,#0x34000
   \       0x20   0x....'....        BL       pwmc_get_it_status1
   \       0x24   0xE8BD'4004        POP      {R2,LR}
   \       0x28   0xE1A0'1000        MOV      R1,R0
   \       0x2C   0x....'....        LDR      R0,??DataTable11_7
   \       0x30   0x....'....        B        printf           ;; tailcall
    416          #endif
    417          }

   \                                 In section .data, align 4
   \                     captured_rarb:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x60   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x70   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x80   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0x90   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xA0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xB0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xC0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xD0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xE0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \       0xF0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00
   \      0x100   0xFFFF'FFFF        DC32 4'294'967'295
   \      0x104   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \      0x108   0x00               DC8 0
    418          
    419          /**
    420           * \brief Configure outputs for a PWM asynchronous channel
    421           */
    422          static void _pwm_demo_asynchronous_channel(bool init, uint8_t channel, uint32_t cprd)
    423          {
    424          	static uint32_t duty_cycle;
    425          	static bool duty_cycle_inc;
    426          	uint32_t id = get_pwm_id_from_addr(PWM_ADDR);
    427          
    428          	if (init) {
    429          		/* Configure PWM channel 0 */
    430          		pwmc_disable_channel(PWM_ADDR, channel);
    431          		pwmc_configure_channel(PWM_ADDR, channel,
    432          			PWM_CMR_CPOL | PWM_CMR_CALG | PWM_CMR_CPRE_CLKA);
    433          		pwmc_set_period(PWM_ADDR, channel, cprd);
    434          		pwmc_set_duty_cycle(PWM_ADDR, channel, 0);
    435          		pwmc_enable_channel(PWM_ADDR, channel);
    436          		duty_cycle = 0;
    437          		duty_cycle_inc = true;
    438          		return;
    439          	}
    440          	printf("-- PWM Channel %u Duty cycle: %lu%% Signal Period: %lu ms--\n\r",
    441          			(unsigned)channel,
    442          			(unsigned)(duty_cycle * 100) / cprd,
    443          			(unsigned)((2 * cprd * 1024 * 32)) / (pmc_get_peripheral_clock(id)
    444          			/ 1000));
    445          
    446          	pwmc_set_duty_cycle(PWM_ADDR, channel, duty_cycle);
    447          	msleep(50);
    448          
    449          	if (duty_cycle_inc) {
    450          		if (duty_cycle < (cprd - 1))
    451          			duty_cycle++;
    452          		else
    453          			duty_cycle_inc = false;;
    454          	} else {
    455          		if (duty_cycle > 0)
    456          			duty_cycle--;
    457          		else
    458          			duty_cycle_inc = true;
    459          	}
    460          }
    461          
    462          #ifdef CONFIG_HAVE_PWMC_DMA
    463          
    464          /**
    465           * \brief PWM call-back routine for DMA operations
    466           */
    467          static int _pwmc_callback(void* arg1, void* arg2)
    468          {
    469          	trace_debug("PWM DMA Transfer Finished\r\n");
    470          	return 0;
    471          }
    472          
    473          /**
    474           * \brief Configure DMA operation for PWM synchronous channel
    475           */
    476          static void _pwm_demo_dma(uint8_t channel, uint32_t cprd)
    477          {
    478          	int i;
    479          	bool flag = false;
    480          	struct _callback _cb;
    481          
    482          	pwmc_disable_channel(PWM_ADDR, channel);
    483          	pwmc_configure_sync_channels(PWM_ADDR,
    484          		PWM_SCM_UPDM_MODE2 | (1 << channel) | (1 << 0));
    485          	pwmc_configure_channel(PWM_ADDR, 0,
    486          		PWM_CMR_CPOL | PWM_CMR_CALG | PWM_CMR_CPRE_CLKA);
    487          	pwmc_set_period(PWM_ADDR, 0, cprd);
    488          	pwmc_set_duty_cycle(PWM_ADDR, 0, 0);
    489          	pwmc_set_sync_channels_update_period(PWM_ADDR, 0, 8);
    490          	/* Enable the synchronous channels */
    491          	pwmc_enable_channel(PWM_ADDR, 0);
    492          	for (i = 0; i < ARRAY_SIZE(duty_buffer); i++) {
    493          		if (0 == (i % cprd))
    494          			flag = !flag;
    495          		duty_buffer[i] = flag ? (i % cprd) : (cprd - (i % cprd));
    496          	}
    497          	callback_set(&_cb, _pwmc_callback, 0);
    498          	pwmc_set_dma_finished_callback(PWM_ADDR, &_cb);
    499          	pwmc_dma_duty_cycle(PWM_ADDR, duty_buffer, ARRAY_SIZE(duty_buffer));
    500          }
    501          
    502          #endif /* CONFIG_HAVE_PWMC_DMA */
    503          
    504          /*----------------------------------------------------------------------------
    505           *         Global functions
    506           *----------------------------------------------------------------------------*/
    507          
    508          /**
    509           * \brief Application entry point for PWM example.
    510           *
    511           * \return Unused (ANSI-C compatibility).
    512           */

   \                                 In section SOFTPACK, align 4, keep-with-next
    513          int main(void)
    514          {
   \                     main:
   \        0x0   0xE92D'4FF8        PUSH     {R3-R11,LR}
    515          	uint8_t key;
    516          	uint32_t cprd;
    517          	uint8_t current_demo = 'h';
    518          	uint32_t id = get_pwm_id_from_addr(PWM_ADDR);
   \        0x4   0xE3A0'84F8        MOV      R8,#-134217728
   \        0x8   0xE388'8BD0        ORR      R8,R8,#0x34000
   \        0xC   0xE1A0'0008        MOV      R0,R8
   \       0x10   0x....'....        BL       get_pwm_id_from_addr
   \       0x14   0xE1A0'5000        MOV      R5,R0
    519          
    520          	/* Output example information */
    521          	console_example_info("PWM Example");
   \       0x18   0x....'....        ADR      R0,?_17
   \       0x1C   0x....'....        BL       console_example_info
    522          
    523          	/* Configure PIO Pins for TC capture */
    524          	pio_configure(pins_tc_capture, ARRAY_SIZE(pins_tc_capture));
   \       0x20   0xE3A0'1001        MOV      R1,#+1
   \       0x24   0x....'....        ADR      R0,pins_tc_capture
   \       0x28   0x....'....        BL       pio_configure
    525          #ifdef SETUP_CAPTURE_PIN
    526          	SETUP_CAPTURE_PIN;
   \       0x2C   0xE3A0'1001        MOV      R1,#+1
   \       0x30   0x....'....        ADR      R0,`main{1}{2}::pin_tioa0_connect`
   \       0x34   0x....'....        BL       pio_configure
    527          #endif
    528          
    529          	/* Configure one TC channel as capture operating mode */
    530          	printf("Configure TC channel %d as capture operating mode \n\r",
    531          		tc_capture.channel);
   \       0x38   0x....'....        LDR      R9,??DataTable11_8
   \       0x3C   0xE3A0'1000        MOV      R1,#+0
   \       0x40   0xE289'0F45        ADD      R0,R9,#+276
   \       0x44   0x....'....        BL       printf
    532          	_tc_capture_initialize();
   \       0x48   0xE3A0'1000        MOV      R1,#+0
   \       0x4C   0xE248'0BB0        SUB      R0,R8,#+180224
   \       0x50   0x....'....        BL       get_tc_id_from_addr
   \       0x54   0xE1A0'6000        MOV      R6,R0
   \       0x58   0xE3A0'2001        MOV      R2,#+1
   \       0x5C   0xE3A0'1000        MOV      R1,#+0
   \       0x60   0x....'....        BL       pmc_configure_peripheral
   \       0x64   0x....'....        LDR      R2,??DataTable11_9  ;; 0x90603
   \       0x68   0xE3A0'1000        MOV      R1,#+0
   \       0x6C   0xE248'0BB0        SUB      R0,R8,#+180224
   \       0x70   0x....'....        BL       tc_configure
   \       0x74   0xE3A0'2000        MOV      R2,#+0
   \       0x78   0x....'....        ADR      R1,_tc_capture_handler
   \       0x7C   0xE1A0'0006        MOV      R0,R6
   \       0x80   0x....'....        BL       irq_add_handler
   \       0x84   0xE1A0'0006        MOV      R0,R6
   \       0x88   0x....'....        BL       irq_enable
    533          
    534          	/* PIO configuration */
    535          	pio_configure(pins_pwm, ARRAY_SIZE(pins_pwm));
   \       0x8C   0xE3A0'1001        MOV      R1,#+1
   \       0x90   0x....'....        ADR      R0,pins_pwm
   \       0x94   0x....'....        BL       pio_configure
    536          
    537          	/* Enable PWM peripheral clock */
    538          	pmc_configure_peripheral(id, NULL, true);
   \       0x98   0xE3A0'2001        MOV      R2,#+1
   \       0x9C   0xE3A0'1000        MOV      R1,#+0
   \       0xA0   0xE1A0'0005        MOV      R0,R5
   \       0xA4   0x....'....        BL       pmc_configure_peripheral
    539          
    540          	/* Enable PWM interrupt */
    541          	irq_add_handler(id, _pwm_handler, NULL);
   \       0xA8   0xE3A0'2000        MOV      R2,#+0
   \       0xAC   0x....'....        ADR      R1,_pwm_handler
   \       0xB0   0xE1A0'0005        MOV      R0,R5
   \       0xB4   0x....'....        BL       irq_add_handler
    542          	irq_enable(id);
   \       0xB8   0xE1A0'0005        MOV      R0,R5
   \       0xBC   0x....'....        BL       irq_enable
    543          
    544          	/* Set clock A and clock B */
    545          	/* CLKA clock is clock selected by PREA : 0x0A Peripheral clock/1024 */
    546          	/* divided by DIVB factor : 32 */
    547          	pwmc_configure_clocks(PWM_ADDR, PWM_CLK_PREB_CLK_DIV1024 | PWM_CLK_DIVB(32) |
    548          	                           PWM_CLK_PREA_CLK_DIV1024 | PWM_CLK_DIVA(32));
   \       0xC0   0xE3A0'16A2        MOV      R1,#+169869312
   \       0xC4   0xE381'1EA2        ORR      R1,R1,#0xA20
   \       0xC8   0xE1A0'0008        MOV      R0,R8
   \       0xCC   0x....'....        BL       pwmc_configure_clocks
    549          	printf("-- PWM Peripheral Clock: %u MHz --\n\r",
    550          			(unsigned)(pmc_get_peripheral_clock(id) / 1000000));
   \       0xD0   0xE1A0'0005        MOV      R0,R5
   \       0xD4   0x....'....        BL       pmc_get_peripheral_clock
   \       0xD8   0x....'....        LDR      R2,??DataTable11_10  ;; 0x8637bd06
   \       0xDC   0xE3A0'4068        MOV      R4,#+104
   \       0xE0   0xE081'2290        UMULL    R2,R1,R0,R2
   \       0xE4   0xE1A0'19A1        LSR      R1,R1,#+19
   \       0xE8   0xE289'0F53        ADD      R0,R9,#+332
   \       0xEC   0x....'....        BL       printf
    551          
    552          	cprd = 26;
    553          
    554          	_display_menu();
   \       0xF0   0x....'....        BL       _display_menu
   \       0xF4   0x....'....        LDR      R10,??DataTable11_5
   \       0xF8   0xE5CD'4000        STRB     R4,[SP, #+0]
    555          	while (1) {
    556          		if (console_is_rx_ready()) {
   \                     ??main_0:
   \       0xFC   0x....'....        BL       console_is_rx_ready
   \      0x100   0xE350'0000        CMP      R0,#+0
   \      0x104   0x0A00'0040        BEQ      ??main_1
    557          			key = console_get_char();
   \      0x108   0x....'....        BL       console_get_char
   \      0x10C   0xE1A0'4000        MOV      R4,R0
    558          			printf("Input %c\n\r", key);
   \      0x110   0xE1A0'1004        MOV      R1,R4
   \      0x114   0x....'....        ADR      R0,?_18
   \      0x118   0x....'....        BL       printf
    559          			switch (key) {
   \      0x11C   0xE354'0061        CMP      R4,#+97
   \      0x120   0x0A00'0002        BEQ      ??main_2
   \      0x124   0xE354'0063        CMP      R4,#+99
   \      0x128   0x0A00'001C        BEQ      ??main_3
   \      0x12C   0xEA00'002D        B        ??main_4
    560          			case 'a':
    561          				current_demo = key;
   \                     ??main_2:
   \      0x130   0xE3A0'0061        MOV      R0,#+97
   \      0x134   0xE5CD'0000        STRB     R0,[SP, #+0]
    562          				_pwm_demo_asynchronous_channel(true, pwm_channel, cprd);
   \      0x138   0xE1A0'0008        MOV      R0,R8
   \      0x13C   0x....'....        BL       get_pwm_id_from_addr
   \      0x140   0xE3A0'1000        MOV      R1,#+0
   \      0x144   0xE1A0'0008        MOV      R0,R8
   \      0x148   0x....'....        BL       pwmc_disable_channel
   \      0x14C   0xE3A0'200B        MOV      R2,#+11
   \      0x150   0xE382'2FC0        ORR      R2,R2,#0x300
   \      0x154   0xE3A0'1000        MOV      R1,#+0
   \      0x158   0xE1A0'0008        MOV      R0,R8
   \      0x15C   0x....'....        BL       pwmc_configure_channel
   \      0x160   0xE3A0'201A        MOV      R2,#+26
   \      0x164   0xE3A0'1000        MOV      R1,#+0
   \      0x168   0xE1A0'0008        MOV      R0,R8
   \      0x16C   0x....'....        BL       pwmc_set_period
   \      0x170   0xE3A0'2000        MOV      R2,#+0
   \      0x174   0xE3A0'1000        MOV      R1,#+0
   \      0x178   0xE1A0'0008        MOV      R0,R8
   \      0x17C   0x....'....        BL       pwmc_set_duty_cycle
   \      0x180   0xE3A0'1000        MOV      R1,#+0
   \      0x184   0xE1A0'0008        MOV      R0,R8
   \      0x188   0x....'....        BL       pwmc_enable_channel
   \      0x18C   0xE3A0'0000        MOV      R0,#+0
   \      0x190   0xE3A0'1001        MOV      R1,#+1
   \      0x194   0xE58A'0104        STR      R0,[R10, #+260]
   \      0x198   0xE5CA'1108        STRB     R1,[R10, #+264]
   \      0x19C   0xEA00'001A        B        ??main_1
    563          				break;
    564          #ifdef CONFIG_HAVE_PWMC_DMA
    565          			case 'd':
    566          				current_demo = key;
    567          				_pwm_demo_dma(pwm_channel, cprd);
    568          				break;
    569          #endif /* CONFIG_HAVE_PWMC_DMA */
    570          #ifdef CONFIG_HAVE_TC_FAULT_MODE
    571          #ifdef CONFIG_HAVE_PWMC_FMODE
    572          			case 'f':
    573          				pwmc_set_fault_mode(PWM_ADDR, PWM_FMR_FPOL(1 << pwm_fault_input) |
    574          				                         PWM_FMR_FMOD(0));
    575          				pwmc_set_fault_mode(PWM_ADDR, PWM_FMR_FPOL(1 << pwm_fault_input) |
    576          				                         PWM_FMR_FMOD(1 << pwm_fault_input));
    577          				pwmc_set_fault_protection(PWM_ADDR, (PWM_FPV1_FPVH0 << pwm_channel) |
    578          				                               (PWM_FPV1_FPVL0 << pwm_channel));
    579          #ifdef CONFIG_HAVE_PWMC_FAULT_PROT_HIZ
    580          				pwmc_set_fault_protection_to_hiz(PWM_ADDR, 0);
    581          #endif /* CONFIG_HAVE_PWMC_FAULT_PROT_HIZ */
    582          				pwmc_fault_clear(PWM_ADDR, 1 << pwm_fault_input);
    583          				pwmc_enable_fault_protection(PWM_ADDR, pwm_channel, 1 << pwm_fault_input);
    584          				pwmc_enable_it(PWM_ADDR, PWM_IER1_FCHID0 << pwm_channel, 0);
    585          				_tc_fault_initialize();
    586          				_tc_fault_start();
    587          				break;
    588          			case 'F':
    589          				pwmc_enable_fault_protection(PWM_ADDR, pwm_channel, 0);
    590          				pwmc_disable_it(PWM_ADDR, PWM_IER1_FCHID0 << pwm_channel, 0);
    591          				pwmc_fault_clear(PWM_ADDR, 1 << pwm_fault_input);
    592          				break;
    593          #endif /* CONFIG_HAVE_PWMC_FMODE */
    594          #endif /* CONFIG_HAVE_TC_FAULT_MODE */
    595          #ifdef CONFIG_HAVE_PWMC_STEPPER_MOTOR
    596          			case 'm':
    597          				pwmc_configure_stepper_motor_mode(PWM_ADDR,
    598          					PWM_SMMR_GCEN0 | PWM_SMMR_GCEN1 | PWM_SMMR_DOWN0);
    599          				break;
    600          #endif /* CONFIG_HAVE_PWMC_STEPPER_MOTOR */
    601          #ifdef CONFIG_HAVE_PWMC_OOV
    602          			case 'o':
    603          				printf("\n\r  ---- Input options: ----\r\n");
    604          				printf("  0/1: override to 0/1\n\r  others: set dead-time\n\r");
    605          				key = console_get_char();
    606          				switch (key) {
    607          				case '0':
    608          					pwmc_output_override(PWM_ADDR, pwm_channel, 0, 0, 0);
    609          					pwmc_output_override(PWM_ADDR, pwm_channel, 1, 0, 0);
    610          					break;
    611          				case '1':
    612          					pwmc_output_override(PWM_ADDR, pwm_channel, 0, 1, 0);
    613          					pwmc_output_override(PWM_ADDR, pwm_channel, 1, 1, 0);
    614          					break;
    615          				default:
    616          					pwmc_output_dead_time(PWM_ADDR, pwm_channel, 0, 0);
    617          					pwmc_disable_output_override(PWM_ADDR, pwm_channel, 0, 0);
    618          					pwmc_disable_output_override(PWM_ADDR, pwm_channel, 1, 0);
    619          					break;
    620          				}
    621          				break;
    622          #endif/* CONFIG_HAVE_PWMC_OOV */
    623          			case 'c':
    624          				_start_capture();
   \                     ??main_3:
   \      0x1A0   0xE59A'0100        LDR      R0,[R10, #+256]
   \      0x1A4   0xE370'0001        CMN      R0,#+1
   \      0x1A8   0x0A00'0002        BEQ      ??main_5
   \      0x1AC   0xE1A0'0009        MOV      R0,R9
   \      0x1B0   0x....'....        BL       printf
   \      0x1B4   0xEA00'0014        B        ??main_1
   \                     ??main_5:
   \      0x1B8   0xE289'0028        ADD      R0,R9,#+40
   \      0x1BC   0x....'....        BL       printf
   \      0x1C0   0xE3A0'0000        MOV      R0,#+0
   \      0x1C4   0xE58A'0100        STR      R0,[R10, #+256]
   \      0x1C8   0xE3A0'2040        MOV      R2,#+64
   \      0x1CC   0xE3A0'1000        MOV      R1,#+0
   \      0x1D0   0xE248'0BB0        SUB      R0,R8,#+180224
   \      0x1D4   0x....'....        BL       tc_enable_it
   \      0x1D8   0xE3A0'1000        MOV      R1,#+0
   \      0x1DC   0xE248'0BB0        SUB      R0,R8,#+180224
   \      0x1E0   0x....'....        BL       tc_start
   \      0x1E4   0xEA00'0008        B        ??main_1
    625          				break;
    626          			case 'h':
    627          			default:
    628          				current_demo = 0;
   \                     ??main_4:
   \      0x1E8   0xE3A0'0000        MOV      R0,#+0
   \      0x1EC   0xE5CD'0000        STRB     R0,[SP, #+0]
    629          				pwmc_disable_channel(PWM_ADDR, 0);
   \      0x1F0   0xE3A0'1000        MOV      R1,#+0
   \      0x1F4   0xE1A0'0008        MOV      R0,R8
   \      0x1F8   0x....'....        BL       pwmc_disable_channel
    630          				pwmc_disable_channel(PWM_ADDR, pwm_channel);
   \      0x1FC   0xE3A0'1000        MOV      R1,#+0
   \      0x200   0xE1A0'0008        MOV      R0,R8
   \      0x204   0x....'....        BL       pwmc_disable_channel
    631          #ifdef CONFIG_HAVE_PWMC_SYNC_MODE
    632          				/* no PWM synchronous channels */
    633          				pwmc_configure_sync_channels(PWM_ADDR, 0);
    634          #endif/* CONFIG_HAVE_PWMC_SYNC_MODE */
    635          #ifdef CONFIG_HAVE_PWMC_DMA
    636          				pwmc_set_dma_finished_callback(PWM_ADDR, NULL);
    637          #endif /* CONFIG_HAVE_PWMC_DMA */
    638          #ifdef CONFIG_HAVE_PWMC_STEPPER_MOTOR
    639          				pwmc_configure_stepper_motor_mode(PWM_ADDR, 0);
    640          #endif /* CONFIG_HAVE_PWMC_STEPPER_MOTOR */
    641          				_display_menu();
   \      0x208   0x....'....        BL       _display_menu
    642          				break;
    643          			}
    644          		}
    645          		_show_captured_results();
   \                     ??main_1:
   \      0x20C   0xE59A'1100        LDR      R1,[R10, #+256]
   \      0x210   0xE351'0020        CMP      R1,#+32
   \      0x214   0x3A00'0021        BCC      ??main_6
   \      0x218   0xE371'0001        CMN      R1,#+1
   \      0x21C   0x0A00'001F        BEQ      ??main_6
   \      0x220   0xE289'006C        ADD      R0,R9,#+108
   \      0x224   0x....'....        BL       printf
   \      0x228   0xE3A0'6000        MOV      R6,#+0
   \      0x22C   0xE1A0'700A        MOV      R7,R10
   \                     ??main_7:
   \      0x230   0xE3A0'2003        MOV      R2,#+3
   \      0x234   0xE3A0'1000        MOV      R1,#+0
   \      0x238   0xE248'0BB0        SUB      R0,R8,#+180224
   \      0x23C   0x....'....        BL       tc_get_available_freq
   \      0x240   0xE1A0'4000        MOV      R4,R0
   \      0x244   0xE597'5004        LDR      R5,[R7, #+4]
   \      0x248   0xE497'0008        LDR      R0,[R7], #+8
   \      0x24C   0xE3A0'1064        MOV      R1,#+100
   \      0x250   0xE045'0000        SUB      R0,R5,R0
   \      0x254   0xE000'0091        MUL      R0,R1,R0
   \      0x258   0xE1A0'1005        MOV      R1,R5
   \      0x25C   0x....'....        BL       __aeabi_uidiv
   \      0x260   0xE1A0'B000        MOV      R11,R0
   \      0x264   0xE1A0'0004        MOV      R0,R4
   \      0x268   0xE1A0'1005        MOV      R1,R5
   \      0x26C   0x....'....        BL       __aeabi_uidiv
   \      0x270   0xE1A0'2000        MOV      R2,R0
   \      0x274   0xE1A0'300B        MOV      R3,R11
   \      0x278   0xE1A0'1006        MOV      R1,R6
   \      0x27C   0xE289'009C        ADD      R0,R9,#+156
   \      0x280   0x....'....        BL       printf
   \      0x284   0xE286'6001        ADD      R6,R6,#+1
   \      0x288   0xE356'0020        CMP      R6,#+32
   \      0x28C   0x3AFF'FFE7        BCC      ??main_7
   \      0x290   0x....'....        ADR      R0,??DataTable11  ;; 0x0A, 0x0D, 0x00, 0x00
   \      0x294   0x....'....        BL       printf
   \      0x298   0xE3E0'0000        MVN      R0,#+0
   \      0x29C   0xE58A'0100        STR      R0,[R10, #+256]
    646          		if ('a' == current_demo)
   \                     ??main_6:
   \      0x2A0   0xE5DD'0000        LDRB     R0,[SP, #+0]
   \      0x2A4   0xE350'0061        CMP      R0,#+97
   \      0x2A8   0x1AFF'FF93        BNE      ??main_0
    647          			_pwm_demo_asynchronous_channel(false, pwm_channel, cprd);
   \      0x2AC   0xE1A0'0008        MOV      R0,R8
   \      0x2B0   0x....'....        BL       get_pwm_id_from_addr
   \      0x2B4   0x....'....        BL       pmc_get_peripheral_clock
   \      0x2B8   0x....'....        LDR      R2,??DataTable11_11  ;; 0x83126e98
   \      0x2BC   0xE081'2290        UMULL    R2,R1,R0,R2
   \      0x2C0   0xE1A0'14A1        LSR      R1,R1,#+9
   \      0x2C4   0xE3A0'0968        MOV      R0,#+1703936
   \      0x2C8   0x....'....        BL       __aeabi_uidiv
   \      0x2CC   0xE1A0'3000        MOV      R3,R0
   \      0x2D0   0xE59A'0104        LDR      R0,[R10, #+260]
   \      0x2D4   0xE3A0'1064        MOV      R1,#+100
   \      0x2D8   0xE002'0091        MUL      R2,R1,R0
   \      0x2DC   0x....'....        LDR      LR,??DataTable11_12  ;; 0x9d89d89e
   \      0x2E0   0xE3A0'1000        MOV      R1,#+0
   \      0x2E4   0xE08C'EE92        UMULL    LR,R12,R2,LR
   \      0x2E8   0xE1A0'222C        LSR      R2,R12,#+4
   \      0x2EC   0xE289'00D4        ADD      R0,R9,#+212
   \      0x2F0   0x....'....        BL       printf
   \      0x2F4   0xE59A'2104        LDR      R2,[R10, #+260]
   \      0x2F8   0xE3A0'1000        MOV      R1,#+0
   \      0x2FC   0xE1A0'2802        LSL      R2,R2,#+16
   \      0x300   0xE1A0'2822        LSR      R2,R2,#+16
   \      0x304   0xE1A0'0008        MOV      R0,R8
   \      0x308   0x....'....        BL       pwmc_set_duty_cycle
   \      0x30C   0xE3A0'0032        MOV      R0,#+50
   \      0x310   0x....'....        BL       msleep
   \      0x314   0xE5DA'1108        LDRB     R1,[R10, #+264]
   \      0x318   0xE59A'0104        LDR      R0,[R10, #+260]
   \      0x31C   0xE351'0000        CMP      R1,#+0
   \      0x320   0x0A00'0005        BEQ      ??main_8
   \      0x324   0xE350'0019        CMP      R0,#+25
   \      0x328   0x23A0'0000        MOVCS    R0,#+0
   \      0x32C   0x3280'1001        ADDCC    R1,R0,#+1
   \      0x330   0x25CA'0108        STRBCS   R0,[R10, #+264]
   \      0x334   0x358A'1104        STRCC    R1,[R10, #+260]
   \      0x338   0xEAFF'FF6F        B        ??main_0
   \                     ??main_8:
   \      0x33C   0xE350'0000        CMP      R0,#+0
   \      0x340   0x1240'0001        SUBNE    R0,R0,#+1
   \      0x344   0x03A0'1001        MOVEQ    R1,#+1
   \      0x348   0x158A'0104        STRNE    R0,[R10, #+260]
   \      0x34C   0x05CA'1108        STRBEQ   R1,[R10, #+264]
   \      0x350   0xEAFF'FF69        B        ??main_0
    648          	}
    649          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     `main{1}{2}::pin_tioa0_connect`:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x2000'0000        DC32 536'870'912
   \        0x8   0x08 0x00          DC8 8, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x0A 0x0D          DC8      0x0A, 0x0D, 0x00, 0x00

   \              0x00 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     captured_rarb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x0009'0603        DC32     0x90603

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x8637'BD06        DC32     0x8637bd06

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0x8312'6E98        DC32     0x83126e98

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x9D89'D89E        DC32     0x9d89d89e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x20 0x20          DC8 "  -------------------------------------------\012\015"

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x0A    

   \              0x0D 0x00
   \       0x30   0x20 0x20          DC8 "  a: PWM operations for asynchronous channels \012\015"

   \              0x61 0x3A    

   \              0x20 0x50    

   \              0x57 0x4D    

   \              0x20 0x6F    

   \              0x70 0x65    

   \              0x72 0x61    

   \              0x74 0x69    

   \              0x6F 0x6E    

   \              0x73 0x20    

   \              0x66 0x6F    

   \              0x72 0x20    

   \              0x61 0x73    

   \              0x79 0x6E    

   \              0x63 0x68    

   \              0x72 0x6F    

   \              0x6E 0x6F    

   \              0x75 0x73    

   \              0x20 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x73 0x20    

   \              0x0A 0x0D    

   \              0x00
   \       0x61   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \       0x64   0x20 0x20          DC8 "  c: Capture waveform from TC capture channel \012\015"

   \              0x63 0x3A    

   \              0x20 0x43    

   \              0x61 0x70    

   \              0x74 0x75    

   \              0x72 0x65    

   \              0x20 0x77    

   \              0x61 0x76    

   \              0x65 0x66    

   \              0x6F 0x72    

   \              0x6D 0x20    

   \              0x66 0x72    

   \              0x6F 0x6D    

   \              0x20 0x54    

   \              0x43 0x20    

   \              0x63 0x61    

   \              0x70 0x74    

   \              0x75 0x72    

   \              0x65 0x20    

   \              0x63 0x68    

   \              0x61 0x6E    

   \              0x6E 0x65    

   \              0x6C 0x20    

   \              0x0A 0x0D    

   \              0x00
   \       0x95   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \       0x98   0x20 0x20          DC8 "  -------------------------------------------\012\015\012\015"

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x2D    

   \              0x2D 0x0A    

   \              0x0D 0x0A    

   \              0x0D 0x00
   \       0xCA   0x00 0x00          DC8 0, 0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x50 0x57          DC8 "PWM Example"

   \              0x4D 0x20    

   \              0x45 0x78    

   \              0x61 0x6D    

   \              0x70 0x6C    

   \              0x65 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x49 0x6E          DC8 "Input %c\012\015"

   \              0x70 0x75    

   \              0x74 0x20    

   \              0x25 0x63    

   \              0x0A 0x0D    

   \              0x00
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x73 0x6F          DC8 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x3D

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x3D
   \        0x8   0x3D 0x20          DC8 0x3D, 0x20, 0x67, 0x65, 0x74, 0x5F, 0x74, 0x63

   \              0x67 0x65    

   \              0x74 0x5F    

   \              0x74 0x63
   \       0x10   0x5F 0x69          DC8 0x5F, 0x69, 0x64, 0x5F, 0x66, 0x72, 0x6F, 0x6D

   \              0x64 0x5F    

   \              0x66 0x72    

   \              0x6F 0x6D
   \       0x18   0x5F 0x61          DC8 0x5F, 0x61, 0x64, 0x64, 0x72, 0x28, 0x74, 0x63

   \              0x64 0x64    

   \              0x72 0x28    

   \              0x74 0x63
   \       0x20   0x5F 0x63          DC8 0x5F, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65

   \              0x61 0x70    

   \              0x74 0x75    

   \              0x72 0x65
   \       0x28   0x2E 0x61          DC8 0x2E, 0x61, 0x64, 0x64, 0x72, 0x2C, 0x20, 0x74

   \              0x64 0x64    

   \              0x72 0x2C    

   \              0x20 0x74
   \       0x30   0x63 0x5F          DC8 0x63, 0x5F, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72

   \              0x63 0x61    

   \              0x70 0x74    

   \              0x75 0x72
   \       0x38   0x65 0x2E          DC8 0x65, 0x2E, 0x63, 0x68, 0x61, 0x6E, 0x6E, 0x65

   \              0x63 0x68    

   \              0x61 0x6E    

   \              0x6E 0x65
   \       0x40   0x6C 0x29          DC8 0x6C, 0x29, 0

   \              0x00
   \       0x43   0x00               DC8 0
   \       0x44   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \       0x4C   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x54   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x5C   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x64   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x6C   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x74   0x37 0x5C          DC8 0x37, 0x5C, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C

   \              0x65 0x78    

   \              0x61 0x6D    

   \              0x70 0x6C
   \       0x7C   0x65 0x73          DC8 0x65, 0x73, 0x5C, 0x70, 0x77, 0x6D, 0x5C, 0x6D

   \              0x5C 0x70    

   \              0x77 0x6D    

   \              0x5C 0x6D
   \       0x84   0x61 0x69          DC8 0x61, 0x69, 0x6E, 0x2E, 0x63, 0

   \              0x6E 0x2E    

   \              0x63 0x00
   \       0x8A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x43 0x61          DC8 "Capturing, can not start new capture\012\015"

   \              0x70 0x74    

   \              0x75 0x72    

   \              0x69 0x6E    

   \              0x67 0x2C    

   \              0x20 0x63    

   \              0x61 0x6E    

   \              0x20 0x6E    

   \              0x6F 0x74    

   \              0x20 0x73    

   \              0x74 0x61    

   \              0x72 0x74    

   \              0x20 0x6E    

   \              0x65 0x77    

   \              0x20 0x63    

   \              0x61 0x70    

   \              0x74 0x75    

   \              0x72 0x65    

   \              0x0A 0x0D    

   \              0x00
   \       0x27   0x00               DC8 0
   \       0x28   0x53 0x74          DC8 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61

   \              0x61 0x72    

   \              0x74 0x20    

   \              0x63 0x61
   \       0x30   0x70 0x74          DC8 0x70, 0x74, 0x75, 0x72, 0x65, 0x2C, 0x20, 0x72

   \              0x75 0x72    

   \              0x65 0x2C    

   \              0x20 0x72
   \       0x38   0x65 0x73          DC8 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x77, 0x69

   \              0x75 0x6C    

   \              0x74 0x20    

   \              0x77 0x69
   \       0x40   0x6C 0x6C          DC8 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x64, 0x75

   \              0x20 0x62    

   \              0x65 0x20    

   \              0x64 0x75
   \       0x48   0x6D 0x70          DC8 0x6D, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20

   \              0x65 0x64    

   \              0x20 0x74    

   \              0x6F 0x20
   \       0x50   0x63 0x6F          DC8 0x63, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x20

   \              0x6E 0x73    

   \              0x6F 0x6C    

   \              0x65 0x20
   \       0x58   0x77 0x68          DC8 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6E

   \              0x65 0x6E    

   \              0x20 0x66    

   \              0x69 0x6E
   \       0x60   0x69 0x73          DC8 0x69, 0x73, 0x68, 0x65, 0x64, 0x2E, 0x0A, 0x0D

   \              0x68 0x65    

   \              0x64 0x2E    

   \              0x0A 0x0D
   \       0x68   0x00               DC8 0
   \       0x69   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \       0x6C   0x0A 0x0D          DC8 "\012\015Captured %u pulses from TC capture channel:\012\015"

   \              0x43 0x61    

   \              0x70 0x74    

   \              0x75 0x72    

   \              0x65 0x64    

   \              0x20 0x25    

   \              0x75 0x20    

   \              0x70 0x75    

   \              0x6C 0x73    

   \              0x65 0x73    

   \              0x20 0x66    

   \              0x72 0x6F    

   \              0x6D 0x20    

   \              0x54 0x43    

   \              0x20 0x63    

   \              0x61 0x70    

   \              0x74 0x75    

   \              0x72 0x65    

   \              0x20 0x63    

   \              0x68 0x61    

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x3A 0x0A    

   \              0x0D 0x00
   \       0x9C   0x43 0x61          DC8 0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x64

   \              0x70 0x74    

   \              0x75 0x72    

   \              0x65 0x64
   \       0xA4   0x5B 0x25          DC8 0x5B, 0x25, 0x64, 0x5D, 0x20, 0x66, 0x72, 0x65

   \              0x64 0x5D    

   \              0x20 0x66    

   \              0x72 0x65
   \       0xAC   0x71 0x75          DC8 0x71, 0x75, 0x65, 0x6E, 0x63, 0x79, 0x20, 0x3D

   \              0x65 0x6E    

   \              0x63 0x79    

   \              0x20 0x3D
   \       0xB4   0x20 0x25          DC8 0x20, 0x25, 0x64, 0x20, 0x48, 0x7A, 0x2C, 0x20

   \              0x64 0x20    

   \              0x48 0x7A    

   \              0x2C 0x20
   \       0xBC   0x44 0x75          DC8 0x44, 0x75, 0x74, 0x79, 0x20, 0x63, 0x79, 0x63

   \              0x74 0x79    

   \              0x20 0x63    

   \              0x79 0x63
   \       0xC4   0x6C 0x65          DC8 0x6C, 0x65, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x25

   \              0x20 0x3D    

   \              0x20 0x25    

   \              0x64 0x25
   \       0xCC   0x25 0x20          DC8 0x25, 0x20, 0x0A, 0x0D, 0

   \              0x0A 0x0D    

   \              0x00
   \       0xD1   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \       0xD4   0x2D 0x2D          DC8 0x2D, 0x2D, 0x20, 0x50, 0x57, 0x4D, 0x20, 0x43

   \              0x20 0x50    

   \              0x57 0x4D    

   \              0x20 0x43
   \       0xDC   0x68 0x61          DC8 0x68, 0x61, 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x25

   \              0x6E 0x6E    

   \              0x65 0x6C    

   \              0x20 0x25
   \       0xE4   0x75 0x20          DC8 0x75, 0x20, 0x44, 0x75, 0x74, 0x79, 0x20, 0x63

   \              0x44 0x75    

   \              0x74 0x79    

   \              0x20 0x63
   \       0xEC   0x79 0x63          DC8 0x79, 0x63, 0x6C, 0x65, 0x3A, 0x20, 0x25, 0x6C

   \              0x6C 0x65    

   \              0x3A 0x20    

   \              0x25 0x6C
   \       0xF4   0x75 0x25          DC8 0x75, 0x25, 0x25, 0x20, 0x53, 0x69, 0x67, 0x6E

   \              0x25 0x20    

   \              0x53 0x69    

   \              0x67 0x6E
   \       0xFC   0x61 0x6C          DC8 0x61, 0x6C, 0x20, 0x50, 0x65, 0x72, 0x69, 0x6F

   \              0x20 0x50    

   \              0x65 0x72    

   \              0x69 0x6F
   \      0x104   0x64 0x3A          DC8 0x64, 0x3A, 0x20, 0x25, 0x6C, 0x75, 0x20, 0x6D

   \              0x20 0x25    

   \              0x6C 0x75    

   \              0x20 0x6D
   \      0x10C   0x73 0x2D          DC8 0x73, 0x2D, 0x2D, 0x0A, 0x0D, 0

   \              0x2D 0x0A    

   \              0x0D 0x00
   \      0x112   0x00 0x00          DC8 0, 0
   \      0x114   0x43 0x6F          DC8 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75, 0x72

   \              0x6E 0x66    

   \              0x69 0x67    

   \              0x75 0x72
   \      0x11C   0x65 0x20          DC8 0x65, 0x20, 0x54, 0x43, 0x20, 0x63, 0x68, 0x61

   \              0x54 0x43    

   \              0x20 0x63    

   \              0x68 0x61
   \      0x124   0x6E 0x6E          DC8 0x6E, 0x6E, 0x65, 0x6C, 0x20, 0x25, 0x64, 0x20

   \              0x65 0x6C    

   \              0x20 0x25    

   \              0x64 0x20
   \      0x12C   0x61 0x73          DC8 0x61, 0x73, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75

   \              0x20 0x63    

   \              0x61 0x70    

   \              0x74 0x75
   \      0x134   0x72 0x65          DC8 0x72, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61

   \              0x20 0x6F    

   \              0x70 0x65    

   \              0x72 0x61
   \      0x13C   0x74 0x69          DC8 0x74, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x6F, 0x64

   \              0x6E 0x67    

   \              0x20 0x6D    

   \              0x6F 0x64
   \      0x144   0x65 0x20          DC8 0x65, 0x20, 0x0A, 0x0D, 0

   \              0x0A 0x0D    

   \              0x00
   \      0x149   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \      0x14C   0x2D 0x2D          DC8 "-- PWM Peripheral Clock: %u MHz --\012\015"

   \              0x20 0x50    

   \              0x57 0x4D    

   \              0x20 0x50    

   \              0x65 0x72    

   \              0x69 0x70    

   \              0x68 0x65    

   \              0x72 0x61    

   \              0x6C 0x20    

   \              0x43 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x3A    

   \              0x20 0x25    

   \              0x75 0x20    

   \              0x4D 0x48    

   \              0x7A 0x20    

   \              0x2D 0x2D    

   \              0x0A 0x0D    

   \              0x00
   \      0x171   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x65, 0x78

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x65 0x78
   \       0x38   0x61 0x6D          DC8 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x73, 0x5C, 0x70

   \              0x70 0x6C    

   \              0x65 0x73    

   \              0x5C 0x70
   \       0x40   0x77 0x6D          DC8 0x77, 0x6D, 0x5C, 0x6D, 0x61, 0x69, 0x6E, 0x2E

   \              0x5C 0x6D    

   \              0x61 0x69    

   \              0x6E 0x2E
   \       0x48   0x63 0x3A          DC8 0x63, 0x3A, 0x34, 0x31, 0x35, 0x20, 0x50, 0x57

   \              0x34 0x31    

   \              0x35 0x20    

   \              0x50 0x57
   \       0x50   0x4D 0x20          DC8 0x4D, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65

   \              0x68 0x61    

   \              0x6E 0x64    

   \              0x6C 0x65
   \       0x58   0x72 0x2C          DC8 0x72, 0x2C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72

   \              0x20 0x69    

   \              0x6E 0x74    

   \              0x65 0x72
   \       0x60   0x72 0x75          DC8 0x72, 0x75, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61

   \              0x70 0x74    

   \              0x20 0x73    

   \              0x74 0x61
   \       0x68   0x74 0x75          DC8 0x74, 0x75, 0x73, 0x20, 0x30, 0x78, 0x25, 0x30

   \              0x73 0x20    

   \              0x30 0x78    

   \              0x25 0x30
   \       0x70   0x38 0x78          DC8 0x38, 0x78, 0x20, 0

   \              0x20 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x0A 0x0D          DC8 "\012\015Menu :\012\015"

   \              0x4D 0x65    

   \              0x6E 0x75    

   \              0x20 0x3A    

   \              0x0A 0x0D    

   \              0x00
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x20 0x20          DC8 "  h: Display menu \012\015"

   \              0x68 0x3A    

   \              0x20 0x44    

   \              0x69 0x73    

   \              0x70 0x6C    

   \              0x61 0x79    

   \              0x20 0x6D    

   \              0x65 0x6E    

   \              0x75 0x20    

   \              0x0A 0x0D    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x0A 0x0D          DC8 "\012\015"

   \              0x00
   \        0x3   0x00               DC8 0
    650          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _display_menu
         0   -> printf
         8   -> printf
       8   _pwm_handler
         0   -> printf
         8   -> pwmc_get_it_status1
      24   _tc_capture_handler
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> get_tc_id_from_addr
        24   -> tc_get_ra_rb_rc
        24   -> tc_get_status
         0   -> tc_stop
      40   main
        40   -> _display_menu
        40   -> console_example_info
        40   -> console_get_char
        40   -> console_is_rx_ready
        40   -> get_pwm_id_from_addr
        40   -> get_tc_id_from_addr
        40   -> irq_add_handler
        40   -> irq_enable
        40   -> msleep
        40   -> pio_configure
        40   -> pmc_configure_peripheral
        40   -> pmc_get_peripheral_clock
        40   -> printf
        40   -> pwmc_configure_channel
        40   -> pwmc_configure_clocks
        40   -> pwmc_disable_channel
        40   -> pwmc_enable_channel
        40   -> pwmc_set_duty_cycle
        40   -> pwmc_set_period
        40   -> tc_configure
        40   -> tc_enable_it
        40   -> tc_get_available_freq
        40   -> tc_start
        40 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
     204  ?_0
     116  ?_13
      12  ?_14
      24  ?_15
       4  ?_16
      12  ?_17
      12  ?_18
     140  ?_4
     372  ?_6
      60  _display_menu
      52  _pwm_handler
     152  _tc_capture_handler
     265  captured_rarb
          captured_pulses
          duty_cycle
          duty_cycle_inc
     852  main
      16  pin_tioa0_connect
      16  pins_pwm
      16  pins_tc_capture

 
   265 bytes in section .data
   872 bytes in section .rodata
 1'240 bytes in section SOFTPACK
 
 1'240 bytes of CODE  memory
   872 bytes of CONST memory
   265 bytes of DATA  memory

Errors: none
Warnings: none
