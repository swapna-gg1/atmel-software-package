###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         24/Nov/2020  14:00:49
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW5375.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_SRAM -D
#        CONFIG_ARCH_ARMV7A -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAMA5D4 -D
#        CONFIG_CHIP_SAMA5D44 -D CONFIG_BOARD_SAMA5D4_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_PIO3 -D CONFIG_HAVE_NFC -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SMC_SCRAMBLING -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_MPDDRC_LPDDR2 -D
#        CONFIG_HAVE_ADC_LOW_RES -D CONFIG_HAVE_PMC_PLLADIV2 -D
#        CONFIG_HAVE_PMC_H32MXDIV -D CONFIG_HAVE_PMC_UPLL_BIAS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_PWMC_SPREAD_SPECTRUM -D
#        CONFIG_HAVE_PWMC_FAULT_PROT_HIZ -D CONFIG_HAVE_PWMC_STEPPER_MOTOR -D
#        CONFIG_HAVE_PWMC_CMP_UNIT -D CONFIG_HAVE_PWMC_SYNC_MODE -D
#        CONFIG_HAVE_PWMC_OOV -D CONFIG_HAVE_PWMC_FMODE -D CONFIG_HAVE_PWMC_WP
#        -D CONFIG_HAVE_PWMC_DTIME -D CONFIG_HAVE_PWMC_ELINE -D
#        CONFIG_HAVE_L2CC -D CONFIG_HAVE_SAIC -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD -D CONFIG_HAVE_SFC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_SECURE_MATRIX -D
#        CONFIG_HAVE_DDR2_MT47H128M8 -D
#        CONFIG_HAVE_RSTC_CONFIGURABLE_USER_RESET -D
#        CONFIG_HAVE_RSTC_INDEPENDENT_RESET -D CONFIG_HAVE_TC_FAULT_MODE -D
#        CONFIG_HAVE_RTC_CALIBRATION -D CONFIG_HAVE_RTC_MODE_PERSIAN -D
#        CONFIG_HAVE_RTC_TAMPER -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_L2CACHE -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_UART -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_SPI_MODE -D CONFIG_HAVE_SERIALD_USART --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d4-ek\sram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d4-ek\sram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d4-ek\sram\Obj
#        --debug --endian=little --cpu=Cortex-A5 -e --fpu=VFPv4_D16
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\sama5d4\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -Oh)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d4-ek\sram\List\pmc.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sama5d4-ek\sram\Obj\pmc.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\drivers\peripherals\pmc.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2015, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /** \addtogroup pmc_module Working with PMC
     31           * \section Purpose
     32           * The PMC driver provides the Interface for configuration the Power Management
     33           *  Controller (PMC).
     34           *
     35           * \section Usage
     36           * <ul>
     37           * <li>  Enable & disable peripherals using pmc_enable_peripheral() and
     38           * pmc_enable_all_peripherals() or pmc_disable_peripheral() and
     39           * pmc_disable_all_peripherals().
     40           * <li>  Get & set maximum frequency clock for giving peripheral using
     41           * pmc_get_peri_max_freq() and pmc_set_peri_max_clock().
     42           * <li>  Get Peripheral Status for the given peripheral using pmc_is_periph_enabled()
     43           * <li>  Select clocks's source using pmc_select_external_crystal(),
     44           * pmc_select_internal_crystal(), pmc_select_external_osc() and pmc_select_internal_osc().
     45           * <li>  Switch MCK using pmc_switch_mck_to_pll(), pmc_switch_mck_to_main() and
     46           * pmc_switch_mck_to_slck().
     47           * <li>  Config PLL using pmc_set_pll_a() and pmc_disable_pll_a().
     48           * </li>
     49           * </ul>
     50           * For more accurate information, please look at the PMC section of the
     51           * Datasheet.
     52           *
     53           * Related files :\n
     54           * \ref pmc.c\n
     55           * \ref pmc.h\n
     56          */
     57          /*@{*/
     58          /*@}*/
     59          
     60          /**
     61           * \file
     62           *
     63           * Implementation of PIO (Parallel Input/Output) controller.
     64           *
     65           */
     66          /*----------------------------------------------------------------------------
     67           *        Headers
     68           *----------------------------------------------------------------------------*/
     69          
     70          #include <assert.h>
     71          #include <errno.h>
     72          #include <string.h>
     73          
     74          #include "chip.h"
     75          #include "timer.h"
     76          #include "peripherals/pmc.h"
     77          #include "peripherals/slowclock.h"
     78          #include "trace.h"
     79          #include "barriers.h"
     80          /*----------------------------------------------------------------------------
     81           *        Types
     82           *----------------------------------------------------------------------------*/
     83          
     84          struct _pmc_main_osc {
     85          	uint32_t rc_freq;
     86          	uint32_t crystal_freq;
     87          };
     88          
     89          #define OSC_STARTUP_TIME	0xFFu
     90          #define MAINFRDY_TIMEOUT	32000u
     91          #define MOSCXTS_TIMEOUT		((OSC_STARTUP_TIME * 8) + 8)
     92          #define MOSCSELS_TIMEOUT	32u
     93          
     94          /*----------------------------------------------------------------------------
     95           *        Variables
     96           *----------------------------------------------------------------------------*/
     97          

   \                                 In section .data, align 4
     98          RAMDATA static uint32_t _pmc_mck = 0;
     99          static struct _pmc_main_osc _pmc_main_oscillators = {
   \                     _pmc_main_oscillators:
   \        0x0   0x00B7'1B00        DC32 12'000'000
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x8   0x0000'0000        DC32 0
    100          	.rc_freq = MAIN_CLOCK_INT_OSC,
    101          };
    102          
    103          #ifdef CONFIG_RAMCODE
    104          	#define TRACE_FATAL(...) ((void)0)
    105          	#define _ASSERT(x) ((void)0)
    106          	#define _SLEEP(x) do { for(volatile uint32_t count = 0; count < 100; count++);} while(0)
    107          #else
    108          	#define TRACE_FATAL trace_fatal
    109          	#define _ASSERT assert
    110          	#define _SLEEP(x) do { usleep(x); } while(0)
    111          #endif
    112          
    113          /*----------------------------------------------------------------------------
    114           *        Private functions
    115           *----------------------------------------------------------------------------*/
    116          
    117          static void _pmc_compute_mck(void)
    118          {
    119          	uint32_t clk = 0;
    120          	uint32_t mckr = PMC->PMC_MCKR;
    121          
    122          	uint32_t css = mckr & PMC_MCKR_CSS_Msk;
    123          	switch (css) {
    124          	case PMC_MCKR_CSS_SLOW_CLK:
    125          		clk = pmc_get_slow_clock();
    126          		break;
    127          	case PMC_MCKR_CSS_MAIN_CLK:
    128          		clk = pmc_get_main_clock();
    129          		break;
    130          	case PMC_MCKR_CSS_PLLA_CLK:
    131          		clk = pmc_get_plla_clock();
    132          		break;
    133          	case PMC_MCKR_CSS_UPLL_CLK:
    134          		clk = pmc_get_upll_clock();
    135          		break;
    136          	default:
    137          		/* should never get here... */
    138          		break;
    139          	}
    140          
    141          	uint32_t pres = mckr & PMC_MCKR_PRES_Msk;
    142          	switch (pres) {
    143          	case PMC_MCKR_PRES_CLOCK:
    144          		break;
    145          	case PMC_MCKR_PRES_CLOCK_DIV2:
    146          		clk >>= 1;
    147          		break;
    148          	case PMC_MCKR_PRES_CLOCK_DIV4:
    149          		clk >>= 2;
    150          		break;
    151          	case PMC_MCKR_PRES_CLOCK_DIV8:
    152          		clk >>= 3;
    153          		break;
    154          	case PMC_MCKR_PRES_CLOCK_DIV16:
    155          		clk >>= 4;
    156          		break;
    157          	case PMC_MCKR_PRES_CLOCK_DIV32:
    158          		clk >>= 5;
    159          		break;
    160          	case PMC_MCKR_PRES_CLOCK_DIV64:
    161          		clk >>= 6;
    162          		break;
    163          #ifdef PMC_MCKR_PRES_CLOCK_DIV3
    164          	case PMC_MCKR_PRES_CLOCK_DIV3:
    165          		clk /= 3;
    166          		break;
    167          #endif
    168          	default:
    169          		/* should never get here... */
    170          		break;
    171          	}
    172          
    173          	uint32_t mdiv = mckr & PMC_MCKR_MDIV_Msk;
    174          	switch (mdiv) {
    175          	case PMC_MCKR_MDIV_EQ_PCK:
    176          		break;
    177          	case PMC_MCKR_MDIV_PCK_DIV2:
    178          		clk >>= 1; // divide by 2
    179          		break;
    180          	case PMC_MCKR_MDIV_PCK_DIV4:
    181          		clk >>= 2; // divide by 4
    182          		break;
    183          	case PMC_MCKR_MDIV_PCK_DIV3:
    184          		clk /= 3;  // divide by 3
    185          		break;
    186          	default:
    187          		/* should never get here... */
    188          		break;
    189          	}
    190          
    191          	_pmc_mck = clk;
    192          }
    193          
    194          static uint32_t _pmc_get_pck_clock(uint32_t index)
    195          {
    196          	uint32_t clk = 0;
    197          	uint32_t pck = PMC->PMC_PCK[index];
    198          
    199          	switch (pck & PMC_PCK_CSS_Msk) {
    200          	case PMC_PCK_CSS_SLOW_CLK:
    201          		clk = pmc_get_slow_clock();
    202          		break;
    203          	case PMC_PCK_CSS_MAIN_CLK:
    204          		clk = pmc_get_main_clock();
    205          		break;
    206          	case PMC_PCK_CSS_PLLA_CLK:
    207          		clk = pmc_get_plla_clock();
    208          		break;
    209          	case PMC_PCK_CSS_UPLL_CLK:
    210          		clk = pmc_get_upll_clock();
    211          		break;
    212          	case PMC_PCK_CSS_MCK:
    213          		clk = pmc_get_master_clock();
    214          		break;
    215          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
    216          	case PMC_PCK_CSS_AUDIO_CLK:
    217          		clk = pmc_get_audio_pmc_clock();
    218          		break;
    219          #endif
    220          	}
    221          
    222          	uint32_t prescaler = (pck & PMC_PCK_PRES_Msk) >> PMC_PCK_PRES_Pos;
    223          	return clk / (prescaler + 1);
    224          }
    225          

   \                                 In section SOFTPACK, align 4, keep-with-next
    226          RAMCODE static bool _pmc_get_system_clock_bits(enum _pmc_system_clock clock,
    227          	uint32_t *scer, uint32_t* scdr, uint32_t *scsr)
    228          {
    229          	uint32_t e, d, s;
    230          
    231          	switch (clock)
   \                     _pmc_get_system_clock_bits:
   \        0x0   0xE350'0007        CMP      R0,#+7
   \        0x4   0xE92D'4000        PUSH     {LR}
   \        0x8   0x8A00'001A        BHI      ??_pmc_get_system_clock_bits_1
   \        0xC   0xE7DF'C000        LDRB     R12,[PC, R0]
   \       0x10   0xE08F'F10C        ADD      PC,PC,R12, LSL #+2
   \                     ??_pmc_get_system_clock_bits_0:
   \       0x14   0x01 0x03          DC8      0x1,0x3,0x5,0x7

   \              0x05 0x07
   \       0x18   0x09 0x0B          DC8      0x9,0xB,0xD,0xF

   \              0x0D 0x0F
    232          	{
    233          #ifdef PMC_SCER_DDRCK
    234          	case PMC_SYSTEM_CLOCK_DDR:
    235          		e = PMC_SCER_DDRCK;
   \                     ??_pmc_get_system_clock_bits_2:
   \       0x1C   0xE3A0'0004        MOV      R0,#+4
    236          		d = PMC_SCDR_DDRCK;
   \       0x20   0xEA00'000C        B        ??_pmc_get_system_clock_bits_3
    237          		s = PMC_SCSR_DDRCK;
    238          		break;
    239          #endif
    240          #ifdef PMC_SCER_LCDCK
    241          	case PMC_SYSTEM_CLOCK_LCD:
    242          		e = PMC_SCER_LCDCK;
   \                     ??_pmc_get_system_clock_bits_4:
   \       0x24   0xE3A0'0008        MOV      R0,#+8
    243          		d = PMC_SCDR_LCDCK;
   \       0x28   0xEA00'000A        B        ??_pmc_get_system_clock_bits_3
    244          		s = PMC_SCSR_LCDCK;
    245          		break;
    246          #endif
    247          #ifdef PMC_SCER_SMDCK
    248          	case PMC_SYSTEM_CLOCK_SMD:
    249          		e = PMC_SCER_SMDCK;
   \                     ??_pmc_get_system_clock_bits_5:
   \       0x2C   0xE3A0'0010        MOV      R0,#+16
    250          		d = PMC_SCDR_SMDCK;
   \       0x30   0xEA00'0008        B        ??_pmc_get_system_clock_bits_3
    251          		s = PMC_SCSR_SMDCK;
    252          		break;
    253          #endif
    254          #ifdef PMC_SCER_UHP
    255          	case PMC_SYSTEM_CLOCK_UHP:
    256          		e = PMC_SCER_UHP;
   \                     ??_pmc_get_system_clock_bits_6:
   \       0x34   0xE3A0'0040        MOV      R0,#+64
    257          		d = PMC_SCDR_UHP;
   \       0x38   0xEA00'0006        B        ??_pmc_get_system_clock_bits_3
    258          		s = PMC_SCSR_UHP;
    259          		break;
    260          #endif
    261          #ifdef PMC_SCER_UDP
    262          	case PMC_SYSTEM_CLOCK_UDP:
    263          		e = PMC_SCER_UDP;
   \                     ??_pmc_get_system_clock_bits_7:
   \       0x3C   0xE3A0'0080        MOV      R0,#+128
    264          		d = PMC_SCDR_UDP;
   \       0x40   0xEA00'0004        B        ??_pmc_get_system_clock_bits_3
    265          		s = PMC_SCSR_UDP;
    266          		break;
    267          #endif
    268          #ifdef PMC_SCER_PCK0
    269          	case PMC_SYSTEM_CLOCK_PCK0:
    270          		e = PMC_SCER_PCK0;
   \                     ??_pmc_get_system_clock_bits_8:
   \       0x44   0xE3A0'0F40        MOV      R0,#+256
    271          		d = PMC_SCDR_PCK0;
   \       0x48   0xEA00'0002        B        ??_pmc_get_system_clock_bits_3
    272          		s = PMC_SCSR_PCK0;
    273          		break;
    274          #endif
    275          #ifdef PMC_SCER_PCK1
    276          	case PMC_SYSTEM_CLOCK_PCK1:
    277          		e = PMC_SCER_PCK1;
   \                     ??_pmc_get_system_clock_bits_9:
   \       0x4C   0xE3A0'0F80        MOV      R0,#+512
    278          		d = PMC_SCDR_PCK1;
   \       0x50   0xEA00'0000        B        ??_pmc_get_system_clock_bits_3
    279          		s = PMC_SCSR_PCK1;
    280          		break;
    281          #endif
    282          #ifdef PMC_SCER_PCK2
    283          	case PMC_SYSTEM_CLOCK_PCK2:
    284          		e = PMC_SCER_PCK2;
   \                     ??_pmc_get_system_clock_bits_10:
   \       0x54   0xE3A0'0E40        MOV      R0,#+1024
    285          		d = PMC_SCDR_PCK2;
    286          		s = PMC_SCSR_PCK2;
    287          		break;
    288          #endif
    289          #ifdef PMC_SCER_PCK3
    290          	case PMC_SYSTEM_CLOCK_PCK3:
    291          		e = PMC_SCER_PCK3;
    292          		d = PMC_SCDR_PCK3;
    293          		s = PMC_SCSR_PCK3;
    294          		break;
    295          #endif
    296          #ifdef PMC_SCER_PCK4
    297          	case PMC_SYSTEM_CLOCK_PCK4:
    298          		e = PMC_SCER_PCK4;
    299          		d = PMC_SCDR_PCK4;
    300          		s = PMC_SCSR_PCK4;
    301          		break;
    302          #endif
    303          #ifdef PMC_SCER_PCK5
    304          	case PMC_SYSTEM_CLOCK_PCK5:
    305          		e = PMC_SCER_PCK5;
    306          		d = PMC_SCDR_PCK5;
    307          		s = PMC_SCSR_PCK5;
    308          		break;
    309          #endif
    310          #ifdef PMC_SCER_PCK6
    311          	case PMC_SYSTEM_CLOCK_PCK6:
    312          		e = PMC_SCER_PCK6;
    313          		d = PMC_SCDR_PCK6;
    314          		s = PMC_SCSR_PCK6;
    315          		break;
    316          #endif
    317          #ifdef PMC_SCER_ISCCK
    318          	case PMC_SYSTEM_CLOCK_ISC:
    319          		e = PMC_SCER_ISCCK;
    320          		d = PMC_SCDR_ISCCK;
    321          		s = PMC_SCSR_ISCCK;
    322          		break;
    323          #endif
    324          #ifdef PMC_SCER_QSPICLK
    325          	case PMC_SYSTEM_CLOCK_QSPI:
    326          		e = PMC_SCER_QSPICLK;
    327          		d = PMC_SCDR_QSPICLK;
    328          		s = PMC_SCSR_QSPICLK;
    329          		break;
    330          #endif
    331          	default:
    332          		return false;
    333          	}
    334          
    335          	if (scer) {
   \                     ??_pmc_get_system_clock_bits_3:
   \       0x58   0xE351'0000        CMP      R1,#+0
    336          		if (e)
    337          			*scer = e;
   \       0x5C   0x1581'0000        STRNE    R0,[R1, #+0]
    338          		else
    339          			return false;
    340          	}
    341          
    342          	if (scdr) {
   \       0x60   0xE352'0000        CMP      R2,#+0
    343          		if (d)
    344          			*scdr = d;
   \       0x64   0x1582'0000        STRNE    R0,[R2, #+0]
    345          		else
    346          			return false;
    347          	}
    348          
    349          	if (scsr) {
   \       0x68   0xE353'0000        CMP      R3,#+0
    350          		if (s)
    351          			*scsr = s;
   \       0x6C   0x1583'0000        STRNE    R0,[R3, #+0]
    352          		else
    353          			return false;
    354          	}
    355          
    356          	return true;
   \       0x70   0xE3A0'0001        MOV      R0,#+1
   \       0x74   0xE8BD'8000        POP      {PC}             ;; return
   \                     ??_pmc_get_system_clock_bits_1:
   \       0x78   0xE3A0'0000        MOV      R0,#+0
   \       0x7C   0xE8BD'8000        POP      {PC}
    357          }
    358          
    359          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
    360          static void _pmc_configure_peripheral_div(uint32_t id, uint32_t div)
    361          {
    362          	uint32_t clk_max;
    363          	bool can_divide;
    364          
    365          	can_divide = peripheral_has_clock_div(id);
    366          	clk_max = get_peripheral_clock_max_freq(id);
    367          
    368          	if (div == 0) {
    369          		if (can_divide) {
    370          			for (div = 0; div < ((PMC_PCR_DIV_Msk >> PMC_PCR_DIV_Pos)); div++)
    371          				if ((pmc_get_master_clock() >> div) <= clk_max)
    372          					break;
    373          		}
    374          	} else {
    375          		if (div > 1 && !can_divide)
    376          			TRACE_FATAL("Peripheral does not support divided clock\r\n");
    377          		div--;
    378          	}
    379          
    380          	if ((pmc_get_master_clock() >> div) <= clk_max) {
    381          		PMC->PMC_PCR = PMC_PCR_PID(id);
    382          		volatile uint32_t pcr = PMC->PMC_PCR;
    383          		PMC->PMC_PCR = (pcr & ~PMC_PCR_DIV_Msk) | PMC_PCR_DIV(div) | PMC_PCR_CMD;
    384          	} else {
    385          		TRACE_FATAL("Peripheral clock for periph#%d is too high\r\n", (int)id);
    386          	}
    387          }
    388          #endif
    389          

   \                                 In section SOFTPACK, align 4, keep-with-next
    390          static uint16_t _pmc_measure_main_osc_freq(bool external_xt)
    391          {
   \                     _pmc_measure_main_osc_freq:
   \        0x0   0xE24D'D004        SUB      SP,SP,#+4
    392          	volatile uint32_t timeout = MAINFRDY_TIMEOUT;
   \        0x4   0xE3A0'0C7D        MOV      R0,#+32000
   \        0x8   0xE58D'0000        STR      R0,[SP, #+0]
    393          
    394          #ifdef CKGR_MCFR_CCSS
    395          	PMC->CKGR_MCFR = external_xt ? CKGR_MCFR_CCSS : 0;
    396          #endif
    397          
    398          #ifdef CKGR_MCFR_RCMEAS
    399          	PMC->CKGR_MCFR |= CKGR_MCFR_RCMEAS;
   \        0xC   0x....'....        LDR      R0,??DataTable41  ;; 0xf0018024
   \       0x10   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x14   0xE382'3940        ORR      R3,R2,#0x100000
   \       0x18   0xE580'3000        STR      R3,[R0, #+0]
    400          #endif
    401          	dsb();
   \       0x1C   0xF57F'F04F        dsb
    402          	while (!(PMC->CKGR_MCFR & CKGR_MCFR_MAINFRDY) && (--timeout > 0));
   \                     ??_pmc_measure_main_osc_freq_0:
   \       0x20   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x24   0xE31C'0B40        TST      R12,#0x10000
   \       0x28   0x1A00'0003        BNE      ??_pmc_measure_main_osc_freq_1
   \       0x2C   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x30   0xE252'1001        SUBS     R1,R2,#+1
   \       0x34   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x38   0x1AFF'FFF8        BNE      ??_pmc_measure_main_osc_freq_0
    403          	return (timeout ?
    404          		((PMC->CKGR_MCFR & CKGR_MCFR_MAINF_Msk) >> CKGR_MCFR_MAINF_Pos) :
    405          		0u);
   \                     ??_pmc_measure_main_osc_freq_1:
   \       0x3C   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x40   0xE352'0000        CMP      R2,#+0
   \       0x44   0x1590'0000        LDRNE    R0,[R0, #+0]
   \       0x48   0xE28D'D004        ADD      SP,SP,#+4
   \       0x4C   0x03A0'0000        MOVEQ    R0,#+0
   \       0x50   0xE6FF'0070        UXTH     R0,R0
   \       0x54   0xE12F'FF1E        BX       LR               ;; return
    406          }
    407          
    408          #if defined(PMC_PLL_UPDT_ID)
    409          RAMCODE static void _pmc_configure_pll(const struct _pmc_plla_cfg* plla)
    410          {
    411          	uint32_t reg;
    412          
    413          	if (plla->pll_id == PLL_ID_PLLA) {
    414          	} else if (plla->pll_id == PLL_ID_UPLL){
    415          		_ASSERT(plla->div == 1);
    416          	} else {
    417          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)plla->pll_id);
    418          	}
    419          
    420          	/* Follow the steps below to power-on a PLL: */
    421          	/* 1. Define the ID (ID=n) and startup time by configuring the fields PMC_PLL_UPDT.ID and
    422          	PMC_PLL_UPDT.STUPTIM. Set PMC_PLL_UPDT.UPDATE to '0'. */
    423          	reg = PMC->PMC_PLL_UPDT;
    424          	reg &= ~(PMC_PLL_UPDT_STUPTIM_Msk | PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
    425          	reg |= PMC_PLL_UPDT_STUPTIM(plla->count);
    426          	if (plla->pll_id)
    427          		reg |= PMC_PLL_UPDT_ID;
    428          	PMC->PMC_PLL_UPDT = reg;
    429          	
    430          	if ((PMC -> PMC_PLL_ACR & PMC_PLL_ACR_UTMIBG) != PMC_PLL_ACR_UTMIBG) {
    431          		/* 2. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    432          		reg = PMC->PMC_PLL_ACR;
    433          		reg |= PMC_PLL_ACR_UTMIBG;
    434          		PMC->PMC_PLL_ACR = reg;
    435          		/* 3. Wait 10 us. */
    436          		_SLEEP(10);
    437          	}
    438          
    439          	/* 2. Configure PMC_PLL_ACR.LOOP_FILTER. */
    440          	reg = PMC->PMC_PLL_ACR;
    441          	reg &= ~PMC_PLL_ACR_LOOP_FILTER_Msk;
    442          	reg |= PMC_PLL_ACR_LOOP_FILTER(plla->loop_filter);
    443          	PMC->PMC_PLL_ACR = reg;
    444          
    445          	/* 3. Define the MUL and FRACR to be applied to PLL(n) in PMC_PLL_CTRL1. */
    446          	PMC->PMC_PLL_CTRL1 = PMC_PLL_CTRL1_MUL(plla->mul) | PMC_PLL_CTRL1_FRACR(plla->fracr);
    447          
    448          	/* In case UPLL is being configured, follow Step 4. to Step 7., else jump to Step 8. */
    449          	if (plla->pll_id == PLL_ID_UPLL) {
    450          		/* 4. Write PMC_PLL_ACR.UTMIBG to '1' to enable the UTMI internal bandgap. */
    451          		reg = PMC->PMC_PLL_ACR;
    452          		reg |= PMC_PLL_ACR_UTMIBG;
    453          		PMC->PMC_PLL_ACR = reg;
    454          		/* 5. Wait 10 us. */
    455          		_SLEEP(10);
    456          
    457          		/* 6. Write PMC_PLL_ACR.UTMIVR to '1' to enable the UTMI internal regulator. */
    458          		reg = PMC->PMC_PLL_ACR;
    459          		reg |= PMC_PLL_ACR_UTMIVR;
    460          		PMC->PMC_PLL_ACR = reg;
    461          
    462          		/* 7. Wait 10 us. */
    463          		_SLEEP(10);
    464          	}
    465          
    466          	/* 8. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    467          	1, else the update is cancelled. */
    468          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
    469          
    470          	/* 9. In PMC_PLL_CTRL0, write a '1' to ENLOCK and to ENPLL and configure DIVPMC (for PLLA only,
    471          	as UPLL has a fixed divider value) and ENPLLCK. */
    472          	reg = PMC->PMC_PLL_CTRL0 & ~PMC_PLL_CTRL0_DIVPMC_Msk;
    473          	reg |= PMC_PLL_CTRL0_ENLOCK | PMC_PLL_CTRL0_ENPLL;
    474          	reg |= PMC_PLL_CTRL0_DIVPMC(plla->div) | PMC_PLL_CTRL0_ENPLLCK;
    475          	PMC->PMC_PLL_CTRL0 = reg;
    476          
    477          	/* 10. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    478          	1, else the update is cancelled. */
    479          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
    480          
    481          	/* 11. Wait for the lock bit to rise by polling the PMC_PLL_ISR0 or by enabling the corresponding interrupt
    482          	in PMC_PLL_IER. */
    483          	while ((PMC->PMC_PLL_ISR0 & (PMC_PLL_ISR0_LOCKA << plla->pll_id)) != (PMC_PLL_ISR0_LOCKA << plla->pll_id));
    484          
    485          	/* 12. Disable the interrupt (if enabled) */
    486          
    487          	/* 13. Enable the unlock interrupt to quickly detect a failure on the generation of the clock of the PLL. */
    488          	PMC->PMC_PLL_IER |= (PMC_PLL_IER_UNLOCKA << plla->pll_id);
    489          }
    490          
    491          RAMCODE static void _pmc_disable_pll(uint32_t pll_id)
    492          {
    493          	uint32_t reg;
    494          
    495          	if (pll_id == PLL_ID_PLLA) {
    496          	} else if (pll_id == PLL_ID_UPLL){
    497          	} else {
    498          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
    499          	}
    500          
    501          	/* To power-down a PLL, the following sequence must be applied: */
    502          	/* 1. If the PLL drives a section of the system that is active, modify the source clock of the system. */
    503          
    504          	/* 2. Define the ID (ID=n) of the PLL to be switched off in PMC_UPDT. The bit UPDATE in this register
    505          	must be set at 0 in this step. */
    506          	reg = PMC->PMC_PLL_UPDT;
    507          	reg &= ~(PMC_PLL_UPDT_UPDATE | PMC_PLL_UPDT_ID);
    508          	if (pll_id)
    509          		reg |= PMC_PLL_UPDT_ID;
    510          	PMC->PMC_PLL_UPDT = reg;
    511          
    512          	/* 3. In PMC_PLL_CTRL0, set ENPLLCK to 0 and leave ENPLL at '1'. */
    513          	reg = PMC->PMC_PLL_CTRL0 & (~PMC_PLL_CTRL0_ENPLLCK);
    514          	PMC->PMC_PLL_CTRL0 = reg | PMC_PLL_CTRL0_ENPLL;
    515          
    516          	/* 4. Set PMC_PLL_UPDT.UPDATE to '1'. PMC_PLL_UPDT.ID must equal the one written during step
    517          	2, else the update is cancelled. */
    518          	PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_UPDATE;
    519          
    520          	/* 5. Write a '0' to PMC_PLL_CTRL0.ENPLL. */
    521          	PMC->PMC_PLL_CTRL0 &= ~PMC_PLL_CTRL0_ENPLL;
    522          
    523          	/* 6. In case a UPLL is being powered down, write a '0' to PMC_PLL_ACR.UTMIBG and
    524          	PMC_PLL_ACR.UTMIVR. */
    525          	if (pll_id == PLL_ID_UPLL) {
    526          		reg = PMC->PMC_PLL_ACR;
    527          		reg &= ~(PMC_PLL_ACR_UTMIBG | PMC_PLL_ACR_UTMIVR);
    528          		PMC->PMC_PLL_ACR = reg;
    529          	}
    530          }
    531          
    532          static bool _pmc_pll_enabled(uint32_t pll_id)
    533          {
    534          	return (PMC->PMC_PLL_ISR0 & (1 << (pll_id & 0xf))) != 0;
    535          }
    536          
    537          static void _pmc_get_pll_config(uint32_t pll_id, struct _pmc_plla_cfg *plla)
    538          {
    539          #ifdef PMC_PLL_UPDT_ID_Msk
    540          	uint32_t pll_updt;
    541          
    542          	pll_updt = PMC->PMC_PLL_UPDT;
    543          	pll_updt = (pll_updt & ~PMC_PLL_UPDT_ID_Msk) | PMC_PLL_UPDT_ID(pll_id);
    544          	PMC->PMC_PLL_UPDT = pll_updt;
    545          #else
    546          	if (pll_id)
    547          		PMC->PMC_PLL_UPDT |= PMC_PLL_UPDT_ID;
    548          	else 
    549          		PMC->PMC_PLL_UPDT &= ~PMC_PLL_UPDT_ID;
    550          #endif
    551          
    552          	memset(plla, 0, sizeof(*plla));
    553          	plla->pll_id = pll_id;
    554          	plla->mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
    555          	plla->fracr = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_FRACR_Msk) >> PMC_PLL_CTRL1_FRACR_Pos;
    556          	plla->div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
    557          
    558          #if defined(CONFIG_SOC_SAM9X60)
    559          	/*
    560          	 * On SAM9X60, the value of DIVPMC in PMC_PLL_CTRL0 is ignored for the
    561          	 * USB PLL as there is a fixed hardware divider of 2. Hence, we should
    562          	 * always consider that DIVPMC is actually read as 1, whatever its real
    563          	 * value.
    564          	 */
    565          	if (pll_id)
    566          		plla->div = 1;
    567          #endif
    568          }
    569          
    570          static uint32_t _pmc_get_pll_clock(uint32_t pll_id)
    571          {
    572          	struct _pmc_plla_cfg plla;
    573          	uint32_t f_core, f_ref;
    574          
    575          	if (pll_id == PLL_ID_PLLA) {
    576          		f_ref = pmc_get_main_clock();
    577          	} else if (pll_id == PLL_ID_UPLL){
    578          		f_ref = pmc_get_main_oscillator_freq();
    579          	} else {
    580          		TRACE_FATAL("Unknown PLL which index is %d\r\n", (int)pll_id);
    581          	}
    582          
    583          	_pmc_get_pll_config(pll_id, &plla);
    584          
    585          	f_core = f_ref * (plla.mul + 1) + (uint32_t)((((uint64_t)f_ref) * plla.fracr) >> 22);
    586          	return f_core / (plla.div + 1);
    587          }
    588          #endif /* PMC_PLL_UPDT_ID */
    589          
    590          /*----------------------------------------------------------------------------
    591           *        Exported functions (General)
    592           *----------------------------------------------------------------------------*/
    593          

   \                                 In section SOFTPACK, align 4, keep-with-next
    594          uint32_t pmc_set_main_oscillator_freq(uint32_t freq)
    595          {
   \                     pmc_set_main_oscillator_freq:
   \        0x0   0xE92D'47F0        PUSH     {R4-R10,LR}
    596          	uint32_t mor, mckr, mckr_mask;
    597          #ifdef CKGR_PLLAR_MULA_Msk
    598          	uint32_t pllar;
    599          #endif
    600          	uint16_t mainf_rc, mainf_xt = 0;
    601          
    602          	_pmc_main_oscillators.crystal_freq = freq;
    603          	if (freq > 0)
   \        0x4   0xE350'0000        CMP      R0,#+0
   \        0x8   0x....'....        LDR      R4,??DataTable42
   \        0xC   0xE3A0'1000        MOV      R1,#+0
   \       0x10   0xE3A0'5000        MOV      R5,#+0
   \       0x14   0xE584'0004        STR      R0,[R4, #+4]
   \       0x18   0x1A00'0069        BNE      ??pmc_set_main_oscillator_freq_0
    604          		return freq;
    605          
    606          	/*
    607          	 * Save the current value of the CKGR_MCKR register then swith to
    608          	 * the slow clock.
    609          	 */
    610          	mckr = PMC->PMC_MCKR;
   \       0x1C   0x....'....        LDR      R6,??DataTable42_1  ;; 0xf0018020
   \       0x20   0xE596'7010        LDR      R7,[R6, #+16]
    611          	pmc_switch_mck_to_slck();
   \       0x24   0xE596'0010        LDR      R0,[R6, #+16]
   \       0x28   0xE3C0'2003        BIC      R2,R0,#0x3
   \       0x2C   0xE586'2010        STR      R2,[R6, #+16]
   \                     ??pmc_set_main_oscillator_freq_1:
   \       0x30   0xE596'3048        LDR      R3,[R6, #+72]
   \       0x34   0xE313'0008        TST      R3,#0x8
   \       0x38   0x0AFF'FFFC        BEQ      ??pmc_set_main_oscillator_freq_1
   \       0x3C   0xE584'1008        STR      R1,[R4, #+8]
    612          	mckr_mask = PMC_MCKR_MDIV_Msk | PMC_MCKR_PRES_Msk;
    613          	PMC->PMC_MCKR &= ~mckr_mask;
   \       0x40   0xE596'0010        LDR      R0,[R6, #+16]
   \       0x44   0xE3C0'1FDC        BIC      R1,R0,#0x370
   \       0x48   0xE586'1010        STR      R1,[R6, #+16]
    614          
    615          	/* Save the current value of the CKGR_MOR register. */
    616          	mor = PMC->CKGR_MOR;
   \       0x4C   0xE596'8000        LDR      R8,[R6, #+0]
    617          
    618          #ifdef CKGR_PLLAR_MULA_Msk
    619          	/*
    620          	 * Save the current value of the CKGR_PLLAR register then stop this
    621          	 * PLL, if needed.
    622          	 */
    623          	pllar = PMC->CKGR_PLLAR;
   \       0x50   0xE596'9008        LDR      R9,[R6, #+8]
    624          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk))
   \       0x54   0xE319'077F        TST      R9,#0x1FC0000
   \       0x58   0x0A00'0006        BEQ      ??pmc_set_main_oscillator_freq_2
   \       0x5C   0xE319'0001        TST      R9,#0x1
   \       0x60   0x0A00'0004        BEQ      ??pmc_set_main_oscillator_freq_2
    625          		PMC->CKGR_PLLAR &= ~(CKGR_PLLAR_MULA_Msk | CKGR_PLLAR_DIVA_Msk);
   \       0x64   0xE596'0008        LDR      R0,[R6, #+8]
   \       0x68   0xE3E0'1001        MVN      R1,#+1
   \       0x6C   0xE3C1'177F        BIC      R1,R1,#0x1FC0000
   \       0x70   0xE001'1000        AND      R1,R1,R0
   \       0x74   0xE586'1008        STR      R1,[R6, #+8]
    626          #endif
    627          
    628          	/* Switch to internal 12MHz RC, if needed. */
    629          	pmc_select_internal_osc();
   \                     ??pmc_set_main_oscillator_freq_2:
   \       0x78   0x....'....        BL       pmc_select_internal_osc
    630          
    631          	/* Measure the 12MHz RC frequency. */
    632          	mainf_rc = _pmc_measure_main_osc_freq(false);
   \       0x7C   0xE3A0'0000        MOV      R0,#+0
   \       0x80   0x....'....        BL       _pmc_measure_main_osc_freq
   \       0x84   0xE1A0'A000        MOV      R10,R0
    633          
    634          	/* Measure the crystal or by-pass frequency. */
    635          
    636          #ifdef CKGR_MOR_MOSCXTBY
    637          	/* Try by-pass first. */
    638          	if (pmc_select_external_osc(true) == 0)
   \       0x88   0xE3A0'0001        MOV      R0,#+1
   \       0x8C   0x....'....        BL       pmc_select_external_osc
   \       0x90   0xE350'0000        CMP      R0,#+0
   \       0x94   0x1A00'0003        BNE      ??pmc_set_main_oscillator_freq_3
    639          		mainf_xt = _pmc_measure_main_osc_freq(true);
   \       0x98   0xE3A0'0001        MOV      R0,#+1
   \       0x9C   0x....'....        BL       _pmc_measure_main_osc_freq
   \       0xA0   0xE1B0'5000        MOVS     R5,R0
    640          #endif /* CKGR_MOR_MOSCXTBY */
    641          
    642          	/* Then try external crytal if no by-pass. */
    643          	if (!mainf_xt) {
   \       0xA4   0x1A00'0006        BNE      ??pmc_set_main_oscillator_freq_4
    644          		if (pmc_select_external_osc(false) == 0)
   \                     ??pmc_set_main_oscillator_freq_3:
   \       0xA8   0xE3A0'0000        MOV      R0,#+0
   \       0xAC   0x....'....        BL       pmc_select_external_osc
   \       0xB0   0xE350'0000        CMP      R0,#+0
   \       0xB4   0x1A00'0002        BNE      ??pmc_set_main_oscillator_freq_4
    645          			mainf_xt = _pmc_measure_main_osc_freq(true);
   \       0xB8   0xE3A0'0001        MOV      R0,#+1
   \       0xBC   0x....'....        BL       _pmc_measure_main_osc_freq
   \       0xC0   0xE1A0'5000        MOV      R5,R0
    646          	}
    647          
    648          	/* Switch back to internal 12MHz RC if it was selected initially */
    649          	if (!(mor & CKGR_MOR_MOSCSEL))
   \                     ??pmc_set_main_oscillator_freq_4:
   \       0xC4   0xE318'0740        TST      R8,#0x1000000
   \       0xC8   0x1A00'0000        BNE      ??pmc_set_main_oscillator_freq_5
    650          		pmc_select_internal_osc();
   \       0xCC   0x....'....        BL       pmc_select_internal_osc
    651          
    652          #ifdef CKGR_MOR_MOSCRCEN
    653          	/* Disable internal oscillator if it wasn't enabled initially */
    654          	if (!(mor & CKGR_MOR_MOSCRCEN))
    655          		pmc_disable_internal_osc();
    656          #endif
    657          
    658          #ifdef CKGR_PLLAR_MULA_Msk
    659          	/* Restart the PLLA, if needed. */
    660          	if ((pllar & CKGR_PLLAR_MULA_Msk) && (pllar & CKGR_PLLAR_DIVA_Msk)) {
   \                     ??pmc_set_main_oscillator_freq_5:
   \       0xD0   0xE319'077F        TST      R9,#0x1FC0000
   \       0xD4   0x0A00'0005        BEQ      ??pmc_set_main_oscillator_freq_6
   \       0xD8   0xE319'0001        TST      R9,#0x1
   \       0xDC   0x0A00'0003        BEQ      ??pmc_set_main_oscillator_freq_6
    661          		PMC->CKGR_PLLAR = pllar;
   \       0xE0   0xE586'9008        STR      R9,[R6, #+8]
    662          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
   \                     ??pmc_set_main_oscillator_freq_7:
   \       0xE4   0xE596'0048        LDR      R0,[R6, #+72]
   \       0xE8   0xE310'0002        TST      R0,#0x2
   \       0xEC   0x0AFF'FFFC        BEQ      ??pmc_set_main_oscillator_freq_7
    663          	}
    664          #endif
    665          
    666          	/* Switch back to the former MCK source. */
    667          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~mckr_mask) | (mckr & mckr_mask);
   \                     ??pmc_set_main_oscillator_freq_6:
   \       0xF0   0xE596'1010        LDR      R1,[R6, #+16]
   \       0xF4   0xE207'2FDC        AND      R2,R7,#0x370
   \       0xF8   0xE3C1'0FDC        BIC      R0,R1,#0x370
   \       0xFC   0xE182'2000        ORR      R2,R2,R0
    668          	pmc_switch_mck_to_new_source(mckr & PMC_MCKR_CSS_Msk);
   \      0x100   0xE207'0003        AND      R0,R7,#0x3
   \      0x104   0xE586'2010        STR      R2,[R6, #+16]
   \      0x108   0x....'....        BL       pmc_switch_mck_to_new_source
    669          
    670          	/* Guess the external crystal frequency, if available. */
    671          	if (mainf_rc && mainf_xt) {
   \      0x10C   0xE35A'0000        CMP      R10,#+0
   \      0x110   0x0A00'002A        BEQ      ??pmc_set_main_oscillator_freq_8
   \      0x114   0xE1B0'0005        MOVS     R0,R5
   \      0x118   0x0A00'0028        BEQ      ??pmc_set_main_oscillator_freq_8
    672          		uint32_t ratio = (mainf_xt * 1000) / mainf_rc;
   \      0x11C   0xE3A0'1FFA        MOV      R1,#+1000
   \      0x120   0xE000'0591        MUL      R0,R1,R5
   \      0x124   0xE1A0'100A        MOV      R1,R10
   \      0x128   0x....'....        BL       __aeabi_idiv
    673          
    674          		// Use 10% low and high margins
    675          		if (3600 <= ratio && ratio <= 4400) {
   \      0x12C   0xE3E0'200F        MVN      R2,#+15
   \      0x130   0xE300'3321        MOVW     R3,#+801
   \      0x134   0xE3C2'2EE0        BIC      R2,R2,#0xE00
   \      0x138   0xE082'2000        ADD      R2,R2,R0
   \      0x13C   0xE152'0003        CMP      R2,R3
    676          			// 48/12 => ratio = 4000
    677          			_pmc_main_oscillators.crystal_freq = 48000000u;
   \      0x140   0x33A0'07B7        MOVCC    R0,#+47972352
   \      0x144   0x3380'0C6C        ORRCC    R0,R0,#0x6C00
   \      0x148   0x3A00'001B        BCC      ??pmc_set_main_oscillator_freq_9
    678          		} else if (1800 <= ratio && ratio <= 2200) {
   \      0x14C   0xE3E0'1007        MVN      R1,#+7
   \      0x150   0xE243'2F64        SUB      R2,R3,#+400
   \      0x154   0xE3C1'1E70        BIC      R1,R1,#0x700
   \      0x158   0xE081'1000        ADD      R1,R1,R0
   \      0x15C   0xE151'0002        CMP      R1,R2
    679          			// 24/12 => ratio = 2000
    680          			_pmc_main_oscillators.crystal_freq = 24000000u;
   \      0x160   0x....'....        LDRCC    R0,??DataTable49  ;; 0x16e3600
   \      0x164   0x3A00'0014        BCC      ??pmc_set_main_oscillator_freq_9
    681          		} else if (1200 <= ratio && ratio <= 1467) {
   \      0x168   0xE3E0'10AF        MVN      R1,#+175
   \      0x16C   0xE3C1'1E40        BIC      R1,R1,#0x400
   \      0x170   0xE081'1000        ADD      R1,R1,R0
   \      0x174   0xE351'0F43        CMP      R1,#+268
    682          			// 16/12 => ratio = 1333
    683          			_pmc_main_oscillators.crystal_freq = 16000000u;
   \      0x178   0x33A0'08F4        MOVCC    R0,#+15990784
   \      0x17C   0x3380'0D90        ORRCC    R0,R0,#0x2400
   \      0x180   0x3A00'000D        BCC      ??pmc_set_main_oscillator_freq_9
    684          		} else if (900 <= ratio && ratio <= 1100) {
   \      0x184   0xE3E0'1083        MVN      R1,#+131
   \      0x188   0xE3C1'1FC0        BIC      R1,R1,#0x300
   \      0x18C   0xE081'1000        ADD      R1,R1,R0
   \      0x190   0xE351'00C9        CMP      R1,#+201
    685          			// 12/12 => ratio = 1000
    686          			_pmc_main_oscillators.crystal_freq = 12000000u;
   \      0x194   0x33A0'08B7        MOVCC    R0,#+11993088
   \      0x198   0x3380'0D6C        ORRCC    R0,R0,#0x1B00
   \      0x19C   0x3A00'0006        BCC      ??pmc_set_main_oscillator_freq_9
    687          		} else if (600 <= ratio && ratio <= 733) {
   \      0x1A0   0xE3E0'1057        MVN      R1,#+87
   \      0x1A4   0xE3C1'1F80        BIC      R1,R1,#0x200
   \      0x1A8   0xE081'1000        ADD      R1,R1,R0
   \      0x1AC   0xE351'0086        CMP      R1,#+134
   \      0x1B0   0x2A00'0002        BCS      ??pmc_set_main_oscillator_freq_8
    688          			// 8/12 => ratio = 667
    689          			_pmc_main_oscillators.crystal_freq = 8000000u;
   \      0x1B4   0xE3A0'087A        MOV      R0,#+7995392
   \      0x1B8   0xE380'0D48        ORR      R0,R0,#0x1200
   \                     ??pmc_set_main_oscillator_freq_9:
   \      0x1BC   0xE584'0004        STR      R0,[R4, #+4]
    690          		}
    691          	}
    692          
    693          	return _pmc_main_oscillators.crystal_freq;
   \                     ??pmc_set_main_oscillator_freq_8:
   \      0x1C0   0xE594'0004        LDR      R0,[R4, #+4]
   \                     ??pmc_set_main_oscillator_freq_0:
   \      0x1C4   0xE8BD'87F0        POP      {R4-R10,PC}      ;; return
    694          }
    695          

   \                                 In section SOFTPACK, align 4, keep-with-next
    696          uint32_t pmc_get_main_oscillator_freq(void)
    697          {
    698          	if (_pmc_main_oscillators.crystal_freq > 0)
   \                     pmc_get_main_oscillator_freq:
   \        0x0   0x....'....        LDR      R0,??DataTable42
   \        0x4   0xE590'0004        LDR      R0,[R0, #+4]
   \        0x8   0xE350'0000        CMP      R0,#+0
    699          		return _pmc_main_oscillators.crystal_freq;
    700          	else
    701          		return pmc_set_main_oscillator_freq(0);
   \        0xC   0x....'....        BEQ      pmc_set_main_oscillator_freq  ;; tailcall
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
    702          }
    703          

   \                                 In section SOFTPACK, align 4, keep-with-next
    704          uint32_t pmc_get_master_clock(void)
    705          {
   \                     pmc_get_master_clock:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
    706          	if (!_pmc_mck)
   \        0x4   0x....'....        LDR      R4,??DataTable42
   \        0x8   0xE594'0008        LDR      R0,[R4, #+8]
   \        0xC   0xE350'0000        CMP      R0,#+0
   \       0x10   0x1A00'004A        BNE      ??pmc_get_master_clock_1
    707          		_pmc_compute_mck();
   \       0x14   0x....'....        LDR      R6,??DataTable42_1  ;; 0xf0018020
   \       0x18   0xE596'5010        LDR      R5,[R6, #+16]
   \       0x1C   0xE205'1003        AND      R1,R5,#0x3
   \       0x20   0xE351'0003        CMP      R1,#+3
   \       0x24   0x8A00'001E        BHI      ??pmc_get_master_clock_2
   \       0x28   0xE7DF'2001        LDRB     R2,[PC, R1]
   \       0x2C   0xE08F'F102        ADD      PC,PC,R2, LSL #+2
   \                     ??pmc_get_master_clock_0:
   \       0x30   0x1B 0x16          DC8      0x1B,0x16,0x4,0x0

   \              0x04 0x00
   \                     ??pmc_get_master_clock_3:
   \       0x34   0xE594'0004        LDR      R0,[R4, #+4]
   \       0x38   0xE080'3100        ADD      R3,R0,R0, LSL #+2
   \       0x3C   0xE1A0'0183        LSL      R0,R3,#+3
   \       0x40   0xEA00'0017        B        ??pmc_get_master_clock_2
   \                     ??pmc_get_master_clock_4:
   \       0x44   0xE596'1008        LDR      R1,[R6, #+8]
   \       0x48   0xE7E6'2951        UBFX     R2,R1,#+18,#+7
   \       0x4C   0xE211'1001        ANDS     R1,R1,#0x1
   \       0x50   0x0A00'0013        BEQ      ??pmc_get_master_clock_2
   \       0x54   0xE352'0000        CMP      R2,#+0
   \       0x58   0x0A00'0011        BEQ      ??pmc_get_master_clock_2
   \       0x5C   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x60   0xE282'2001        ADD      R2,R2,#+1
   \       0x64   0xE310'0740        TST      R0,#0x1000000
   \       0x68   0x1594'0004        LDRNE    R0,[R4, #+4]
   \       0x6C   0x0594'0000        LDREQ    R0,[R4, #+0]
   \       0x70   0xE000'0092        MUL      R0,R2,R0
   \       0x74   0xE596'6010        LDR      R6,[R6, #+16]
   \       0x78   0x....'....        BL       __aeabi_uidiv
   \       0x7C   0xE316'0D40        TST      R6,#0x1000
   \       0x80   0x0A00'0007        BEQ      ??pmc_get_master_clock_2
   \       0x84   0xE1A0'00A0        LSR      R0,R0,#+1
   \       0x88   0xEA00'0005        B        ??pmc_get_master_clock_2
   \                     ??pmc_get_master_clock_5:
   \       0x8C   0xE596'0000        LDR      R0,[R6, #+0]
   \       0x90   0xE310'0740        TST      R0,#0x1000000
   \       0x94   0x1594'0004        LDRNE    R0,[R4, #+4]
   \       0x98   0x0594'0000        LDREQ    R0,[R4, #+0]
   \       0x9C   0xEA00'0000        B        ??pmc_get_master_clock_2
   \                     ??pmc_get_master_clock_6:
   \       0xA0   0x....'....        BL       slowclock_get_clock
   \                     ??pmc_get_master_clock_2:
   \       0xA4   0xE205'1070        AND      R1,R5,#0x70
   \       0xA8   0xE351'0010        CMP      R1,#+16
   \       0xAC   0x0A00'0013        BEQ      ??pmc_get_master_clock_7
   \       0xB0   0xE351'0020        CMP      R1,#+32
   \       0xB4   0x0A00'000F        BEQ      ??pmc_get_master_clock_8
   \       0xB8   0xE351'0030        CMP      R1,#+48
   \       0xBC   0x0A00'000B        BEQ      ??pmc_get_master_clock_9
   \       0xC0   0xE351'0040        CMP      R1,#+64
   \       0xC4   0x0A00'0007        BEQ      ??pmc_get_master_clock_10
   \       0xC8   0xE351'0050        CMP      R1,#+80
   \       0xCC   0x0A00'0003        BEQ      ??pmc_get_master_clock_11
   \       0xD0   0xE351'0060        CMP      R1,#+96
   \       0xD4   0x1A00'000A        BNE      ??pmc_get_master_clock_12
   \       0xD8   0xE1A0'0320        LSR      R0,R0,#+6
   \       0xDC   0xEA00'0008        B        ??pmc_get_master_clock_12
   \                     ??pmc_get_master_clock_11:
   \       0xE0   0xE1A0'02A0        LSR      R0,R0,#+5
   \       0xE4   0xEA00'0006        B        ??pmc_get_master_clock_12
   \                     ??pmc_get_master_clock_10:
   \       0xE8   0xE1A0'0220        LSR      R0,R0,#+4
   \       0xEC   0xEA00'0004        B        ??pmc_get_master_clock_12
   \                     ??pmc_get_master_clock_9:
   \       0xF0   0xE1A0'01A0        LSR      R0,R0,#+3
   \       0xF4   0xEA00'0002        B        ??pmc_get_master_clock_12
   \                     ??pmc_get_master_clock_8:
   \       0xF8   0xE1A0'0120        LSR      R0,R0,#+2
   \       0xFC   0xEA00'0000        B        ??pmc_get_master_clock_12
   \                     ??pmc_get_master_clock_7:
   \      0x100   0xE1A0'00A0        LSR      R0,R0,#+1
   \                     ??pmc_get_master_clock_12:
   \      0x104   0xE205'1FC0        AND      R1,R5,#0x300
   \      0x108   0xE351'0F40        CMP      R1,#+256
   \      0x10C   0x0A00'0009        BEQ      ??pmc_get_master_clock_13
   \      0x110   0xE351'0F80        CMP      R1,#+512
   \      0x114   0x0A00'0005        BEQ      ??pmc_get_master_clock_14
   \      0x118   0xE351'0FC0        CMP      R1,#+768
   \      0x11C   0x1A00'0006        BNE      ??pmc_get_master_clock_15
   \      0x120   0x....'....        LDR      R12,??DataTable50  ;; 0xaaaaaaab
   \      0x124   0xE083'CC90        UMULL    R12,R3,R0,R12
   \      0x128   0xE1A0'00A3        LSR      R0,R3,#+1
   \      0x12C   0xEA00'0002        B        ??pmc_get_master_clock_15
   \                     ??pmc_get_master_clock_14:
   \      0x130   0xE1A0'0120        LSR      R0,R0,#+2
   \      0x134   0xEA00'0000        B        ??pmc_get_master_clock_15
   \                     ??pmc_get_master_clock_13:
   \      0x138   0xE1A0'00A0        LSR      R0,R0,#+1
   \                     ??pmc_get_master_clock_15:
   \      0x13C   0xE584'0008        STR      R0,[R4, #+8]
    708          	return _pmc_mck;
   \                     ??pmc_get_master_clock_1:
   \      0x140   0xE594'0008        LDR      R0,[R4, #+8]
   \      0x144   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    709          }
    710          

   \                                 In section SOFTPACK, align 4, keep-with-next
    711          uint32_t pmc_get_slow_clock(void)
    712          {
    713          	return slowclock_get_clock(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     pmc_get_slow_clock:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0x....'....        B        slowclock_get_clock  ;; tailcall
    714          }
    715          

   \                                 In section SOFTPACK, align 4, keep-with-next
    716          uint32_t pmc_get_main_clock(void)
    717          {
    718          	if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)
   \                     pmc_get_main_clock:
   \        0x0   0x....'....        LDR      R1,??DataTable42_1  ;; 0xf0018020
   \        0x4   0x....'....        LDR      R0,??DataTable42
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
   \        0xC   0xE312'0740        TST      R2,#0x1000000
    719          		return _pmc_main_oscillators.crystal_freq; /* external crystal */
   \       0x10   0x1590'0004        LDRNE    R0,[R0, #+4]
    720          	else
    721          		return _pmc_main_oscillators.rc_freq; /* on-chip main clock RC */
   \       0x14   0x0590'0000        LDREQ    R0,[R0, #+0]
   \       0x18   0xE12F'FF1E        BX       LR               ;; return
    722          }
    723          

   \                                 In section SOFTPACK, align 4, keep-with-next
    724          uint32_t pmc_get_plla_clock(void)
    725          {
   \                     pmc_get_plla_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    726          #if defined(PMC_PLL_UPDT_ID)
    727          	return _pmc_get_pll_clock(PLL_ID_PLLA);
    728          #elif defined(CKGR_PLLAR_DIVA_Pos)
    729          	uint32_t pllaclk, pllar, pllmula, plldiva;
    730          
    731          	pllar = PMC->CKGR_PLLAR;
   \        0x4   0x....'....        LDR      R4,??DataTable42_1  ;; 0xf0018020
   \        0x8   0xE594'1008        LDR      R1,[R4, #+8]
    732          	pllmula = (pllar & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
   \        0xC   0xE7E6'0951        UBFX     R0,R1,#+18,#+7
    733          	plldiva = (pllar & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
   \       0x10   0xE211'1001        ANDS     R1,R1,#0x1
    734          	if (plldiva == 0 || pllmula == 0)
   \       0x14   0x0A00'0001        BEQ      ??pmc_get_plla_clock_0
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0001        BNE      ??pmc_get_plla_clock_1
    735          		return 0;
   \                     ??pmc_get_plla_clock_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xE8BD'8010        POP      {R4,PC}
    736          
    737          	pllaclk = pmc_get_main_clock();
   \                     ??pmc_get_plla_clock_1:
   \       0x28   0xE594'3000        LDR      R3,[R4, #+0]
   \       0x2C   0x....'....        LDR      R2,??DataTable42
   \       0x30   0xE313'0740        TST      R3,#0x1000000
    738          	pllaclk = pllaclk * (pllmula + 1) / plldiva;
   \       0x34   0xE280'3001        ADD      R3,R0,#+1
   \       0x38   0x1592'2004        LDRNE    R2,[R2, #+4]
   \       0x3C   0x0592'2000        LDREQ    R2,[R2, #+0]
   \       0x40   0xE000'0293        MUL      R0,R3,R2
    739          #ifdef CONFIG_HAVE_PMC_PLLADIV2
    740          	if (PMC->PMC_MCKR & PMC_MCKR_PLLADIV2)
   \       0x44   0xE594'4010        LDR      R4,[R4, #+16]
   \       0x48   0x....'....        BL       __aeabi_uidiv
   \       0x4C   0xE314'0D40        TST      R4,#0x1000
    741          		pllaclk >>= 1;
   \       0x50   0x11A0'00A0        LSRNE    R0,R0,#+1
    742          #endif
    743          	return pllaclk;
   \       0x54   0xE8BD'8010        POP      {R4,PC}          ;; return
    744          #endif
    745          }
    746          

   \                                 In section SOFTPACK, align 4, keep-with-next
    747          uint32_t pmc_get_processor_clock(void)
    748          {
   \                     pmc_get_processor_clock:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    749          	uint32_t procclk, mdiv;
    750          
    751          	procclk = pmc_get_master_clock();
   \        0x4   0x....'....        BL       pmc_get_master_clock
    752          
    753          	mdiv = PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk;
   \        0x8   0x....'....        LDR      R1,??DataTable50_2  ;; 0xf0018030
   \        0xC   0xE591'1000        LDR      R1,[R1, #+0]
    754          	switch (mdiv) {
   \       0x10   0xE201'2FC0        AND      R2,R1,#0x300
   \       0x14   0xE352'0F40        CMP      R2,#+256
   \       0x18   0x0A00'0004        BEQ      ??pmc_get_processor_clock_0
   \       0x1C   0xE352'0F80        CMP      R2,#+512
   \       0x20   0x0A00'0004        BEQ      ??pmc_get_processor_clock_1
   \       0x24   0xE352'0FC0        CMP      R2,#+768
    755          	case PMC_MCKR_MDIV_EQ_PCK:
    756          		break;
    757          	case PMC_MCKR_MDIV_PCK_DIV2:
    758          		procclk <<= 1; // multiply by 2
    759          		break;
    760          	case PMC_MCKR_MDIV_PCK_DIV3:
    761          		procclk *= 3;  // multiply by 3
   \       0x28   0x0080'0080        ADDEQ    R0,R0,R0, LSL #+1
   \       0x2C   0xE8BD'8002        POP      {R1,PC}
   \                     ??pmc_get_processor_clock_0:
   \       0x30   0xE1A0'0080        LSL      R0,R0,#+1
   \       0x34   0xE8BD'8002        POP      {R1,PC}
    762          		break;
    763          	case PMC_MCKR_MDIV_PCK_DIV4:
    764          		procclk <<= 2; // multiply by 4
   \                     ??pmc_get_processor_clock_1:
   \       0x38   0xE1A0'0100        LSL      R0,R0,#+2
    765          		break;
    766          	default:
    767          		/* should never get here... */
    768          		break;
    769          	}
    770          
    771          	return procclk;
   \       0x3C   0xE8BD'8002        POP      {R1,PC}          ;; return
    772          }
    773          

   \                                 In section SOFTPACK, align 4, keep-with-next
    774          RAMCODE void pmc_select_external_crystal(void)
    775          {
   \                     pmc_select_external_crystal:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    776          	bool return_to_slck = false;
    777          
    778          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \        0x4   0x....'....        LDR      R5,??DataTable50_2  ;; 0xf0018030
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0001        BNE      ??pmc_select_external_crystal_0
    779          		pmc_switch_mck_to_main();
   \       0x18   0x....'....        BL       pmc_switch_mck_to_main
    780          		return_to_slck = true;
   \       0x1C   0xE3A0'4001        MOV      R4,#+1
    781          	}
    782          
    783          	slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_external_crystal_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0x....'....        BL       slowclock_select_external
    784          
    785          	/* Switch to slow clock again if needed */
    786          	if (return_to_slck)
   \       0x28   0x....'....        B        ?Subroutine6
    787          		pmc_switch_mck_to_slck();
    788          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine6:
   \        0x0   0xE354'0000        CMP      R4,#+0
   \        0x4   0x0A00'0008        BEQ      ??Subroutine6_0
   \        0x8   0xE595'0000        LDR      R0,[R5, #+0]
   \        0xC   0xE3C0'1003        BIC      R1,R0,#0x3
   \       0x10   0xE585'1000        STR      R1,[R5, #+0]
   \                     ??Subroutine6_1:
   \       0x14   0xE595'2038        LDR      R2,[R5, #+56]
   \       0x18   0xE312'0008        TST      R2,#0x8
   \       0x1C   0x0AFF'FFFC        BEQ      ??Subroutine6_1
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0x....'....        LDR      R1,??DataTable42
   \       0x28   0xE581'0008        STR      R0,[R1, #+8]
   \                     ??Subroutine6_0:
   \       0x2C   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    789          

   \                                 In section SOFTPACK, align 4, keep-with-next
    790          RAMCODE void pmc_select_internal_crystal(void)
    791          {
   \                     pmc_select_internal_crystal:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    792          	bool return_to_slck = false;
    793          
    794          	if (PMC->PMC_MCKR == PMC_MCKR_CSS(PMC_MCKR_CSS_SLOW_CLK)) {
   \        0x4   0x....'....        LDR      R5,??DataTable50_2  ;; 0xf0018030
   \        0x8   0xE3A0'4000        MOV      R4,#+0
   \        0xC   0xE595'0000        LDR      R0,[R5, #+0]
   \       0x10   0xE350'0000        CMP      R0,#+0
   \       0x14   0x1A00'0001        BNE      ??pmc_select_internal_crystal_0
    795          		pmc_switch_mck_to_main();
   \       0x18   0x....'....        BL       pmc_switch_mck_to_main
    796          		return_to_slck = true;
   \       0x1C   0xE3A0'4001        MOV      R4,#+1
    797          	}
    798          
    799          	slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   \                     ??pmc_select_internal_crystal_0:
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0x....'....        BL       slowclock_select_internal
    800          
    801          	/* Switch to slow clock again if needed */
    802          	if (return_to_slck)
   \       0x28                      REQUIRE ?Subroutine6
   \       0x28                      ;; // Fall through to label ?Subroutine6
    803          		pmc_switch_mck_to_slck();
    804          }
    805          

   \                                 In section SOFTPACK, align 4, keep-with-next
    806          RAMCODE int pmc_select_external_osc(bool bypass)
    807          {
   \                     pmc_select_external_osc:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
    808          	int err;
    809          	volatile uint32_t timeout;
    810          
    811          	/* Return if external oscillator had been selected */
    812          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \        0x4   0x....'....        LDR      R4,??DataTable42_1  ;; 0xf0018020
   \        0x8   0xE594'1000        LDR      R1,[R4, #+0]
   \        0xC   0xE311'0740        TST      R1,#0x1000000
   \       0x10   0x0A00'0006        BEQ      ??pmc_select_external_osc_0
    813          #ifdef CKGR_MOR_MOSCXTBY
    814          		uint32_t mask = bypass ? CKGR_MOR_MOSCXTBY : CKGR_MOR_MOSCXTEN;
    815          #else
    816          		uint32_t mask = CKGR_MOR_MOSCXTEN;
    817          #endif  /* CKGR_MOR_MOSCXTBY */
    818          		if ((PMC->CKGR_MOR & mask) == mask)
   \       0x14   0xE594'2000        LDR      R2,[R4, #+0]
   \       0x18   0xE1B0'1000        MOVS     R1,R0
   \       0x1C   0x13A0'1002        MOVNE    R1,#+2
   \       0x20   0x03A0'1001        MOVEQ    R1,#+1
   \       0x24   0xE001'2002        AND      R2,R1,R2
   \       0x28   0xE152'0001        CMP      R2,R1
   \       0x2C   0x0A00'0025        BEQ      ??pmc_select_external_osc_1
    819          			return 0;
    820          	}
    821          
    822          	/*
    823          	 * When switching the source of the main clock between the RC oscillator and the crystal
    824          	 * oscillator, both oscillators must be enabled. After completion of the switch, the
    825          	 * unused oscillator can be disabled.
    826          	 */
    827          	pmc_enable_internal_osc();
    828          	err = pmc_enable_external_osc(bypass);
   \                     ??pmc_select_external_osc_0:
   \       0x30   0x....'....        BL       pmc_enable_external_osc
    829          	if (err < 0)
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x4A00'0023        BMI      ??pmc_select_external_osc_2
    830          		return err;
    831          
    832          	/* switch MAIN clock to external oscillator */
    833          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCSEL
    834          	    | CKGR_MOR_KEY_PASSWD;
   \       0x3C   0xE594'0000        LDR      R0,[R4, #+0]
   \       0x40   0xE3C0'18FF        BIC      R1,R0,#0xFF0000
   \       0x44   0xE381'29DC        ORR      R2,R1,#0x370000
   \       0x48   0xE382'2740        ORR      R2,R2,#0x1000000
   \       0x4C   0xE584'2000        STR      R2,[R4, #+0]
    835          
    836          	/* wait for the command to be taken into account */
    837          	while ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) != CKGR_MOR_MOSCSEL);
   \                     ??pmc_select_external_osc_3:
   \       0x50   0xE594'3000        LDR      R3,[R4, #+0]
   \       0x54   0xE313'0740        TST      R3,#0x1000000
   \       0x58   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_3
    838          
    839          	/* wait MAIN clock status change for external oscillator selection */
    840          	timeout = MOSCSELS_TIMEOUT;
   \       0x5C   0xE3A0'0020        MOV      R0,#+32
   \       0x60   0xE58D'0000        STR      R0,[SP, #+0]
    841          	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS) && --timeout > 0);
   \                     ??pmc_select_external_osc_4:
   \       0x64   0xE594'2048        LDR      R2,[R4, #+72]
   \       0x68   0xE312'0B40        TST      R2,#0x10000
   \       0x6C   0x1A00'0003        BNE      ??pmc_select_external_osc_5
   \       0x70   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x74   0xE251'0001        SUBS     R0,R1,#+1
   \       0x78   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x7C   0x1AFF'FFF8        BNE      ??pmc_select_external_osc_4
    842          	if (!timeout) {
   \                     ??pmc_select_external_osc_5:
   \       0x80   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0x84   0xE351'0000        CMP      R1,#+0
   \       0x88   0x1A00'0005        BNE      ??pmc_select_external_osc_6
    843          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk))
    844          			| CKGR_MOR_KEY_PASSWD;
   \       0x8C   0xE594'3000        LDR      R3,[R4, #+0]
   \       0x90   0xE7D8'381F        BFC      R3,#+16,#+9
   \       0x94   0xE383'09DC        ORR      R0,R3,#0x370000
   \       0x98   0xE584'0000        STR      R0,[R4, #+0]
    845          		return -ETIMEDOUT;
   \       0x9C   0xE3E0'004C        MVN      R0,#+76
   \       0xA0   0xE8BD'8016        POP      {R1,R2,R4,PC}
    846          	}
    847          
    848          	/* in case where MCK is running on MAIN CLK */
    849          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \                     ??pmc_select_external_osc_6:
   \       0xA4   0xE594'1010        LDR      R1,[R4, #+16]
   \       0xA8   0xE311'0002        TST      R1,#0x2
   \       0xAC   0x1A00'0002        BNE      ??pmc_select_external_osc_7
   \       0xB0   0xE594'0010        LDR      R0,[R4, #+16]
   \       0xB4   0xE310'0001        TST      R0,#0x1
   \       0xB8   0x0A00'0002        BEQ      ??pmc_select_external_osc_1
    850          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_external_osc_7:
   \       0xBC   0xE594'1048        LDR      R1,[R4, #+72]
   \       0xC0   0xE311'0008        TST      R1,#0x8
   \       0xC4   0x0AFF'FFFC        BEQ      ??pmc_select_external_osc_7
    851          
    852          	/* disable internal 12MHz RC to save power */
    853          	pmc_disable_internal_osc();
    854          
    855          	return 0;
   \                     ??pmc_select_external_osc_1:
   \       0xC8   0xE3A0'0000        MOV      R0,#+0
   \                     ??pmc_select_external_osc_2:
   \       0xCC   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
    856          }
    857          

   \                                 In section SOFTPACK, align 4, keep-with-next
    858          RAMCODE int pmc_enable_external_osc(bool bypass)
    859          {
    860          	uint32_t cgmor = PMC->CKGR_MOR;
   \                     pmc_enable_external_osc:
   \        0x0   0x....'....        LDR      R1,??DataTable42_1  ;; 0xf0018020
   \        0x4   0xE24D'D004        SUB      SP,SP,#+4
    861          	uint32_t mask = CKGR_MOR_MOSCXTEN;
   \        0x8   0xE3A0'3001        MOV      R3,#+1
   \        0xC   0xE591'2000        LDR      R2,[R1, #+0]
    862          	volatile uint32_t timeout;
    863          
    864          #ifdef CKGR_MOR_MOSCXTBY
    865          	if (bypass)
   \       0x10   0xE1B0'C000        MOVS     R12,R0
    866          		mask = CKGR_MOR_MOSCXTBY;
   \       0x14   0x13A0'3002        MOVNE    R3,#+2
    867          #else
    868          	(void)bypass;
    869          #endif /* CKGR_MOR_MOSCXTBY */
    870          
    871          	/* Enable Crystal Oscillator if needed */
    872          	if ((cgmor & mask) != mask) {
   \       0x18   0xE003'C002        AND      R12,R3,R2
   \       0x1C   0xE15C'0003        CMP      R12,R3
   \       0x20   0x0A00'0022        BEQ      ??pmc_enable_external_osc_0
    873          		cgmor &= ~CKGR_MOR_KEY_Msk;
    874          		cgmor |= CKGR_MOR_KEY_PASSWD;
    875          
    876          #ifdef CKGR_MOR_MOSCXTBY
    877          		if (bypass) {
   \       0x24   0xE350'0000        CMP      R0,#+0
   \       0x28   0xE3C2'28FF        BIC      R2,R2,#0xFF0000
   \       0x2C   0xE382'29DC        ORR      R2,R2,#0x370000
   \       0x30   0x0A00'0006        BEQ      ??pmc_enable_external_osc_1
    878          			/* Disable Crystal Oscillator */
    879          			cgmor &= ~CKGR_MOR_MOSCXTEN;
   \       0x34   0xE3C2'0001        BIC      R0,R2,#0x1
    880          			PMC->CKGR_MOR = cgmor;
   \       0x38   0xE581'0000        STR      R0,[R1, #+0]
    881          
    882          			/* Wait Main Oscillator not ready */
    883          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
   \                     ??pmc_enable_external_osc_2:
   \       0x3C   0xE591'2048        LDR      R2,[R1, #+72]
   \       0x40   0xE312'0001        TST      R2,#0x1
   \       0x44   0x1AFF'FFFC        BNE      ??pmc_enable_external_osc_2
    884          
    885          			/* Enable Crystal Oscillator Bypass */
    886          			cgmor |= CKGR_MOR_MOSCXTBY;
    887          			PMC->CKGR_MOR = cgmor;
   \       0x48   0xE380'0002        ORR      R0,R0,#0x2
   \       0x4C   0xEA00'0008        B        ??pmc_enable_external_osc_3
    888          		} else {
    889          			/* Disable Crystal Oscillator Bypass */
    890          			cgmor &= ~CKGR_MOR_MOSCXTBY;
   \                     ??pmc_enable_external_osc_1:
   \       0x50   0xE3C2'0002        BIC      R0,R2,#0x2
    891          			PMC->CKGR_MOR = cgmor;
   \       0x54   0xE581'0000        STR      R0,[R1, #+0]
    892          
    893          			/* Wait Main Oscillator not ready */
    894          			while (PMC->PMC_SR & PMC_SR_MOSCXTS);
   \                     ??pmc_enable_external_osc_4:
   \       0x58   0xE591'2048        LDR      R2,[R1, #+72]
   \       0x5C   0xE312'0001        TST      R2,#0x1
   \       0x60   0x1AFF'FFFC        BNE      ??pmc_enable_external_osc_4
    895          
    896          			/* Set Oscillator Startup Time */
    897          			cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
    898          			cgmor |= CKGR_MOR_MOSCXTST(18);
   \       0x64   0xE3A0'2012        MOV      R2,#+18
   \       0x68   0xE7CF'0412        BFI      R0,R2,#+8,#+8
    899          			PMC->CKGR_MOR = cgmor;
   \       0x6C   0xE581'0000        STR      R0,[R1, #+0]
    900          
    901          			/* Enable Crystal Oscillator */
    902          			cgmor |= CKGR_MOR_MOSCXTEN;
    903          			PMC->CKGR_MOR = cgmor;
   \       0x70   0xE380'0001        ORR      R0,R0,#0x1
   \                     ??pmc_enable_external_osc_3:
   \       0x74   0xE581'0000        STR      R0,[R1, #+0]
    904          		}
    905          #else
    906          		/* Set Oscillator Startup Time */
    907          		cgmor &= ~CKGR_MOR_MOSCXTST_Msk;
    908          		cgmor |= CKGR_MOR_MOSCXTST(18);
    909          		PMC->CKGR_MOR = cgmor;
    910          
    911          		/* Enable Crystal Oscillator */
    912          		cgmor |= CKGR_MOR_MOSCXTEN;
    913          		PMC->CKGR_MOR = cgmor;
    914          #endif /* CKGR_MOR_MOSCXTBY */
    915          
    916          		/* Wait Main Oscillator ready */
    917          		timeout = MOSCXTS_TIMEOUT;
   \       0x78   0xE3A0'3E80        MOV      R3,#+2048
   \       0x7C   0xE58D'3000        STR      R3,[SP, #+0]
    918          		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS) && --timeout > 0);
   \                     ??pmc_enable_external_osc_5:
   \       0x80   0xE591'0048        LDR      R0,[R1, #+72]
   \       0x84   0xE310'0001        TST      R0,#0x1
   \       0x88   0x1A00'0003        BNE      ??pmc_enable_external_osc_6
   \       0x8C   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x90   0xE253'0001        SUBS     R0,R3,#+1
   \       0x94   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x98   0x1AFF'FFF8        BNE      ??pmc_enable_external_osc_5
    919          
    920          		/* Return true if oscillator ready before timeout */
    921          		return timeout == 0 ? -ETIMEDOUT : 0;
   \                     ??pmc_enable_external_osc_6:
   \       0x9C   0xE59D'1000        LDR      R1,[SP, #+0]
   \       0xA0   0xE351'0000        CMP      R1,#+0
   \       0xA4   0x1A00'0004        BNE      ??pmc_enable_external_osc_7
   \       0xA8   0xE3E0'004C        MVN      R0,#+76
   \       0xAC   0x....'....        B        ?Subroutine1
    922          	} else {
    923          		/* Crystal Oscillator already selected, just check if ready */
    924          		if (PMC->PMC_SR & PMC_SR_MOSCXTS)
   \                     ??pmc_enable_external_osc_0:
   \       0xB0   0xE591'0048        LDR      R0,[R1, #+72]
   \       0xB4   0xE310'0001        TST      R0,#0x1
   \       0xB8   0x0A00'0001        BEQ      ??pmc_enable_external_osc_8
    925          			return 0;
   \                     ??pmc_enable_external_osc_7:
   \       0xBC   0xE3A0'0000        MOV      R0,#+0
   \       0xC0   0x....'....        B        ?Subroutine1
    926          		else
    927          			return -ENOTSUP;
   \                     ??pmc_enable_external_osc_8:
   \       0xC4   0xE3E0'003C        MVN      R0,#+60
   \       0xC8                      REQUIRE ?Subroutine1
   \       0xC8                      ;; // Fall through to label ?Subroutine1
    928          	}
    929          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine1:
   \        0x0   0xE28D'D004        ADD      SP,SP,#+4
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
    930          

   \                                 In section SOFTPACK, align 4, keep-with-next
    931          RAMCODE void pmc_disable_external_osc(void)
    932          {
   \                     pmc_disable_external_osc:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    933          #ifdef CKGR_MOR_MOSCXTBY
    934          	uint32_t mask = CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTBY;
    935          #else
    936          	uint32_t mask = CKGR_MOR_MOSCXTEN;
    937          #endif /* CKGR_MOR_MOSCXTBY */
    938          
    939          	/* disable external OSC */
    940          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \        0x4   0x....'....        LDR      R0,??DataTable47  ;; 0xf0018020
    941          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(mask | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \        0x8   0xE3E0'E003        MVN      LR,#+3
   \        0xC   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x10   0xE3CE'E8FF        BIC      LR,LR,#0xFF0000
   \       0x14   0xE7D8'281F        BFC      R2,#+16,#+9
   \       0x18   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0x1C   0xE580'3000        STR      R3,[R0, #+0]
   \       0x20   0xE590'C000        LDR      R12,[R0, #+0]
   \       0x24   0xE00E'E00C        AND      LR,LR,R12
   \       0x28   0x....'....        B        ?Subroutine5
    942          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine5:
   \        0x0   0xE38E'49DC        ORR      R4,LR,#0x370000
   \        0x4   0xE580'4000        STR      R4,[R0, #+0]
   \        0x8   0xE8BD'8010        POP      {R4,PC}          ;; return
    943          

   \                                 In section SOFTPACK, align 4, keep-with-next
    944          RAMCODE void pmc_select_internal_osc(void)
    945          {
   \                     pmc_select_internal_osc:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    946          	pmc_enable_internal_osc();
    947          
    948          	/* switch MAIN clock to internal 12MHz RC */
    949          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~(CKGR_MOR_MOSCSEL | CKGR_MOR_KEY_Msk)) | CKGR_MOR_KEY_PASSWD;
   \        0x4   0x....'....        LDR      R0,??DataTable42_1  ;; 0xf0018020
   \        0x8   0xE3E0'1740        MVN      R1,#+16777216
   \        0xC   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x10   0xE3C1'18FF        BIC      R1,R1,#0xFF0000
   \       0x14   0xE001'2002        AND      R2,R1,R2
   \       0x18   0xE382'39DC        ORR      R3,R2,#0x370000
   \       0x1C   0xE580'3000        STR      R3,[R0, #+0]
    950          
    951          	/* in case where MCK is running on MAIN CLK */
    952          	if ((PMC->PMC_MCKR & PMC_MCKR_CSS_PLLA_CLK) || (PMC->PMC_MCKR & PMC_MCKR_CSS_MAIN_CLK))
   \       0x20   0xE590'C010        LDR      R12,[R0, #+16]
   \       0x24   0xE31C'0002        TST      R12,#0x2
   \       0x28   0x1A00'0002        BNE      ??pmc_select_internal_osc_0
   \       0x2C   0xE590'2010        LDR      R2,[R0, #+16]
   \       0x30   0xE312'0001        TST      R2,#0x1
   \       0x34   0x0A00'0002        BEQ      ??pmc_select_internal_osc_1
    953          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_select_internal_osc_0:
   \       0x38   0xE590'3048        LDR      R3,[R0, #+72]
   \       0x3C   0xE313'0008        TST      R3,#0x8
   \       0x40   0x0AFF'FFFC        BEQ      ??pmc_select_internal_osc_0
    954          
    955          	/* disable external OSC 12 MHz to save power*/
    956          	pmc_disable_external_osc();
   \                     ??pmc_select_internal_osc_1:
   \       0x44   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x48   0xE3E0'E003        MVN      LR,#+3
   \       0x4C   0xE3CE'E8FF        BIC      LR,LR,#0xFF0000
   \       0x50   0xE001'1002        AND      R1,R1,R2
   \       0x54   0xE381'C9DC        ORR      R12,R1,#0x370000
   \       0x58   0xE580'C000        STR      R12,[R0, #+0]
   \       0x5C   0xE590'3000        LDR      R3,[R0, #+0]
   \       0x60   0xE00E'E003        AND      LR,LR,R3
   \       0x64                      REQUIRE ?Subroutine5
   \       0x64                      ;; // Fall through to label ?Subroutine5
    957          }
    958          

   \                                 In section SOFTPACK, align 4, keep-with-next
    959          RAMCODE void pmc_enable_internal_osc(void)
    960          {
    961          #ifdef CKGR_MOR_MOSCRCEN
    962          	/* Enable internal 12MHz RC when needed */
    963          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCRCEN) != CKGR_MOR_MOSCRCEN) {
    964          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_MOSCRCEN | CKGR_MOR_KEY_PASSWD;
    965          		/* Wait internal 12MHz RC Startup Time for clock stabilization */
    966          		while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
    967          	}
    968          #endif
    969          }
   \                     pmc_enable_internal_osc:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    970          

   \                                 In section SOFTPACK, align 4, keep-with-next
    971          RAMCODE void pmc_disable_internal_osc(void)
    972          {
    973          #ifdef CKGR_MOR_MOSCRCEN
    974          	/* disable internal 12MHz RC */
    975          	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCEN & ~CKGR_MOR_KEY_Msk) | CKGR_MOR_KEY_PASSWD;
    976          #endif
    977          }
   \                     pmc_disable_internal_osc:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    978          

   \                                 In section SOFTPACK, align 4, keep-with-next
    979          RAMCODE void pmc_enable_ulp1(void)
    980          {
    981          #ifdef CKGR_MOR_ULP1
    982          	/* enable ulp1 mode */
    983          	PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_ULP1 | CKGR_MOR_KEY_PASSWD;
    984          	asm volatile ("nop");
    985          	asm volatile ("nop");
    986          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
    987          #endif
    988          }
   \                     pmc_enable_ulp1:
   \        0x0   0xE12F'FF1E        BX       LR               ;; return
    989          

   \                                 In section SOFTPACK, align 4, keep-with-next
    990          void pmc_switch_mck_to_new_source(uint32_t mckr_css)
    991          {
    992          	uint32_t mckr = PMC->PMC_MCKR;
   \                     pmc_switch_mck_to_new_source:
   \        0x0   0x....'....        LDR      R1,??DataTable50_2  ;; 0xf0018030
   \        0x4   0xE591'2000        LDR      R2,[R1, #+0]
    993          	uint32_t mask = PMC_MCKR_CSS_Msk;
    994          
    995          	if ((mckr ^ mckr_css) & mask) {
   \        0x8   0xE020'3002        EOR      R3,R0,R2
   \        0xC   0xE313'0003        TST      R3,#0x3
   \       0x10   0x0A00'0006        BEQ      ??pmc_switch_mck_to_new_source_0
    996          		PMC->PMC_MCKR = (mckr & ~mask) | (mckr_css & mask);
   \       0x14   0xE1A0'2122        LSR      R2,R2,#+2
   \       0x18   0xE200'0003        AND      R0,R0,#0x3
   \       0x1C   0xE180'0102        ORR      R0,R0,R2, LSL #+2
   \       0x20   0xE581'0000        STR      R0,[R1, #+0]
    997          		while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_new_source_1:
   \       0x24   0xE591'3038        LDR      R3,[R1, #+56]
   \       0x28   0xE313'0008        TST      R3,#0x8
   \       0x2C   0x0AFF'FFFC        BEQ      ??pmc_switch_mck_to_new_source_1
    998          	}
    999          
   1000          	_pmc_mck = 0;
   \                     ??pmc_switch_mck_to_new_source_0:
   \       0x30   0x....'....        B        ??Subroutine8_0
   1001          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??Subroutine8_0:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0x....'....        LDR      R1,??DataTable42
   \        0x8   0xE581'0008        STR      R0,[R1, #+8]
   \        0xC   0xE12F'FF1E        BX       LR               ;; return
   1002          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1003          RAMCODE void pmc_switch_mck_to_pll(void)
   1004          {
   1005          	/* Select PLL as input clock for PCK and MCK */
   1006          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_PLLA_CLK;
   \                     pmc_switch_mck_to_pll:
   \        0x0   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'2003        BIC      R2,R1,#0x3
   \        0xC   0xE382'3002        ORR      R3,R2,#0x2
   \       0x10   0x....'....        B        ?Subroutine0
   1007          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1008          
   1009          	_pmc_mck = 0;
   1010          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine0:
   \        0x0   0xE580'3000        STR      R3,[R0, #+0]
   \                     ??Subroutine0_0:
   \        0x4   0xE590'C038        LDR      R12,[R0, #+56]
   \        0x8   0xE31C'0008        TST      R12,#0x8
   \        0xC   0x0AFF'FFFC        BEQ      ??Subroutine0_0
   \       0x10                      REQUIRE ??Subroutine8_0
   \       0x10                      ;; // Fall through to label ??Subroutine8_0
   1011          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1012          RAMCODE void pmc_switch_mck_to_upll(void)
   1013          {
   1014          	/* Select UPLL as input clock for PCK and MCK */
   1015          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_UPLL_CLK;
   \                     pmc_switch_mck_to_upll:
   \        0x0   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE381'2003        ORR      R2,R1,#0x3
   \        0xC   0xE580'2000        STR      R2,[R0, #+0]
   1016          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_upll_0:
   \       0x10   0xE590'3038        LDR      R3,[R0, #+56]
   \       0x14   0xE313'0008        TST      R3,#0x8
   \       0x18   0x0AFF'FFFC        BEQ      ??pmc_switch_mck_to_upll_0
   1017          
   1018          	_pmc_mck = 0;
   \       0x1C   0x....'....        B        ??Subroutine8_0
   1019          }
   1020          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1021          RAMCODE void pmc_switch_mck_to_main(void)
   1022          {
   1023          	/* Select Main Oscillator as input clock for PCK and MCK */
   1024          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   \                     pmc_switch_mck_to_main:
   \        0x0   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'2003        BIC      R2,R1,#0x3
   \        0xC   0xE382'3001        ORR      R3,R2,#0x1
   \       0x10                      REQUIRE ?Subroutine0
   \       0x10                      ;; // Fall through to label ?Subroutine0
   1025          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1026          
   1027          	_pmc_mck = 0;
   1028          }
   1029          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1030          RAMCODE void pmc_switch_mck_to_slck(void)
   1031          {
   1032          	/* Select Slow Clock as input clock for PCK and MCK */
   1033          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_SLOW_CLK;
   \                     pmc_switch_mck_to_slck:
   \        0x0   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'2003        BIC      R2,R1,#0x3
   \        0xC   0xE580'2000        STR      R2,[R0, #+0]
   1034          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_switch_mck_to_slck_0:
   \       0x10   0xE590'3038        LDR      R3,[R0, #+56]
   \       0x14   0xE313'0008        TST      R3,#0x8
   \       0x18   0x0AFF'FFFC        BEQ      ??pmc_switch_mck_to_slck_0
   1035          
   1036          	_pmc_mck = 0;
   \       0x1C   0x....'....        B        ??Subroutine8_0
   1037          }
   1038          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1039          RAMCODE void pmc_set_mck_prescaler(uint32_t prescaler)
   1040          {
   \                     pmc_set_mck_prescaler:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1041          	_ASSERT(!(prescaler & ~PMC_MCKR_PRES_Msk));
   \        0x8   0xE3D4'0070        BICS     R0,R4,#0x70
   \        0xC   0x0A00'0004        BEQ      ??pmc_set_mck_prescaler_0
   \       0x10   0xE300'2411        MOVW     R2,#+1041
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_4
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1042          
   1043          	/* Change MCK Prescaler divider in PMC_MCKR register */
   1044          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_PRES_Msk) | prescaler;
   \                     ??pmc_set_mck_prescaler_0:
   \       0x24   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \       0x28   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x2C   0xE3C1'2070        BIC      R2,R1,#0x70
   \       0x30   0x....'....        B        ?Subroutine3
   1045          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1046          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine3:
   \        0x0   0xE184'2002        ORR      R2,R4,R2
   \        0x4   0xE580'2000        STR      R2,[R0, #+0]
   \                     ??Subroutine3_0:
   \        0x8   0xE590'3038        LDR      R3,[R0, #+56]
   \        0xC   0xE313'0008        TST      R3,#0x8
   \       0x10   0x0AFF'FFFC        BEQ      ??Subroutine3_0
   \       0x14   0xE8BD'8010        POP      {R4,PC}          ;; return
   1047          
   1048          #ifdef CONFIG_HAVE_PMC_PLLADIV2

   \                                 In section SOFTPACK, align 4, keep-with-next
   1049          RAMCODE void pmc_set_mck_plladiv2(bool div2)
   1050          {
   1051          	uint32_t mckr = PMC->PMC_MCKR;
   \                     pmc_set_mck_plladiv2:
   \        0x0   0x....'....        LDR      R1,??DataTable50_2  ;; 0xf0018030
   1052          	if (div2) {
   \        0x4   0xE350'0000        CMP      R0,#+0
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
   \        0xC   0x0A00'0004        BEQ      ??pmc_set_mck_plladiv2_0
   1053          		if ((mckr & PMC_MCKR_PLLADIV2) != PMC_MCKR_PLLADIV2)
   \       0x10   0xE312'0D40        TST      R2,#0x1000
   \       0x14   0x1A00'0005        BNE      ??pmc_set_mck_plladiv2_1
   1054          			PMC->PMC_MCKR = mckr | PMC_MCKR_PLLADIV2;
   \       0x18   0xE382'0D40        ORR      R0,R2,#0x1000
   \       0x1C   0xE581'0000        STR      R0,[R1, #+0]
   \       0x20   0xEA00'0002        B        ??pmc_set_mck_plladiv2_1
   1055          	} else {
   1056          		if ((mckr & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2)
   \                     ??pmc_set_mck_plladiv2_0:
   \       0x24   0xE312'0D40        TST      R2,#0x1000
   1057          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_PLLADIV2;
   \       0x28   0x13C2'2D40        BICNE    R2,R2,#0x1000
   \       0x2C   0x1581'2000        STRNE    R2,[R1, #+0]
   1058          	}
   1059          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_set_mck_plladiv2_1:
   \       0x30   0xE591'0038        LDR      R0,[R1, #+56]
   \       0x34   0xE310'0008        TST      R0,#0x8
   \       0x38   0x0AFF'FFFC        BEQ      ??pmc_set_mck_plladiv2_1
   1060          }
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
   1061          #endif
   1062          
   1063          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1064          void pmc_set_mck_uplldiv2(bool div2)
   1065          {
   1066          	uint32_t mckr = PMC->PMC_MCKR;
   1067          	if (div2) {
   1068          		if ((mckr & PMC_MCKR_UPLLDIV2) != PMC_MCKR_UPLLDIV2)
   1069          			PMC->PMC_MCKR = mckr | PMC_MCKR_UPLLDIV2;
   1070          	} else {
   1071          		if ((PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2) == PMC_MCKR_UPLLDIV2)
   1072          			PMC->PMC_MCKR = mckr & ~PMC_MCKR_UPLLDIV2;
   1073          	}
   1074          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1075          }
   1076          #endif
   1077          
   1078          #ifdef CONFIG_HAVE_PMC_H32MXDIV

   \                                 In section SOFTPACK, align 4, keep-with-next
   1079          RAMCODE void pmc_set_mck_h32mxdiv(bool div2)
   1080          {
   1081          	uint32_t mckr = PMC->PMC_MCKR;
   \                     pmc_set_mck_h32mxdiv:
   \        0x0   0x....'....        LDR      R1,??DataTable50_2  ;; 0xf0018030
   1082          	if (div2) {
   \        0x4   0xE350'0000        CMP      R0,#+0
   \        0x8   0xE591'2000        LDR      R2,[R1, #+0]
   \        0xC   0x0A00'0004        BEQ      ??pmc_set_mck_h32mxdiv_0
   1083          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV2)
   \       0x10   0xE312'0740        TST      R2,#0x1000000
   \       0x14   0x1A00'0005        BNE      ??pmc_set_mck_h32mxdiv_1
   1084          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV2;
   \       0x18   0xE382'0740        ORR      R0,R2,#0x1000000
   \       0x1C   0xE581'0000        STR      R0,[R1, #+0]
   \       0x20   0xEA00'0002        B        ??pmc_set_mck_h32mxdiv_1
   1085          	} else {
   1086          		if ((mckr & PMC_MCKR_H32MXDIV) != PMC_MCKR_H32MXDIV_H32MXDIV1)
   \                     ??pmc_set_mck_h32mxdiv_0:
   \       0x24   0xE312'0740        TST      R2,#0x1000000
   1087          			PMC->PMC_MCKR = (mckr & ~PMC_MCKR_H32MXDIV) | PMC_MCKR_H32MXDIV_H32MXDIV1;
   \       0x28   0x13C2'2740        BICNE    R2,R2,#0x1000000
   \       0x2C   0x1581'2000        STRNE    R2,[R1, #+0]
   1088          	}
   1089          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   \                     ??pmc_set_mck_h32mxdiv_1:
   \       0x30   0xE591'0038        LDR      R0,[R1, #+56]
   \       0x34   0xE310'0008        TST      R0,#0x8
   \       0x38   0x0AFF'FFFC        BEQ      ??pmc_set_mck_h32mxdiv_1
   1090          }
   \       0x3C   0xE12F'FF1E        BX       LR               ;; return
   1091          #endif /* CONFIG_HAVE_PMC_H32MXDIV */
   1092          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1093          RAMCODE void pmc_set_mck_divider(uint32_t divider)
   1094          {
   \                     pmc_set_mck_divider:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1095          	_ASSERT(!(divider & ~PMC_MCKR_MDIV_Msk));
   \        0x8   0xE3D4'0FC0        BICS     R0,R4,#0x300
   \        0xC   0x0A00'0004        BEQ      ??pmc_set_mck_divider_0
   \       0x10   0xE300'2447        MOVW     R2,#+1095
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_5
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1096          
   1097          	/* change MCK Prescaler divider in PMC_MCKR register */
   1098          	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~PMC_MCKR_MDIV_Msk) | divider;
   \                     ??pmc_set_mck_divider_0:
   \       0x24   0x....'....        LDR      R0,??DataTable50_2  ;; 0xf0018030
   \       0x28   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x2C   0xE3C1'2FC0        BIC      R2,R1,#0x300
   \       0x30                      REQUIRE ?Subroutine3
   \       0x30                      ;; // Fall through to label ?Subroutine3
   1099          	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
   1100          }
   1101          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1102          RAMCODE void pmc_configure_plla(const struct _pmc_plla_cfg* plla)
   1103          {
   \                     pmc_configure_plla:
   \        0x0   0xE92D'4000        PUSH     {LR}
   1104          #if defined(PMC_PLL_UPDT_ID)
   1105          	_pmc_configure_pll(plla);
   1106          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1107          	uint32_t pllar = 0;
   1108          
   1109          #ifdef CKGR_PLLAR_ONE
   1110          	pllar |= CKGR_PLLAR_ONE;
   1111          #endif
   1112          	pllar |= CKGR_PLLAR_MULA(plla->mul);
   1113          	pllar |= CKGR_PLLAR_DIVA(plla->div);
   1114          	pllar |= CKGR_PLLAR_PLLACOUNT(plla->count);
   1115          	PMC->CKGR_PLLAR = pllar;
   \        0x4   0xE590'2000        LDR      R2,[R0, #+0]
   \        0x8   0xE5D0'C004        LDRB     R12,[R0, #+4]
   \        0xC   0xE3A0'377F        MOV      R3,#+33292288
   \       0x10   0x....'....        LDR      R1,??DataTable50_6  ;; 0xf0018028
   \       0x14   0xE003'3902        AND      R3,R3,R2, LSL #+18
   \       0x18   0xE590'2008        LDR      R2,[R0, #+8]
   \       0x1C   0xE20C'E001        AND      LR,R12,#0x1
   \       0x20   0xE18E'E003        ORR      LR,LR,R3
   \       0x24   0xE3A0'3DFC        MOV      R3,#+16128
   \       0x28   0xE003'3402        AND      R3,R3,R2, LSL #+8
   \       0x2C   0xE183'300E        ORR      R3,R3,LR
   \       0x30   0xE383'C580        ORR      R12,R3,#0x20000000
   \       0x34   0xE581'C000        STR      R12,[R1, #+0]
   1116          
   1117          #ifdef CONFIG_HAVE_PMC_PLLA_CHARGEPUMP
   1118          	PMC->PMC_PLLICPR = plla->icp & PMC_PLLICPR_ICP_PLLA_Msk;
   1119          #endif /* CONFIG_HAVE_PMC_PLLA_CHARGEPUMP */
   1120          
   1121          	if (plla->mul > 0)
   \       0x38   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x3C   0xE350'0000        CMP      R0,#+0
   \       0x40   0x0A00'0002        BEQ      ??pmc_configure_plla_0
   1122          		while (!(PMC->PMC_SR & PMC_SR_LOCKA));
   \                     ??pmc_configure_plla_1:
   \       0x44   0xE591'2040        LDR      R2,[R1, #+64]
   \       0x48   0xE312'0002        TST      R2,#0x2
   \       0x4C   0x0AFF'FFFC        BEQ      ??pmc_configure_plla_1
   1123          #endif
   1124          }
   \                     ??pmc_configure_plla_0:
   \       0x50   0xE8BD'8000        POP      {PC}             ;; return
   1125          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1126          RAMCODE void pmc_disable_plla(void)
   1127          {
   1128          #if defined(PMC_PLL_UPDT_ID)
   1129          	_pmc_disable_pll(PLL_ID_PLLA);
   1130          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1131          	PMC->CKGR_PLLAR = (PMC->CKGR_PLLAR & ~CKGR_PLLAR_MULA_Msk) | CKGR_PLLAR_MULA(0);
   \                     pmc_disable_plla:
   \        0x0   0x....'....        LDR      R0,??DataTable50_6  ;; 0xf0018028
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'277F        BIC      R2,R1,#0x1FC0000
   \        0xC   0x....'....        B        ?Subroutine2
   1132          #endif
   1133          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine2:
   \        0x0   0xE580'2000        STR      R2,[R0, #+0]
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
   1134          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1135          bool pmc_has_system_clock(enum _pmc_system_clock clock)
   1136          {
   1137          	return _pmc_get_system_clock_bits(clock, NULL, NULL, NULL);
   \                     pmc_has_system_clock:
   \        0x0   0xE3A0'3000        MOV      R3,#+0
   \        0x4   0xE3A0'2000        MOV      R2,#+0
   \        0x8   0xE3A0'1000        MOV      R1,#+0
   \        0xC   0x....'....        B        _pmc_get_system_clock_bits  ;; tailcall
   1138          }
   1139          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1140          RAMCODE void pmc_enable_system_clock(enum _pmc_system_clock clock)
   1141          {
   \                     pmc_enable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1142          	uint32_t scer, scsr;
   1143          
   1144          	if (!_pmc_get_system_clock_bits(clock, &scer, NULL, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE28D'1004        ADD      R1,SP,#+4
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0006        BNE      ??pmc_enable_system_clock_0
   1145          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable50_7
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000C        BCC      ??pmc_enable_system_clock_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable50_8
   \       0x38   0x....'....        B        ?Subroutine7
   1146          		return;
   1147          	}
   1148          
   1149          	PMC->PMC_SCER |= scer;
   \                     ??pmc_enable_system_clock_0:
   \       0x3C   0xE3A0'04F0        MOV      R0,#-268435456
   \       0x40   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x44   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x48   0xE59D'3004        LDR      R3,[SP, #+4]
   \       0x4C   0xE183'3001        ORR      R3,R3,R1
   \       0x50   0xE580'3000        STR      R3,[R0, #+0]
   1150          	while (!(PMC->PMC_SCSR & scsr));
   \                     ??pmc_enable_system_clock_2:
   \       0x54   0xE590'C008        LDR      R12,[R0, #+8]
   \       0x58   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x5C   0xE112'000C        TST      R2,R12
   \       0x60   0x0AFF'FFFB        BEQ      ??pmc_enable_system_clock_2
   1151          }
   \                     ??pmc_enable_system_clock_1:
   \       0x64   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine7:
   \        0x0   0x....'....        BL       printf
   \        0x4   0xE8BD'8013        POP      {R0,R1,R4,PC}
   1152          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1153          RAMCODE void pmc_disable_system_clock(enum _pmc_system_clock clock)
   1154          {
   \                     pmc_disable_system_clock:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1155          	uint32_t scdr, scsr;
   1156          
   1157          	if (!_pmc_get_system_clock_bits(clock, NULL, &scdr, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE28D'2004        ADD      R2,SP,#+4
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0006        BNE      ??pmc_disable_system_clock_0
   1158          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable50_7
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000C        BCC      ??pmc_disable_system_clock_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable50_9
   \       0x38   0x....'....        B        ?Subroutine7
   1159          		return;
   1160          	}
   1161          
   1162          	PMC->PMC_SCDR |= scdr;
   \                     ??pmc_disable_system_clock_0:
   \       0x3C   0xE3A0'024F        MOV      R0,#-268435452
   \       0x40   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x44   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x48   0xE59D'3004        LDR      R3,[SP, #+4]
   \       0x4C   0xE183'3001        ORR      R3,R3,R1
   \       0x50   0xE580'3000        STR      R3,[R0, #+0]
   1163          	while (PMC->PMC_SCSR & scsr);
   \                     ??pmc_disable_system_clock_2:
   \       0x54   0xE590'C004        LDR      R12,[R0, #+4]
   \       0x58   0xE59D'2000        LDR      R2,[SP, #+0]
   \       0x5C   0xE112'000C        TST      R2,R12
   \       0x60   0x1AFF'FFFB        BNE      ??pmc_disable_system_clock_2
   1164          }
   \                     ??pmc_disable_system_clock_1:
   \       0x64   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1165          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1166          bool pmc_is_system_clock_enabled(enum _pmc_system_clock clock)
   1167          {
   \                     pmc_is_system_clock_enabled:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1168          	uint32_t scsr;
   1169          
   1170          	if (!_pmc_get_system_clock_bits(clock, NULL, NULL, &scsr)) {
   \        0x8   0xE1A0'300D        MOV      R3,SP
   \        0xC   0xE3A0'2000        MOV      R2,#+0
   \       0x10   0xE3A0'1000        MOV      R1,#+0
   \       0x14   0x....'....        BL       _pmc_get_system_clock_bits
   \       0x18   0xE350'0000        CMP      R0,#+0
   \       0x1C   0x1A00'0007        BNE      ??pmc_is_system_clock_enabled_0
   1171          		trace_debug("Unknown System clock: %d\r\n", clock);
   \       0x20   0x....'....        LDR      R0,??DataTable50_7
   \       0x24   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x28   0xE351'0005        CMP      R1,#+5
   \       0x2C   0x3A00'000D        BCC      ??pmc_is_system_clock_enabled_1
   \       0x30   0xE1A0'1004        MOV      R1,R4
   \       0x34   0x....'....        LDR      R0,??DataTable50_10
   \       0x38   0x....'....        BL       printf
   1172          		return false;
   \       0x3C   0xEA00'0009        B        ??pmc_is_system_clock_enabled_1
   1173          	}
   1174          
   1175          	return (PMC->PMC_SCSR & scsr) == scsr;
   \                     ??pmc_is_system_clock_enabled_0:
   \       0x40   0xE3A0'028F        MOV      R0,#-268435448
   \       0x44   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x48   0xE590'1000        LDR      R1,[R0, #+0]
   \       0x4C   0xE59D'3000        LDR      R3,[SP, #+0]
   \       0x50   0xE59D'E000        LDR      LR,[SP, #+0]
   \       0x54   0xE003'3001        AND      R3,R3,R1
   \       0x58   0xE153'000E        CMP      R3,LR
   \       0x5C   0x1A00'0001        BNE      ??pmc_is_system_clock_enabled_1
   \       0x60   0xE3A0'0001        MOV      R0,#+1
   \       0x64   0xE8BD'8016        POP      {R1,R2,R4,PC}
   \                     ??pmc_is_system_clock_enabled_1:
   \       0x68   0xE3A0'0000        MOV      R0,#+0
   \       0x6C   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
   1176          }
   1177          
   1178          #ifdef CONFIG_HAVE_PMC_FAST_STARTUP
   1179          void pmc_set_fast_startup_mode(uint32_t startup_mode)
   1180          {
   1181          	PMC->PMC_FSMR = startup_mode;
   1182          }
   1183          
   1184          void pmc_set_fast_startup_polarity(uint32_t high_level, uint32_t low_level)
   1185          {
   1186          #ifdef PMC_FSPR_FSTP0
   1187          	PMC->PMC_FSPR &= ~low_level;
   1188          	PMC->PMC_FSPR |= high_level;
   1189          #endif /* PMC_FSPR_FSTP0 */
   1190          }
   1191          #endif /* CONFIG_HAVE_PMC_FAST_STARTUP */
   1192          
   1193          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1194           * it doesn't support samv71 targets. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1195          RAMCODE void pmc_set_custom_pck_mck(const struct pck_mck_cfg *cfg)
   1196          {
   \                     pmc_set_custom_pck_mck:
   \        0x0   0xE92D'40F8        PUSH     {R3-R7,LR}
   1197          	pmc_switch_mck_to_slck();
   \        0x4   0x....'....        LDR      R4,??DataTable42_1  ;; 0xf0018020
   \        0x8   0xE1A0'5000        MOV      R5,R0
   \        0xC   0xE594'0010        LDR      R0,[R4, #+16]
   \       0x10   0xE3C0'1003        BIC      R1,R0,#0x3
   \       0x14   0xE584'1010        STR      R1,[R4, #+16]
   \                     ??pmc_set_custom_pck_mck_0:
   \       0x18   0xE594'2048        LDR      R2,[R4, #+72]
   \       0x1C   0xE312'0008        TST      R2,#0x8
   \       0x20   0x0AFF'FFFC        BEQ      ??pmc_set_custom_pck_mck_0
   \       0x24   0x....'....        LDR      R6,??DataTable46
   \       0x28   0xE3A0'7000        MOV      R7,#+0
   \       0x2C   0xE586'7008        STR      R7,[R6, #+8]
   1198          
   1199          	if (cfg->extosc)
   \       0x30   0xE5D5'0004        LDRB     R0,[R5, #+4]
   \       0x34   0xE350'0000        CMP      R0,#+0
   \       0x38   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_1
   1200          		pmc_select_external_osc(cfg->ext_bypass);
   \       0x3C   0xE5D5'0005        LDRB     R0,[R5, #+5]
   \       0x40   0x....'....        BL       pmc_select_external_osc
   \       0x44   0xEA00'0000        B        ??pmc_set_custom_pck_mck_2
   1201          	else
   1202          		pmc_select_internal_osc();
   \                     ??pmc_set_custom_pck_mck_1:
   \       0x48   0x....'....        BL       pmc_select_internal_osc
   1203          
   1204          	pmc_switch_mck_to_main();
   \                     ??pmc_set_custom_pck_mck_2:
   \       0x4C   0x....'....        BL       pmc_switch_mck_to_main
   1205          
   1206          	if (cfg->ext32k) {
   \       0x50   0xE5D5'0006        LDRB     R0,[R5, #+6]
   \       0x54   0xE350'0000        CMP      R0,#+0
   \       0x58   0x0A00'0001        BEQ      ??pmc_set_custom_pck_mck_3
   1207          		pmc_select_external_crystal();
   \       0x5C   0x....'....        BL       pmc_select_external_crystal
   \       0x60   0xEA00'0000        B        ??pmc_set_custom_pck_mck_4
   1208          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1209          		slowclock_set_bypass(cfg->ext32k_bypass);
   1210          #endif
   1211          	}
   1212          	else
   1213          		pmc_select_internal_crystal();
   \                     ??pmc_set_custom_pck_mck_3:
   \       0x64   0x....'....        BL       pmc_select_internal_crystal
   1214          
   1215          	pmc_disable_plla();
   \                     ??pmc_set_custom_pck_mck_4:
   \       0x68   0xE594'0008        LDR      R0,[R4, #+8]
   \       0x6C   0xE3C0'177F        BIC      R1,R0,#0x1FC0000
   \       0x70   0xE584'1008        STR      R1,[R4, #+8]
   1216          	if (cfg->plla.mul > 0 && cfg->plla.div > 0) {
   \       0x74   0xE595'2008        LDR      R2,[R5, #+8]
   \       0x78   0xE352'0000        CMP      R2,#+0
   \       0x7C   0x0A00'0006        BEQ      ??pmc_set_custom_pck_mck_5
   \       0x80   0xE595'000C        LDR      R0,[R5, #+12]
   \       0x84   0xE350'0000        CMP      R0,#+0
   \       0x88   0x0A00'0003        BEQ      ??pmc_set_custom_pck_mck_5
   1217          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1218          		pmc_set_mck_plladiv2(cfg->plla_div2);
   \       0x8C   0xE5D5'001C        LDRB     R0,[R5, #+28]
   \       0x90   0x....'....        BL       pmc_set_mck_plladiv2
   1219          #endif
   1220          		pmc_configure_plla(&cfg->plla);
   \       0x94   0xE285'0008        ADD      R0,R5,#+8
   \       0x98   0x....'....        BL       pmc_configure_plla
   1221          	}
   1222          
   1223          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1224          	pmc_set_mck_uplldiv2(cfg->upll_div2);
   1225          #endif
   1226          	pmc_set_mck_prescaler(cfg->pck_pres);
   \                     ??pmc_set_custom_pck_mck_5:
   \       0x9C   0xE595'0014        LDR      R0,[R5, #+20]
   \       0xA0   0x....'....        BL       pmc_set_mck_prescaler
   1227          	pmc_set_mck_divider(cfg->mck_div);
   \       0xA4   0xE595'0018        LDR      R0,[R5, #+24]
   \       0xA8   0x....'....        BL       pmc_set_mck_divider
   1228          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1229          	pmc_set_mck_h32mxdiv(cfg->h32mx_div2);
   \       0xAC   0xE5D5'001D        LDRB     R0,[R5, #+29]
   \       0xB0   0x....'....        BL       pmc_set_mck_h32mxdiv
   1230          #endif
   1231          
   1232          	switch (cfg->pck_input) {
   \       0xB4   0xE595'0000        LDR      R0,[R5, #+0]
   \       0xB8   0xE350'0000        CMP      R0,#+0
   \       0xBC   0x0A00'000E        BEQ      ??pmc_set_custom_pck_mck_6
   \       0xC0   0xE350'0002        CMP      R0,#+2
   \       0xC4   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_7
   \       0xC8   0xE350'0003        CMP      R0,#+3
   \       0xCC   0x0A00'0002        BEQ      ??pmc_set_custom_pck_mck_8
   \       0xD0   0xE8BD'80F1        POP      {R0,R4-R7,PC}
   1233          	case PMC_MCKR_CSS_PLLA_CLK:
   1234          		pmc_switch_mck_to_pll();
   \                     ??pmc_set_custom_pck_mck_7:
   \       0xD4   0xE8BD'40F1        POP      {R0,R4-R7,LR}
   \       0xD8   0x....'....        B        pmc_switch_mck_to_pll  ;; tailcall
   1235          		break;
   1236          
   1237          	case PMC_MCKR_CSS_UPLL_CLK:
   1238          		pmc_switch_mck_to_upll();
   \                     ??pmc_set_custom_pck_mck_8:
   \       0xDC   0xE594'2010        LDR      R2,[R4, #+16]
   \       0xE0   0xE382'0003        ORR      R0,R2,#0x3
   \       0xE4   0xE584'0010        STR      R0,[R4, #+16]
   \                     ??pmc_set_custom_pck_mck_9:
   \       0xE8   0xE594'1048        LDR      R1,[R4, #+72]
   \       0xEC   0xE311'0008        TST      R1,#0x8
   \       0xF0   0x0AFF'FFFC        BEQ      ??pmc_set_custom_pck_mck_9
   \       0xF4   0xE586'7008        STR      R7,[R6, #+8]
   1239          		break;
   \       0xF8   0xE8BD'80F1        POP      {R0,R4-R7,PC}
   1240          
   1241          	case PMC_MCKR_CSS_SLOW_CLK:
   1242          		pmc_switch_mck_to_slck();
   \                     ??pmc_set_custom_pck_mck_6:
   \       0xFC   0xE594'0010        LDR      R0,[R4, #+16]
   \      0x100   0xE3C0'1003        BIC      R1,R0,#0x3
   \      0x104   0xE584'1010        STR      R1,[R4, #+16]
   \                     ??pmc_set_custom_pck_mck_10:
   \      0x108   0xE594'2048        LDR      R2,[R4, #+72]
   \      0x10C   0xE312'0008        TST      R2,#0x8
   \      0x110   0x0AFF'FFFC        BEQ      ??pmc_set_custom_pck_mck_10
   \      0x114   0xE586'7008        STR      R7,[R6, #+8]
   1243          		pmc_disable_internal_osc();
   1244          		pmc_disable_external_osc();
   \      0x118   0xE594'1000        LDR      R1,[R4, #+0]
   \      0x11C   0xE3E0'C003        MVN      R12,#+3
   \      0x120   0xE3CC'C8FF        BIC      R12,R12,#0xFF0000
   \      0x124   0xE7D8'181F        BFC      R1,#+16,#+9
   \      0x128   0xE381'29DC        ORR      R2,R1,#0x370000
   \      0x12C   0xE584'2000        STR      R2,[R4, #+0]
   \      0x130   0xE594'3000        LDR      R3,[R4, #+0]
   \      0x134   0xE00C'C003        AND      R12,R12,R3
   \      0x138   0xE38C'E9DC        ORR      LR,R12,#0x370000
   \      0x13C   0xE584'E000        STR      LR,[R4, #+0]
   1245          		break;
   1246          	}
   1247          }
   \      0x140   0xE8BD'80F1        POP      {R0,R4-R7,PC}    ;; return
   1248          
   1249          /*----------------------------------------------------------------------------
   1250           *        Exported functions (Peripherals)
   1251           *----------------------------------------------------------------------------*/
   1252          
   1253          /* About CONFIG_RAMCODE: when relocated in SRAM this function is limited,
   1254           * it only supports a NULL (struct _pmc_periph_cfg*) parameter. */

   \                                 In section SOFTPACK, align 4, keep-with-next
   1255          RAMCODE void pmc_configure_peripheral(uint32_t id, const struct _pmc_periph_cfg* cfg, bool enable)
   1256          {
   \                     pmc_configure_peripheral:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5002        MOV      R5,R2
   1257          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0xC   0xE354'0044        CMP      R4,#+68
   \       0x10   0x3A00'0004        BCC      ??pmc_configure_peripheral_0
   \       0x14   0xE300'24E9        MOVW     R2,#+1257
   \       0x18   0x....'....        LDR      R1,??DataTable50_3
   \       0x1C   0x....'....        LDR      R0,??DataTable50_11
   \       0x20   0x....'....        BL       __aeabi_assert
   \       0x24   0x....'....        BL       __iar_EmptyStepPoint
   1258          
   1259          	pmc_disable_peripheral(id);
   \                     ??pmc_configure_peripheral_0:
   \       0x28   0xE1A0'0004        MOV      R0,R4
   \       0x2C   0x....'....        BL       pmc_disable_peripheral
   1260          
   1261          	if (cfg != NULL) {
   1262          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1263          		if (cfg->gck.div > 0)
   1264          			pmc_configure_gck(id, cfg->gck.css, cfg->gck.div);
   1265          #endif
   1266          
   1267          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1268          		_pmc_configure_peripheral_div(id, cfg->div);
   1269          #endif
   1270          	} else {
   1271          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1272          		pmc_disable_gck(id);
   1273          #endif
   1274          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1275          		_pmc_configure_peripheral_div(id, 0);
   1276          #endif
   1277          	}
   1278          
   1279          	/* Enable peripheral, gck or only configure it */
   1280          	if (enable) {
   \       0x30   0xE355'0000        CMP      R5,#+0
   1281          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1282          		if (cfg && cfg->gck.div > 0)
   1283          			pmc_enable_gck(id);
   1284          #endif
   1285          		pmc_enable_peripheral(id);
   \       0x34   0x11A0'0004        MOVNE    R0,R4
   \       0x38   0x18BD'4032        POPNE    {R1,R4,R5,LR}
   \       0x3C   0x....'....        BNE      pmc_enable_peripheral  ;; tailcall
   1286          	}
   1287          }
   \       0x40   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
   1288          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1289          RAMCODE void pmc_enable_peripheral(uint32_t id)
   1290          {
   \                     pmc_enable_peripheral:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1291          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0044        CMP      R4,#+68
   \        0xC   0x3A00'0004        BCC      ??pmc_enable_peripheral_0
   \       0x10   0xE300'250B        MOVW     R2,#+1291
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_11
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1292          
   1293          	// select peripheral
   1294          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_enable_peripheral_0:
   \       0x24   0x....'....        LDR      R0,??DataTable50_12  ;; 0xf001810c
   \       0x28   0xE204'103F        AND      R1,R4,#0x3F
   \       0x2C   0xE580'1000        STR      R1,[R0, #+0]
   1295          
   1296          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x30   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x34   0xE58D'2000        STR      R2,[SP, #+0]
   1297          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_EN;
   \       0x38   0xE59D'E000        LDR      LR,[SP, #+0]
   \       0x3C   0xE38E'4D40        ORR      R4,LR,#0x1000
   \       0x40   0xE384'4540        ORR      R4,R4,#0x10000000
   \       0x44   0xE580'4000        STR      R4,[R0, #+0]
   1298          }
   \       0x48   0xE8BD'8013        POP      {R0,R1,R4,PC}    ;; return
   1299          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1300          RAMCODE void pmc_disable_peripheral(uint32_t id)
   1301          {
   \                     pmc_disable_peripheral:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1302          	_ASSERT(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0044        CMP      R4,#+68
   \        0xC   0x3A00'0004        BCC      ??pmc_disable_peripheral_0
   \       0x10   0xE300'2516        MOVW     R2,#+1302
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_11
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1303          
   1304          	// select peripheral
   1305          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_disable_peripheral_0:
   \       0x24   0x....'....        LDR      R0,??DataTable50_12  ;; 0xf001810c
   \       0x28   0xE204'103F        AND      R1,R4,#0x3F
   \       0x2C   0xE580'1000        STR      R1,[R0, #+0]
   1306          
   1307          	// disable it but keep previous configuration
   1308          	PMC->PMC_PCR = (PMC->PMC_PCR & ~PMC_PCR_EN) | PMC_PCR_CMD;
   \       0x30   0xE590'2000        LDR      R2,[R0, #+0]
   \       0x34   0xE3C2'3540        BIC      R3,R2,#0x10000000
   \       0x38   0xE383'CD40        ORR      R12,R3,#0x1000
   \       0x3C   0xE580'C000        STR      R12,[R0, #+0]
   1309          }
   \       0x40   0xE8BD'8010        POP      {R4,PC}          ;; return
   1310          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1311          bool pmc_is_peripheral_enabled(uint32_t id)
   1312          {
   \                     pmc_is_peripheral_enabled:
   \        0x0   0xE92D'401C        PUSH     {R2-R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1313          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0044        CMP      R4,#+68
   \        0xC   0x3A00'0004        BCC      ??pmc_is_peripheral_enabled_0
   \       0x10   0xE300'2521        MOVW     R2,#+1313
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_11
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1314          
   1315          #if defined(PMC_CSR_PID0) || defined(PMC_CSR0_PID5)
   1316          	return (PMC->PMC_CSR[(id >> 5) & 3] & (1 << (id & 31))) != 0;
   1317          #elif defined(PMC_PCR_PID)
   1318          	PMC->PMC_PCR = PMC_PCR_PID(id);
   \                     ??pmc_is_peripheral_enabled_0:
   \       0x24   0x....'....        LDR      R0,??DataTable50_12  ;; 0xf001810c
   \       0x28   0xE204'103F        AND      R1,R4,#0x3F
   \       0x2C   0xE580'1000        STR      R1,[R0, #+0]
   1319          	volatile uint32_t pcr = PMC->PMC_PCR;
   \       0x30   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x34   0xE58D'0000        STR      R0,[SP, #+0]
   1320          
   1321          	return (pcr & PMC_PCR_EN) != 0;
   \       0x38   0xE59D'C000        LDR      R12,[SP, #+0]
   \       0x3C   0xE1A0'EE2C        LSR      LR,R12,#+28
   \       0x40   0xE20E'0001        AND      R0,LR,#0x1
   \       0x44   0xE8BD'8016        POP      {R1,R2,R4,PC}    ;; return
   1322          #else
   1323          	#error pmc_is_peripheral_enabled() needs to be updated.
   1324          #endif
   1325          }
   1326          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1327          uint32_t pmc_get_peripheral_clock(uint32_t id)
   1328          {
   \                     pmc_get_peripheral_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1329          	assert(id < ID_PERIPH_COUNT);
   \        0x8   0xE354'0044        CMP      R4,#+68
   \        0xC   0x3A00'0004        BCC      ??pmc_get_peripheral_clock_0
   \       0x10   0xE300'2531        MOVW     R2,#+1329
   \       0x14   0x....'....        LDR      R1,??DataTable50_3
   \       0x18   0x....'....        LDR      R0,??DataTable50_11
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1330          
   1331          	uint32_t div = get_peripheral_clock_matrix_div(id);
   \                     ??pmc_get_peripheral_clock_0:
   \       0x24   0xE1A0'0004        MOV      R0,R4
   \       0x28   0x....'....        BL       get_peripheral_clock_matrix_div
   \       0x2C   0xE1A0'4000        MOV      R4,R0
   1332          #ifdef CONFIG_HAVE_PMC_PERIPH_DIV
   1333          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1334          	volatile uint32_t pcr = PMC->PMC_PCR;
   1335          	div *= 1 << ((pcr & PMC_PCR_DIV_Msk) >> PMC_PCR_DIV_Pos);
   1336          #endif
   1337          
   1338          	return pmc_get_master_clock() / div;
   \       0x30   0x....'....        BL       pmc_get_master_clock
   \       0x34   0xE1A0'1004        MOV      R1,R4
   \       0x38   0xE8BD'4010        POP      {R4,LR}
   \       0x3C   0x....'....        B        __aeabi_uidiv
   1339          }
   1340          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1341          void pmc_disable_all_peripherals(void)
   1342          {
   \                     pmc_disable_all_peripherals:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   1343          	int i;
   1344          	for (i = 2; i < ID_PERIPH_COUNT; i++)
   \        0x4   0xE3A0'8002        MOV      R8,#+2
   \        0x8   0x....'....        LDR      R4,??DataTable50_12  ;; 0xf001810c
   \        0xC   0x....'....        LDR      R5,??DataTable50_11
   \       0x10   0x....'....        LDR      R6,??DataTable50_3
   \       0x14   0xE300'7516        MOVW     R7,#+1302
   1345          		pmc_disable_peripheral(i);
   \                     ??pmc_disable_all_peripherals_0:
   \       0x18   0xE358'0044        CMP      R8,#+68
   \       0x1C   0x3A00'0004        BCC      ??pmc_disable_all_peripherals_1
   \       0x20   0xE1A0'2007        MOV      R2,R7
   \       0x24   0xE1A0'1006        MOV      R1,R6
   \       0x28   0xE1A0'0005        MOV      R0,R5
   \       0x2C   0x....'....        BL       __aeabi_assert
   \       0x30   0x....'....        BL       __iar_EmptyStepPoint
   \                     ??pmc_disable_all_peripherals_1:
   \       0x34   0xE208'003F        AND      R0,R8,#0x3F
   \       0x38   0xE288'8001        ADD      R8,R8,#+1
   \       0x3C   0xE584'0000        STR      R0,[R4, #+0]
   \       0x40   0xE594'1000        LDR      R1,[R4, #+0]
   \       0x44   0xE358'0044        CMP      R8,#+68
   \       0x48   0xE3C1'2540        BIC      R2,R1,#0x10000000
   \       0x4C   0xE382'3D40        ORR      R3,R2,#0x1000
   \       0x50   0xE584'3000        STR      R3,[R4, #+0]
   \       0x54   0xBAFF'FFEF        BLT      ??pmc_disable_all_peripherals_0
   1346          }
   \       0x58   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
   1347          
   1348          /*----------------------------------------------------------------------------
   1349           *        Exported functions (PCK)
   1350           *----------------------------------------------------------------------------*/
   1351          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1352          void pmc_configure_pck(uint32_t index, uint32_t clock_source, uint32_t prescaler)
   1353          {
   \                     pmc_configure_pck:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   \        0x8   0xE1A0'5001        MOV      R5,R1
   1354          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0xC   0xE354'0003        CMP      R4,#+3
   \       0x10   0xE1A0'6002        MOV      R6,R2
   \       0x14   0x3A00'0004        BCC      ??pmc_configure_pck_0
   \       0x18   0x....'....        LDR      R1,??DataTable50_3
   \       0x1C   0xE300'254A        MOVW     R2,#+1354
   \       0x20   0xE281'004C        ADD      R0,R1,#+76
   \       0x24   0x....'....        BL       __aeabi_assert
   \       0x28   0x....'....        BL       __iar_EmptyStepPoint
   1355          	assert(!(clock_source & ~PMC_PCK_CSS_Msk));
   \                     ??pmc_configure_pck_0:
   \       0x2C   0xE3D5'0007        BICS     R0,R5,#0x7
   \       0x30   0x0A00'0004        BEQ      ??pmc_configure_pck_1
   \       0x34   0xE300'254B        MOVW     R2,#+1355
   \       0x38   0x....'....        LDR      R1,??DataTable50_3
   \       0x3C   0x....'....        LDR      R0,??DataTable50_13
   \       0x40   0x....'....        BL       __aeabi_assert
   \       0x44   0x....'....        BL       __iar_EmptyStepPoint
   1356          	assert(!(prescaler << PMC_PCK_PRES_Pos & ~PMC_PCK_PRES_Msk));
   \                     ??pmc_configure_pck_1:
   \       0x48   0xE1A0'6206        LSL      R6,R6,#+4
   \       0x4C   0xE3D6'0070        BICS     R0,R6,#0x70
   \       0x50   0x0A00'0004        BEQ      ??pmc_configure_pck_2
   \       0x54   0x....'....        LDR      R1,??DataTable50_3
   \       0x58   0xE300'254C        MOVW     R2,#+1356
   \       0x5C   0xE281'00AC        ADD      R0,R1,#+172
   \       0x60   0x....'....        BL       __aeabi_assert
   \       0x64   0x....'....        BL       __iar_EmptyStepPoint
   1357          
   1358          	pmc_disable_pck(index);
   \                     ??pmc_configure_pck_2:
   \       0x68   0xE1A0'0004        MOV      R0,R4
   \       0x6C   0x....'....        BL       pmc_disable_pck
   1359          	PMC->PMC_PCK[index] = clock_source | PMC_PCK_PRES(prescaler);
   \       0x70   0xE206'0070        AND      R0,R6,#0x70
   \       0x74   0x....'....        LDR      R1,??DataTable50_14  ;; 0xf0018040
   \       0x78   0xE180'0005        ORR      R0,R0,R5
   \       0x7C   0xE781'0104        STR      R0,[R1, +R4, LSL #+2]
   1360          }
   \       0x80   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
   1361          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1362          void pmc_enable_pck(uint32_t index)
   1363          {
   \                     pmc_enable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1364          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0003        CMP      R4,#+3
   \        0xC   0x3A00'0004        BCC      ??pmc_enable_pck_0
   \       0x10   0x....'....        LDR      R1,??DataTable50_3
   \       0x14   0xE300'2554        MOVW     R2,#+1364
   \       0x18   0xE281'004C        ADD      R0,R1,#+76
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1365          
   1366          	switch (index) {
   \                     ??pmc_enable_pck_0:
   \       0x24   0xE354'0000        CMP      R4,#+0
   \       0x28   0x0A00'0003        BEQ      ??pmc_enable_pck_1
   \       0x2C   0xE354'0002        CMP      R4,#+2
   \       0x30   0x0A00'0011        BEQ      ??pmc_enable_pck_2
   \       0x34   0x3A00'0008        BCC      ??pmc_enable_pck_3
   \       0x38   0xEA00'0017        B        ??pmc_enable_pck_4
   1367          #ifdef PMC_SCER_PCK0
   1368          	case 0:
   1369          		PMC->PMC_SCER = PMC_SCER_PCK0;
   \                     ??pmc_enable_pck_1:
   \       0x3C   0xE3A0'04F0        MOV      R0,#-268435456
   \       0x40   0xE3A0'1F40        MOV      R1,#+256
   \       0x44   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x48   0xE580'1000        STR      R1,[R0, #+0]
   1370          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY0));
   \                     ??pmc_enable_pck_5:
   \       0x4C   0xE590'2068        LDR      R2,[R0, #+104]
   \       0x50   0xE312'0F40        TST      R2,#0x100
   \       0x54   0x0AFF'FFFC        BEQ      ??pmc_enable_pck_5
   \       0x58   0xE8BD'8010        POP      {R4,PC}
   1371          		break;
   1372          #endif
   1373          #ifdef PMC_SCER_PCK1
   1374          	case 1:
   1375          		PMC->PMC_SCER = PMC_SCER_PCK1;
   \                     ??pmc_enable_pck_3:
   \       0x5C   0xE3A0'04F0        MOV      R0,#-268435456
   \       0x60   0xE3A0'1F80        MOV      R1,#+512
   \       0x64   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x68   0xE580'1000        STR      R1,[R0, #+0]
   1376          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY1));
   \                     ??pmc_enable_pck_6:
   \       0x6C   0xE590'2068        LDR      R2,[R0, #+104]
   \       0x70   0xE312'0F80        TST      R2,#0x200
   \       0x74   0x0AFF'FFFC        BEQ      ??pmc_enable_pck_6
   \       0x78   0xE8BD'8010        POP      {R4,PC}
   1377          		break;
   1378          #endif
   1379          #ifdef PMC_SCER_PCK2
   1380          	case 2:
   1381          		PMC->PMC_SCER = PMC_SCER_PCK2;
   \                     ??pmc_enable_pck_2:
   \       0x7C   0xE3A0'04F0        MOV      R0,#-268435456
   \       0x80   0xE3A0'1E40        MOV      R1,#+1024
   \       0x84   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x88   0xE580'1000        STR      R1,[R0, #+0]
   1382          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY2));
   \                     ??pmc_enable_pck_7:
   \       0x8C   0xE590'2068        LDR      R2,[R0, #+104]
   \       0x90   0xE312'0E40        TST      R2,#0x400
   \       0x94   0x0AFF'FFFC        BEQ      ??pmc_enable_pck_7
   \       0x98   0xE8BD'8010        POP      {R4,PC}
   1383          		break;
   1384          #endif
   1385          #ifdef PMC_SCER_PCK3
   1386          	case 3:
   1387          		PMC->PMC_SCER = PMC_SCER_PCK3;
   1388          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY3));
   1389          		break;
   1390          #endif
   1391          #ifdef PMC_SCER_PCK4
   1392          	case 4:
   1393          		PMC->PMC_SCER = PMC_SCER_PCK4;
   1394          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY4));
   1395          		break;
   1396          #endif
   1397          #ifdef PMC_SCER_PCK5
   1398          	case 5:
   1399          		PMC->PMC_SCER = PMC_SCER_PCK5;
   1400          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY5));
   1401          		break;
   1402          #endif
   1403          #ifdef PMC_SCER_PCK6
   1404          	case 6:
   1405          		PMC->PMC_SCER = PMC_SCER_PCK6;
   1406          		while (!(PMC->PMC_SR & PMC_SR_PCKRDY6));
   1407          		break;
   1408          #endif
   1409          	default:
   1410          		assert(0);
   \                     ??pmc_enable_pck_4:
   \       0x9C   0xE300'2582        MOVW     R2,#+1410
   \       0xA0   0x....'....        B        ?Subroutine4
   1411          	}
   1412          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ?Subroutine4:
   \        0x0   0x....'....        LDR      R1,??DataTable50_3
   \        0x4   0x....'....        ADR      R0,??DataTable50_1  ;; "0"
   \        0x8   0x....'....        BL       __aeabi_assert
   \        0xC   0x....'....        BL       __iar_EmptyStepPoint
   \       0x10   0xE8BD'8010        POP      {R4,PC}          ;; return
   1413          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1414          void pmc_disable_pck(uint32_t index)
   1415          {
   \                     pmc_disable_pck:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1416          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0003        CMP      R4,#+3
   \        0xC   0x3A00'0004        BCC      ??pmc_disable_pck_0
   \       0x10   0x....'....        LDR      R1,??DataTable50_3
   \       0x14   0xE300'2588        MOVW     R2,#+1416
   \       0x18   0xE281'004C        ADD      R0,R1,#+76
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1417          
   1418          	switch (index) {
   \                     ??pmc_disable_pck_0:
   \       0x24   0xE354'0000        CMP      R4,#+0
   \       0x28   0x0A00'0003        BEQ      ??pmc_disable_pck_1
   \       0x2C   0xE354'0002        CMP      R4,#+2
   \       0x30   0x0A00'0011        BEQ      ??pmc_disable_pck_2
   \       0x34   0x3A00'0008        BCC      ??pmc_disable_pck_3
   \       0x38   0xEA00'0017        B        ??pmc_disable_pck_4
   1419          #ifdef PMC_SCDR_PCK0
   1420          	case 0:
   1421          		PMC->PMC_SCDR = PMC_SCDR_PCK0;
   \                     ??pmc_disable_pck_1:
   \       0x3C   0xE3A0'024F        MOV      R0,#-268435452
   \       0x40   0xE3A0'1F40        MOV      R1,#+256
   \       0x44   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x48   0xE580'1000        STR      R1,[R0, #+0]
   1422          		while (PMC->PMC_SCSR & PMC_SCSR_PCK0);
   \                     ??pmc_disable_pck_5:
   \       0x4C   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x50   0xE312'0F40        TST      R2,#0x100
   \       0x54   0x1AFF'FFFC        BNE      ??pmc_disable_pck_5
   \       0x58   0xE8BD'8010        POP      {R4,PC}
   1423          		break;
   1424          #endif
   1425          #ifdef PMC_SCDR_PCK1
   1426          	case 1:
   1427          		PMC->PMC_SCDR = PMC_SCDR_PCK1;
   \                     ??pmc_disable_pck_3:
   \       0x5C   0xE3A0'024F        MOV      R0,#-268435452
   \       0x60   0xE3A0'1F80        MOV      R1,#+512
   \       0x64   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x68   0xE580'1000        STR      R1,[R0, #+0]
   1428          		while (PMC->PMC_SCSR & PMC_SCSR_PCK1);
   \                     ??pmc_disable_pck_6:
   \       0x6C   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x70   0xE312'0F80        TST      R2,#0x200
   \       0x74   0x1AFF'FFFC        BNE      ??pmc_disable_pck_6
   \       0x78   0xE8BD'8010        POP      {R4,PC}
   1429          		break;
   1430          #endif
   1431          #ifdef PMC_SCDR_PCK2
   1432          	case 2:
   1433          		PMC->PMC_SCDR = PMC_SCDR_PCK2;
   \                     ??pmc_disable_pck_2:
   \       0x7C   0xE3A0'024F        MOV      R0,#-268435452
   \       0x80   0xE3A0'1E40        MOV      R1,#+1024
   \       0x84   0xE380'0B60        ORR      R0,R0,#0x18000
   \       0x88   0xE580'1000        STR      R1,[R0, #+0]
   1434          		while (PMC->PMC_SCSR & PMC_SCSR_PCK2);
   \                     ??pmc_disable_pck_7:
   \       0x8C   0xE590'2004        LDR      R2,[R0, #+4]
   \       0x90   0xE312'0E40        TST      R2,#0x400
   \       0x94   0x1AFF'FFFC        BNE      ??pmc_disable_pck_7
   \       0x98   0xE8BD'8010        POP      {R4,PC}
   1435          		break;
   1436          #endif
   1437          #ifdef PMC_SCDR_PCK3
   1438          	case 3:
   1439          		PMC->PMC_SCDR = PMC_SCDR_PCK3;
   1440          		while (PMC->PMC_SCSR & PMC_SCSR_PCK3);
   1441          		break;
   1442          #endif
   1443          #ifdef PMC_SCDR_PCK4
   1444          	case 4:
   1445          		PMC->PMC_SCDR = PMC_SCDR_PCK4;
   1446          		while (PMC->PMC_SCSR & PMC_SCSR_PCK4);
   1447          		break;
   1448          #endif
   1449          #ifdef PMC_SCDR_PCK5
   1450          	case 5:
   1451          		PMC->PMC_SCDR = PMC_SCDR_PCK5;
   1452          		while (PMC->PMC_SCSR & PMC_SCSR_PCK5);
   1453          		break;
   1454          #endif
   1455          #ifdef PMC_SCDR_PCK6
   1456          	case 6:
   1457          		PMC->PMC_SCDR = PMC_SCDR_PCK6;
   1458          		while (PMC->PMC_SCSR & PMC_SCSR_PCK6);
   1459          		break;
   1460          #endif
   1461          	default:
   1462          		assert(0);
   \                     ??pmc_disable_pck_4:
   \       0x9C   0xE300'25B6        MOVW     R2,#+1462
   \       0xA0                      REQUIRE ?Subroutine4
   \       0xA0                      ;; // Fall through to label ?Subroutine4
   1463          	}
   1464          }
   1465          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1466          uint32_t pmc_get_pck_clock(uint32_t index)
   1467          {
   \                     pmc_get_pck_clock:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE1A0'4000        MOV      R4,R0
   1468          	assert(index < ARRAY_SIZE(PMC->PMC_PCK));
   \        0x8   0xE354'0003        CMP      R4,#+3
   \        0xC   0x3A00'0004        BCC      ??pmc_get_pck_clock_1
   \       0x10   0x....'....        LDR      R1,??DataTable50_3
   \       0x14   0xE300'25BC        MOVW     R2,#+1468
   \       0x18   0xE281'004C        ADD      R0,R1,#+76
   \       0x1C   0x....'....        BL       __aeabi_assert
   \       0x20   0x....'....        BL       __iar_EmptyStepPoint
   1469          	return _pmc_get_pck_clock(index);
   \                     ??pmc_get_pck_clock_1:
   \       0x24   0x....'....        LDR      R1,??DataTable50_14  ;; 0xf0018040
   \       0x28   0xE3A0'0000        MOV      R0,#+0
   \       0x2C   0xE791'4104        LDR      R4,[R1, +R4, LSL #+2]
   \       0x30   0xE204'2007        AND      R2,R4,#0x7
   \       0x34   0xE352'0004        CMP      R2,#+4
   \       0x38   0x8A00'0013        BHI      ??pmc_get_pck_clock_2
   \       0x3C   0xE7DF'3002        LDRB     R3,[PC, R2]
   \       0x40   0xE08F'F103        ADD      PC,PC,R3, LSL #+2
   \                     ??pmc_get_pck_clock_0:
   \       0x44   0x10 0x0A          DC8      0x10,0xA,0x8,0x3

   \              0x08 0x03
   \       0x48   0x01 0x00          DC8      0x1,0x0,0x0,0x0

   \              0x00 0x00
   \                     ??pmc_get_pck_clock_3:
   \       0x4C   0x....'....        BL       pmc_get_master_clock
   \       0x50   0xEA00'000D        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_4:
   \       0x54   0x....'....        LDR      R0,??DataTable46
   \       0x58   0xE590'1004        LDR      R1,[R0, #+4]
   \       0x5C   0xE081'2101        ADD      R2,R1,R1, LSL #+2
   \       0x60   0xE1A0'0182        LSL      R0,R2,#+3
   \       0x64   0xEA00'0008        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_5:
   \       0x68   0x....'....        BL       pmc_get_plla_clock
   \       0x6C   0xEA00'0006        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_6:
   \       0x70   0xE531'2020        LDR      R2,[R1, #-32]!
   \       0x74   0x....'....        LDR      R0,??DataTable46
   \       0x78   0xE312'0740        TST      R2,#0x1000000
   \       0x7C   0x1590'0004        LDRNE    R0,[R0, #+4]
   \       0x80   0x0590'0000        LDREQ    R0,[R0, #+0]
   \       0x84   0xEA00'0000        B        ??pmc_get_pck_clock_2
   \                     ??pmc_get_pck_clock_7:
   \       0x88   0x....'....        BL       slowclock_get_clock
   \                     ??pmc_get_pck_clock_2:
   \       0x8C   0xE7E2'1254        UBFX     R1,R4,#+4,#+3
   \       0x90   0xE8BD'4010        POP      {R4,LR}
   \       0x94   0xE281'1001        ADD      R1,R1,#+1
   \       0x98   0x....'....        B        __aeabi_uidiv
   1470          }
   1471          
   1472          /*----------------------------------------------------------------------------
   1473           *        Exported functions (UPLL)
   1474           *----------------------------------------------------------------------------*/
   1475          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1476          void pmc_enable_upll_clock(void)
   1477          {
   1478          #if defined(PMC_PLL_UPDT_ID)
   1479          	struct _pmc_plla_cfg plla = {
   1480          #if defined(BOARD_PMC_PLLA_MUL) && defined(BOARD_PMC_PLLA_DIV)
   1481          		.mul = BOARD_PMC_UPLL_MUL,
   1482          		.div = BOARD_PMC_UPLL_DIV,
   1483          #else
   1484          		.mul = 49,
   1485          		.div = 1,
   1486          #endif
   1487          		.count = 0x3f,
   1488          		.fracr = 0,
   1489          		.pll_id = PLL_ID_UPLL,
   1490          };
   1491          	_pmc_configure_pll(&plla);
   1492          #else
   1493          	uint32_t uckr = CKGR_UCKR_UPLLEN | CKGR_UCKR_UPLLCOUNT(0x3);
   1494          
   1495          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS
   1496          	uckr |= CKGR_UCKR_BIASCOUNT(0x1);
   1497          #endif
   1498          
   1499          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1500          	switch (_pmc_main_oscillators.crystal_freq) {
   1501          #ifdef SFR_UTMICKTRIM_FREQ_48
   1502          	case 48000000:
   1503          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_48;
   1504          		break;
   1505          #endif
   1506          	case 24000000:
   1507          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_24;
   1508          		break;
   1509          	case 16000000:
   1510          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_16;
   1511          		break;
   1512          	default:
   1513          		SFR->SFR_UTMICKTRIM = (SFR->SFR_UTMICKTRIM & ~SFR_UTMICKTRIM_FREQ_Msk) | SFR_UTMICKTRIM_FREQ_12;
   1514          	}
   1515          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1516          	switch (_pmc_main_oscillators.crystal_freq) {
   1517          	case 16000000:
   1518          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL16;
   1519          		break;
   1520          	default:
   1521          		UTMI->UTMI_CKTRIM = (UTMI->UTMI_CKTRIM & ~UTMI_CKTRIM_FREQ_Msk) | UTMI_CKTRIM_FREQ_XTAL12;
   1522          	}
   1523          #endif
   1524          
   1525          	/* enable the 480MHz UTMI PLL  */
   1526          	PMC->CKGR_UCKR = uckr;
   \                     pmc_enable_upll_clock:
   \        0x0   0xE3A0'1540        MOV      R1,#+268435456
   \        0x4   0x....'....        LDR      R0,??DataTable50_15  ;; 0xf001801c
   \        0x8   0xE381'19C4        ORR      R1,R1,#0x310000
   \        0xC   0xE580'1000        STR      R1,[R0, #+0]
   1527          
   1528          	/* wait until UPLL is locked */
   1529          	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   \                     ??pmc_enable_upll_clock_0:
   \       0x10   0xE590'204C        LDR      R2,[R0, #+76]
   \       0x14   0xE312'0040        TST      R2,#0x40
   \       0x18   0x0AFF'FFFC        BEQ      ??pmc_enable_upll_clock_0
   1530          #endif
   1531          }
   \       0x1C   0xE12F'FF1E        BX       LR               ;; return
   1532          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1533          void pmc_disable_upll_clock(void)
   1534          {
   1535          #if defined(PMC_PLL_UPDT_ID)
   1536          	_pmc_disable_pll(PLL_ID_UPLL);
   1537          #else
   1538          	PMC->CKGR_UCKR &= ~CKGR_UCKR_UPLLEN;
   \                     pmc_disable_upll_clock:
   \        0x0   0x....'....        LDR      R0,??DataTable50_15  ;; 0xf001801c
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'2B40        BIC      R2,R1,#0x10000
   \        0xC                      REQUIRE ?Subroutine2
   \        0xC                      ;; // Fall through to label ?Subroutine2
   1539          #endif
   1540          }
   1541          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1542          bool pmc_is_upll_clock_enabled(void)
   1543          {
   1544          #if defined(PMC_PLL_UPDT_ID)
   1545          	return _pmc_pll_enabled(PLL_ID_UPLL);
   1546          #else
   1547          	return (PMC->PMC_SR & PMC_SR_LOCKU) != 0;
   \                     pmc_is_upll_clock_enabled:
   \        0x0   0x....'....        LDR      R0,??DataTable50_16  ;; 0xf0018068
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE1A0'2321        LSR      R2,R1,#+6
   \        0xC   0xE202'0001        AND      R0,R2,#0x1
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
   1548          #endif
   1549          }
   1550          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1551          uint32_t pmc_get_upll_clock(void)
   1552          {
   1553          #if defined(PMC_PLL_UPDT_ID)
   1554          	return _pmc_get_pll_clock(PLL_ID_UPLL);
   1555          #elif defined(CKGR_PLLAR_DIVA_Pos)
   1556          	uint32_t upllclk;
   1557          
   1558          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1559          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1560          	switch (clktrim) {
   1561          #ifdef SFR_UTMICKTRIM_FREQ_48
   1562          		case SFR_UTMICKTRIM_FREQ_48:
   1563          			upllclk = 10 * _pmc_main_oscillators.crystal_freq;
   1564          			break;
   1565          #endif
   1566          		case SFR_UTMICKTRIM_FREQ_24:
   1567          			upllclk = 20 * _pmc_main_oscillators.crystal_freq;
   1568          			break;
   1569          		case SFR_UTMICKTRIM_FREQ_16:
   1570          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1571          			break;
   1572          		default:
   1573          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1574          			break;
   1575          	}
   1576          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1577          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1578          	switch (clktrim) {
   1579          		case UTMI_CKTRIM_FREQ_XTAL16:
   1580          			upllclk = 30 * _pmc_main_oscillators.crystal_freq;
   1581          			break;
   1582          		default:
   1583          			upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1584          			break;
   1585          	}
   1586          #else
   1587          	upllclk = 40 * _pmc_main_oscillators.crystal_freq;
   1588          #endif
   1589          
   1590          #ifdef CONFIG_HAVE_PMC_UPLLDIV2
   1591          	if (PMC->PMC_MCKR & PMC_MCKR_UPLLDIV2)
   1592          		upllclk >>= 1;
   1593          #endif
   1594          
   1595          	return upllclk;
   \                     pmc_get_upll_clock:
   \        0x0   0x....'....        LDR      R0,??DataTable50_17
   \        0x4   0xE590'1004        LDR      R1,[R0, #+4]
   \        0x8   0xE081'2101        ADD      R2,R1,R1, LSL #+2
   \        0xC   0xE1A0'0182        LSL      R0,R2,#+3
   \       0x10   0xE12F'FF1E        BX       LR               ;; return
   1596          #endif
   1597          }
   1598          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1599          RAMCODE bool pmc_ext32k_monitor(void)
   1600          {
   1601          	bool bypass = false;
   1602          	volatile int count;
   1603          	/* 32.768kHz crystal oscillator frequency monitor  */
   1604          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1605          	if(!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   1606          		slowclock_set_bypass(false);
   1607          
   1608          		/* Wait 5 slow clock cycles for internal resynchronization. */
   1609          		for (count = 0; count < 0x100000; count++);
   1610          
   1611          		/* 32.768 kHz Crystal Oscillator Frequency Monitoring Enabled */
   1612          		PMC->CKGR_MOR = PMC->CKGR_MOR | CKGR_MOR_KEY_PASSWD | CKGR_MOR_XT32KFME;
   1613          
   1614          		/* Wait 4 slow clock cycles for internal resynchronization */
   1615          		for (count = 0; count < 0x1000; count++);
   1616          
   1617          		/* check if the 32.768 kHz crystal oscillator was correct */
   1618          		if((PMC->PMC_SR & PMC_SR_XT32KERR) == PMC_SR_XT32KERR) {
   1619          			slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   1620          			slowclock_set_bypass(true);
   1621          			bypass = true;
   1622          		}
   1623          		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_XT32KFME) | CKGR_MOR_KEY_PASSWD;
   1624          	}
   1625          #endif
   1626          	return bypass;
   \                     pmc_ext32k_monitor:
   \        0x0   0xE3A0'0000        MOV      R0,#+0
   \        0x4   0xE12F'FF1E        BX       LR               ;; return
   1627          }
   1628          
   1629          #ifdef CONFIG_HAVE_PMC_UPLL_BIAS

   \                                 In section SOFTPACK, align 4, keep-with-next
   1630          void pmc_enable_upll_bias(void)
   1631          {
   1632          	PMC->CKGR_UCKR |= CKGR_UCKR_BIASEN;
   \                     pmc_enable_upll_bias:
   \        0x0   0x....'....        LDR      R0,??DataTable50_15  ;; 0xf001801c
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE381'2740        ORR      R2,R1,#0x1000000
   \        0xC   0x....'....        B        ?Subroutine2
   1633          }
   1634          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1635          void pmc_disable_upll_bias(void)
   1636          {
   1637          	PMC->CKGR_UCKR &= ~CKGR_UCKR_BIASEN;
   \                     pmc_disable_upll_bias:
   \        0x0   0x....'....        LDR      R0,??DataTable50_15  ;; 0xf001801c
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE3C1'2740        BIC      R2,R1,#0x1000000
   \        0xC   0x....'....        B        ?Subroutine2
   1638          }
   1639          #endif /* CONFIG_HAVE_PMC_UPLL_BIAS */
   1640          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1641          uint32_t pmc_get_utmi_clock_trim(void)
   1642          {
   1643          #if defined(SFR_UTMICKTRIM_FREQ_Msk)
   1644          	uint32_t clktrim = SFR->SFR_UTMICKTRIM & SFR_UTMICKTRIM_FREQ_Msk;
   1645          	switch (clktrim) {
   1646          #ifdef SFR_UTMICKTRIM_FREQ_48
   1647          		case SFR_UTMICKTRIM_FREQ_48:
   1648          			return 48000000;
   1649          #endif
   1650          		case SFR_UTMICKTRIM_FREQ_24:
   1651          			return 24000000;
   1652          		case SFR_UTMICKTRIM_FREQ_16:
   1653          			return 16000000;
   1654          		default:
   1655          			return 12000000;
   1656          	}
   1657          #elif defined(UTMI_CKTRIM_FREQ_Msk)
   1658          	uint32_t clktrim = UTMI->UTMI_CKTRIM & UTMI_CKTRIM_FREQ_Msk;
   1659          	switch (clktrim) {
   1660          		case UTMI_CKTRIM_FREQ_XTAL16:
   1661          			return 16000000;
   1662          		default:
   1663          			return 12000000;
   1664          	}
   1665          #elif defined(CONFIG_SOC_SAM9X60)
   1666          	struct _pmc_plla_cfg plla;
   1667          
   1668          	_pmc_get_pll_config(PLL_ID_UPLL, &plla);
   1669          	return 480000000U * (plla.div + 1) / (plla.mul + 1);
   1670          #else
   1671          	return 12000000;
   \                     pmc_get_utmi_clock_trim:
   \        0x0   0xE3A0'08B7        MOV      R0,#+11993088
   \        0x4   0xE380'0D6C        ORR      R0,R0,#0x1B00
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
   1672          #endif
   1673          }
   1674          
   1675          /*----------------------------------------------------------------------------
   1676           *        Exported functions (Generated clocks)
   1677           *----------------------------------------------------------------------------*/
   1678          

   \                                 In section SOFTPACK, align 4, keep-with-next
   1679          struct pck_mck_cfg pmc_get_pck_mck_cfg(void)
   1680          {
   \                     pmc_get_pck_mck_cfg:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE24D'D020        SUB      SP,SP,#+32
   \        0x8   0xE1A0'4000        MOV      R4,R0
   \        0xC   0xE3A0'1020        MOV      R1,#+32
   \       0x10   0xE1A0'000D        MOV      R0,SP
   \       0x14   0x....'....        BL       __aeabi_memclr4
   1681          	struct pck_mck_cfg cfg = { 0 };
   1682          	cfg.pck_input = PMC->PMC_MCKR & PMC_MCKR_CSS_Msk;
   \       0x18   0x....'....        LDR      R5,??DataTable50_18  ;; 0xf0018020
   1683          	if ((PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) == CKGR_MOR_MOSCSEL) {
   \       0x1C   0xE3A0'6001        MOV      R6,#+1
   \       0x20   0xE3A0'7000        MOV      R7,#+0
   \       0x24   0xE595'0010        LDR      R0,[R5, #+16]
   \       0x28   0xE200'1003        AND      R1,R0,#0x3
   1684          		cfg.extosc = true;
   1685          	} else {
   1686          		cfg.extosc = false;
   1687          	}
   1688          	if (!slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   \       0x2C   0xE3A0'0000        MOV      R0,#+0
   \       0x30   0xE58D'1000        STR      R1,[SP, #+0]
   \       0x34   0xE595'3000        LDR      R3,[R5, #+0]
   \       0x38   0xE313'0740        TST      R3,#0x1000000
   \       0x3C   0x15CD'6004        STRBNE   R6,[SP, #+4]
   \       0x40   0x05CD'7004        STRBEQ   R7,[SP, #+4]
   \       0x44   0x....'....        BL       slowclock_is_internal
   \       0x48   0xE350'0000        CMP      R0,#+0
   1689          		cfg.ext32k = true;
   \       0x4C   0x05CD'6006        STRBEQ   R6,[SP, #+6]
   1690          	} else {
   1691          		cfg.ext32k = false;
   \       0x50   0x15CD'7006        STRBNE   R7,[SP, #+6]
   1692          	}
   1693          #if defined(CKGR_MOR_XT32KFME) && defined(SCKC_CR_OSC32BYP)
   1694          	/* Get ext32k bypass state*/
   1695          	if(slowclock_is_internal(SLOWCLOCK_DOMAIN_DEFAULT)) {
   1696          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   1697          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   1698          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   1699          	} else {
   1700          		slowclock_select_internal(SLOWCLOCK_DOMAIN_DEFAULT);
   1701          		slowclock_select_external(SLOWCLOCK_DOMAIN_DEFAULT);
   1702          		cfg.ext32k_bypass = pmc_ext32k_monitor();
   1703          	}
   1704          #endif
   1705          	cfg.pck_pres = (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk);
   \       0x54   0xE595'0010        LDR      R0,[R5, #+16]
   \       0x58   0xE200'2070        AND      R2,R0,#0x70
   \       0x5C   0xE58D'2014        STR      R2,[SP, #+20]
   1706          	cfg.mck_div = (PMC->PMC_MCKR & PMC_MCKR_MDIV_Msk);
   \       0x60   0xE595'3010        LDR      R3,[R5, #+16]
   1707          
   1708          #ifdef PMC_PLL_UPDT_ID
   1709          	if ((cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) | (cfg.pck_input == PMC_MCKR_CSS_UPLL_CLK)) {
   1710          		if (cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   1711          			cfg.plla.pll_id = PLL_ID_PLLA;
   1712          		} else {
   1713          			cfg.plla.pll_id = PLL_ID_UPLL;
   1714          		}
   1715          		PMC->PMC_PLL_UPDT = (PMC->PMC_PLL_UPDT & ~PMC_PLL_UPDT_ID) | cfg.plla.pll_id;
   1716          		cfg.plla.mul = (PMC->PMC_PLL_CTRL1 & PMC_PLL_CTRL1_MUL_Msk) >> PMC_PLL_CTRL1_MUL_Pos;
   1717          		cfg.plla.div = (PMC->PMC_PLL_CTRL0 & PMC_PLL_CTRL0_DIVPMC_Msk) >> PMC_PLL_CTRL0_DIVPMC_Pos;
   1718          	}
   1719          #else
   1720          	if(cfg.pck_input == PMC_MCKR_CSS_PLLA_CLK) {
   \       0x64   0xE59D'C000        LDR      R12,[SP, #+0]
   \       0x68   0xE35C'0002        CMP      R12,#+2
   \       0x6C   0xE203'0FC0        AND      R0,R3,#0x300
   \       0x70   0xE58D'0018        STR      R0,[SP, #+24]
   \       0x74   0x1A00'0008        BNE      ??pmc_get_pck_mck_cfg_0
   1721          		cfg.plla.mul = (PMC->CKGR_PLLAR & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos;
   \       0x78   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x7C   0xE7E6'0950        UBFX     R0,R0,#+18,#+7
   \       0x80   0xE58D'0008        STR      R0,[SP, #+8]
   1722          		cfg.plla.div = (PMC->CKGR_PLLAR & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos;
   \       0x84   0xE595'2008        LDR      R2,[R5, #+8]
   \       0x88   0xE202'0001        AND      R0,R2,#0x1
   \       0x8C   0xE58D'000C        STR      R0,[SP, #+12]
   1723          		cfg.plla.count = (PMC->CKGR_PLLAR & CKGR_PLLAR_PLLACOUNT_Msk) >> CKGR_PLLAR_PLLACOUNT_Pos;
   \       0x90   0xE595'0008        LDR      R0,[R5, #+8]
   \       0x94   0xE7E5'0450        UBFX     R0,R0,#+8,#+6
   \       0x98   0xE58D'0010        STR      R0,[SP, #+16]
   1724          	}
   1725          #endif
   1726          #ifdef CKGR_MOR_MOSCXTBY	
   1727          	if((PMC->CKGR_MOR & CKGR_MOR_MOSCXTBY) == CKGR_MOR_MOSCXTBY) {
   \                     ??pmc_get_pck_mck_cfg_0:
   \       0x9C   0xE595'2000        LDR      R2,[R5, #+0]
   \       0xA0   0xE312'0002        TST      R2,#0x2
   1728          		cfg.ext_bypass = true;
   \       0xA4   0x15CD'6005        STRBNE   R6,[SP, #+5]
   1729          	} else {
   1730          		cfg.ext_bypass = false;
   \       0xA8   0x05CD'7005        STRBEQ   R7,[SP, #+5]
   1731          	}
   1732          #endif
   1733          
   1734          #ifdef CONFIG_HAVE_PMC_PLLADIV2
   1735          	if((PMC->PMC_MCKR & PMC_MCKR_PLLADIV2) == PMC_MCKR_PLLADIV2) {
   \       0xAC   0xE595'0010        LDR      R0,[R5, #+16]
   \       0xB0   0xE310'0D40        TST      R0,#0x1000
   1736          		cfg.plla_div2 = true;
   \       0xB4   0x15CD'601C        STRBNE   R6,[SP, #+28]
   1737          	} else {
   1738          		cfg.plla_div2 = false;
   \       0xB8   0x05CD'701C        STRBEQ   R7,[SP, #+28]
   1739          	}
   1740          #endif
   1741          
   1742          #ifdef CONFIG_HAVE_PMC_H32MXDIV
   1743          	if ((PMC->PMC_MCKR & PMC_MCKR_H32MXDIV_H32MXDIV2) == PMC_MCKR_H32MXDIV_H32MXDIV2) {
   \       0xBC   0xE595'1010        LDR      R1,[R5, #+16]
   \       0xC0   0xE311'0740        TST      R1,#0x1000000
   1744          		cfg.h32mx_div2 = true;
   \       0xC4   0x15CD'601D        STRBNE   R6,[SP, #+29]
   1745          	} else {
   1746          		cfg.h32mx_div2 = false;
   \       0xC8   0x05CD'701D        STRBEQ   R7,[SP, #+29]
   1747          	}
   1748          #endif
   1749          	return cfg;
   \       0xCC   0xE89D'51EC        LDM      SP,{R2,R3,R5-R8,R12,LR}
   \       0xD0   0xE884'51EC        STM      R4,{R2,R3,R5-R8,R12,LR}
   \       0xD4   0xE28D'D020        ADD      SP,SP,#+32
   \       0xD8   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return
   1750          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable41:
   \        0x0   0xF001'8024        DC32     0xf0018024

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable42_1:
   \        0x0   0xF001'8020        DC32     0xf0018020

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0xF001'8020        DC32     0xf0018020

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50:
   \        0x0   0xAAAA'AAAB        DC32     0xaaaaaaab

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_1:
   \        0x0   0x30 0x00          DC8      "0",0x0,0x0

   \              0x00 0x00

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_2:
   \        0x0   0xF001'8030        DC32     0xf0018030

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_4:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_5:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_6:
   \        0x0   0xF001'8028        DC32     0xf0018028

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_7:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_8:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_9:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_10:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_11:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_12:
   \        0x0   0xF001'810C        DC32     0xf001810c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_13:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_14:
   \        0x0   0xF001'8040        DC32     0xf0018040

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_15:
   \        0x0   0xF001'801C        DC32     0xf001801c

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_16:
   \        0x0   0xF001'8068        DC32     0xf0018068

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_17:
   \        0x0   0x....'....        DC32     _pmc_main_oscillators

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable50_18:
   \        0x0   0xF001'8020        DC32     0xf0018020

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x43 0x3A          DC8 0x43, 0x3A, 0x5C, 0x77, 0x6F, 0x72, 0x6B, 0x5C

   \              0x5C 0x77    

   \              0x6F 0x72    

   \              0x6B 0x5C
   \        0x8   0x41 0x74          DC8 0x41, 0x74, 0x6D, 0x65, 0x6C, 0x53, 0x6F, 0x66

   \              0x6D 0x65    

   \              0x6C 0x53    

   \              0x6F 0x66
   \       0x10   0x74 0x50          DC8 0x74, 0x50, 0x41, 0x63, 0x6B, 0x5C, 0x61, 0x74

   \              0x41 0x63    

   \              0x6B 0x5C    

   \              0x61 0x74
   \       0x18   0x6D 0x65          DC8 0x6D, 0x65, 0x6C, 0x2D, 0x73, 0x6F, 0x66, 0x74

   \              0x6C 0x2D    

   \              0x73 0x6F    

   \              0x66 0x74
   \       0x20   0x77 0x61          DC8 0x77, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x61, 0x63

   \              0x72 0x65    

   \              0x2D 0x70    

   \              0x61 0x63
   \       0x28   0x6B 0x61          DC8 0x6B, 0x61, 0x67, 0x65, 0x2D, 0x32, 0x2E, 0x31

   \              0x67 0x65    

   \              0x2D 0x32    

   \              0x2E 0x31
   \       0x30   0x37 0x5C          DC8 0x37, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72

   \              0x64 0x72    

   \              0x69 0x76    

   \              0x65 0x72
   \       0x38   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68

   \              0x70 0x65    

   \              0x72 0x69    

   \              0x70 0x68
   \       0x40   0x65 0x72          DC8 0x65, 0x72, 0x61, 0x6C, 0x73, 0x5C, 0x70, 0x6D

   \              0x61 0x6C    

   \              0x73 0x5C    

   \              0x70 0x6D
   \       0x48   0x63 0x2E          DC8 0x63, 0x2E, 0x63, 0

   \              0x63 0x00
   \       0x4C   0x69 0x6E          DC8 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x3C, 0x20

   \              0x64 0x65    

   \              0x78 0x20    

   \              0x3C 0x20
   \       0x54   0x28 0x73          DC8 0x28, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x20

   \              0x69 0x7A    

   \              0x65 0x6F    

   \              0x66 0x20
   \       0x5C   0x28 0x28          DC8 0x28, 0x28, 0x28, 0x28, 0x50, 0x6D, 0x63, 0x20

   \              0x28 0x28    

   \              0x50 0x6D    

   \              0x63 0x20
   \       0x64   0x2A 0x29          DC8 0x2A, 0x29, 0x30, 0x78, 0x46, 0x30, 0x30, 0x31

   \              0x30 0x78    

   \              0x46 0x30    

   \              0x30 0x31
   \       0x6C   0x38 0x30          DC8 0x38, 0x30, 0x30, 0x30, 0x55, 0x29, 0x2D, 0x3E

   \              0x30 0x30    

   \              0x55 0x29    

   \              0x2D 0x3E
   \       0x74   0x50 0x4D          DC8 0x50, 0x4D, 0x43, 0x5F, 0x50, 0x43, 0x4B, 0x29

   \              0x43 0x5F    

   \              0x50 0x43    

   \              0x4B 0x29
   \       0x7C   0x29 0x20          DC8 0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65

   \              0x2F 0x20    

   \              0x73 0x69    

   \              0x7A 0x65
   \       0x84   0x6F 0x66          DC8 0x6F, 0x66, 0x28, 0x2A, 0x28, 0x28, 0x28, 0x50

   \              0x28 0x2A    

   \              0x28 0x28    

   \              0x28 0x50
   \       0x8C   0x6D 0x63          DC8 0x6D, 0x63, 0x20, 0x2A, 0x29, 0x30, 0x78, 0x46

   \              0x20 0x2A    

   \              0x29 0x30    

   \              0x78 0x46
   \       0x94   0x30 0x30          DC8 0x30, 0x30, 0x31, 0x38, 0x30, 0x30, 0x30, 0x55

   \              0x31 0x38    

   \              0x30 0x30    

   \              0x30 0x55
   \       0x9C   0x29 0x2D          DC8 0x29, 0x2D, 0x3E, 0x50, 0x4D, 0x43, 0x5F, 0x50

   \              0x3E 0x50    

   \              0x4D 0x43    

   \              0x5F 0x50
   \       0xA4   0x43 0x4B          DC8 0x43, 0x4B, 0x29, 0x29, 0x29, 0

   \              0x29 0x29    

   \              0x29 0x00
   \       0xAA   0x00 0x00          DC8 0, 0
   \       0xAC   0x21 0x28          DC8 "!(prescaler << 4 & ~(0x7u << 4))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x3C 0x3C    

   \              0x20 0x34    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x37    

   \              0x75 0x20    

   \              0x3C 0x3C    

   \              0x20 0x34    

   \              0x29 0x29    

   \              0x00
   \       0xCD   0x00 0x00          DC8 0, 0, 0

   \              0x00

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x34, 0x35, 0x20, 0x55, 0x6E, 0x6B

   \              0x34 0x35    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x35, 0x38, 0x20, 0x55, 0x6E, 0x6B

   \              0x35 0x38    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x2D 0x44          DC8 0x2D, 0x44, 0x2D, 0x20, 0x43, 0x3A, 0x5C, 0x77

   \              0x2D 0x20    

   \              0x43 0x3A    

   \              0x5C 0x77
   \        0x8   0x6F 0x72          DC8 0x6F, 0x72, 0x6B, 0x5C, 0x41, 0x74, 0x6D, 0x65

   \              0x6B 0x5C    

   \              0x41 0x74    

   \              0x6D 0x65
   \       0x10   0x6C 0x53          DC8 0x6C, 0x53, 0x6F, 0x66, 0x74, 0x50, 0x41, 0x63

   \              0x6F 0x66    

   \              0x74 0x50    

   \              0x41 0x63
   \       0x18   0x6B 0x5C          DC8 0x6B, 0x5C, 0x61, 0x74, 0x6D, 0x65, 0x6C, 0x2D

   \              0x61 0x74    

   \              0x6D 0x65    

   \              0x6C 0x2D
   \       0x20   0x73 0x6F          DC8 0x73, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65

   \              0x66 0x74    

   \              0x77 0x61    

   \              0x72 0x65
   \       0x28   0x2D 0x70          DC8 0x2D, 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65

   \              0x61 0x63    

   \              0x6B 0x61    

   \              0x67 0x65
   \       0x30   0x2D 0x32          DC8 0x2D, 0x32, 0x2E, 0x31, 0x37, 0x5C, 0x64, 0x72

   \              0x2E 0x31    

   \              0x37 0x5C    

   \              0x64 0x72
   \       0x38   0x69 0x76          DC8 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x70, 0x65

   \              0x65 0x72    

   \              0x73 0x5C    

   \              0x70 0x65
   \       0x40   0x72 0x69          DC8 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6C

   \              0x70 0x68    

   \              0x65 0x72    

   \              0x61 0x6C
   \       0x48   0x73 0x5C          DC8 0x73, 0x5C, 0x70, 0x6D, 0x63, 0x2E, 0x63, 0x3A

   \              0x70 0x6D    

   \              0x63 0x2E    

   \              0x63 0x3A
   \       0x50   0x31 0x31          DC8 0x31, 0x31, 0x37, 0x31, 0x20, 0x55, 0x6E, 0x6B

   \              0x37 0x31    

   \              0x20 0x55    

   \              0x6E 0x6B
   \       0x58   0x6E 0x6F          DC8 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x53, 0x79, 0x73

   \              0x77 0x6E    

   \              0x20 0x53    

   \              0x79 0x73
   \       0x60   0x74 0x65          DC8 0x74, 0x65, 0x6D, 0x20, 0x63, 0x6C, 0x6F, 0x63

   \              0x6D 0x20    

   \              0x63 0x6C    

   \              0x6F 0x63
   \       0x68   0x6B 0x3A          DC8 0x6B, 0x3A, 0x20, 0x25, 0x64, 0x0D, 0x0A, 0

   \              0x20 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x21 0x28          DC8 "!(prescaler & ~(0x7u << 4))"

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x63 0x61    

   \              0x6C 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x37 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x34 0x29    

   \              0x29 0x00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x21 0x28          DC8 "!(divider & ~(0x3u << 8))"

   \              0x64 0x69    

   \              0x76 0x69    

   \              0x64 0x65    

   \              0x72 0x20    

   \              0x26 0x20    

   \              0x7E 0x28    

   \              0x30 0x78    

   \              0x33 0x75    

   \              0x20 0x3C    

   \              0x3C 0x20    

   \              0x38 0x29    

   \              0x29 0x00
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x69 0x64          DC8 "id < (68)"

   \              0x20 0x3C    

   \              0x20 0x28    

   \              0x36 0x38    

   \              0x29 0x00
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x21 0x28          DC8 "!(clock_source & ~(0x7u << 0))"

   \              0x63 0x6C    

   \              0x6F 0x63    

   \              0x6B 0x5F    

   \              0x73 0x6F    

   \              0x75 0x72    

   \              0x63 0x65    

   \              0x20 0x26    

   \              0x20 0x7E    

   \              0x28 0x30    

   \              0x78 0x37    

   \              0x75 0x20    

   \              0x3C 0x3C    

   \              0x20 0x30    

   \              0x29 0x29    

   \              0x00
   \       0x1F   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_10:
   \        0x0   0x30 0x00          DC8 "0"
   1751          
   1752          #ifdef CONFIG_HAVE_PMC_GENERATED_CLOCKS
   1753          
   1754          void pmc_configure_gck(uint32_t id, uint32_t clock_source, uint32_t div)
   1755          {
   1756          	assert(id < ID_PERIPH_COUNT);
   1757          	assert(!(clock_source & ~PMC_PCR_GCKCSS_Msk));
   1758          	assert(div > 0);
   1759          	assert(!((div << PMC_PCR_GCKDIV_Pos) & ~PMC_PCR_GCKDIV_Msk));
   1760          
   1761          	pmc_disable_gck(id);
   1762          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1763          	volatile uint32_t pcr = PMC->PMC_PCR & ~(PMC_PCR_GCKCSS_Msk | PMC_PCR_GCKDIV_Msk);
   1764          	PMC->PMC_PCR = pcr | clock_source | PMC_PCR_CMD | PMC_PCR_GCKDIV(div - 1);
   1765          }
   1766          
   1767          void pmc_enable_gck(uint32_t id)
   1768          {
   1769          	assert(id < ID_PERIPH_COUNT);
   1770          
   1771          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1772          	volatile uint32_t pcr = PMC->PMC_PCR;
   1773          	PMC->PMC_PCR = pcr | PMC_PCR_CMD | PMC_PCR_GCKEN;
   1774          
   1775          #if defined(PMC_GCSR_PID0) || defined(PMC_GCSR0_GPID5)
   1776          	/* check whether or not fGCLK(Max) is out of range */
   1777          	switch(id) {
   1778          	case ID_LCDC:
   1779          		if (pmc_get_gck_clock(id) > 140000000) {
   1780          			trace_warning("fGCK(Max) for LCDC should not exceed 140MHz!\r\n");
   1781          		}
   1782          		break;
   1783          	case ID_CLASSD0:
   1784          		if (pmc_get_gck_clock(id) > 100000000) {
   1785          			trace_warning("fGCK(Max) for CLASSD should not exceed 100MHz!\r\n");
   1786          		}
   1787          		break;
   1788          	case ID_SDMMC0:
   1789          	case ID_SDMMC1:
   1790          		if (pmc_get_gck_clock(id) > 105000000) {
   1791          			trace_warning("fGCK(Max) for SDMMC should not exceed 105MHz!\r\n");
   1792          		}
   1793          		break;
   1794          	case ID_I2SMCC:
   1795          		if (pmc_get_gck_clock(id) > 105000000) {
   1796          			trace_warning("fGCK(Max) for I2SMCC should not exceed 105MHz!\r\n");
   1797          		}
   1798          		break;
   1799          	case ID_ADC:
   1800          	case ID_TC0: case ID_TC1:
   1801          	case ID_PIT64B:
   1802          	case ID_DBGU:
   1803          	case ID_FLEXCOM0: case ID_FLEXCOM1: case ID_FLEXCOM2: case ID_FLEXCOM3:
   1804          	case ID_FLEXCOM4: case ID_FLEXCOM5: case ID_FLEXCOM6: case ID_FLEXCOM7:
   1805          	case ID_FLEXCOM8: case ID_FLEXCOM9:	case ID_FLEXCOM10: case ID_FLEXCOM11:
   1806          	case ID_FLEXCOM12:
   1807          		if (3 * pmc_get_gck_clock(id) > pmc_get_master_clock()) {
   1808          			trace_warning("fGCK(Max) for perpheral %d should not exceed fMCK/3!\r\n", id);
   1809          		}
   1810          		break;
   1811          	}
   1812          
   1813          	while ((PMC->PMC_GCSR[(id >> 5) & 3] & (1 << (id & 31))) == 0);
   1814          #elif defined (PMC_SR_GCKRDY)
   1815          	while (!(PMC->PMC_SR & PMC_SR_GCKRDY));
   1816          #else
   1817          	#error pmc_enable_gck() needs to be updated.
   1818          #endif
   1819          }
   1820          
   1821          RAMCODE void pmc_disable_gck(uint32_t id)
   1822          {
   1823          	assert(id < ID_PERIPH_COUNT);
   1824          
   1825          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1826          	volatile uint32_t pcr = PMC->PMC_PCR;
   1827          	PMC->PMC_PCR = PMC_PCR_CMD | (pcr & ~PMC_PCR_GCKEN);
   1828          }
   1829          
   1830          uint32_t pmc_get_gck_clock(uint32_t id)
   1831          {
   1832          	uint32_t clk = 0;
   1833          	assert(id < ID_PERIPH_COUNT);
   1834          
   1835          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1836          	volatile uint32_t pcr = PMC->PMC_PCR;
   1837          
   1838          	switch (pcr & PMC_PCR_GCKCSS_Msk) {
   1839          	case PMC_PCR_GCKCSS_SLOW_CLK:
   1840          		clk = pmc_get_slow_clock();
   1841          		break;
   1842          	case PMC_PCR_GCKCSS_MAIN_CLK:
   1843          		clk = pmc_get_main_clock();
   1844          		break;
   1845          	case PMC_PCR_GCKCSS_PLLA_CLK:
   1846          		clk = pmc_get_plla_clock();
   1847          		break;
   1848          	case PMC_PCR_GCKCSS_UPLL_CLK:
   1849          		clk = pmc_get_upll_clock();
   1850          		break;
   1851          	case PMC_PCR_GCKCSS_MCK_CLK:
   1852          		clk = pmc_get_master_clock();
   1853          		break;
   1854          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1855          	case PMC_PCR_GCKCSS_AUDIO_CLK:
   1856          		clk = pmc_get_audio_pmc_clock();
   1857          		break;
   1858          #endif
   1859          	}
   1860          
   1861          	uint32_t div = (pcr & PMC_PCR_GCKDIV_Msk) >> PMC_PCR_GCKDIV_Pos;
   1862          	return ROUND_INT_DIV(clk, div + 1);
   1863          }
   1864          
   1865          bool pmc_is_gck_enabled(uint32_t id)
   1866          {
   1867          	assert(id < ID_PERIPH_COUNT);
   1868          
   1869          	PMC->PMC_PCR = PMC_PCR_PID(id);
   1870          
   1871          	return (PMC->PMC_PCR & PMC_PCR_GCKEN) != 0;
   1872          }
   1873          
   1874          #endif /* CONFIG_HAVE_PMC_GENERATED_CLOCKS */
   1875          
   1876          /*----------------------------------------------------------------------------
   1877           *        Exported functions (Audio PLL)
   1878           *----------------------------------------------------------------------------*/
   1879          
   1880          #ifdef CONFIG_HAVE_PMC_AUDIO_CLOCK
   1881          void pmc_configure_audio(const struct _pmc_audio_cfg *cfg)
   1882          {
   1883          #ifdef PMC_AUDIO_PLL0_PLLEN
   1884          	/* reset audio clock */
   1885          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_RESETN |
   1886          	                         PMC_AUDIO_PLL0_PLLEN);
   1887          	PMC->PMC_AUDIO_PLL0 |= PMC_AUDIO_PLL0_RESETN;
   1888          
   1889          	/* configure values */
   1890          	PMC->PMC_AUDIO_PLL0 = PMC_AUDIO_PLL0_ND(cfg->nd)
   1891          	                    | PMC_AUDIO_PLL0_QDPMC(cfg->qdpmc)
   1892          	                    | PMC_AUDIO_PLL0_PLLFLT_STD
   1893          	                    | PMC_AUDIO_PLL0_RESETN;
   1894          	PMC->PMC_AUDIO_PLL1 = PMC_AUDIO_PLL1_FRACR(cfg->fracr)
   1895          	                    | PMC_AUDIO_PLL1_DIV(cfg->div)
   1896          	                    | PMC_AUDIO_PLL1_QDAUDIO(cfg->qdaudio);
   1897          #else
   1898          	/* reset audio clock */
   1899          	PMC->PMC_APLLCCR &= ~(PMC_APLLCCR_RESETN |
   1900          	                      PMC_APLLCCR_PLLEN);
   1901          	PMC->PMC_APLLCCR |= PMC_APLLCCR_RESETN;
   1902          
   1903          	/* configure values */
   1904          	PMC->PMC_APLLCCR = PMC_APLLCCR_ND(cfg->nd)
   1905          	                 | PMC_APLLCCR_FRACR(cfg->fracr)
   1906          	                 | PMC_APLLCCR_RESETN;
   1907          	PMC->PMC_APLLPCR = PMC_APLLPCR_QDAUDIO(cfg->div * cfg->qdaudio);
   1908          	PMC->PMC_APLLICR = PMC_APLLICR_QDPMC(cfg->qdpmc);
   1909          #endif
   1910          }
   1911          
   1912          void pmc_enable_audio(bool pmc_clock, bool pad_clock)
   1913          {
   1914          #ifdef PMC_AUDIO_PLL0_PLLEN
   1915          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1916          	pll0 &= ~(PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1917          	pll0 |= PMC_AUDIO_PLL0_PLLEN;
   1918          	if (pad_clock)
   1919          		pll0 |= PMC_AUDIO_PLL0_PADEN;
   1920          	if (pmc_clock)
   1921          		pll0 |= PMC_AUDIO_PLL0_PMCEN;
   1922          	PMC->PMC_AUDIO_PLL0 = pll0;
   1923          #else
   1924          	PMC->PMC_APLLCCR |= PMC_APLLCCR_PLLEN;
   1925          
   1926          	if (pad_clock)
   1927          		PMC->PMC_APLLPCR |= PMC_APLLPCR_PADEN;
   1928          	else
   1929          		PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1930          
   1931          	if (pmc_clock)
   1932          		PMC->PMC_APLLICR |= PMC_APLLICR_PMCEN;
   1933          	else
   1934          		PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1935          #endif
   1936          
   1937          	/* Wait for the Audio PLL Startup Time (tSTART = 100 usec) */
   1938          	usleep(100);
   1939          }
   1940          
   1941          void pmc_disable_audio()
   1942          {
   1943          #ifdef PMC_AUDIO_PLL0_PLLEN
   1944          	PMC->PMC_AUDIO_PLL0 &= ~(PMC_AUDIO_PLL0_PLLEN | PMC_AUDIO_PLL0_PADEN | PMC_AUDIO_PLL0_PMCEN);
   1945          #else
   1946          	PMC->PMC_APLLPCR &= ~PMC_APLLPCR_PADEN;
   1947          	PMC->PMC_APLLICR &= ~PMC_APLLICR_PMCEN;
   1948          	PMC->PMC_APLLCCR &= ~PMC_APLLCCR_PLLEN;
   1949          #endif
   1950          }
   1951          
   1952          uint32_t pmc_get_audio_pmc_clock(void)
   1953          {
   1954          	uint32_t nd, fracr, qdpmc;
   1955          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1956          
   1957          #ifdef PMC_AUDIO_PLL0_PLLEN
   1958          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1959          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1960          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1961          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1962          	qdpmc = (pll0 & PMC_AUDIO_PLL0_QDPMC_Msk) >> PMC_AUDIO_PLL0_QDPMC_Pos;
   1963          #else
   1964          	uint32_t ccr = PMC->PMC_APLLCCR;
   1965          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1966          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1967          	qdpmc = (PMC->PMC_APLLICR & PMC_APLLICR_QDPMC_Msk) >> PMC_APLLICR_QDPMC_Pos;
   1968          #endif
   1969          
   1970          	clk *= ((nd + 1) << 22) + fracr;
   1971          	clk /= 1 << 22;
   1972          	clk /= qdpmc + 1;
   1973          	return (uint32_t)clk;
   1974          }
   1975          
   1976          uint32_t pmc_get_audio_pad_clock(void)
   1977          {
   1978          	uint32_t nd, fracr, qdaudio, div;
   1979          	uint64_t clk = _pmc_main_oscillators.crystal_freq;
   1980          
   1981          #ifdef PMC_AUDIO_PLL0_PLLEN
   1982          	uint32_t pll0 = PMC->PMC_AUDIO_PLL0;
   1983          	uint32_t pll1 = PMC->PMC_AUDIO_PLL1;
   1984          	nd = (pll0 & PMC_AUDIO_PLL0_ND_Msk) >> PMC_AUDIO_PLL0_ND_Pos;
   1985          	fracr = (pll1 & PMC_AUDIO_PLL1_FRACR_Msk) >> PMC_AUDIO_PLL1_FRACR_Pos;
   1986          	qdaudio = (pll1 & PMC_AUDIO_PLL1_QDAUDIO_Msk) >> PMC_AUDIO_PLL1_QDAUDIO_Pos;
   1987          	if (qdaudio == 0)
   1988          		return 0;
   1989          	div = (pll1 & PMC_AUDIO_PLL1_DIV_Msk) >> PMC_AUDIO_PLL1_DIV_Pos;
   1990          	if (div != 2 && div != 3)
   1991          		return 0;
   1992          #else
   1993          	uint32_t ccr = PMC->PMC_APLLCCR;
   1994          	nd = (ccr & PMC_APLLCCR_ND_Msk) >> PMC_APLLCCR_ND_Pos;
   1995          	fracr = (ccr & PMC_APLLCCR_FRACR_Msk) >> PMC_APLLCCR_FRACR_Pos;
   1996          	qdaudio = (PMC->PMC_APLLPCR & PMC_APLLPCR_QDAUDIO_Msk) >> PMC_APLLPCR_QDAUDIO_Pos;
   1997          	if (qdaudio == 0)
   1998          		return 0;
   1999          	div = 1;
   2000          #endif
   2001          
   2002          	clk *= ((nd + 1) << 22) + fracr;
   2003          	clk /= 1 << 22;
   2004          	clk /= div * qdaudio;
   2005          	return (uint32_t)clk;
   2006          }
   2007          #endif /* CONFIG_HAVE_PMC_AUDIO_CLOCK */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   _pmc_get_system_clock_bits
       4   _pmc_measure_main_osc_freq
      16   pmc_configure_pck
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_disable_pck
      16   pmc_configure_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
        16   -> pmc_disable_peripheral
        16   -> pmc_enable_peripheral
       4   pmc_configure_plla
      24   pmc_disable_all_peripherals
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       8   pmc_disable_external_osc
       0   pmc_disable_internal_osc
       8   pmc_disable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   pmc_disable_peripheral
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_disable_plla
      16   pmc_disable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_disable_upll_bias
       0   pmc_disable_upll_clock
       4   pmc_enable_external_osc
       0   pmc_enable_internal_osc
       8   pmc_enable_pck
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   pmc_enable_peripheral
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   pmc_enable_system_clock
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_enable_ulp1
       0   pmc_enable_upll_bias
       0   pmc_enable_upll_clock
       0   pmc_ext32k_monitor
       0   pmc_get_main_clock
       0   pmc_get_main_oscillator_freq
         0   -> pmc_set_main_oscillator_freq
      16   pmc_get_master_clock
        16   -> slowclock_get_clock
        16 __aeabi_uidiv
       8   pmc_get_pck_clock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> pmc_get_master_clock
         8   -> pmc_get_plla_clock
         8   -> slowclock_get_clock
         0 __aeabi_uidiv
      56   pmc_get_pck_mck_cfg
        56   -> __aeabi_memclr4
        56   -> slowclock_is_internal
       8   pmc_get_peripheral_clock
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> get_peripheral_clock_matrix_div
         8   -> pmc_get_master_clock
         0 __aeabi_uidiv
       8   pmc_get_plla_clock
         8 __aeabi_uidiv
       8   pmc_get_processor_clock
         8   -> pmc_get_master_clock
       0   pmc_get_slow_clock
         0   -> slowclock_get_clock
       0   pmc_get_upll_clock
       0   pmc_get_utmi_clock_trim
       0   pmc_has_system_clock
         0   -> _pmc_get_system_clock_bits
      16   pmc_is_peripheral_enabled
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   pmc_is_system_clock_enabled
        16   -> _pmc_get_system_clock_bits
        16   -> printf
       0   pmc_is_upll_clock_enabled
      16   pmc_select_external_crystal
        16   -> pmc_switch_mck_to_main
        16   -> slowclock_select_external
      16   pmc_select_external_osc
        16   -> pmc_enable_external_osc
      16   pmc_select_internal_crystal
        16   -> pmc_switch_mck_to_main
        16   -> slowclock_select_internal
       8   pmc_select_internal_osc
      24   pmc_set_custom_pck_mck
        24   -> pmc_configure_plla
        24   -> pmc_select_external_crystal
        24   -> pmc_select_external_osc
        24   -> pmc_select_internal_crystal
        24   -> pmc_select_internal_osc
        24   -> pmc_set_mck_divider
        24   -> pmc_set_mck_h32mxdiv
        24   -> pmc_set_mck_plladiv2
        24   -> pmc_set_mck_prescaler
        24   -> pmc_switch_mck_to_main
         0   -> pmc_switch_mck_to_pll
      32   pmc_set_main_oscillator_freq
        32   -> _pmc_measure_main_osc_freq
        32   -> pmc_select_external_osc
        32   -> pmc_select_internal_osc
        32   -> pmc_switch_mck_to_new_source
        32 __aeabi_idiv
       8   pmc_set_mck_divider
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_set_mck_h32mxdiv
       0   pmc_set_mck_plladiv2
       8   pmc_set_mck_prescaler
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   pmc_switch_mck_to_main
       0   pmc_switch_mck_to_new_source
       0   pmc_switch_mck_to_pll
       0   pmc_switch_mck_to_slck
       0   pmc_switch_mck_to_upll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable46
       4  ??DataTable47
       4  ??DataTable49
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_10
       4  ??DataTable50_11
       4  ??DataTable50_12
       4  ??DataTable50_13
       4  ??DataTable50_14
       4  ??DataTable50_15
       4  ??DataTable50_16
       4  ??DataTable50_17
       4  ??DataTable50_18
       4  ??DataTable50_2
       4  ??DataTable50_3
       4  ??DataTable50_4
       4  ??DataTable50_5
       4  ??DataTable50_6
       4  ??DataTable50_7
       4  ??DataTable50_8
       4  ??DataTable50_9
      16  ??Subroutine8_0
      16  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
      24  ?Subroutine3
      20  ?Subroutine4
      12  ?Subroutine5
      48  ?Subroutine6
       8  ?Subroutine7
     208  ?_0
       2  ?_10
     112  ?_3
     112  ?_4
     112  ?_5
      28  ?_6
      28  ?_7
      12  ?_8
      32  ?_9
     128  _pmc_get_system_clock_bits
      12  _pmc_main_oscillators
          _pmc_mck
      88  _pmc_measure_main_osc_freq
     132  pmc_configure_pck
      68  pmc_configure_peripheral
      84  pmc_configure_plla
      92  pmc_disable_all_peripherals
      44  pmc_disable_external_osc
       4  pmc_disable_internal_osc
     160  pmc_disable_pck
      68  pmc_disable_peripheral
      16  pmc_disable_plla
     104  pmc_disable_system_clock
      16  pmc_disable_upll_bias
      12  pmc_disable_upll_clock
     200  pmc_enable_external_osc
       4  pmc_enable_internal_osc
     164  pmc_enable_pck
      76  pmc_enable_peripheral
     104  pmc_enable_system_clock
       4  pmc_enable_ulp1
      16  pmc_enable_upll_bias
      32  pmc_enable_upll_clock
       8  pmc_ext32k_monitor
      28  pmc_get_main_clock
      20  pmc_get_main_oscillator_freq
     328  pmc_get_master_clock
     156  pmc_get_pck_clock
     220  pmc_get_pck_mck_cfg
      64  pmc_get_peripheral_clock
      88  pmc_get_plla_clock
      64  pmc_get_processor_clock
       8  pmc_get_slow_clock
      20  pmc_get_upll_clock
      12  pmc_get_utmi_clock_trim
      16  pmc_has_system_clock
      72  pmc_is_peripheral_enabled
     112  pmc_is_system_clock_enabled
      20  pmc_is_upll_clock_enabled
      44  pmc_select_external_crystal
     208  pmc_select_external_osc
      40  pmc_select_internal_crystal
     100  pmc_select_internal_osc
     324  pmc_set_custom_pck_mck
     456  pmc_set_main_oscillator_freq
      48  pmc_set_mck_divider
      64  pmc_set_mck_h32mxdiv
      64  pmc_set_mck_plladiv2
      52  pmc_set_mck_prescaler
      16  pmc_switch_mck_to_main
      52  pmc_switch_mck_to_new_source
      20  pmc_switch_mck_to_pll
      32  pmc_switch_mck_to_slck
      32  pmc_switch_mck_to_upll

 
    12 bytes in section .data
   646 bytes in section .rodata
 4'664 bytes in section SOFTPACK
 
 4'664 bytes of CODE  memory
   646 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: none
