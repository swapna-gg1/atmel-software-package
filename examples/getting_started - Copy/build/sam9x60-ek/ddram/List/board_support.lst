###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.1.245/W32 for ARM         22/Jul/2020  11:19:48
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                    
#    Endian                   =  little
#    Source file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
#    Command line             =
#        -f C:\Users\c40450\AppData\Local\Temp\EW8918.tmp
#        (C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
#        -D "SOFTPACK_VERSION=\"2.17\"" -D TRACE_LEVEL=5 -D VARIANT_DDRAM -D
#        CONFIG_ARCH_ARMV5TE -D CONFIG_ARCH_ARM -D CONFIG_SOC_SAM9X60 -D
#        CONFIG_CHIP_SAM9X60 -D CONFIG_BOARD_SAM9X60_EK -D CONFIG_HAVE_AIC5 -D
#        CONFIG_HAVE_FLEXCOM -D CONFIG_HAVE_PIO3 -D CONFIG_HAVE_PIT -D
#        CONFIG_HAVE_SMC -D CONFIG_HAVE_SDRAMC -D CONFIG_HAVE_MPDDRC -D
#        CONFIG_HAVE_MPDDRC_DATA_PATH -D CONFIG_HAVE_MPDDRC_IO_CALIBRATION -D
#        CONFIG_HAVE_MPDDRC_DDR2 -D CONFIG_HAVE_ADC_LOW_RES -D
#        CONFIG_HAVE_PMC_FAST_STARTUP -D CONFIG_HAVE_PMC_GENERATED_CLOCKS -D
#        CONFIG_HAVE_SCKC -D CONFIG_HAVE_NFD0_ON_D16 -D CONFIG_HAVE_XDMAC -D
#        CONFIG_HAVE_PWMC -D CONFIG_HAVE_DDR2_W972GG6KB -D
#        CONFIG_HAVE_RSTC_EXTERNAL_RESET -D CONFIG_HAVE_RSTC_INDEPENDENT_RESET
#        -D CONFIG_HAVE_RTT -D CONFIG_HAVE_SHDWC -D CONFIG_HAVE_LED -D
#        CONFIG_HAVE_MMU -D CONFIG_HAVE_L1CACHE -D CONFIG_HAVE_OTPC -D
#        CONFIG_HAVE_DBGU -D CONFIG_HAVE_SERIALD_DBGU -D CONFIG_HAVE_USART -D
#        CONFIG_HAVE_USART_FIFO -D CONFIG_HAVE_DWDT --preprocess
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sam9x60-ek\ddram\List
#        -lC
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sam9x60-ek\ddram\List
#        --diag_suppress Pa050 -o
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sam9x60-ek\ddram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=ARM926EJ-S -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\arch\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\utils\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\common\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\target\sam9x60\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\drivers\
#        -I
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\..\..\lib\
#        --section .text=SOFTPACK --cpu_mode arm -On)
#    Locale                   =  C
#    List file                =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sam9x60-ek\ddram\List\board_support.lst
#    Object file              =
#        C:\work\AtmelSoftPAck\atmel-software-package-2.17\examples\getting_started\build\sam9x60-ek\ddram\Obj\board_support.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf  =  int_specials,qualifiers
#
###############################################################################

C:\work\AtmelSoftPAck\atmel-software-package-2.17\target\sam9x60\board_support.c
      1          /* ----------------------------------------------------------------------------
      2           *         SAM Software Package License
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2018, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          /**
     31           * \file
     32           *
     33           * Implementation of memories configuration on board.
     34           *
     35           */
     36          
     37          /*----------------------------------------------------------------------------
     38           *        Headers
     39           *----------------------------------------------------------------------------*/
     40          
     41          #include "board.h"
     42          #include "board_timer.h"
     43          #include "timer.h"
     44          #include "trace.h"
     45          
     46          #include "irq/irq.h"
     47          #include "gpio/pio.h"
     48          #include "peripherals/pmc.h"
     49          #include "sdmmc/sdmmc.h"
     50          #include "extram/smc.h"
     51          #include "peripherals/wdt.h"
     52          #ifdef BOARD_DDRAM_TYPE
     53          	#include "extram/ddram.h"
     54          #endif
     55          #ifdef BOARD_SDRAM_TYPE
     56          	#include "extram/sdram.h"
     57          #endif
     58          #include "arm/mmu_cp15.h"
     59          #include "mm/l1cache.h"
     60          
     61          #include "board_support.h"
     62          #include "string.h"
     63          /*----------------------------------------------------------------------------
     64           *        Local constants
     65           *----------------------------------------------------------------------------*/
     66          #define PLLA_DIV 1
     67          #define PLLA_COUNT 0x3f
     68          #define PLLA_LOOP_FILTER 0
     69          
     70          #define PLLA_CFG(_mul, _fracr)			\
     71          	{									\
     72          		.mul = (_mul),					\
     73          		.div = PLLA_DIV,				\
     74          		.count = PLLA_COUNT,			\
     75          		.fracr = (_fracr),				\
     76          		.loop_filter = PLLA_LOOP_FILTER,\
     77          	}
     78          
     79          #define PLLA_FRACR(_p, _q) ((uint32_t)((((uint64_t)(_p)) << 22) / (_q)))
     80          
     81          /*----------------------------------------------------------------------------
     82           *        Local variables
     83           *----------------------------------------------------------------------------*/

   \                                 In section .data, align 4
     84          static const char* board_name = BOARD_NAME;
   \                     board_name:
   \        0x0   0x....'....        DC32 ?_0
     85          

   \                                 In section .region_ddr, align 16384
     86          SECTION(".region_ddr") ALIGNED(16384) static uint32_t tlb[4096];
   \                     tlb:
   \        0x0                      DS8 16'384
     87          
     88          /*----------------------------------------------------------------------------
     89           *        Exported functions
     90           *----------------------------------------------------------------------------*/
     91          

   \                                 In section SOFTPACK, align 4, keep-with-next
     92          const char* get_board_name(void)
     93          {
     94          	return board_name;
   \                     get_board_name:
   \        0x0   0x....'....        LDR      R0,??DataTable10
   \        0x4   0xE590'0000        LDR      R0,[R0, #+0]
   \        0x8   0xE12F'FF1E        BX       LR               ;; return
     95          }
     96          

   \                                 In section SOFTPACK, align 4, keep-with-next
     97          void board_cfg_clocks_for_preset(uint32_t preset)
     98          {
   \                     board_cfg_clocks_for_preset:
   \        0x0   0xE92D'41F0        PUSH     {R4-R8,LR}
   \        0x4   0xE24D'D018        SUB      SP,SP,#+24
   \        0x8   0xE1B0'4000        MOVS     R4,R0
     99          	struct _pmc_plla_cfg plla_config;
    100          
    101          #define MAX_PRESET 2 /* PCK/MCK (MHz) = { 600/200, 500/167 } */
    102          
    103          	static const struct _pmc_plla_cfg plla_configs[][MAX_PRESET] = {
    104          		/* MAINCK = 12MHz */
    105          		{ PLLA_CFG(99, 0), PLLA_CFG(82, PLLA_FRACR(1, 3)) },
    106          
    107          		/* MAINCK = 16MHz */
    108          		{ PLLA_CFG(74, 0), PLLA_CFG(61, PLLA_FRACR(1, 2)) },
    109          
    110          		/* MAINCK = 24MHz */
    111          #ifdef CONFIG_HAVE_CLASSD
    112          		{ PLLA_CFG(48, 0x9ba5e), PLLA_CFG(40, PLLA_FRACR(2, 3)) },
    113          #else
    114          		{ PLLA_CFG(49, 0), PLLA_CFG(40, PLLA_FRACR(2, 3)) },
    115          #endif
    116          		/* MAINCK = 48MHz */
    117          		{ PLLA_CFG(24, 0), PLLA_CFG(19, PLLA_FRACR(5, 6)) },
    118          	};
    119          	uint32_t row;
    120          
    121          	switch (pmc_get_main_oscillator_freq()) {
   \        0xC   0x....'....        BL       pmc_get_main_oscillator_freq
   \       0x10   0xE3A0'18F4        MOV      R1,#+15990784
   \       0x14   0xE381'1D90        ORR      R1,R1,#0x2400
   \       0x18   0xE150'0001        CMP      R0,R1
   \       0x1C   0x0A00'0008        BEQ      ??board_cfg_clocks_for_preset_0
   \       0x20   0x....'....        LDR      R1,??DataTable10_1  ;; 0x16e3600
   \       0x24   0xE150'0001        CMP      R0,R1
   \       0x28   0x0A00'0007        BEQ      ??board_cfg_clocks_for_preset_1
   \       0x2C   0xE3A0'17B7        MOV      R1,#+47972352
   \       0x30   0xE381'1C6C        ORR      R1,R1,#0x6C00
   \       0x34   0xE150'0001        CMP      R0,R1
   \       0x38   0x0A00'0005        BEQ      ??board_cfg_clocks_for_preset_2
    122          	default:
    123          	case 12000000:
    124          		row = 0;
   \                     ??board_cfg_clocks_for_preset_3:
   \       0x3C   0xE3A0'5000        MOV      R5,#+0
    125          		break;
   \       0x40   0xEA00'0004        B        ??board_cfg_clocks_for_preset_4
    126          	case 16000000:
    127          		row = 1;
   \                     ??board_cfg_clocks_for_preset_0:
   \       0x44   0xE3A0'5001        MOV      R5,#+1
    128          		break;
   \       0x48   0xEA00'0002        B        ??board_cfg_clocks_for_preset_4
    129          	case 24000000:
    130          		row = 2;
   \                     ??board_cfg_clocks_for_preset_1:
   \       0x4C   0xE3A0'5002        MOV      R5,#+2
    131          		break;
   \       0x50   0xEA00'0000        B        ??board_cfg_clocks_for_preset_4
    132          	case 48000000:
    133          		row = 3;
   \                     ??board_cfg_clocks_for_preset_2:
   \       0x54   0xE3A0'5003        MOV      R5,#+3
    134          		break;
    135          	}
    136          
    137          	if (preset >= MAX_PRESET)
   \                     ??board_cfg_clocks_for_preset_4:
   \       0x58   0xE354'0002        CMP      R4,#+2
   \       0x5C   0x3A00'0008        BCC      ??board_cfg_clocks_for_preset_5
    138          		trace_fatal("Invalid preset for board: %lu (max %d).\r\n", preset, MAX_PRESET);
   \       0x60   0x....'....        LDR      R0,??DataTable10_2
   \       0x64   0xE590'0000        LDR      R0,[R0, #+0]
   \       0x68   0xE350'0000        CMP      R0,#+0
   \       0x6C   0x0A00'0003        BEQ      ??board_cfg_clocks_for_preset_6
   \       0x70   0xE3A0'2002        MOV      R2,#+2
   \       0x74   0xE1B0'1004        MOVS     R1,R4
   \       0x78   0x....'....        LDR      R0,??DataTable10_3
   \       0x7C   0x....'....        BL       printf
   \                     ??board_cfg_clocks_for_preset_6:
   \       0x80   0xEAFF'FFFE        B        ??board_cfg_clocks_for_preset_6
    139          	memcpy(&plla_config, &plla_configs[row][preset], sizeof(plla_config));
   \                     ??board_cfg_clocks_for_preset_5:
   \       0x84   0xE3A0'6018        MOV      R6,#+24
   \       0x88   0x....'....        LDR      R0,??DataTable10_4
   \       0x8C   0xE085'1085        ADD      R1,R5,R5, LSL #+1
   \       0x90   0xE090'0201        ADDS     R0,R0,R1, LSL #+4
   \       0x94   0xE084'1084        ADD      R1,R4,R4, LSL #+1
   \       0x98   0xE090'7181        ADDS     R7,R0,R1, LSL #+3
   \       0x9C   0xE1B0'800D        MOVS     R8,SP
   \       0xA0   0xE1B0'2006        MOVS     R2,R6
   \       0xA4   0xE1B0'1007        MOVS     R1,R7
   \       0xA8   0xE1B0'0008        MOVS     R0,R8
   \       0xAC   0x....'....        BL       __aeabi_memcpy
   \       0xB0   0xE1B0'0008        MOVS     R0,R8
    140          
    141          	pmc_switch_mck_to_main();
   \       0xB4   0x....'....        BL       pmc_switch_mck_to_main
    142          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0xB8   0xE3A0'0000        MOV      R0,#+0
   \       0xBC   0x....'....        BL       pmc_set_mck_prescaler
    143          	pmc_select_external_osc(false);
   \       0xC0   0xE3A0'0000        MOV      R0,#+0
   \       0xC4   0x....'....        BL       pmc_select_external_osc
    144          	pmc_configure_plla(&plla_config);
   \       0xC8   0xE1B0'000D        MOVS     R0,SP
   \       0xCC   0x....'....        BL       pmc_configure_plla
    145          	pmc_set_mck_divider(PMC_MCKR_MDIV_PCK_DIV3);
   \       0xD0   0xE3A0'0FC0        MOV      R0,#+768
   \       0xD4   0x....'....        BL       pmc_set_mck_divider
    146          	pmc_set_mck_prescaler(PMC_MCKR_PRES_CLOCK);
   \       0xD8   0xE3A0'0000        MOV      R0,#+0
   \       0xDC   0x....'....        BL       pmc_set_mck_prescaler
    147          	pmc_switch_mck_to_pll();
   \       0xE0   0x....'....        BL       pmc_switch_mck_to_pll
    148          }
   \       0xE4   0xE28D'D018        ADD      SP,SP,#+24
   \       0xE8   0xE8BD'81F0        POP      {R4-R8,PC}       ;; return

   \                                 In section .rodata, align 4
   \                     `board_cfg_clocks_for_preset::plla_configs`:
   \        0x0   0x0000'0063        DC32 99, 1, 63, 0, 0, 0, 82, 1, 63, 0, 1'398'101, 0, 74, 1, 63, 0, 0, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0052  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0015'5555  

   \              0x0000'0000  

   \              0x0000'004A  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000
   \       0x48   0x0000'003D        DC32 61, 1, 63, 0, 2'097'152, 0, 49, 1, 63, 0, 0, 0, 40, 1, 63, 0

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0020'0000  

   \              0x0000'0000  

   \              0x0000'0031  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0028  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000
   \       0x88   0x002A'AAAA        DC32 2'796'202, 0, 24, 1, 63, 0, 0, 0, 19, 1, 63, 0, 3'495'253, 0

   \              0x0000'0000  

   \              0x0000'0018  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0013  

   \              0x0000'0001  

   \              0x0000'003F  

   \              0x0000'0000  

   \              0x0035'5555  

   \              0x0000'0000
    149          

   \                                 In section SOFTPACK, align 4, keep-with-next
    150          void board_cfg_clocks(void)
    151          {
   \                     board_cfg_clocks:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
    152          	board_cfg_clocks_for_preset(0);
   \        0x4   0xE3A0'0000        MOV      R0,#+0
   \        0x8   0x....'....        BL       board_cfg_clocks_for_preset
    153          }
   \        0xC   0xE8BD'8001        POP      {R0,PC}          ;; return
    154          

   \                                 In section SOFTPACK, align 4, keep-with-next
    155          void board_cfg_lowlevel(bool clocks, bool ddram, bool mmu)
    156          {
   \                     board_cfg_lowlevel:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
   \        0xC   0xE1B0'6002        MOVS     R6,R2
    157          	/* Disable Watchdog */
    158          	wdt_disable();
   \       0x10   0x....'....        BL       wdt_disable
    159          
    160          	/* Disable all PIO interrupts */
    161          	pio_reset_all_it();
   \       0x14   0x....'....        BL       pio_reset_all_it
    162          
    163          	/* Set the external oscillator frequency */
    164          	pmc_set_main_oscillator_freq(BOARD_MAIN_CLOCK_EXT_OSC);
   \       0x18   0x....'....        LDR      R0,??DataTable10_1  ;; 0x16e3600
   \       0x1C   0x....'....        BL       pmc_set_main_oscillator_freq
    165          
    166          	if (clocks) {
   \       0x20   0xE1B0'0004        MOVS     R0,R4
   \       0x24   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x28   0xE350'0000        CMP      R0,#+0
   \       0x2C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_0
    167          		/* Configure system clocks */
    168          		board_cfg_clocks();
   \       0x30   0x....'....        BL       board_cfg_clocks
    169          	}
    170          
    171          	/* Setup default interrupt handlers */
    172          	irq_initialize();
   \                     ??board_cfg_lowlevel_0:
   \       0x34   0x....'....        BL       irq_initialize
    173          
    174          	/* Configure system timer */
    175          	board_cfg_timer();
   \       0x38   0x....'....        BL       board_cfg_timer
    176          
    177          	if (ddram) {
   \       0x3C   0xE1B0'0005        MOVS     R0,R5
   \       0x40   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x44   0xE350'0000        CMP      R0,#+0
   \       0x48   0x0A00'0000        BEQ      ??board_cfg_lowlevel_1
    178          		/* Configure DDRAM */
    179          		board_cfg_ddram();
   \       0x4C   0x....'....        BL       board_cfg_ddram
    180          	}
    181          
    182          	if (mmu) {
   \                     ??board_cfg_lowlevel_1:
   \       0x50   0xE1B0'0006        MOVS     R0,R6
   \       0x54   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x58   0xE350'0000        CMP      R0,#+0
   \       0x5C   0x0A00'0000        BEQ      ??board_cfg_lowlevel_2
    183          		/* Setup MMU */
    184          		board_cfg_mmu();
   \       0x60   0x....'....        BL       board_cfg_mmu
    185          	}
    186          }
   \                     ??board_cfg_lowlevel_2:
   \       0x64   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    187          

   \                                 In section SOFTPACK, align 4, keep-with-next
    188          void board_restore_pio_reset_state(void)
    189          {
   \                     board_restore_pio_reset_state:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
   \        0x4   0xE24D'D040        SUB      SP,SP,#+64
    190          	int i;
    191          
    192          	/* all pins */
    193          	struct _pin pins[] = {
    194          		{ PIO_GROUP_A, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    195          		{ PIO_GROUP_B, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    196          		{ PIO_GROUP_C, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    197          		{ PIO_GROUP_D, 0xFFFFFFFF, PIO_INPUT, PIO_PULLUP },
    198          	};
   \        0x8   0xE1B0'000D        MOVS     R0,SP
   \        0xC   0x....'....        LDR      R1,??DataTable10_5
   \       0x10   0xE3A0'2040        MOV      R2,#+64
   \       0x14   0x....'....        BL       __aeabi_memcpy4
    199          
    200          	pio_configure(pins, ARRAY_SIZE(pins));
   \       0x18   0xE3A0'1004        MOV      R1,#+4
   \       0x1C   0xE1B0'000D        MOVS     R0,SP
   \       0x20   0x....'....        BL       pio_configure
    201          	for (i = 0; i < ARRAY_SIZE(pins); i++)
   \       0x24   0xE3A0'4000        MOV      R4,#+0
   \                     ??board_restore_pio_reset_state_0:
   \       0x28   0xE354'0004        CMP      R4,#+4
   \       0x2C   0x2A00'0005        BCS      ??board_restore_pio_reset_state_1
    202          		pio_clear(&pins[i]);
   \       0x30   0xE1B0'000D        MOVS     R0,SP
   \       0x34   0xE1B0'1204        LSLS     R1,R4,#+4
   \       0x38   0xE090'0001        ADDS     R0,R0,R1
   \       0x3C   0x....'....        BL       pio_clear
   \       0x40   0xE294'4001        ADDS     R4,R4,#+1
   \       0x44   0xEAFF'FFF7        B        ??board_restore_pio_reset_state_0
    203          }
   \                     ??board_restore_pio_reset_state_1:
   \       0x48   0xE28D'D040        ADD      SP,SP,#+64
   \       0x4C   0xE8BD'8010        POP      {R4,PC}          ;; return
    204          

   \                                 In section SOFTPACK, align 4, keep-with-next
    205          void board_save_misc_power(void)
    206          {
   \                     board_save_misc_power:
   \        0x0   0xE92D'4038        PUSH     {R3-R5,LR}
    207          	int i;
    208          	int tc_id = get_tc_id_from_addr(BOARD_TIMER_TC, BOARD_TIMER_CHANNEL);
   \        0x4   0xE3A0'1000        MOV      R1,#+0
   \        0x8   0xE3A0'04F8        MOV      R0,#-134217728
   \        0xC   0xE380'0CC0        ORR      R0,R0,#0xC000
   \       0x10   0x....'....        BL       get_tc_id_from_addr
   \       0x14   0xE1B0'5000        MOVS     R5,R0
    209          
    210          	/* disable USB clock */
    211          	pmc_disable_upll_clock();
   \       0x18   0x....'....        BL       pmc_disable_upll_clock
    212          
    213          	/* disable system clocks */
    214          #ifdef VARIANT_SRAM
    215          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_DDR);
    216          #endif
    217          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_UHP);
   \       0x1C   0xE3A0'0003        MOV      R0,#+3
   \       0x20   0x....'....        BL       pmc_disable_system_clock
    218          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK0);
   \       0x24   0xE3A0'0005        MOV      R0,#+5
   \       0x28   0x....'....        BL       pmc_disable_system_clock
    219          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_PCK1);
   \       0x2C   0xE3A0'0006        MOV      R0,#+6
   \       0x30   0x....'....        BL       pmc_disable_system_clock
    220          	pmc_disable_system_clock(PMC_SYSTEM_CLOCK_QSPI);
   \       0x34   0xE3A0'000D        MOV      R0,#+13
   \       0x38   0x....'....        BL       pmc_disable_system_clock
    221          
    222          	/* disable all peripheral clocks except PIOA for JTAG, serial debug port */
    223          	for (i = ID_PIT; i < ID_PERIPH_COUNT; i++) {
   \       0x3C   0xE3A0'4001        MOV      R4,#+1
   \                     ??board_save_misc_power_0:
   \       0x40   0xE354'0033        CMP      R4,#+51
   \       0x44   0xAA00'0009        BGE      ??board_save_misc_power_1
    224          		if (i == ID_PIOA)
   \       0x48   0xE354'0002        CMP      R4,#+2
   \       0x4C   0x0A00'0005        BEQ      ??board_save_misc_power_2
    225          			continue;
    226          		if (i == tc_id)
   \                     ??board_save_misc_power_3:
   \       0x50   0xE154'0005        CMP      R4,R5
   \       0x54   0x0A00'0003        BEQ      ??board_save_misc_power_2
    227          			continue;
    228          #ifdef VARIANT_DDRAM
    229          		if (i == ID_MPDDRC)
   \                     ??board_save_misc_power_4:
   \       0x58   0xE354'0031        CMP      R4,#+49
   \       0x5C   0x0A00'0001        BEQ      ??board_save_misc_power_2
    230          			continue;
    231          #endif
    232          		pmc_disable_peripheral(i);
   \                     ??board_save_misc_power_5:
   \       0x60   0xE1B0'0004        MOVS     R0,R4
   \       0x64   0x....'....        BL       pmc_disable_peripheral
    233          	}
   \                     ??board_save_misc_power_2:
   \       0x68   0xE294'4001        ADDS     R4,R4,#+1
   \       0x6C   0xEAFF'FFF3        B        ??board_save_misc_power_0
    234          }
   \                     ??board_save_misc_power_1:
   \       0x70   0xE8BD'8031        POP      {R0,R4,R5,PC}    ;; return
    235          

   \                                 In section SOFTPACK, align 4, keep-with-next
    236          void board_cfg_mmu(void)
    237          {
   \                     board_cfg_mmu:
   \        0x0   0xE92D'4010        PUSH     {R4,LR}
    238          	uint32_t addr;
    239          
    240          	if (mmu_is_enabled())
   \        0x4   0x....'....        BL       mmu_is_enabled
   \        0x8   0xE350'0000        CMP      R0,#+0
   \        0xC   0x1A00'0088        BNE      ??board_cfg_mmu_0
    241          		return;
    242          
    243          	/* TODO: some peripherals are configured TTB_SECT_STRONGLY_ORDERED
    244          	   instead of TTB_SECT_SHAREABLE_DEVICE because their drivers have to
    245          	   be verified for correct operation when write-back is enabled */
    246          
    247          	/* Reset table entries */
    248          	for (addr = 0; addr < 4096; addr++)
   \                     ??board_cfg_mmu_1:
   \       0x10   0xE3A0'0000        MOV      R0,#+0
   \       0x14   0xE1B0'1000        MOVS     R1,R0
   \                     ??board_cfg_mmu_2:
   \       0x18   0xE351'0D40        CMP      R1,#+4096
   \       0x1C   0x2A00'0004        BCS      ??board_cfg_mmu_3
    249          		tlb[addr] = 0;
   \       0x20   0x....'....        LDR      R2,??DataTable10_6
   \       0x24   0xE1B0'3101        LSLS     R3,R1,#+2
   \       0x28   0xE782'0003        STR      R0,[R2, +R3]
   \       0x2C   0xE291'1001        ADDS     R1,R1,#+1
   \       0x30   0xEAFF'FFF8        B        ??board_cfg_mmu_2
    250          
    251          	/* 0x00000000: SRAM (Remapped) */
    252          	tlb[0x000] = TTB_SECT_ADDR(0x00000000)
    253          	           | TTB_SECT_AP_FULL_ACCESS
    254          	           | TTB_SECT_DOMAIN(0xf)
    255          	           | TTB_SECT_CACHEABLE_WB
    256          	           | TTB_SECT_SBO
    257          	           | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_3:
   \       0x34   0xE3A0'30FE        MOV      R3,#+254
   \       0x38   0xE383'3ED0        ORR      R3,R3,#0xD00
   \       0x3C   0x....'....        LDR      R0,??DataTable10_6
   \       0x40   0xE580'3000        STR      R3,[R0, #+0]
    258          
    259          	/* 0x00100000: ROM */
    260          	tlb[0x001] = TTB_SECT_ADDR(0x00100000)
    261          	           | TTB_SECT_AP_FULL_ACCESS
    262          	           | TTB_SECT_DOMAIN(0xf)
    263          	           | TTB_SECT_CACHEABLE_WB
    264          	           | TTB_SECT_SBO
    265          	           | TTB_TYPE_SECT;
   \       0x44   0x....'....        LDR      R2,??DataTable10_7  ;; 0x100dfe
   \       0x48   0xE580'2004        STR      R2,[R0, #+4]
    266          
    267          	/* 0x00300000: SRAM0 */
    268          	tlb[0x003] = TTB_SECT_ADDR(0x00300000)
    269          	           | TTB_SECT_AP_FULL_ACCESS
    270          	           | TTB_SECT_DOMAIN(0xf)
    271          	           | TTB_SECT_CACHEABLE_WB
    272          	           | TTB_SECT_SBO
    273          	           | TTB_TYPE_SECT;
   \       0x4C   0x....'....        LDR      R2,??DataTable10_8  ;; 0x300dfe
   \       0x50   0xE580'200C        STR      R2,[R0, #+12]
    274          
    275          	/* 0x00400000: SRAM1 */
    276          	tlb[0x004] = TTB_SECT_ADDR(0x00400000)
    277          	           | TTB_SECT_AP_FULL_ACCESS
    278          	           | TTB_SECT_DOMAIN(0xf)
    279          	           | TTB_SECT_SHAREABLE_DEVICE
    280          	           | TTB_SECT_SBO
    281          	           | TTB_TYPE_SECT;
   \       0x54   0x....'....        LDR      R2,??DataTable10_9  ;; 0x400df6
   \       0x58   0xE580'2010        STR      R2,[R0, #+16]
    282          
    283          #ifdef CONFIG_HAVE_UDPHS
    284          	/* 0x00500000: UDPHS RAM */
    285          	tlb[0x005] = TTB_SECT_ADDR(0x00500000)
    286          	           | TTB_SECT_AP_FULL_ACCESS
    287          	           | TTB_SECT_DOMAIN(0xf)
    288          	           | TTB_SECT_SHAREABLE_DEVICE
    289          	           | TTB_SECT_SBO
    290          	           | TTB_TYPE_SECT;
    291          
    292          	/* 0x00600000: UHP (OHCI) */
    293          	tlb[0x006] = TTB_SECT_ADDR(0x00600000)
    294          	           | TTB_SECT_AP_FULL_ACCESS
    295          	           | TTB_SECT_DOMAIN(0xf)
    296          	           | TTB_SECT_SHAREABLE_DEVICE
    297          	           | TTB_SECT_SBO
    298          	           | TTB_TYPE_SECT;
    299          
    300          	/* 0x00700000: UHP (EHCI) */
    301          	tlb[0x007] = TTB_SECT_ADDR(0x00700000)
    302          	           | TTB_SECT_AP_FULL_ACCESS
    303          	           | TTB_SECT_DOMAIN(0xf)
    304          	           | TTB_SECT_SHAREABLE_DEVICE
    305          	           | TTB_SECT_SBO
    306          	           | TTB_TYPE_SECT;
    307          #endif /* CONFIG_HAVE_UDPHS */
    308          
    309          	/* 0x10000000: EBI Chip Select 0 */
    310          	for (addr = 0x100; addr < 0x200; addr++)
   \       0x5C   0xE3A0'2F40        MOV      R2,#+256
   \                     ??board_cfg_mmu_4:
   \       0x60   0xE352'0F80        CMP      R2,#+512
   \       0x64   0x2A00'0006        BCS      ??board_cfg_mmu_5
    311          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    312          	                  | TTB_SECT_AP_FULL_ACCESS
    313          	                  | TTB_SECT_DOMAIN(0xf)
    314          	                  | TTB_SECT_STRONGLY_ORDERED
    315          	                  | TTB_SECT_SBO
    316          	                  | TTB_TYPE_SECT;
   \       0x68   0xE3A0'10F2        MOV      R1,#+242
   \       0x6C   0xE381'1ED0        ORR      R1,R1,#0xD00
   \       0x70   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \       0x74   0xE1B0'C102        LSLS     R12,R2,#+2
   \       0x78   0xE780'100C        STR      R1,[R0, +R12]
   \       0x7C   0xE292'2001        ADDS     R2,R2,#+1
   \       0x80   0xEAFF'FFF6        B        ??board_cfg_mmu_4
    317          
    318          	/* 0x20000000: EBI Chip Select 1 / DDR CS */
    319          	/* (64MB cacheable, 192MB strongly ordered) */
    320          	for (addr = 0x200; addr < 0x240; addr++)
   \                     ??board_cfg_mmu_5:
   \       0x84   0xE3A0'1F80        MOV      R1,#+512
   \                     ??board_cfg_mmu_6:
   \       0x88   0xE351'0F90        CMP      R1,#+576
   \       0x8C   0x2A00'0004        BCS      ??board_cfg_mmu_7
    321          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    322          	                  | TTB_SECT_AP_FULL_ACCESS
    323          	                  | TTB_SECT_DOMAIN(0xf)
    324          	                  | TTB_SECT_CACHEABLE_WB
    325          	                  | TTB_SECT_SBO
    326          	                  | TTB_TYPE_SECT;
   \       0x90   0xE193'2A01        ORRS     R2,R3,R1, LSL #+20
   \       0x94   0xE1B0'C101        LSLS     R12,R1,#+2
   \       0x98   0xE780'200C        STR      R2,[R0, +R12]
   \       0x9C   0xE291'1001        ADDS     R1,R1,#+1
   \       0xA0   0xEAFF'FFF8        B        ??board_cfg_mmu_6
    327          	for (addr = 0x240; addr < 0x300; addr++)
   \                     ??board_cfg_mmu_7:
   \       0xA4   0xE3A0'2F90        MOV      R2,#+576
   \                     ??board_cfg_mmu_8:
   \       0xA8   0xE352'0FC0        CMP      R2,#+768
   \       0xAC   0x2A00'0006        BCS      ??board_cfg_mmu_9
    328          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    329          	                  | TTB_SECT_AP_FULL_ACCESS
    330          	                  | TTB_SECT_DOMAIN(0xf)
    331          	                  | TTB_SECT_STRONGLY_ORDERED
    332          	                  | TTB_SECT_SBO
    333          	                  | TTB_TYPE_SECT;
   \       0xB0   0xE3A0'10F2        MOV      R1,#+242
   \       0xB4   0xE381'1ED0        ORR      R1,R1,#0xD00
   \       0xB8   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \       0xBC   0xE1B0'3102        LSLS     R3,R2,#+2
   \       0xC0   0xE780'1003        STR      R1,[R0, +R3]
   \       0xC4   0xE292'2001        ADDS     R2,R2,#+1
   \       0xC8   0xEAFF'FFF6        B        ??board_cfg_mmu_8
    334          
    335          	/* 0x30000000: EBI Chip Select 2 */
    336          	for (addr = 0x300; addr < 0x400; addr++)
   \                     ??board_cfg_mmu_9:
   \       0xCC   0xE3A0'1FC0        MOV      R1,#+768
   \                     ??board_cfg_mmu_10:
   \       0xD0   0xE351'0E40        CMP      R1,#+1024
   \       0xD4   0x2A00'0006        BCS      ??board_cfg_mmu_11
    337          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    338          	                  | TTB_SECT_AP_FULL_ACCESS
    339          	                  | TTB_SECT_DOMAIN(0xf)
    340          	                  | TTB_SECT_STRONGLY_ORDERED
    341          	                  | TTB_SECT_SBO
    342          	                  | TTB_TYPE_SECT;
   \       0xD8   0xE3A0'20F2        MOV      R2,#+242
   \       0xDC   0xE382'2ED0        ORR      R2,R2,#0xD00
   \       0xE0   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \       0xE4   0xE1B0'3101        LSLS     R3,R1,#+2
   \       0xE8   0xE780'2003        STR      R2,[R0, +R3]
   \       0xEC   0xE291'1001        ADDS     R1,R1,#+1
   \       0xF0   0xEAFF'FFF6        B        ??board_cfg_mmu_10
    343          
    344          	/* 0x40000000: EBI Chip Select 3 */
    345          	for (addr = 0x400; addr < 0x500; addr++)
   \                     ??board_cfg_mmu_11:
   \       0xF4   0xE3A0'2E40        MOV      R2,#+1024
   \                     ??board_cfg_mmu_12:
   \       0xF8   0xE352'0E50        CMP      R2,#+1280
   \       0xFC   0x2A00'0006        BCS      ??board_cfg_mmu_13
    346          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    347          	                  | TTB_SECT_AP_FULL_ACCESS
    348          	                  | TTB_SECT_DOMAIN(0xf)
    349          	                  | TTB_SECT_STRONGLY_ORDERED
    350          	                  | TTB_SECT_SBO
    351          	                  | TTB_TYPE_SECT;
   \      0x100   0xE3A0'10F2        MOV      R1,#+242
   \      0x104   0xE381'1ED0        ORR      R1,R1,#0xD00
   \      0x108   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x10C   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x110   0xE780'1003        STR      R1,[R0, +R3]
   \      0x114   0xE292'2001        ADDS     R2,R2,#+1
   \      0x118   0xEAFF'FFF6        B        ??board_cfg_mmu_12
    352          
    353          	/* 0x50000000: EBI Chip Select 4 */
    354          	for (addr = 0x500; addr < 0x600; addr++)
   \                     ??board_cfg_mmu_13:
   \      0x11C   0xE3A0'1E50        MOV      R1,#+1280
   \                     ??board_cfg_mmu_14:
   \      0x120   0xE351'0E60        CMP      R1,#+1536
   \      0x124   0x2A00'0006        BCS      ??board_cfg_mmu_15
    355          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    356          	                  | TTB_SECT_AP_FULL_ACCESS
    357          	                  | TTB_SECT_DOMAIN(0xf)
    358          	                  | TTB_SECT_STRONGLY_ORDERED
    359          	                  | TTB_SECT_SBO
    360          	                  | TTB_TYPE_SECT;
   \      0x128   0xE3A0'20F2        MOV      R2,#+242
   \      0x12C   0xE382'2ED0        ORR      R2,R2,#0xD00
   \      0x130   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \      0x134   0xE1B0'3101        LSLS     R3,R1,#+2
   \      0x138   0xE780'2003        STR      R2,[R0, +R3]
   \      0x13C   0xE291'1001        ADDS     R1,R1,#+1
   \      0x140   0xEAFF'FFF6        B        ??board_cfg_mmu_14
    361          
    362          	/* 0x60000000: EBI Chip Select 5 */
    363          	for (addr = 0x600; addr < 0x700; addr++)
   \                     ??board_cfg_mmu_15:
   \      0x144   0xE3A0'2E60        MOV      R2,#+1536
   \                     ??board_cfg_mmu_16:
   \      0x148   0xE352'0E70        CMP      R2,#+1792
   \      0x14C   0x2A00'0006        BCS      ??board_cfg_mmu_17
    364          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    365          	                  | TTB_SECT_AP_FULL_ACCESS
    366          	                  | TTB_SECT_DOMAIN(0xf)
    367          	                  | TTB_SECT_STRONGLY_ORDERED
    368          	                  | TTB_SECT_SBO
    369          	                  | TTB_TYPE_SECT;
   \      0x150   0xE3A0'10F2        MOV      R1,#+242
   \      0x154   0xE381'1ED0        ORR      R1,R1,#0xD00
   \      0x158   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x15C   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x160   0xE780'1003        STR      R1,[R0, +R3]
   \      0x164   0xE292'2001        ADDS     R2,R2,#+1
   \      0x168   0xEAFF'FFF6        B        ??board_cfg_mmu_16
    370          
    371          	/* 0x70000000: QSPI0/1 AESB MEM */
    372          	for (addr = 0x700; addr < 0x800; addr++)
   \                     ??board_cfg_mmu_17:
   \      0x16C   0xE3A0'1E70        MOV      R1,#+1792
   \                     ??board_cfg_mmu_18:
   \      0x170   0xE351'0E80        CMP      R1,#+2048
   \      0x174   0x2A00'0006        BCS      ??board_cfg_mmu_19
    373          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    374          	                  | TTB_SECT_AP_FULL_ACCESS
    375          	                  | TTB_SECT_DOMAIN(0xf)
    376          #if defined(VARIANT_QSPI0)
    377          	                  | TTB_SECT_CACHEABLE_WB
    378          #else
    379          	                  | TTB_SECT_STRONGLY_ORDERED
    380          #endif
    381          	                  | TTB_TYPE_SECT;
   \      0x178   0xE3A0'20E2        MOV      R2,#+226
   \      0x17C   0xE382'2ED0        ORR      R2,R2,#0xD00
   \      0x180   0xE192'2A01        ORRS     R2,R2,R1, LSL #+20
   \      0x184   0xE1B0'3101        LSLS     R3,R1,#+2
   \      0x188   0xE780'2003        STR      R2,[R0, +R3]
   \      0x18C   0xE291'1001        ADDS     R1,R1,#+1
   \      0x190   0xEAFF'FFF6        B        ??board_cfg_mmu_18
    382          
    383          	/* 0x80000000: SDMMC0 */
    384          	for (addr = 0x800; addr < 0x900; addr++)
   \                     ??board_cfg_mmu_19:
   \      0x194   0xE3A0'2E80        MOV      R2,#+2048
   \                     ??board_cfg_mmu_20:
   \      0x198   0xE352'0E90        CMP      R2,#+2304
   \      0x19C   0x2A00'0006        BCS      ??board_cfg_mmu_21
    385          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    386          	                  | TTB_SECT_AP_FULL_ACCESS
    387          	                  | TTB_SECT_DOMAIN(0xf)
    388          	                  | TTB_SECT_STRONGLY_ORDERED
    389          	                  | TTB_TYPE_SECT;
   \      0x1A0   0xE3A0'10E2        MOV      R1,#+226
   \      0x1A4   0xE381'1ED0        ORR      R1,R1,#0xD00
   \      0x1A8   0xE191'1A02        ORRS     R1,R1,R2, LSL #+20
   \      0x1AC   0xE1B0'3102        LSLS     R3,R2,#+2
   \      0x1B0   0xE780'1003        STR      R1,[R0, +R3]
   \      0x1B4   0xE292'2001        ADDS     R2,R2,#+1
   \      0x1B8   0xEAFF'FFF6        B        ??board_cfg_mmu_20
    390          
    391          	/* 0x90000000: SDMMC1 */
    392          	for (addr = 0x900; addr < 0xa00; addr++)
   \                     ??board_cfg_mmu_21:
   \      0x1BC   0xE3A0'4E90        MOV      R4,#+2304
   \                     ??board_cfg_mmu_22:
   \      0x1C0   0xE354'0EA0        CMP      R4,#+2560
   \      0x1C4   0x2A00'0006        BCS      ??board_cfg_mmu_23
    393          		tlb[addr] = TTB_SECT_ADDR(addr << 20)
    394          	                  | TTB_SECT_AP_FULL_ACCESS
    395          	                  | TTB_SECT_DOMAIN(0xf)
    396          	                  | TTB_SECT_STRONGLY_ORDERED
    397          	                  | TTB_TYPE_SECT;
   \      0x1C8   0xE3A0'10E2        MOV      R1,#+226
   \      0x1CC   0xE381'1ED0        ORR      R1,R1,#0xD00
   \      0x1D0   0xE191'1A04        ORRS     R1,R1,R4, LSL #+20
   \      0x1D4   0xE1B0'2104        LSLS     R2,R4,#+2
   \      0x1D8   0xE780'1002        STR      R1,[R0, +R2]
   \      0x1DC   0xE294'4001        ADDS     R4,R4,#+1
   \      0x1E0   0xEAFF'FFF6        B        ??board_cfg_mmu_22
    398          
    399          	/* 0xeff00000: OTPC */
    400          	tlb[0xeff] = TTB_SECT_ADDR(0xeff00000)
    401          	           | TTB_SECT_AP_FULL_ACCESS
    402          	           | TTB_SECT_DOMAIN(0xf)
    403          	           | TTB_SECT_STRONGLY_ORDERED
    404          	           | TTB_SECT_SBO
    405          	           | TTB_TYPE_SECT;
   \                     ??board_cfg_mmu_23:
   \      0x1E4   0x....'....        LDR      R1,??DataTable10_10  ;; 0xeff00df2
   \      0x1E8   0xE3A0'20FC        MOV      R2,#+252
   \      0x1EC   0xE382'2DEC        ORR      R2,R2,#0x3B00
   \      0x1F0   0xE780'1002        STR      R1,[R0, +R2]
    406          
    407          	/* 0xf0000000: Peripherals */
    408          	tlb[0xf00] = TTB_SECT_ADDR(0xf0000000)
    409          	           | TTB_SECT_AP_FULL_ACCESS
    410          	           | TTB_SECT_DOMAIN(0xf)
    411          	           | TTB_SECT_STRONGLY_ORDERED
    412          	           | TTB_SECT_SBO
    413          	           | TTB_TYPE_SECT;
   \      0x1F4   0xE3A0'13BC        MOV      R1,#-268435454
   \      0x1F8   0xE381'1EDF        ORR      R1,R1,#0xDF0
   \      0x1FC   0xE290'2DF0        ADDS     R2,R0,#+15360
   \      0x200   0xE582'1000        STR      R1,[R2, #+0]
    414          
    415          	/* 0xf8000000: Peripherals */
    416          	tlb[0xf80] = TTB_SECT_ADDR(0xf8000000)
    417          	           | TTB_SECT_AP_FULL_ACCESS
    418          	           | TTB_SECT_DOMAIN(0xf)
    419          	           | TTB_SECT_STRONGLY_ORDERED
    420          	           | TTB_SECT_SBO
    421          	           | TTB_TYPE_SECT;
   \      0x204   0xE3A0'13BE        MOV      R1,#-134217726
   \      0x208   0xE381'1EDF        ORR      R1,R1,#0xDF0
   \      0x20C   0xE290'2DF8        ADDS     R2,R0,#+15872
   \      0x210   0xE582'1000        STR      R1,[R2, #+0]
    422          
    423          	/* 0xfff0000: System Controller */
    424          	tlb[0xfff] = TTB_SECT_ADDR(0xfff00000)
    425          	           | TTB_SECT_AP_FULL_ACCESS
    426          	           | TTB_SECT_DOMAIN(0xf)
    427          	           | TTB_SECT_STRONGLY_ORDERED
    428          	           | TTB_SECT_SBO
    429          	           | TTB_TYPE_SECT;
   \      0x214   0x....'....        LDR      R1,??DataTable10_11  ;; 0xfff00df2
   \      0x218   0xE3A0'20FC        MOV      R2,#+252
   \      0x21C   0xE382'2DFC        ORR      R2,R2,#0x3F00
   \      0x220   0xE780'1002        STR      R1,[R0, +R2]
    430          
    431          	/* Enable MMU, I-Cache and D-Cache */
    432          	mmu_configure(tlb);
   \      0x224   0x....'....        BL       mmu_configure
    433          	icache_enable();
   \      0x228   0x....'....        BL       icache_enable
    434          	mmu_enable();
   \      0x22C   0x....'....        BL       mmu_enable
    435          	dcache_enable();
   \      0x230   0x....'....        BL       dcache_enable
    436          }
   \                     ??board_cfg_mmu_0:
   \      0x234   0xE8BD'8010        POP      {R4,PC}          ;; return
    437          
    438          
    439          #define VDDIOM_1V8_OUT_Z_CALN_TYP 4
    440          #define VDDIOM_1V8_OUT_Z_CALP_TYP 10
    441          

   \                                 In section SOFTPACK, align 4, keep-with-next
    442          void board_cfg_matrix_for_ddr(void)
    443          {
    444          	uint32_t reg;
    445          
    446          	SFR->SFR_CCFG_EBICSA |= SFR_CCFG_EBICSA_EBI_CS1A;
   \                     board_cfg_matrix_for_ddr:
   \        0x0   0x....'....        LDR      R0,??DataTable10_12  ;; 0xf8050004
   \        0x4   0xE590'1000        LDR      R1,[R0, #+0]
   \        0x8   0xE391'1002        ORRS     R1,R1,#0x2
   \        0xC   0xE580'1000        STR      R1,[R0, #+0]
    447          	/*
    448          	 * On the first SAM9X60 V/DWB samples, automatic calibration computes
    449          	 * wrong value. Calibrate output impedance manually.
    450          	 */
    451          	reg = SFR->SFR_CAL1;
   \       0x10   0x....'....        LDR      R1,??DataTable10_13  ;; 0xf80500b4
   \       0x14   0xE591'0000        LDR      R0,[R1, #+0]
    452          	reg &= ~(SFR_CAL1_CALN_M_Msk | SFR_CAL1_CALP_M_Msk);
   \       0x18   0xE3D0'00FF        BICS     R0,R0,#0xFF
    453          	reg |= SFR_CAL1_TEST_M | SFR_CAL1_CALN_M(VDDIOM_1V8_OUT_Z_CALN_TYP) | SFR_CAL1_CALP_M(VDDIOM_1V8_OUT_Z_CALP_TYP);
   \       0x1C   0xE390'0F69        ORRS     R0,R0,#0x1A4
    454          	SFR->SFR_CAL1 = reg;
   \       0x20   0xE581'0000        STR      R0,[R1, #+0]
    455          }
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    456          

   \                                 In section SOFTPACK, align 4, keep-with-next
    457          void board_cfg_matrix_for_nand(void)
    458          {
    459          	uint32_t mask = SFR_CCFG_EBICSA_EBI_CS3A | SFR_CCFG_EBICSA_NFD0_ON_D16;
   \                     board_cfg_matrix_for_nand:
   \        0x0   0xE3A0'0008        MOV      R0,#+8
   \        0x4   0xE380'0740        ORR      R0,R0,#0x1000000
    460          	uint32_t value = SFR_CCFG_EBICSA_EBI_CS3A;
   \        0x8   0xE3A0'1008        MOV      R1,#+8
    461          	uint32_t reg;
    462          
    463          	value |= SFR_CCFG_EBICSA_NFD0_ON_D16;
   \        0xC   0xE391'2740        ORRS     R2,R1,#0x1000000
    464          
    465          	reg = SFR->SFR_CCFG_EBICSA;
   \       0x10   0x....'....        LDR      R3,??DataTable10_12  ;; 0xf8050004
   \       0x14   0xE593'1000        LDR      R1,[R3, #+0]
    466          	reg = (reg & ~mask) | value;
   \       0x18   0xE1D1'1000        BICS     R1,R1,R0
   \       0x1C   0xE192'1001        ORRS     R1,R2,R1
    467          	SFR->SFR_CCFG_EBICSA = reg;
   \       0x20   0xE583'1000        STR      R1,[R3, #+0]
    468          }
   \       0x24   0xE12F'FF1E        BX       LR               ;; return
    469          

   \                                 In section SOFTPACK, align 4, keep-with-next
    470          void board_cfg_matrix_for_nand_ex(bool nfd0_on_d16)
    471          {
    472          	uint32_t mask = SFR_CCFG_EBICSA_EBI_CS3A | SFR_CCFG_EBICSA_NFD0_ON_D16;
   \                     board_cfg_matrix_for_nand_ex:
   \        0x0   0xE3A0'1008        MOV      R1,#+8
   \        0x4   0xE381'1740        ORR      R1,R1,#0x1000000
    473          	uint32_t value = SFR_CCFG_EBICSA_EBI_CS3A;
   \        0x8   0xE3A0'3008        MOV      R3,#+8
    474          	uint32_t reg;
    475          
    476          	if (nfd0_on_d16)
   \        0xC   0xE1B0'2000        MOVS     R2,R0
   \       0x10   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0x14   0xE352'0000        CMP      R2,#+0
   \       0x18   0x0A00'0000        BEQ      ??board_cfg_matrix_for_nand_ex_0
    477          		value |= SFR_CCFG_EBICSA_NFD0_ON_D16;
   \       0x1C   0xE393'3740        ORRS     R3,R3,#0x1000000
    478          
    479          	reg = SFR->SFR_CCFG_EBICSA;
   \                     ??board_cfg_matrix_for_nand_ex_0:
   \       0x20   0x....'....        LDR      R12,??DataTable10_12  ;; 0xf8050004
   \       0x24   0xE59C'2000        LDR      R2,[R12, #+0]
    480          	reg = (reg & ~mask) | value;
   \       0x28   0xE1D2'2001        BICS     R2,R2,R1
   \       0x2C   0xE193'2002        ORRS     R2,R3,R2
    481          	SFR->SFR_CCFG_EBICSA = reg;
   \       0x30   0xE58C'2000        STR      R2,[R12, #+0]
    482          }
   \       0x34   0xE12F'FF1E        BX       LR               ;; return
    483          

   \                                 In section SOFTPACK, align 4, keep-with-next
    484          void board_cfg_ddram(void)
    485          {
   \                     board_cfg_ddram:
   \        0x0   0xE92D'5000        PUSH     {R12,LR}
   \        0x4   0xE24D'D030        SUB      SP,SP,#+48
    486          	board_cfg_matrix_for_ddr();
   \        0x8   0x....'....        BL       board_cfg_matrix_for_ddr
    487          #ifdef BOARD_DDRAM_TYPE
    488          	struct _mpddrc_desc desc;
    489          	ddram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
   \        0xC   0xE3A0'1000        MOV      R1,#+0
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        BL       ddram_init_descriptor
    490          	ddram_configure(&desc);
   \       0x18   0xE1B0'000D        MOVS     R0,SP
   \       0x1C   0x....'....        BL       ddram_configure
    491          #endif
    492          #ifdef BOARD_SDRAM_TYPE
    493          	struct _sdramc_desc desc;
    494          	sdram_init_descriptor(&desc, BOARD_DDRAM_TYPE);
    495          	sdram_configure(&desc);
    496          #endif
    497          }
   \       0x20   0xE28D'D034        ADD      SP,SP,#+52
   \       0x24   0xE8BD'8000        POP      {PC}             ;; return
    498          
    499          #ifdef CONFIG_HAVE_NAND_FLASH
    500          void board_cfg_nand_flash(void)
    501          {
    502          #if defined(BOARD_NANDFLASH_PINS) && defined(BOARD_NANDFLASH_BUS_WIDTH)
    503          	const struct _pin pins_nandflash[] = BOARD_NANDFLASH_PINS;
    504          	pio_configure(pins_nandflash, ARRAY_SIZE(pins_nandflash));
    505          	board_cfg_matrix_for_nand();
    506          	smc_nand_configure(BOARD_NANDFLASH_BUS_WIDTH);
    507          #else
    508          	trace_fatal("Cannot configure NAND: target board has no NAND definitions!");
    509          #endif
    510          }
    511          #endif /* CONFIG_HAVE_NAND_FLASH */
    512          
    513          #if defined(BOARD_SDMMC0_PINS) || defined(BOARD_SDMMC1_PINS)

   \                                 In section SOFTPACK, align 4, keep-with-next
    514          static void board_cfg_sd_clk_caps(uint32_t periph_id, uint32_t *caps0)
    515          {
   \                     board_cfg_sd_clk_caps:
   \        0x0   0xE92D'4070        PUSH     {R4-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
   \        0x8   0xE1B0'5001        MOVS     R5,R1
    516          		uint32_t base_freq, mult_freq, val;
    517          
    518          		/* Retrieve the frequency of MULTCLK.
    519          		 * Usual values of this frequency are 100 MHz, 104 MHz. */
    520          		mult_freq = pmc_get_gck_clock(periph_id);
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0x....'....        BL       pmc_get_gck_clock
   \       0x14   0xE1B0'6000        MOVS     R6,R0
    521          
    522          		/* Retrieve the frequency of BASECLK and TEOCLK.
    523          		 * Usual values of this frequency are 50 MHz, 52 MHz. */
    524          		base_freq = ROUND_INT_DIV(mult_freq, 2 * 1000000lu);
   \       0x18   0xE356'0000        CMP      R6,#+0
   \       0x1C   0x1A00'0001        BNE      ??board_cfg_sd_clk_caps_0
   \       0x20   0xE3A0'0000        MOV      R0,#+0
   \       0x24   0xEA00'0013        B        ??board_cfg_sd_clk_caps_1
   \                     ??board_cfg_sd_clk_caps_0:
   \       0x28   0xE356'0000        CMP      R6,#+0
   \       0x2C   0x1A00'0001        BNE      ??board_cfg_sd_clk_caps_2
   \       0x30   0xE3A0'0001        MOV      R0,#+1
   \       0x34   0xEA00'0000        B        ??board_cfg_sd_clk_caps_3
   \                     ??board_cfg_sd_clk_caps_2:
   \       0x38   0xE3A0'0000        MOV      R0,#+0
   \                     ??board_cfg_sd_clk_caps_3:
   \       0x3C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x40   0xE350'0000        CMP      R0,#+0
   \       0x44   0x0A00'0005        BEQ      ??board_cfg_sd_clk_caps_4
   \       0x48   0x....'....        LDR      R0,??DataTable10_14  ;; 0xfff0bdc0
   \       0x4C   0xE090'0006        ADDS     R0,R0,R6
   \       0x50   0xE3A0'197A        MOV      R1,#+1998848
   \       0x54   0xE381'1E48        ORR      R1,R1,#0x480
   \       0x58   0x....'....        BL       __aeabi_uidiv
   \       0x5C   0xEA00'0005        B        ??board_cfg_sd_clk_caps_1
   \                     ??board_cfg_sd_clk_caps_4:
   \       0x60   0xE3A0'0AF4        MOV      R0,#+999424
   \       0x64   0xE380'0F90        ORR      R0,R0,#0x240
   \       0x68   0xE090'0006        ADDS     R0,R0,R6
   \       0x6C   0xE3A0'197A        MOV      R1,#+1998848
   \       0x70   0xE381'1E48        ORR      R1,R1,#0x480
   \       0x74   0x....'....        BL       __aeabi_uidiv
    525          		val = base_freq > (SDMMC_CA0R_BASECLKF_Msk >> SDMMC_CA0R_BASECLKF_Pos)
    526          		    ? 0 : base_freq;
   \                     ??board_cfg_sd_clk_caps_1:
   \       0x78   0xE350'0F40        CMP      R0,#+256
   \       0x7C   0x3A00'0001        BCC      ??board_cfg_sd_clk_caps_5
   \       0x80   0xE3A0'1000        MOV      R1,#+0
   \       0x84   0xEA00'0000        B        ??board_cfg_sd_clk_caps_6
   \                     ??board_cfg_sd_clk_caps_5:
   \       0x88   0xE1B0'1000        MOVS     R1,R0
    527          		*caps0 |= SDMMC_CA0R_BASECLKF(val);
   \                     ??board_cfg_sd_clk_caps_6:
   \       0x8C   0xE595'2000        LDR      R2,[R5, #+0]
   \       0x90   0xE3A0'3CFF        MOV      R3,#+65280
   \       0x94   0xE013'3401        ANDS     R3,R3,R1, LSL #+8
   \       0x98   0xE193'2002        ORRS     R2,R3,R2
   \       0x9C   0xE585'2000        STR      R2,[R5, #+0]
    528          		val = base_freq > (SDMMC_CA0R_TEOCLKF_Msk >> SDMMC_CA0R_TEOCLKF_Pos)
    529          		    ? 0 : base_freq;
   \       0xA0   0xE350'0040        CMP      R0,#+64
   \       0xA4   0x3A00'0001        BCC      ??board_cfg_sd_clk_caps_7
   \       0xA8   0xE3A0'1000        MOV      R1,#+0
   \       0xAC   0xEA00'0000        B        ??board_cfg_sd_clk_caps_8
   \                     ??board_cfg_sd_clk_caps_7:
   \       0xB0   0xE1B0'1000        MOVS     R1,R0
    530          		*caps0 |= SDMMC_CA0R_TEOCLKF(val) | SDMMC_CA0R_TEOCLKU;
   \                     ??board_cfg_sd_clk_caps_8:
   \       0xB4   0xE595'2000        LDR      R2,[R5, #+0]
   \       0xB8   0xE211'303F        ANDS     R3,R1,#0x3F
   \       0xBC   0xE393'3080        ORRS     R3,R3,#0x80
   \       0xC0   0xE193'2002        ORRS     R2,R3,R2
   \       0xC4   0xE585'2000        STR      R2,[R5, #+0]
    531          }
   \       0xC8   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    532          #endif
    533          

   \                                 In section SOFTPACK, align 4, keep-with-next
    534          bool board_cfg_sdmmc(uint32_t periph_id)
    535          {
   \                     board_cfg_sdmmc:
   \        0x0   0xE92D'4030        PUSH     {R4,R5,LR}
   \        0x4   0xE24D'D07C        SUB      SP,SP,#+124
   \        0x8   0xE1B0'4000        MOVS     R4,R0
    536          	switch (periph_id) {
   \        0xC   0xE1B0'0004        MOVS     R0,R4
   \       0x10   0xE350'000C        CMP      R0,#+12
   \       0x14   0x0A00'0002        BEQ      ??board_cfg_sdmmc_0
   \       0x18   0xE350'001A        CMP      R0,#+26
   \       0x1C   0x0A00'0031        BEQ      ??board_cfg_sdmmc_1
   \       0x20   0xEA00'0045        B        ??board_cfg_sdmmc_2
    537          	case ID_SDMMC0:
    538          	{
    539          #if defined(BOARD_SDMMC0_CAPS0) && defined(BOARD_SDMMC0_PINS)
    540          		struct _pin pins[] = BOARD_SDMMC0_PINS;
   \                     ??board_cfg_sdmmc_0:
   \       0x24   0xE28D'003C        ADD      R0,SP,#+60
   \       0x28   0x....'....        LDR      R1,??DataTable10_15
   \       0x2C   0xE3A0'2040        MOV      R2,#+64
   \       0x30   0x....'....        BL       __aeabi_memcpy4
    541          		uint32_t caps0 = BOARD_SDMMC0_CAPS0;
   \       0x34   0xE3A0'0740        MOV      R0,#+16777216
   \       0x38   0xE58D'0008        STR      R0,[SP, #+8]
    542          #ifdef BOARD_SDMMC0_PIO_ATTR
    543          		uint8_t ix;
    544          #endif
    545          
    546          		/* Program capabilities for SDMMC0 */
    547          		board_cfg_sd_clk_caps(ID_SDMMC0, &caps0);
   \       0x3C   0xE28D'1008        ADD      R1,SP,#+8
   \       0x40   0xE3A0'000C        MOV      R0,#+12
   \       0x44   0x....'....        BL       board_cfg_sd_clk_caps
    548          		sdmmc_set_capabilities(SDMMC0, caps0, SDMMC_CA0R_SLTYPE_Msk |
    549          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    550          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    551          		    SDMMC_CA0R_TEOCLKF_Msk, 0, 0);
   \       0x48   0xE3A0'0000        MOV      R0,#+0
   \       0x4C   0xE58D'0000        STR      R0,[SP, #+0]
   \       0x50   0xE3A0'3000        MOV      R3,#+0
   \       0x54   0x....'....        LDR      R2,??DataTable10_16  ;; 0xc700ffbf
   \       0x58   0xE59D'1008        LDR      R1,[SP, #+8]
   \       0x5C   0xE3A0'0480        MOV      R0,#-2147483648
   \       0x60   0x....'....        BL       sdmmc_set_capabilities
    552          
    553          		/* Configure SDMMC0 pins */
    554          #ifdef BOARD_SDMMC0_PIO_ATTR
    555          		/* Tune the attributes of CMD, CK and DAT* peripheral outputs */
    556          		for (ix = 0; ix < ARRAY_SIZE(pins); ix++) {
   \       0x64   0xE3A0'5000        MOV      R5,#+0
   \                     ??board_cfg_sdmmc_3:
   \       0x68   0xE1B0'0005        MOVS     R0,R5
   \       0x6C   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \       0x70   0xE350'0004        CMP      R0,#+4
   \       0x74   0x2A00'0016        BCS      ??board_cfg_sdmmc_4
    557          			if (pins[ix].type == PIO_INPUT)
   \       0x78   0xE28D'003C        ADD      R0,SP,#+60
   \       0x7C   0xE1B0'1005        MOVS     R1,R5
   \       0x80   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0x84   0xE1B0'1201        LSLS     R1,R1,#+4
   \       0x88   0xE090'0001        ADDS     R0,R0,R1
   \       0x8C   0xE5D0'0008        LDRB     R0,[R0, #+8]
   \       0x90   0xE350'0007        CMP      R0,#+7
   \       0x94   0x0A00'000C        BEQ      ??board_cfg_sdmmc_5
    558          				continue;
    559          			pins[ix].attribute |= BOARD_SDMMC0_PIO_ATTR;
   \                     ??board_cfg_sdmmc_6:
   \       0x98   0xE28D'003C        ADD      R0,SP,#+60
   \       0x9C   0xE1B0'1005        MOVS     R1,R5
   \       0xA0   0xE211'10FF        ANDS     R1,R1,#0xFF      ;; Zero extend
   \       0xA4   0xE1B0'1201        LSLS     R1,R1,#+4
   \       0xA8   0xE090'0001        ADDS     R0,R0,R1
   \       0xAC   0xE590'000C        LDR      R0,[R0, #+12]
   \       0xB0   0xE390'0EA0        ORRS     R0,R0,#0xA00
   \       0xB4   0xE28D'103C        ADD      R1,SP,#+60
   \       0xB8   0xE1B0'2005        MOVS     R2,R5
   \       0xBC   0xE212'20FF        ANDS     R2,R2,#0xFF      ;; Zero extend
   \       0xC0   0xE1B0'2202        LSLS     R2,R2,#+4
   \       0xC4   0xE091'1002        ADDS     R1,R1,R2
   \       0xC8   0xE581'000C        STR      R0,[R1, #+12]
    560          		}
   \                     ??board_cfg_sdmmc_5:
   \       0xCC   0xE295'5001        ADDS     R5,R5,#+1
   \       0xD0   0xEAFF'FFE4        B        ??board_cfg_sdmmc_3
    561          #endif
    562          		pio_configure(pins, ARRAY_SIZE(pins));
   \                     ??board_cfg_sdmmc_4:
   \       0xD4   0xE3A0'1004        MOV      R1,#+4
   \       0xD8   0xE28D'003C        ADD      R0,SP,#+60
   \       0xDC   0x....'....        BL       pio_configure
    563          		return true;
   \       0xE0   0xE3A0'0001        MOV      R0,#+1
   \       0xE4   0xEA00'0015        B        ??board_cfg_sdmmc_7
    564          #else
    565          		trace_fatal("Cannot configure SDMMC0: target board has no SDMMC0 definitions!");
    566          		return false;
    567          #endif
    568          	}
    569          	case ID_SDMMC1:
    570          	{
    571          #if defined(BOARD_SDMMC1_CAPS0) && defined(BOARD_SDMMC1_PINS)
    572          		const struct _pin pins[] = BOARD_SDMMC1_PINS;
   \                     ??board_cfg_sdmmc_1:
   \       0xE8   0xE28D'000C        ADD      R0,SP,#+12
   \       0xEC   0x....'....        LDR      R1,??DataTable10_17
   \       0xF0   0xE3A0'2030        MOV      R2,#+48
   \       0xF4   0x....'....        BL       __aeabi_memcpy4
    573          		uint32_t caps0 = BOARD_SDMMC1_CAPS0;
   \       0xF8   0xE3A0'0441        MOV      R0,#+1090519040
   \       0xFC   0xE58D'0004        STR      R0,[SP, #+4]
    574          
    575          		/* Program capabilities for SDMMC1 */
    576          		board_cfg_sd_clk_caps(ID_SDMMC1, &caps0);
   \      0x100   0xE28D'1004        ADD      R1,SP,#+4
   \      0x104   0xE3A0'001A        MOV      R0,#+26
   \      0x108   0x....'....        BL       board_cfg_sd_clk_caps
    577          		sdmmc_set_capabilities(SDMMC1, caps0, SDMMC_CA0R_SLTYPE_Msk |
    578          		    SDMMC_CA0R_V18VSUP | SDMMC_CA0R_V30VSUP | SDMMC_CA0R_V33VSUP |
    579          		    SDMMC_CA0R_BASECLKF_Msk | SDMMC_CA0R_TEOCLKU |
    580          		    SDMMC_CA0R_TEOCLKF_Msk, 0, 0);
   \      0x10C   0xE3A0'0000        MOV      R0,#+0
   \      0x110   0xE58D'0000        STR      R0,[SP, #+0]
   \      0x114   0xE3A0'3000        MOV      R3,#+0
   \      0x118   0x....'....        LDR      R2,??DataTable10_16  ;; 0xc700ffbf
   \      0x11C   0xE59D'1004        LDR      R1,[SP, #+4]
   \      0x120   0xE3A0'0490        MOV      R0,#-1879048192
   \      0x124   0x....'....        BL       sdmmc_set_capabilities
    581          
    582          		/* Configure SDMMC1 pins */
    583          		pio_configure(pins, ARRAY_SIZE(pins));
   \      0x128   0xE3A0'1003        MOV      R1,#+3
   \      0x12C   0xE28D'000C        ADD      R0,SP,#+12
   \      0x130   0x....'....        BL       pio_configure
    584          		return true;
   \      0x134   0xE3A0'0001        MOV      R0,#+1
   \      0x138   0xEA00'0000        B        ??board_cfg_sdmmc_7
    585          #else
    586          		trace_fatal("Cannot configure SDMMC1: target board has no SDMMC1 definitions!");
    587          		return false;
    588          #endif
    589          	}
    590          	default:
    591          		return false;
   \                     ??board_cfg_sdmmc_2:
   \      0x13C   0xE3A0'0000        MOV      R0,#+0
   \                     ??board_cfg_sdmmc_7:
   \      0x140   0xE28D'D07C        ADD      SP,SP,#+124
   \      0x144   0xE8BD'8030        POP      {R4,R5,PC}       ;; return
    592          	}
    593          }
    594          

   \                                 In section SOFTPACK, align 4, keep-with-next
    595          bool board_get_sdmmc_card_detect_status(uint32_t periph_id)
    596          {
   \                     board_get_sdmmc_card_detect_status:
   \        0x0   0xE92D'407F        PUSH     {R0-R6,LR}
   \        0x4   0xE1B0'4000        MOVS     R4,R0
    597          	const struct _pin *cd_input = NULL;
   \        0x8   0xE3A0'6000        MOV      R6,#+0
   \        0xC   0xE1B0'5006        MOVS     R5,R6
    598          
    599          #ifdef BOARD_SDMMC0_PIN_CD
    600          	const struct _pin cd0_input = BOARD_SDMMC0_PIN_CD;
   \       0x10   0xE1B0'000D        MOVS     R0,SP
   \       0x14   0x....'....        LDR      R1,??DataTable10_18
   \       0x18   0xE3A0'2010        MOV      R2,#+16
   \       0x1C   0x....'....        BL       __aeabi_memcpy4
    601          	cd_input = periph_id == ID_SDMMC0 ? &cd0_input : cd_input;
   \       0x20   0xE354'000C        CMP      R4,#+12
   \       0x24   0x1A00'0001        BNE      ??board_get_sdmmc_card_detect_status_0
   \       0x28   0xE1B0'500D        MOVS     R5,SP
   \       0x2C   0xEAFF'FFFF        B        ??board_get_sdmmc_card_detect_status_1
    602          #endif
    603          
    604          #ifdef BOARD_SDMMC1_PIN_CD
    605          	const struct _pin cd1_input = BOARD_SDMMC1_PIN_CD;
    606          	cd_input = periph_id == ID_SDMMC1 ? &cd1_input : cd_input;
    607          #endif
    608          
    609          	if (periph_id != ID_SDMMC0 && periph_id != ID_SDMMC1)
   \                     ??board_get_sdmmc_card_detect_status_0:
   \                     ??board_get_sdmmc_card_detect_status_1:
   \       0x30   0xE354'000C        CMP      R4,#+12
   \       0x34   0x0A00'0003        BEQ      ??board_get_sdmmc_card_detect_status_2
   \       0x38   0xE354'001A        CMP      R4,#+26
   \       0x3C   0x0A00'0001        BEQ      ??board_get_sdmmc_card_detect_status_2
    610          		return false;
   \       0x40   0xE3A0'0000        MOV      R0,#+0
   \       0x44   0xEA00'000B        B        ??board_get_sdmmc_card_detect_status_3
    611          
    612          	/* No detection; assume the card/device is always present */
    613          	if (!cd_input)
   \                     ??board_get_sdmmc_card_detect_status_2:
   \       0x48   0xE355'0000        CMP      R5,#+0
   \       0x4C   0x1A00'0001        BNE      ??board_get_sdmmc_card_detect_status_4
    614          		return true;
   \       0x50   0xE3A0'0001        MOV      R0,#+1
   \       0x54   0xEA00'0007        B        ??board_get_sdmmc_card_detect_status_3
    615          
    616          	return pio_get(cd_input) ? false : true;
   \                     ??board_get_sdmmc_card_detect_status_4:
   \       0x58   0xE1B0'0005        MOVS     R0,R5
   \       0x5C   0x....'....        BL       pio_get
   \       0x60   0xE350'0000        CMP      R0,#+0
   \       0x64   0x1A00'0001        BNE      ??board_get_sdmmc_card_detect_status_5
   \       0x68   0xE3A0'6001        MOV      R6,#+1
   \       0x6C   0xEAFF'FFFF        B        ??board_get_sdmmc_card_detect_status_6
   \                     ??board_get_sdmmc_card_detect_status_5:
   \                     ??board_get_sdmmc_card_detect_status_6:
   \       0x70   0xE1B0'0006        MOVS     R0,R6
   \       0x74   0xE210'00FF        ANDS     R0,R0,#0xFF      ;; Zero extend
   \                     ??board_get_sdmmc_card_detect_status_3:
   \       0x78   0xE28D'D010        ADD      SP,SP,#+16
   \       0x7C   0xE8BD'8070        POP      {R4-R6,PC}       ;; return
    617          }

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     board_name

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     trace_level

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x....'....        DC32     `board_cfg_clocks_for_preset::plla_configs`

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x....'....        DC32     tlb

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x0010'0DFE        DC32     0x100dfe

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x0030'0DFE        DC32     0x300dfe

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x0040'0DF6        DC32     0x400df6

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0xEFF0'0DF2        DC32     0xeff00df2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0xFFF0'0DF2        DC32     0xfff00df2

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0xF805'0004        DC32     0xf8050004

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0xF805'00B4        DC32     0xf80500b4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0xFFF0'BDC0        DC32     0xfff0bdc0

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_15:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_16:
   \        0x0   0xC700'FFBF        DC32     0xc700ffbf

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_17:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section SOFTPACK, align 4, keep-with-next
   \                     ??DataTable10_18:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x73 0x61          DC8 "sam9x60-ek"

   \              0x6D 0x39    

   \              0x78 0x36    

   \              0x30 0x2D    

   \              0x65 0x6B    

   \              0x00
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x2D 0x46          DC8 "-F- Invalid preset for board: %lu (max %d).\015\012"

   \              0x2D 0x20    

   \              0x49 0x6E    

   \              0x76 0x61    

   \              0x6C 0x69    

   \              0x64 0x20    

   \              0x70 0x72    

   \              0x65 0x73    

   \              0x65 0x74    

   \              0x20 0x66    

   \              0x6F 0x72    

   \              0x20 0x62    

   \              0x6F 0x61    

   \              0x72 0x64    

   \              0x3A 0x20    

   \              0x25 0x6C    

   \              0x75 0x20    

   \              0x28 0x6D    

   \              0x61 0x78    

   \              0x20 0x25    

   \              0x64 0x29    

   \              0x2E 0x0D    

   \              0x0A 0x00
   \       0x2E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0xFFFF'FFFF        DC32 4'294'967'295
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0001        DC32 1
   \       0x10   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x14   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x18   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x02 0x00          DC8 2, 0, 0, 0

   \              0x00 0x00
   \       0x24   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x28   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x03 0x00          DC8 3, 0, 0, 0

   \              0x00 0x00
   \       0x34   0xFFFF'FFFF        DC32 4'294'967'295
   \       0x38   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0080'0000        DC32 8'388'608
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0002'0000        DC32 131'072
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0000        DC32 0
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x0001'0000        DC32 65'536
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x34   0x001C'8000        DC32 1'867'776
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x3C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0000'2000        DC32 8'192
   \        0x8   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0000        DC32 0
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x14   0x0000'1000        DC32 4'096
   \       0x18   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x1C   0x0000'0001        DC32 1
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \       0x24   0x0000'081C        DC32 2'076
   \       0x28   0x01 0x00          DC8 1, 0, 0, 0

   \              0x00 0x00
   \       0x2C   0x0000'0001        DC32 1

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \        0x4   0x0080'0000        DC32 8'388'608
   \        0x8   0x07 0x00          DC8 7, 0, 0, 0

   \              0x00 0x00
   \        0xC   0x0000'0010        DC32 16

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   board_cfg_clocks
         8   -> board_cfg_clocks_for_preset
      48   board_cfg_clocks_for_preset
        48   -> __aeabi_memcpy
        48   -> pmc_configure_plla
        48   -> pmc_get_main_oscillator_freq
        48   -> pmc_select_external_osc
        48   -> pmc_set_mck_divider
        48   -> pmc_set_mck_prescaler
        48   -> pmc_switch_mck_to_main
        48   -> pmc_switch_mck_to_pll
        48   -> printf
      56   board_cfg_ddram
        56   -> board_cfg_matrix_for_ddr
        56   -> ddram_configure
        56   -> ddram_init_descriptor
      16   board_cfg_lowlevel
        16   -> board_cfg_clocks
        16   -> board_cfg_ddram
        16   -> board_cfg_mmu
        16   -> board_cfg_timer
        16   -> irq_initialize
        16   -> pio_reset_all_it
        16   -> pmc_set_main_oscillator_freq
        16   -> wdt_disable
       0   board_cfg_matrix_for_ddr
       0   board_cfg_matrix_for_nand
       0   board_cfg_matrix_for_nand_ex
       8   board_cfg_mmu
         8   -> dcache_enable
         8   -> icache_enable
         8   -> mmu_configure
         8   -> mmu_enable
         8   -> mmu_is_enabled
      16   board_cfg_sd_clk_caps
        16   -> pmc_get_gck_clock
        16 __aeabi_uidiv
     136   board_cfg_sdmmc
       136   -> __aeabi_memcpy4
       136   -> board_cfg_sd_clk_caps
       136   -> pio_configure
       136   -> sdmmc_set_capabilities
      32   board_get_sdmmc_card_detect_status
        32   -> __aeabi_memcpy4
        32   -> pio_get
      72   board_restore_pio_reset_state
        72   -> __aeabi_memcpy4
        72   -> pio_clear
        72   -> pio_configure
      16   board_save_misc_power
        16   -> get_tc_id_from_addr
        16   -> pmc_disable_peripheral
        16   -> pmc_disable_system_clock
        16   -> pmc_disable_upll_clock
       0   get_board_name


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable10
        4  ??DataTable10_1
        4  ??DataTable10_10
        4  ??DataTable10_11
        4  ??DataTable10_12
        4  ??DataTable10_13
        4  ??DataTable10_14
        4  ??DataTable10_15
        4  ??DataTable10_16
        4  ??DataTable10_17
        4  ??DataTable10_18
        4  ??DataTable10_2
        4  ??DataTable10_3
        4  ??DataTable10_4
        4  ??DataTable10_5
        4  ??DataTable10_6
        4  ??DataTable10_7
        4  ??DataTable10_8
        4  ??DataTable10_9
       12  ?_0
       48  ?_1
       64  ?_2
       64  ?_3
       48  ?_4
       16  ?_5
       16  board_cfg_clocks
      236  board_cfg_clocks_for_preset
       40  board_cfg_ddram
      104  board_cfg_lowlevel
       40  board_cfg_matrix_for_ddr
       40  board_cfg_matrix_for_nand
       56  board_cfg_matrix_for_nand_ex
      568  board_cfg_mmu
      204  board_cfg_sd_clk_caps
      328  board_cfg_sdmmc
      128  board_get_sdmmc_card_detect_status
        4  board_name
       80  board_restore_pio_reset_state
      116  board_save_misc_power
       12  get_board_name
      192  plla_configs
   16'384  tlb

 
      4 bytes in section .data
 16'384 bytes in section .region_ddr
    444 bytes in section .rodata
  2'044 bytes in section SOFTPACK
 
  2'044 bytes of CODE  memory
    444 bytes of CONST memory
 16'388 bytes of DATA  memory

Errors: none
Warnings: none
